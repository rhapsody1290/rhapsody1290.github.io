<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[淘宝存储技术的发展]]></title>
      <url>%2F2017%2F02%2F27%2F%5B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%5D%E6%B7%98%E5%AE%9D%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%2F</url>
      <content type="text"><![CDATA[开发语言决不是系统的瓶颈，业务带来的压力多在于数据和存储方面，淘宝网的数据和存储发展大致如下： 集中式架构缓存：所有数据都从数据库获取一方面速度比较慢，另一方面数据库承受不了这么大的访问量。一些被经常访问的数据直接从缓存中获取可以显著提高效率，减轻数据库的压力 读写分离：从原来的对一个数据库进行所有读写操作，拆分为一个主库和两个从库，并且读写分离，因为写操作比读操作更费时。主库只进行写操作，从库只进行读操作，主库进行写操作的同时，数据向从数据库同步 分库分表：查询速度与数据库容量成反比，采用多个数据库，对同一张表复制成多张，同时数据库路由的框架DBRoute，统一处理了数据的合并、排序、分页等操作，让程序员像使用一个数据库一样操作多个数据库里的数据 Mysql换成Oracle：选择Oracle的原因除了它容量大、稳定、安全、性能高之外，Oracle的性能和并发访问能力之所以如此强大，有一个关键性的设计——连接池，任何一个请求只需要从连接池中取得一个连接即可，用完后释放，这不需要频繁地创建和断开连接，而连接的创建和断开的开销是非常大的。Oracle从一开始运行在本机上，Nas上，到后来的小型机上，这些都能短时间提高存储容量，但Oracle、EMC、小型机都是很贵的，随着淘宝网的快速发展，钱钱终将不能解决问题，需要自主开发新的技术，一步一步地把IOE（IBM小型机、Oracle、EMC存储） 分布式架构淘宝分布式数据库TDDL：对上层来说，像查询一个数据库一样来查询数据，还要像查询一个数据库一样快；从集中式的Oracle切换到分布式的Mysql集群；用PC服务器替换小型机，小型机通过提高CPU，内存，磁盘等方式提高处理能力，价格昂贵，这种集中式架构的存储方式越来越不适应海量数据计算能力 分布式文件存储：淘宝的去IOE战略（IBM小型机、Oracle、EMC），使用适合淘宝使用的图片存储系统TFS 分布式缓存Tair：把常用的信息放在内存中，每次都从内存里取，性能会好很多。现在常用memcached、redis这种Key-Value缓存，只不过当时他们还没崭露头角]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java编码转换]]></title>
      <url>%2F2017%2F02%2F26%2F%5B%E7%BC%96%E7%A0%81%5DJava%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[首先要注意，字符串在java内存中总是按unicode编码 getBytes(charset)Java中个 getBytes(charset) 函数的作用是将字符串所表示的是字符按照charset编码，并以字节表示 比如”中文”，在Java内存中用unicode编码，表示为0x4E2D 0x6587 如果charset为”gbk”，则被编码为0xD6D0 0xCEC4 如果charset为”utf-8”，则被编码为0xE4B8AD 0xE69687 如果是charset为”iso-8859-1”，由于无法编码(不能存储中文)，最后返回0x3F 0x3F，即？？ 如果包含英文字幕和中文字幕，如”a中国”，看一下不同编码英文、中文所占的字节数 在Java内存中用unicode编码，每个字符都编码为两个字节，占的位置一样大，长度为3用gbk编码英文占1个字节，中文占两个字节用utf8编码英文占1个字节，中文占3个字节用iso885901编码英文占1个字节，不能存储中文 new String(charset)这是java字符串处理的另一个标准函数，和上一个函数的作用相反，将字节数组按照charset编码进行组合识别，最后转换为unicode存储。参考上述getBytes的例子，”gbk” 和”utf8”都可以得出正确的结果”4e2d 6587”，但iso8859-1最后变成了”003f 003f”（两个问号）。 因为utf8可以用来表示/编码所有字符，所以new String( str.getBytes( “utf8” ), “utf8” ) === str，即完全可逆。 String a = &quot;中文&quot;; byte[] gbk = a.getBytes(&quot;gbk&quot;); byte[] utf8 = a.getBytes(&quot;utf-8&quot;); byte[] iso8859_1 = a.getBytes(&quot;iso-8859-1&quot;); System.out.println(new String(gbk,&quot;gbk&quot;)); System.out.println(new String(utf8,&quot;utf-8&quot;)); System.out.println(new String(iso8859_1,&quot;iso-8859-1&quot;)); 输出 中文 中文 ?? 使用ISO-8859-1存储中文http://blog.chinaunix.net/uid-26808060-id-5692454.html 在以上例子中，尝试将中文字符使用iso-8859-1编码，字节序都是0xFF，再用iso-8859-1解码后会得到？？，这是因为iso-8859-1是单字节编码，不能直接存储中文 在网络传输或其它应用中常常有统一的中间件，因此需要把其它类型的数据转换为中间件的类型。如在Java Web中，浏览器将编码后的字节流发送给Tomcat，在tomcat内部编码转换，并处理后，然后发送给接收端。这时候如果采用不同的编码可能会出现未成预料的问题，如乱码 案例1： 我们用socket传输String类型的数据时，全部都统一为UTF-8编码，这样比较可以避免一个”中文乱码”的问题，这也是最推荐的解决中文乱码的方式。 //发送端，socket发送 String sendString = &quot;北京&quot;; System.out.println(&quot;发送数据:&quot; + sendString); byte[] sendBytes = sendString.getBytes(&quot;UTF-8&quot;); //接受端，socket接收 String recString = new String(sendBytes, &quot;UTF-8&quot;); System.out.println(&quot;接收数据:&quot; + recString); 案例2 但是想要发送的数据本身就是byte[]类型的。如果将其通过UTF-8编码转换为中间件String类型就会出现问题，（解码）如： 需要采用单字节的编码方式进行转换： String sendString=new String( bytes ,”UTF-8”); 改为 String sendString=new String( bytes , “ISO-8859-1” ); byte[] Mybytes=isoString.getBytes(“UTF8”); 改为 byte[] Mybytes=isoString.getBytes( “ISO-8859-1” ); 这样所需要的字节就有恢复了 //发送端 byte[] bytes = new byte[]{50, 0, -1, 28, -24}; String sendString = new String(bytes, &quot;iso-8859-1&quot;); byte[] sendBytes = sendString.getBytes(&quot;UTF8&quot;); //接收端 String recString = new String(sendBytes, &quot;UTF-8&quot;); byte[] Mybytes = recString.getBytes(&quot;iso-8859-1&quot;); sendString显示的是拉丁字符，是iso-8859-1单字节解码后的结果 避免中文乱码及乱码产生的原因1、最简单避免中文乱码的方式是统一编码，推荐整个系统中采用utf-8编码方式2、编码、解码一致不会出现乱码，如采用utf-8编码，但是用gbk解码，则会产生乱码，如下： String str = &quot;上海&quot;; byte[] b = str.getBytes(&quot;utf-8&quot;); String s = new String(b,&quot;gbk&quot;); System.out.println(s);//输出结果：涓婃捣 而且产生乱码不能恢复到正确的字符： 如”上”先用utf-8编码，在用gbk解码，在用gbk编码，字节序列b和gbk不同，说明由于不同编码长度不同，产生的中文乱码不可恢复 3、ISO8859-1的中文乱码 1、出现？？ String send = &quot;上海&quot;; byte[] t = send.getBytes(&quot;iso-8859-1&quot;); String recv = new String(t,&quot;iso-8859-1&quot;); 原因是正确接收到中文字符，但在存储的时候编码成iso-8859-1，此时返回的字节都是0x3F，再次用iso-8859-1（不管用什么编码，如utf-8）解码出来的时候都出现？？ 2、出现拉丁乱码ä¸æµ·，将接收到的字符按照iso-8859-1编码得到字节序，即为原来utf-8编码后的正确字节，再进行utf-8解码即可（gbk同理） String str = &quot;上海&quot;; byte[] b = str.getBytes(&quot;utf-8&quot;); System.out.println(&quot;汉字：&quot; + str + &quot;utf-8编码形式：&quot; + Arrays.toString(b)); String s = new String(b, &quot;iso8859-1&quot;); System.out.println(&quot;与之对应的iso8859-1解码形式：&quot; + s); byte[] b1 = s.getBytes(&quot;iso8859-1&quot;); System.out.println(s + &quot;与之对应的iso8859-1编码形式：&quot; + Arrays.toString(b1)); String s1 = new String(b1, &quot;utf-8&quot;); System.out.println(&quot;解析后：&quot;+ s1); 结果： 汉字：上海utf-8编码形式：[-28, -72, -118, -26, -75, -73] 与之对应的iso8859-1解码形式：ä¸æµ· ä¸æµ·与之对应的iso8859-1编码形式：[-28, -72, -118, -26, -75, -73] 解析后：上海 3、出现汉字的乱码：中文经过utf-8编码后，字节流传输 String str = &quot;上海&quot;; byte[] b = str.getBytes(&quot;utf-8&quot;); System.out.println(&quot;汉字：&quot; + str + &quot;utf-8编码形式：&quot; + Arrays.toString(b)); String s = new String(b, &quot;iso8859-1&quot;); System.out.println(&quot;与之对应的iso8859-1解码形式：&quot; + s); byte[] b1 = s.getBytes(&quot;iso8859-1&quot;); System.out.println(s + &quot;与之对应的iso8859-1编码形式：&quot; + Arrays.toString(b1)); String s1 = new String(b1, &quot;gbk&quot;);//String s1 = new String(b1, &quot;utf-8&quot;);解码成功 System.out.println(&quot;解析后：&quot;+ s1); 结果： 汉字：上海utf-8编码形式：[-28, -72, -118, -26, -75, -73] 与之对应的iso8859-1解码形式：ä¸æµ· ä¸æµ·与之对应的iso8859-1编码形式：[-28, -72, -118, -26, -75, -73] 解析后：涓婃捣 Mysql 几个参数的意义gbk和utf-8不能转码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql中文乱码]]></title>
      <url>%2F2017%2F02%2F25%2F%5BMysql%5DMysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
      <content type="text"><![CDATA[JDBCJDBC获得数据库连接时写在URL上的?useUnicode=true&amp;characterEncoding=utf-8，作用是指定字符的编码和解码格式 例如：mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码。这时候如果添加了useUnicode=true&amp;characterEncoding=UTF-8 ，那么作用有如下两个方面： 1、存数据时： 数据库在存放项目数据的时候会先用UTF-8格式将数据解码成字节码，然后再将解码后的字节码重新使用GBK编码存放到数据库中。 2、取数据时： 在从数据库中取数据的时候，数据库会先将数据库中的数据按GBK格式解码成字节码，然后再将解码后的字节码重新按UTF-8格式编码数据，最后再将数据返回给客户端。 设置数据库字符集有时候程序操作Mysql数据库时会出现 “?????” 或者是其他中文乱码，在命令行中输入： show variables like &apos;character%&apos;; 可看到如下字符： character_set_client latin1 character_set_connection latin1 character_set_database utf8 character_set_results latin1 character_set_server utf8 character_set_system utf8 解决办法是，在连接数据库之后，读取数据之前，先执行一项查询”SET NAMES UTF8” 在PHP里为 mysql_query(“SET NAMES UTF8”); 在JDBC或者Mybatis中使用查询SQL语句为 “SET NAMES UTF8” 到MySQL命令行输入”SET NAMES UTF8;”，然后执行 show variables like &apos;character%&apos;; 发现原来为latin1的那些量”character_set_client”、“character_set_connection”、“character_set_results”的值全部变为utf8了，原来是这3个变量在捣蛋。 查阅手册，上面那句等于： SET character_set_client = utf8; SET character_set_connection = utf8; SET character_set_results = utf8; 看看这3个变量的作用： 信息输入路径：client→connection→server 信息输出路径：server→connection→results 换句话说，每个路径要经过3次改变字符集编码。以出现乱码的输出为例，server里utf8的数据，传入connection转为latin1，传入results转为latin1，utf-8页面又把results转过来。如果两种字符集不兼容，比如latin1和utf8，转化过程就为不可逆的，破坏性的。 但这里要声明一点，”SET NAMES UTF8”作用只是临时的，MySQL重启后就恢复默认了。 总结：为了让你的网页能在更多的服务器上正常地显示，还是加上”SET NAMES UTF8”吧，即使你现在没有加上这句也能正常访问。 http://blog.csdn.net/zsmj_2011/article/details/7943734]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git笔记]]></title>
      <url>%2F2017%2F02%2F17%2F%5BGit%5DGit%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[git log -p FILEPATH 单文件的改动git reset –hard commit_id 撤销摸个commit ##中文乱码git显示中文被转义http://mushanshitiancai.github.io/2016/03/18/linux/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符编码]]></title>
      <url>%2F2017%2F02%2F15%2F%5B%E7%BC%96%E7%A0%81%5D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[各种字符集和编码详解http://blog.csdn.net/ancky/article/details/2034809Java字符编码http://blog.csdn.net/xiongchao2011/article/details/7276834★★★十分钟搞清字符集和字符编码http://cenalulu.github.io/linux/character-encoding/ 字符（英文、中文、符号、数字等）需要在计算机内存储，必须进行编码 什么是字符集我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。那么在这两者之间的转换规则就需要一个统一的标准，否则把我们的U盘插到老板的电脑上，文档就乱码了 于是为了实现转换标准，各种字符集标准就出现了。简单的说字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系 字符编码发展历史ASCII 最早的ASCII码用7个二进制表示（0x00 - 0x7F），能表示128个字符，足够表示英语及西欧语言 iso8859-1（Latin-1） 最优秀的扩展ASCII，8位长度（一个字节，范围从0x00 - 0xFF），能表示256个字符 单字节编码，和计算机最基础的表示单位一致，在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”，一个汉字编码成两个字节，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节”e4 b8 ad e6 96 87”，一个汉字编码成三个字节。很明显，这种表示方法还需要以另一种编码为基础。 GB码字符集，GB2312，GB12345-90，GBK字符集 双字节编码 GBK编码能够用来同时表示繁体字和简体字，而GB2312只能表示简体字，GBK是兼容gb2312编码的，是GB2312的扩展，共收录汉字21003个、符号883个 BIG5字符集 是目前台湾、香港地区普遍使用的一种繁体汉字的编码标准，为统一繁体字编码，使用2个字节表示汉字，Big5字符集共收录13,053个中文字 Unicode字符集（UCS） 各国文字、符号进行统一性编码，Unicode编码后占用的空间大小是一样的，都是两个字节 定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如Java UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16，UTF-32和UTF-7编码。 UTF-8 unicode对于英文字母也要用两个字节来表示，浪费空间，不利于传输和存储，因而产生了utf编码 UTF-8是不定长编码。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节 虽然utf编码对汉字使用3个字节，但即使对于汉字网页，utf编码也会比unicode编码节省，因为网页中包含了很多的英文字符 Base64 对内容进行简单加密，即一眼望去看不出内容即可，不需要进行复杂的加密 由于历史原因Email只被允许传送ASCII字符，即一个8位字节的低7位，这是产生Base64编码的主要原因 111111 x11 1111 x1111 11x111111]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Thrift笔记]]></title>
      <url>%2F2017%2F02%2F13%2F%5BThrift%5DThrift%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Thrifthttp://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/#ibm-pcon目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架 Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势 Thrift流程1、使用 IDL 语法定义接口 Hello.thrift namespace java service.demo service Hello{ string helloString(1:string para) } service.demo：包名Hello：生成的类名helloString：定义的接口名 2、使用thrift编译器生成Java代码 命令： thrift -r --gen java tutorial.thrift thrift编译器下载地址： http://www.apache.org/dyn/closer.cgi?path=/thrift/0.9.3/thrift-0.9.3.exe 3、生成对应语言的接口代码及服务调用的底层通信细节，生成的对应语言代码与编译器位于同一目录 package service.demo; class Hello{ //生成的对应语言的接口 public interface Iface { public String helloString(String para) throws org.apache.thrift.TException; } //###客户端调用逻辑 public static class Client extends org.apache.thrift.TServiceClient implements Iface { ... //实现的接口方法 public String helloString(String para) throws org.apache.thrift.TException { //向服务器发送请求方法+参数 send_helloString(para); //接受服务器的请求 return recv_helloString(); } //发送请求方法+参数，其中helloString为调用服务器的方法名，args为方法参数 public void send_helloString(String para) throws org.apache.thrift.TException { helloString_args args = new helloString_args(); args.setPara(para); sendBase(&quot;helloString&quot;, args); } //接受服务器返回的结果 public String recv_helloString() throws org.apache.thrift.TException { helloString_result result = new helloString_result(); receiveBase(result, &quot;helloString&quot;); if (result.isSetSuccess()) { return result.success; } throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, &quot;helloString failed: unknown result&quot;); } ... } } //### 服务端处理逻辑 public static class Processor&lt;I extends Iface&gt; extends org.apache.thrift.TBaseProcessor&lt;I&gt; implements org.apache.thrift.TProcessor { private static &lt;I extends Iface&gt; Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; getProcessMap(Map&lt;String, org.apache.thrift.ProcessFunction&lt;I, ? extends org.apache.thrift.TBase&gt;&gt; processMap) { processMap.put(&quot;helloString&quot;, new helloString()); return processMap; } public static class helloString&lt;I extends Iface&gt; extends org.apache.thrift.ProcessFunction&lt;I, helloString_args&gt; { public helloString() { super(&quot;helloString&quot;); } public helloString_args getEmptyArgsInstance() { return new helloString_args(); } protected boolean isOneway() { return false; } public helloString_result getResult(I iface, helloString_args args) throws org.apache.thrift.TException { helloString_result result = new helloString_result(); result.success = iface.helloString(args.para); return result; } } } 4、创建接口实现类 服务器创建接口实现类 public HelloServiceImpl implements Hello.Iface{ @Override public String helloString(String para) throws org.apache.thrift.TException{ System.our.println(&quot;Hello&quot;); } } 5、启动Thrift服务器，HelloServiceImpl 作为具体的处理器传递给 Thrift 服务器 public class Server { /** * 启动 Thrift 服务器 * @param args */ public static void main(String[] args) throws TTransportException { try { //1、传输层，设置服务端口为 7911 TServerSocket serverTransport = new TServerSocket(7911); //2、协议，工厂为 TBinaryProtocol.Factory TBinaryProtocol.Factory proFactory = new TBinaryProtocol.Factory(); // 处理器 TProcessor processor = new Hello.Processor(new HelloImpl()); //3、服务端类型，关联端口、协议、处理器与 Hello 服务的实现 TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(serverTransport); tArgs.processor(processor); tArgs.protocolFactory(proFactory); TServer server = new TThreadPoolServer(tArgs); System.out.println(&quot;Start server on port 7911...&quot;); server.serve(); } catch (TTransportException e) { e.printStackTrace(); } } } 6、客户端连接到端口，发送请求调用方法，服务端响应结果，客户端接受结果 public class Client { /** * 调用 Hello 服务 * * @param args */ public static void main(String[] args) { try { // 设置调用的服务地址为本地，端口为 7911 TTransport transport = new TSocket(&quot;localhost&quot;, 7911); transport.open(); // 设置传输协议为 TBinaryProtocol TProtocol protocol = new TBinaryProtocol(transport); //客户端调用 Hello.Client client = new Hello.Client(protocol); // 调用服务的 helloVoid 方法 System.out.println(client.helloString(&quot;客户端传入参数&quot;)); transport.close(); } catch (TTransportException e) { e.printStackTrace(); } catch (TException e) { e.printStackTrace(); } } } Thrift架构 如图所示，图中黄色部分是用户实现的业务逻辑，褐色部分是根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架，红色部分是根据 Thrift 文件生成代码实现数据的读写操作。红色部分以下是 Thrift 的传输体系、协议以及底层 I/O 通信，使用 Thrift 可以很方便的定义一个服务并且选择不同的传输协议和传输层而不用重新生成代码。 Thrift 服务器包含用于绑定协议和传输层的基础架构，它提供阻塞、非阻塞、单线程和多线程的模式运行在服务器上，可以配合服务器 / 容器一起运行，可以和现有的 J2EE 服务器 /Web 容器无缝的结合。 该图所示是 HelloServiceServer 启动的过程以及服务被客户端调用时，服务器的响应过程。从图中我们可以看到，程序调用了 TThreadPoolServer 的 serve 方法后，server 进入阻塞监听状态，其阻塞在 TServerSocket 的 accept 方法上。当接收到来自客户端的消息后，服务器发起一个新线程处理这个消息请求，原线程再次进入阻塞状态。在新线程中，服务器通过 TBinaryProtocol 协议读取消息内容，调用 HelloServiceImpl 的 helloVoid 方法，并将结果写入 helloVoid_result 中传回客户端。 该图所示是 HelloServiceClient 调用服务的过程以及接收到服务器端的返回值后处理结果的过程。从图中我们可以看到，程序调用了 Hello.Client 的 helloVoid 方法，在 helloVoid 方法中，通过 send_helloVoid 方法发送对服务的调用请求，通过 recv_helloVoid 方法接收服务处理请求后返回的结果。 数据类型Thrift 脚本可定义的数据类型包括以下几种类型： 基本类型： bool：布尔值，true 或 false，对应 Java 的 boolean byte：8 位有符号整数，对应 Java 的 byte i16：16 位有符号整数，对应 Java 的 short i32：32 位有符号整数，对应 Java 的 int i64：64 位有符号整数，对应 Java 的 long double：64 位浮点数，对应 Java 的 double string：未知编码文本或二进制字符串，对应 Java 的 String 结构体类型： struct：定义公共的对象，类似于 C 语言中的结构体定义，在 Java 中是一个 JavaBean 容器类型： list：对应 Java 的 ArrayList set：对应 Java 的 HashSet map：对应 Java 的 HashMap 异常类型： exception：对应 Java 的 Exception 服务类型： service：对应服务的类 ★协议Thrift 可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本 (text) 和二进制 (binary) 传输协议，为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目 / 产品中的实际需求。常用协议有以下几种： TBinaryProtocol —— 二进制编码格式进行数据传输 // 设置协议工厂为 TBinaryProtocol.Factory TBinaryProtocol.Factory proFactory = new TBinaryProtocol.Factory(); TCompactProtocol —— 高效率的、密集的二进制编码格式进行数据传输，构建 TCompactProtocol 协议的服务器和客户端只需替换案例中 TBinaryProtocol 协议部分即可 TCompactProtocol.Factory proFactory = new TCompactProtocol.Factory(); TJSONProtocol —— 使用 JSON 的数据编码协议进行数据传输，构建 TJSONProtocol 协议的服务器和客户端只需替换案例中 TBinaryProtocol 协议部分即可 TJSONProtocol.Factory proFactory = new TJSONProtocol.Factory(); TSimpleJSONProtocol —— 只提供 JSON 只写的协议，适用于通过脚本语言解析 ★传输层常用的传输层有以下几种： TSocket —— 使用阻塞式 I/O 进行传输，是最常见的模式（案例） //服务端 TServerSocket serverTransport = new TServerSocket(7911); //客户端 TTransport transport = new TSocket(&quot;localhost&quot;, 7911); TFramedTransport —— 使用非阻塞方式，按块的大小进行传输，类似于 Java 中的 NIO，若使用 TFramedTransport 传输层，其服务器必须修改为非阻塞的服务类型，客户端只需替换案例中 TTransport 部分 服务器 TNonblockingServerTransport serverTransport; serverTransport = new TNonblockingServerSocket(10005); Hello.Processor processor = new Hello.Processor(new HelloServiceImpl()); TServer server = new TNonblockingServer(processor, serverTransport); System.out.println(&quot;Start server on port 10005 ...&quot;); server.serve(); 客户端 TTransport transport = new TFramedTransport(new TSocket(&quot;localhost&quot;, 10005)); TNonblockingTransport —— 使用非阻塞方式，用于构建异步客户端使用方法请参考 Thrift 异步客户端构建 ★服务端类型常见的服务端类型有以下几种： TSimpleServer —— 单线程服务器端使用标准的阻塞式 I/O TServerSocket serverTransport = new TServerSocket(7911); TProcessor processor = new Hello.Processor(new HelloServiceImpl()); TServer server = new TSimpleServer(processor, serverTransport); System.out.println(&quot;Start server on port 7911...&quot;); server.serve(); TThreadPoolServer —— 多线程服务器端使用标准的阻塞式 I/O（案例） // 设置服务端口为 7911 TServerSocket serverTransport = new TServerSocket(7911); // 设置协议工厂为 TBinaryProtocol.Factory TBinaryProtocol.Factory proFactory = new TBinaryProtocol.Factory(); // 处理器 TProcessor processor = new Hello.Processor(new HelloImpl()); //关联端口、协议、处理器与 Hello 服务的实现 TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(serverTransport); tArgs.processor(processor); tArgs.protocolFactory(proFactory); TServer server = new TThreadPoolServer(tArgs); System.out.println(&quot;Start server on port 7911...&quot;); server.serve(); TNonblockingServer —— 多线程服务器端使用非阻塞式 I/O使用方法请参考 Thrift 异步客户端构建 Thrift 异步客户端构建Thrift 提供非阻塞的调用方式，可构建异步客户端。在这种方式中，Thrift 提供了新的类 TAsyncClientManager 用于管理客户端的请求，在一个线程上追踪请求和响应，同时通过接口 AsyncClient 传递标准的参数和 callback 对象，服务调用完成后，callback 提供了处理调用结果和异常的方法。首先我们看 callback 的实现： package service.callback; import org.apache.thrift.async.AsyncMethodCallback; public class MethodCallback implements AsyncMethodCallback { Object response = null; public Object getResult() { // 返回结果值 return this.response; } // 处理服务返回的结果值 @Override public void onComplete(Object response) { this.response = response; } // 处理调用服务过程中出现的异常 @Override public void onError(Throwable throwable) { } } 如代码所示，onComplete 方法接收服务处理后的结果，此处我们将结果 response 直接赋值给 callback 的私有属性 response。onError 方法接收服务处理过程中抛出的异常，此处未对异常进行处理。 创建非阻塞服务器端实现代码，将 HelloServiceImpl 作为具体的处理器传递给异步 Thrift 服务器，代码如下： package service.server; import org.apache.thrift.server.TNonblockingServer; import org.apache.thrift.server.TServer; import org.apache.thrift.transport.TNonblockingServerSocket; import org.apache.thrift.transport.TNonblockingServerTransport; import org.apache.thrift.transport.TTransportException; import service.demo.Hello; import service.demo.HelloServiceImpl; public class HelloServiceAsyncServer { /** * 启动 Thrift 异步服务器 * @param args */ public static void main(String[] args) { TNonblockingServerTransport serverTransport; try { serverTransport = new TNonblockingServerSocket(10005); Hello.Processor processor = new Hello.Processor( new HelloServiceImpl()); TServer server = new TNonblockingServer(processor, serverTransport); System.out.println(&quot;Start server on port 10005 ...&quot;); server.serve(); } catch (TTransportException e) { e.printStackTrace(); } } } HelloServiceAsyncServer 通过 java.nio.channels.ServerSocketChannel 创建非阻塞的服务器端等待客户端的连接。 创建异步客户端实现代码，调用 Hello.AsyncClient 访问服务端的逻辑实现，将 MethodCallback 对象作为参数传入调用方法中，代码如下： package service.client; import java.io.IOException; import org.apache.thrift.async.AsyncMethodCallback; import org.apache.thrift.async.TAsyncClientManager; import org.apache.thrift.protocol.TBinaryProtocol; import org.apache.thrift.protocol.TProtocolFactory; import org.apache.thrift.transport.TNonblockingSocket; import org.apache.thrift.transport.TNonblockingTransport; import service.callback.MethodCallback; import service.demo.Hello; public class HelloServiceAsyncClient { /** * 调用 Hello 服务 * @param args */ public static void main(String[] args) throws Exception { try { TAsyncClientManager clientManager = new TAsyncClientManager(); TNonblockingTransport transport = new TNonblockingSocket( &quot;localhost&quot;, 10005); TProtocolFactory protocol = new TBinaryProtocol.Factory(); Hello.AsyncClient asyncClient = new Hello.AsyncClient(protocol, clientManager, transport); System.out.println(&quot;Client calls .....&quot;); MethodCallback callBack = new MethodCallback(); asyncClient.helloString(&quot;Hello World&quot;, callBack); Object res = callBack.getResult(); while (res == null) { res = callBack.getResult(); } System.out.println(((Hello.AsyncClient.helloString_call) res) .getResult()); } catch (IOException e) { e.printStackTrace(); } } } HelloServiceAsyncClient 通过 java.nio.channels.Socketchannel 创建异步客户端与服务器建立连接。在本文中异步客户端通过以下的循环代码实现了同步效果，读者可去除这部分代码后再运行对比。 异步客户端实现同步效果代码段 Object res = callBack.getResult(); // 等待服务调用后的返回结果 while (res == null) { res = callBack.getResult(); } 我们可以构建一个 TNonblockingServer 服务类型的服务端，在客户端构建一个 TFramedTransport 传输层的同步客户端和一个 TNonblockingTransport 传输层的异步客户端，那么一个服务就可以通过一个 socket 端口提供两种不同的调用方式。有兴趣的读者可以尝试一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XML CDATA的作用]]></title>
      <url>%2F2017%2F02%2F13%2F%5BSSM%5DXML%20CDATA%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
      <content type="text"><![CDATA[http://www.cnblogs.com/myparamita/archive/2008/12/27/1363626.html XML文件中的一些特殊符号，例如：”&lt;”、”&gt;”、”/“、”？”等，会破坏了XML结构 有两种方式解决： 转义字符 CDATA部件 转义字符如果在XML文档中使用类似”&lt;”的字符, 那么解析器将会出现错误，因为解析器会认为这是一个新元素的开始。所以不应该象下面那样书写代码: &lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; 为了避免出现这种情况，必须将字符”&lt;”转换成实体，象下面这样: &lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; 下面是五个在XML文档中预定义好的实体: &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和 &amp;apos; &apos; 单引号 &amp;quot; &quot; 双引号 实体必须以符号”&amp;”开头，以符号”;”结尾。 注意: 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。 CDATA在CDATA内部的所有内容都会被解析器忽略。 如果文本包含了很多的”&lt;”字符和”&amp;”字符——就象程序代码一样，那么最好把他们都放到CDATA部件中。 一个 CDATA 部件以”&lt;![CDATA[“标记开始，以”]]&gt;”标记结束: &lt;script&gt; &lt;![CDATA[ function matchwo(a,b) { if (a &lt; b &amp;&amp; a &lt; 0) then { return 1 } else { return 0 } } ]]&gt; &lt;/script&gt; 在前面的例子中，所有在CDATA部件之间的文本都会被解析器忽略。 CDATA注意事项:CDATA部件之间不能再包含CDATA部件（不能嵌套）。如果CDATA部件包含了字符”]]&gt;” 或者”&lt;![CDATA[“ ，将很有可能出错哦。 同样要注意在字符串”]]&gt;”之间没有空格或者换行符。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven聚合与继承]]></title>
      <url>%2F2017%2F02%2F09%2F%5BMaven%5DMaven%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[聚合什么是聚合？聚合就是把多个模块或项目聚合到一起，简单统一的完成编译等工作 为了能够使用一条命令就能构建 account-email 和 account-persist两个模块，我们需要建立一个额外的名为 account-aggregator 的模块，然后通过该模块构建整个项目的所有模块。 account-aggregator本身也是个 Maven 项目，它的 POM如下 &lt;project> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.juvenxu.mvnbook.account&lt;/groupId> &lt;artifactId>account-aggregator&lt;/artifactId> &lt;version>1.0.0-SNAPSHOT&lt;/version> &lt;packaging> pom &lt;/packaging> &lt;name>Account Aggregator&lt;/name> &lt;modules> &lt;module>account-email&lt;/module> &lt;module>account-persist&lt;/module> &lt;/modules> &lt;/project> 注意：packaging的类型为pom ，module的值是一个以当前POM为主目录的相对路径。 继承在POM中申明一些配置供子POM继承，以实现”一处申明，多处使用的”目的 在account-aggregator下创建一个account-parent的子目录，然后在该子目录下创建除account-aggregator模块之外的模块的父模块。为此在该子目录下创建一个pom.xml文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;springframework.version&gt;2.5.6&lt;/springframework.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework &lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${springframework.version}&lt;/version&gt; &lt;/dependency&gt; ...... &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 需要注意的是它的packaging的值必须为pom，这一点与模块聚合一样，作为父模块的POM，其打包类型也必须为pom。由于父模块只是为了消除配置的重复，因此也就不需要src/main/java等目录了 有了父模块就让其他子模块来继承它，修改account-email的pom文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../account-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;account-email&lt;/artifactId&gt; &lt;name&gt;Account Email&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; ...... &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; ...... &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 只配置了groupId和artifactId,省去了version，如果父模块配置了依赖的scope也是可以省略的。这些信息可以省略是因为account-email继承了account-parent中的dependencyManagement配置，完整的依赖声明已经包含在父POM中了，子模块只需简单的配置groupId和artifactId。 使用这种以来管理机制虽然不能减少太多的配置项，但是经过别人实践后强烈推荐的方法。如果子模块不声明依赖的使用，即使该依赖已经在父POM文件dependencyManagement中声明了，也不会产生任何实际的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发编程设计模式]]></title>
      <url>%2F2017%2F01%2F25%2F%5BJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5D%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Future 模式考虑这样一个情况，使用者可能快速翻页浏览文件中，而图片档案很大，如此在浏览到有图片的页数时，就会导致图片的载入，因而造成使用者浏览文件时会有停顿的现象，所以我们希望在文件开启之后，会有一个默认背景（可以是纯色图片，也可以是正在加载的图片），与此同时，程序开始加载图片的工作，如此使用者在快速浏览页面时，所造成的停顿可以获得改善。 Future模式在请求发生时，会先产生一个Future物件给发出请求的客户，而同时间，真正的目标物件之生成，由一个新的执行持续进行（即 Worker Thread），真正的目标物件生成之后，将之设定至Future之中，而当客户端真正需要目标物件时，目标物件也已经准备好，可以让客户提取使用。 一个简单的Java程式片段示范可能像是这样： public Future request() { final Future future = new Future(); new Thread() { public void run() { // 下面這個動作可能是耗時的 RealSubject subject = new RealSubject(); future.setRealSubject(subject); } }.start(); return future; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通用mapper]]></title>
      <url>%2F2017%2F01%2F18%2F%5Bmybatis%5D%E9%80%9A%E7%94%A8mapper%2F</url>
      <content type="text"><![CDATA[不是表中字段的属性必须加 @Transient 注解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSTL常用语法]]></title>
      <url>%2F2017%2F01%2F17%2F%5BServlet%5DJSTL%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Maven依赖&lt;!--JSP相关--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; JSP头&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jstl/fmt_rt&quot;%&gt; 常用标签PS：传入的对象除了一般的POJO对象，还可以是JSONObject和JSONArray &lt;c:if&gt; 标签 &lt;!-- 判断集合不为空 --&gt; &lt;c:if test=&quot;${!empty list}&quot;&gt; ... &lt;/c:if&gt; &lt;!-- 元素判断 --&gt; &lt;c:if test=&quot;${salary &gt; 2000}&quot;&gt; &lt;p&gt;我的工资为: &lt;c:out value=&quot;${salary}&quot;/&gt;&lt;p&gt; &lt;/c:if&gt; &lt;c:forEach&gt; 标签 &lt;c:forEach items="${list}" var="o" varStatus="status"> &lt;!-- 下标 --> 订单[${status.index + 1}] 的订单号是： ${o.orderNo} &lt;/c:forEach> forEach嵌套 &lt;% Map&lt;String, String[]&gt; bigCities = new HashMap&lt;String,String[]&gt;(); bigCities.put(&quot;Australia&quot;,new String[]{&quot;Sydney&quot;,&quot;Melbourne&quot;,&quot;Perth&quot;}); bigCities.put(&quot;New Zealand&quot;,new String[]{&quot;Auckland&quot;,&quot;Christchurch&quot;,&quot;Wellington&quot;}); bigCities.put(&quot;Indonesia&quot;,new String[]{&quot;Jakarta&quot;,&quot;Surabaya&quot;,&quot;Medan&quot;}); request.setAttribute(&quot;bigCities&quot;,bigCities); %&gt; &lt;c:forEach var=&quot;mapItem&quot; items=&quot;${bigCities}&quot;&gt; ${mapItem.key} : &lt;c:forEach var=&quot;city&quot; items=&quot;${mapItem.value}&quot;&gt; ${city} &lt;/c:forEach&gt; &lt;br/&gt; &lt;/c:forEach&gt; 遍历Map &lt;% Map&lt;String, String&gt; capitals = new HashMap&lt;String,String&gt;(); capitals.put(&quot;Indonesia&quot;,&quot;Jakarta&quot;); capitals.put(&quot;Malaysia&quot;,&quot;Kuala Lumpur&quot;); capitals.put(&quot;Thailand&quot;,&quot;Bangkok&quot;); request.setAttribute(&quot;capitals&quot;,capitals); %&gt; &lt;c:forEach var=&quot;capital&quot; items=&quot;${capitals}&quot;&gt; ${capital.key} ${capital.value} &lt;br/&gt; &lt;/c:forEach&gt; 日期 &lt;fmt:formatDate value=&quot;${o.confirmDate}&quot; type=&quot;date&quot; /&gt; &lt;fmt:parseDate value=&quot;${now}&quot; var=&quot;parsedEmpDate&quot; pattern=&quot;dd-MM-yyyy&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java并发编程的艺术笔记]]></title>
      <url>%2F2017%2F01%2F13%2F%5BJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5DJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[并发编程的挑战 并发编程的 目的 是让程序运行得更快，但是并不是启动越多的线程就能让程序跑的更快 如果希望多线程执行任务使程序运行得更快，需要面临许多挑战，比如：上下文切换、死锁、资源限制问题 上下文切换多线程 CPU为每个线程划分 时间片，每个线程在给定的时间片上交替运行。因为时间片非常短，从宏观上我们感觉多个线程同时运行 单核 处理器也支持多线程执行代码 上下文切换概念 每个线程在给定的时间片上运行，执行结束后会 切换 到下一个任务。但是在切换前会保存上一个任务的状态，以便下次切换回来后可以 继续加载 这个任务的状态，从保存到加载的过程称为一次上下文切换 多线程速度一定快？ 不一定，用得得当多线程的任务执行速度比串行快；但是线程有创建和上下文切换的开销，有时候并发执行速度比串行慢 如何减小上下文切换 无锁并发编程：多线程竞争锁时会引起上下文切换，可以用一些方法来避免使用锁，如数据分段，每个线程处理不同段的数据 CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要使用锁 使用最少线程：避免创造不需要的线程，比如任务少，线程多，造成大量线程处于等待状态 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换 死锁举个例子 Thread t1 = new Thread(new Runnable(){ @Override public void run(){ synchronized(A){ Thread.sleep(2000); synchronized(B){} } } }); Thread t2 = new Thread(new Runnable(){ @Override public void run(){ synchronized(B){ Thread.sleep(2000); synchronized(A){} } } }); 线程1：持有锁A，等待锁B线程2：持有锁B，等待锁A 线程1和线程2互相等待对方释放锁，引起死锁 避免死锁的一些方法 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 资源限制的挑战资源限制指的是在进行并发编程时，程序的执行速度受限于 计算机硬件资源 或者 软件资源 。硬件资源有带宽、硬盘读写速度、CPU处理速度，软件资源有数据库的连接数和socket连接数等 资源限制会使原来并发执行的代码仍串行执行，由于增加了上下文切换和资源调度的时间，执行速度反而更慢 如何解决资源限制问题？对于硬件资源限制，可以考虑使用集群并行执行程序，对于软件资源限制，可以考虑使用资源池将资源服用 Java并发编程的底层实现原理Java的并发机制依赖于 volatile 的应用synchronized 的实现原理与应用原子操作的实现原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[论文技术方向]]></title>
      <url>%2F2017%2F01%2F11%2F%5B%E8%AE%BA%E6%96%87%5D%E8%AE%BA%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%2F</url>
      <content type="text"><![CDATA[背景各种各样的网络攻击对互联网的安全造成了重大影响 DDoS是一种常见、危害大的网络攻击 —— ddos介绍（DDoS攻击的根源）、危害（服务器崩溃，正常用户提供正常的服务），DDoS攻击类型：不同攻击速率，流量大小，隐藏源IP地址 DDoS攻击检测研究现状，检测方法分类：包分析和流量分析 为什么要大数据分析？进入大数据时代，越来越多的公司使用虚拟化数据中心和云服务，DDoS攻击开始移师云计算。尽管当前针对DDoS攻击的入侵检测模型的研究已经较为成熟，但由于云主机所具有的一些有别于普通主机的特性，所以不能将已有的入侵检测技术直接应用到云计算中。 传统的可行的方案在数据量变大时难以处理，需要使用大数据技术对对DDoS攻击检测 DDoS攻击原理，ddos攻击工具源码分析，DDoS数据库 研究目的：构建一个检测DDos系统模型，具有较高的准确性和实时性 研究内容：目前，对 DDoS 攻击检测技术的研究已经较为成熟，但随着云技术的发展，DDoS 攻击在云环境中又呈现出新的特性。云环境所拥有的强大计算能力和存储资源使得 DDoS 攻击在云环境中具有更强的破坏力。本文先对现有 DDoS 攻击原理、检测技术进行充分研究，又对云环境所具有的虚拟化、分布式特定进行分析。在综合以上二者的基础上，设计出基于云环境的 DDoS 攻击入侵检测模型。该模型具有传统入侵检测系统的优点，并加入了资源调度、容错等更适于云环境攻击检测的功能模块。 云计算-数据泄露等数据安全问题-入侵检测-DDoS攻击检测-传统技术无法处理大型数据-大数据平台Spark-DDos攻击工具源码分析-流量统计[趋势分析，总的应该是上升；]+包分析（负载检查，比如数据包大小，内容是否一致，及其他包特征来判定是否是DDos攻击）-用户行为分析（不同时间访问量不同，设定的阈值不同，回归模型，历史数据生成关联规则算法、序列模式算法、BP神经网络（深度学习）-训练处阈值进行检测（阈值动态变化）） - 当前与历史误差多少判断为遭遇DDos攻击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[论文]]></title>
      <url>%2F2017%2F01%2F07%2F%5B%E8%AE%BA%E6%96%87%5D%E8%AE%BA%E6%96%87%2F</url>
      <content type="text"><![CDATA[基于数据挖掘的网络安全审计技术的研究与实现_辛义忠.caj背景网络攻击问题随着网络的普及而日益突出。 目前的解决方案1、入侵检测技术通过对网络安全审计数据进行分析和处理来发现网络中的入侵活动和入侵者,在网络安全领域起到了重要的作用。其关键和核心内容是进行网络安全审计。2、网络安全审计的目的是实时地、不间断地监视整个网络系统以及应用程序的运行状态,及时发现系统中可疑的、违规的或危险的行为,进行报警和采取阻断措施,并留下记录。 存在问题1、目前的审计系统可以高效地实现安全审计数据的输入、查询、统计等功能,但无法发现数据中存在的关联、关系和规则,无法根据现有的数据预测未来的发展趋势,缺乏挖掘数据背后隐藏的知识的手段。 2、目前入侵检测系统或安全审计系统中普遍采用的特征检测l的方法是由安全专家预先定义一系列特征模式来识别入侵。这种方法的问题是模式库得不到及时的更新,这样在安全审计的过程中系统不能自适应地识别出新型攻击,使误报警和漏报警问题不断发生。另外,一方面随着网络应用的普及,网络数据流量急剧增加,另一方面有些审计记录本身包含了大量的无关信息,于是,数据过载与检测速度过慢的问题也不无出现。可见，目前在安全审计的过程中普遍存在的问题主要有: （1）准确率低准确率低主要体现在误报警和漏报警两个方面。误报警是指将正常的用户行为及模式判断为入侵并发出警告。误报警是在安全审计过程中亟待解决的问题之一。由于事先定义的模式很难精确地划分正常行为和入侵行为之间的界限,因此虚警率一直居高不下。误报情况不仅使得安全管理员疲于人工应对出现的警报,也降低了安全管理员对真正报警的敏感度。而将入侵行为错判为正常行为的漏报情况也会严重影响入侵检测系统的可用性。 （2）检测速度过慢入侵检测系统事后反映的本质决定了将入侵检测的延迟最小化对于入侵检测系统来说是至关重要的。而入侵检测延迟又取决于处理数据的效率。随着网络应用的普及,网络数据流量急剧增加,一个网站每天可能会产生上百万条的事件记录。面对如此庞大的数据,入侵检测系统如何有效地完成数据审计以便做出及时反应成为一个难题。 （3）自适应性差网络上的数据是随着网络应用的变化而改变的,而特征检测是基于预先定义的模式,这就意味着它不可能根据网络数据的变化自适应地修改检测模式。因此,对于现有攻击手段的简单变种,特征检测是无能为力的,更不用说新型的攻击技术了。另外,有些审计记录包含了大量的无关信息,有些则显得过于精简,缺乏审计子系统的说明文档,这些都是目前的商业产品中审计子系统存在的问题。 3、目前大多数服务器操作系统都有日志，但是这些日志往往只是记录一些零碎的信息(如用户登录的时间信息),从这些日志中无法看到用户到底做了些什么操作,整个入侵的步骤是如何发生的。而且分散在各个操作系统中的日志需要用户管理员分别查看,进行人工的综合、分析、判断,实际上是很难奏效的。特别值得重视的是,这些服务器往扫一是处于无人看守状况下自动运行的,所以被攻克或者违规操作的时候管理员不在现场,日志文件很有可能被黑客删除或者修改,在这些被修改的日志卜进行侦破可能根本没有效果,甚至有一可能产生误导,起到相反的作用。目前在国际互联网上几已经有各种修改操作系统日志的工具,用这些工具就可以轻松修改操作系统的日志,所以这些功能和安全测评规范中的安全审计要求也有很大的差距。 4、有此Sniff类的工具(如Netxray、Snoop、Sniffit、Tcpdump)能够显示网络上流过的数抓包,并将包头和包的内部信息标识出来,这些工具从一定意义使得网络上传输的数抓变得可见,能够观察到一些网络用户正在进行的操作和传输的数据,所以这此工具对正在发生的违规操作能够起到一定的检测作用。但是仅仅是这些工具还不能承担日常的安全审计工作,因为这些工具只是对单个包进行解码,缺乏分析能力,无法判断是否是重要的信息和违规的信息,此外它们不具备上下文相关的网络操作行为判断的能力,也缺乏报警响应的能力。目前网络的实际流量是非常大的,如果不加分析全部记录的话,子任何磁盘也会在很短的时间内充满。所以这些只是些辅助判断网络故障的工具,目前还没有哪个系统真正将这些工具收集的数据长时间安全记录下来。 审计系统关键1、如何在大量的审计数据中提取出具有代表性的系统特征模式,并对程序或用户行为做出描述,是实现安全事件审计系统的关键。2、为了对审计数据进行全面、高速和准确地分析,需要利用数据挖掘等方法来处理安全事件数据,从包含大量冗余信息的数据中提取出尽可能多的隐藏的安全信息,抽象出有利于进行判断和比较的特征模型并用相应的算法由计算机判断出当前网络行为的性质。3、数据挖掘作为一种从大量数据中发现有用模式的一种新兴知识发现技术,在特征和规则的提取方面有非常大的优势。 研究目标、内容、重点、拟解决的问题(1)研究目标 用数据挖掘技术解决目前在安全审计过程中存在的不足,找出数据挖掘和网络安全审计在技术上的结合点,建立基于数据挖掘的网络安全审计模型。 (2)研究内容与工作重点 本文试图将数据挖掘技术应用于网络安全审计领域,利用数据挖掘中的分类技术、关联分析、序列模式分析和聚类技术等方法提取与安全有关的系统体征属性,并根据系统特征属性生成安全事件的分类模型,用于对安全事件的自动鉴别。目的是要建立一套完整的基于数据挖掘的网络安全审计模型,在这个模型中包括了针对安全事件审计数据的数据采集、数据预处理、特征变换与选取、数据挖掘、规则生成、挖掘结果处理等系列过程。 (3)拟解决的关键问题 1、安全审计的速度;2、安全审计的准确率;3、安全审计的自适应能力。 但目前在安全审计过程中普遍存在着检测准确率低、检测速度慢和自适应性差等问题。为了解决这些问题,本文提出了基于数据挖掘的网络安全审计系统的方案并加以实现。 数据挖掘数据挖掘是一种新兴的、并且在很短时间内得到了广泛应用的先进的智能化数据分析厅法。数据挖掘旨在从大量的数据中提取隐藏的预测性信息,发掘数据间潜在的模式,找出某些常常被忽略的信息,用便于理解和观察的方式反映给用户,作为决策的依据 数据挖掘的功能及内容1、数据预处理2、概念/类描述：用汇总的、简洁的、精确的方式描述每个类和概念称为概念/类描述3、分类： 分类(classification)是找出描述并区分数据类或概念的模型,以便能够使用模型预测类标记末知的对象类的过程。数据分类的目的是提取数据记录的特征属性,生成分类模型,该模型可以把数据库中的数据项映射到给定类别中的一个,导出模型是基于对训练数据集的分析。数据分类的处理步骤如下:获得训练数据集;定义类标识;分析训练数据集,生成分类描述模型;使用得到的类型描述模型对目标数据进行分类。数据分类算法如C4.5,。RIPER等。 4、关联分析5、演变分析6、聚类分析7、孤立点分析 数据挖掘的应用(l)针对生物医学和DNA数据分析的数据挖掘(2)针对金融数据分析的数据挖掘(3)零售业中的数据挖掘(4)电信业中的数据挖掘 基于数据挖掘的网络安全审计系统的方案通过以上研究,本文一认为将数据挖掘技术应用一于网络安全审计系统中可以较好地解决目前在安全审计过程中出现的问题。而且,在这一领域的研究人员的试验和测试结果表明,将数据挖掘技术应用于网络安全审计在理论上是可行的,在技术上建立这样套系统是可能的。因此,本文试图通过实践将数据挖掘技术应用于网络安全领域,利用数据挖掘中的分类、聚类、关联分析、序列模式分析等技术提取与安全相关的系统特征属性,并根据系统特征属性生成安全事件的分类模型,用于对安全事件的自动鉴别。目的是要建立一套完整的基于数据挖掘的网络安全审计模型。 本着去粗取精、去伪存真的原则,我们将网络安全审计作为一种数据分析的过程,着眼于对大量的安全审计数据应用数据挖掘算法,综合运用数据挖掘中的预处理、关联、序列、分类、聚类等技术,并通过系统运行过程中不断修改和扩充知识库,以一种自动和系统的手段建立一套自适应的、具备良好扩展性的网络安全审计系统[42,43]。基于以下思想,本文确定了如下方案: 1、系统中保存的数据分为当前审计数据和用户的历史行为数据。当前数据通过网络抓包工具和系统主机日志监视工具获取,历史数据是当前数据的历史记录。 2、当前审计信息和用户历史行为数据都需要经过数据的预处理,去除其中的不一致和冗余数据,对网络数据和主机数据进行集成,并对数据进行变换和归约将原始数据转换成易于挖掘的格式,形成具有特定格式的事件序列。 3、为了形成知识库模型需要构造训练数据。对于历史数据或训练数据,由数据挖掘引擎对事件序列进行分析学习,挖掘出审计数据中蕴藏的用户的正常行为模式和异常行为模式,并将正常或异常规则存入知识库中。 4、根据知识库中的规则,入侵检测模块对当前审计数据进行分析,当某用户的行为知识库中定义的异常规则相一致时,我们判定其为入侵。但当前一行为与知识库中的仁何规则都不匹配时,系统将判断当前用户行为与异常规则的相似性是否超过某一阈值,或不在正常行为之列,并认定该行为具有威胁。将这些数据加以存储,并利用聚类挖掘技术将这些数据抽象成为由类似的模式组成的多个类,再利用分类技术将数据转变为观则、添加到知识库中。这样可以通过不断修改知识库来发现未知攻击或已知攻击的变种。 基于流量行为特征的DoS＆DDoS攻击检测与异常流识别按照数据源的不同，现有DoS攻击和DDoS攻击的检测方法主要可以分为两类:基于包信息的检测方法和基于网络流量行为特征的检测方法 1)基于包信息的检测方法通过分析数据包中的特定信息或是用户日志等，建立判定规则，并根据实际的流量数据和这些规则的匹配关系来检测DoS攻击和DDoS攻击典型的研究有:文献［1］提出一种基于主机日志分析的统计方法，通过分析主机的日志数据，利用统计理论对正常行为建模，并比较待检测行为与正常行为的偏离来检测网络DoS攻击文献［2］提出了一种基于数据包包头信息综合分析的异常检测技术，通过分析目的IP地址或端口号在边沿路由器出口流量的关联检测异常文献［3］利用TCP协议不同的控制报文在交互时呈现出的数学约束关系，提出了一种评价TCP流宏观平衡性的系统测度，并将之应用于异常检测 2)基于网络流量行为特征的检测方法通过分析流量行为特征参数，如各种数据包包头信息(如IP地址端口号等)聚合后计算得到的统计量，来进行异常检测 典型的研究有: 使用美国Abilence网络［13］Losa汇接点上的流量数据进行仿真实验 抗Dos攻击模型研究_刘雅林.caj在本文中，作者重点将建立一个抗 DOS 攻击的模型，该模型利用数据挖掘（DM）原理，采用关联规则算法、序列模式算法和 BP 网络算法作为判断攻击的主要理论依据。该模型通过感应模块，获取网络流量信息；采用 BP 网络算法，训练出神经网络模型，建立网络流量趋势曲线，设立一个可以动态变化的阀值，和日志库中的网络流量进行对比分析，对异常流量进行判别；将感应模块抓取的网络连接信息利用关联规则算法、序列模式算法挖掘出关联模型和序列模式模型，作为判断攻击是否发生的重要方法。 Dos攻击的危害第九页 19页 入侵检测入侵检测系统的实现方法有基于概率统计模型的检测、基于神经网络的检测、基于专家系统的检测、基于模型推理的检测和基于免疫的检测等技术。 数据挖掘数据挖掘(DM:DataMining)一般指从大量的数据中自动地提取有效的未知新模式的探索、分析过程。它是一种从数据仓库中发现并提取潜在的、有用的知识的新技术，其作用是寻找数据间潜在的关联，做出归纳推理，以此为基础自动做出预测决策。 为什么在网络攻击中使用数据挖掘在入侵检测系统中，数据挖掘通常是指从大量的数据中自动提取出模型的过程。数据挖掘采取以数据为中心的观点，把攻击检测看作是一个数据分析过程，在异常检测过程中，数据挖掘主要是从审计数据中发现正常的使用模式；而在滥用检测过程中主要是实现审计数据编码并与攻击模式匹配的过程。数据挖掘技术能应用于入侵检测系统中，主要是由于它具有以下特点 1、处理的数据规模十分巨大；由于用户不能形成精确的查询要求，因此需要靠数据挖掘技术来寻找其可能感兴趣的东西；2、数据挖掘可对数据的迅速变化做出快速响应，以提供决策支持信息；3、数据挖掘能发现潜在规则，还可以管理和维护规则，随着新数据的不断加人，规则可随之更新；数据挖掘中规则的发现基于统计规律，发现的规则不必适合于所有数据，而且，当达到某一阀值时，便认为有此规则。因此，在攻击检测系统中利用数据挖掘技术可能会发现大量的规则。数据挖掘技术迅速发展，己经从统计学、模式识别、机器学习和数据库等领域中得到了多种算法，与攻击检测相关的算法主要有分类分析、聚类分析、关联分析和序列模式分析等。将数据挖掘用于网络攻击检测中的主要优点：它能从大量的审计数据中自动生成简洁而精确的检测模型，因此为大量的计算环境建立攻击检测系统。 DOS 攻击的特征与数据挖掘特征的关联DoS 攻击手法虽然简单，但现有的技术和手段对这种攻击几乎没有什么好的对应策略。DoS之所以难于防范和跟踪就在于它是一种自然、简单、通过“正常”渠道发起的攻击方法。由于DoS攻击是利用TCP/IP协议自身的缺陷，产生大量“合法”的数据包来攻击目标，因此对该攻击的防范相当困难。 如果仅仅是检测分析数据包，试图从中区分出合法与非法的数据包是非常困难的。我们认为对 DoS 防护的关键是检测分析由 DoS 攻击数据包形成的流特征。在深入分析 DoS 攻击的各种工具及其源码，并在分析收集的模拟 DoS 攻击通信数据包后，总结出其通信数据包及其流特征如下： 1、大多数攻击的 TCP 数据包利用了 TCP/IP 协议的 3 次握手机制，通过使用了“SYN”的状态标志，向被攻击者发送连接请求，但却不真正建立一个连接，即使得被攻击者维护大量所谓的半打开状态连接；2、利用 UDP Flood 或 TCP Flood 或 Smurf 攻击建立与被攻击方的大量连接，消耗服务器的带宽、CPU 或内存等资源；3、利用 TCP/IP 协议中允许某些怪异数据包的存在，发起攻击。其中包括以下的数据包：（1）在 TCP 数据包中同时加入 SYN 和 ACK 两种状态标志，这就使目标机器出现混乱，要花一些时间来处理这些异常情况。（2）特大型的 TCP 和 UDP 数据包，或数据包内容为固定的信息。（3）其它怪异的数据包，如错误的分段，混乱的 header 偏移量等。（4）DoS 支持对连接速率的限制。在某些情况下，连接可以被高速建立，目标主机上会被快速打开成千上万的端口，在连接超时之前所有的资源就被耗尽了。而在另一种情况下，连接也可以以一种较慢的速率建立，以避免触发目标主机上或(防火墙)的SYN Flood 保护机制。但总体上其发送速率是一种上升的趋势。 从 DDoS 的攻击特征中可以看出，作为 DoS 攻击的升级，此类攻击从单个数据包或通信连接上很像正常的通信，单纯检查单个数据包或通信连接往往不能发现该攻击，这使得检测和防护 DDoS 攻击至今仍缺乏有效的手段，只能是结合各方面有关证据辅助对 DDoS 的检测。作者在研究中发现DDoS 攻击的最终表现在于大量数据涌向受攻击站点，引发流量异常，因此结合流量分析来检测 DDoS 攻击是非常必要的。 在 DoS 攻击流特征分析中已经给出通过流量发现 DoS 攻击的例子，但是流量的分析远不止这样简单。因为各网络情况的不同，仅仅将网络流量数据作为 DoS 检测规则属性是不够的，而需要将网络实际流量以及它和理论中的正常(没有任何攻击行为的情况下的)流量的比较结果均作为关键属性。这样才能完整的反映出当前网络的流量真实情况。 那么理论中的正常流量是否可以获得的，这又如何得到的呢？这里举一个例子：一个专门提供邮箱服务的网站，一般情况下每天上午 8: 00-9: 30期间网络访问量达到一天的最高峰。这是因为大部分人习惯每天上班打开电脑的第一件事就是查看自己的信箱。正是因为每个人的行为都带有一种习惯性，这也使得网络的访问量产生规律性。既然有规律可寻，那么网络的流量就是可以预测的。本文利用趋势分析算法从大量正常通信的流量数据挖掘出网络流量(出、入、IP 段等)的趋势，预测正常流量曲线。因此本文研究的挖掘 DoS 攻击特征的数据挖掘算法除关联分析和序列分析外还有趋势分析，它利用历史数据找出变化规律，建立模型，并用此模型来预测未来数据的种类、特征等。回归分析是一种典型的方法，即利用大量的历史数据，以时间为变量建立线性或非线性回归方程。预测时，只要输入任意的时间值，通过回归方程就可求出该时间的状态。近年来，发展起来的神经网络方法，如 BP 模型，它实现了非线性样本的学习，能进行非线性函数的判别。 算法简介为了抗 DOS 攻击，我设计了一个模型，该模型将用到关联规则算法、序列模式算法以及神经网络算法。在本节里，将对这三种算法进行简介。 关联规则算法：关联规则挖掘是数据挖掘中最活跃的研究方法之一，最初提出的动机是针对购物篮分析问题提出的，其目的是为了发现交易数据库中不同商品之间的联系规则。这些规则刻画了顾客购买的行为模式，可以用来指导商家科学地安排进货、库存以及货架设计等。 序列算法：如果说关联规则算法试图发现审计数据内模式，那么序列算法能用来发现审计数据间模式。序列模式挖掘是指挖掘相对时间或其他模式出现频率高的模式。一个序列模式的经典例子是“9个月前以购买奔腾 PC 的客户很可能在一个月内订购新的 CPU 芯片 基于数据挖掘的抗 DoS 攻击模型将采取上一章介绍的数据挖掘算法，并结合 BP 网络算法，建立一个基于数据挖掘的抗 DoS 攻击的防范模型（Data Mining-Based Anti-Do S Attack Model），本模型可以从网络中抓取网络流量信息和数据包信息，然后根据知识库中已经建立的模型和训练好的流量趋势曲线，对网络信息进行判别，看是否有攻击产生。将感应模块抓取的网络连接信息利用关联规则算法、序列模式算法挖掘出关联模型和序列模式模型，作为判断攻击是否发生的重要方法。同时，为了保证某些模型难以正确判断的复杂情况（如重大事件发生时网络访问量剧增），增加了人工判断情况，对知识库中没有建立的新模型进行更新；针对某些特征比较明显的攻击，本模型用端口挖掘模块和 IP 挖掘模块进行直接处理，并不对其进行过深的分析，一定程序上避免了模型本身遭受 DoS 攻击。本模型由 8 个模块组成，它们分别是：感应模块、开采模块、分析模块、IP 挖掘模块、端口挖掘模块、控制模块、执行模块。我对这些模块分别进行了实验，其抗 DoS 攻击效果比较显著。 模型综述 在本模型中，首先要根据长时间的网络日志，建立 BP 网络，利用以前的数据训练 BP 网络，形成网络流量趋势曲线。这是对异常流量的判别标准。同时，还要利用数据挖掘的序列模式算法（frenquent episode arithmetic ）、关联规则算法（Association rules arithmetic）建立模型，作为比较的标准。 基于云计算的入侵检测技术研究_齐玉珠★★★背景近几年来,随着网络技术的高速发展和社交网络、在线视频、电子商务、搜索引擎等新一代大规模互联网的应用迅速发展下,云计算[1]应运而生。云计算逐渐出现在互联网应用和服务的各个方面,并且已经成为信息产业发展的新方向和促进经济增长的动力[2]。云计算是一项新兴的技术,是虚拟化技术[3]、并行计算[4]、网格计算[5]、效用计算[6]、储存技术[7]、负载均衡[8]等这些传统技术与网络融合的产物。云计算是一种依赖互联网的服务形式,它通过虚拟化技术将底层的计算、存储等基础资源整合起来,以按需的、便捷的服务形式提供给企业和用户,实现了可伸缩扩展、灵活、可靠、高效的 IT 服务交付平台。这种新平台使得企业用户能够最大最优化地将资源切换到需要的应用和系统上,根据需求访问计算机和存储系统,并且可以很好地解决大数据时代的各种问题,从而使云计算有着广阔的应用前景[9]。以 Google 的应用程序引擎10、亚马逊的 E2C[11]、IBM 的蓝云(Blue Cloud)[12]、微软的 Azure 为代表的云计算服务已经开始大规模商用化,越来越多的公司开始使用云计算,云计算已经成为信息技术领域新的发展方向[13]。 然而随着云计算技术广泛深入应用,其强大的计算和存储能力对入侵者有着巨大的诱惑力,云计算安全问题[14]越来越受到业界的关注,云计算环境相应的安全问题也呈现直线上升趋势。近几年,大型云服务提供商不断爆出云安全事故,如 2009 年 Google 云文档服务发生用户的个人文件外泄事件;2011 年,亚马逊云计算服务多次中断,导致第三方网站如回答服务 Quora、 跟踪服务 FourSquare 瘫痪;2009 年,微软的 SIDEKICK 服务宕机中断了一个星期,导致用户不可以访问自己的邮箱等个人数据;2012 年 ,微软云计算平台 Windows azure部分服务因闰年设置问题导致所有集群的服务管理功能被禁用。目前云计算安全问题已成为制约其发展的主要障碍[15],云环境中的安全防护措施将成为研究的热点。 入侵检测系统[16]迄今发展已有二十几年的历史,它通过对计算机网络系统中的许多关键点进行收集信息,如操作系统的审计数据,系统日志及网络数据包等。然后分析收集到的信息,进而发现违反安全规则和危害系统安全的行为,以此来保护系统和资源的安全性,机密性,完整性和可用性。入侵检测系统作为一种主动的、行之有效的网络安全防护措施,在网络安全防护中发挥着举足轻重的作用,是新一代网络安全防护体系的重要组成部分,也是继防火墙之后的网络安全系统的第二道闸门。 现在的入侵检测系统还存在许多需要解决的问题,如在高速千兆级网络下,网络流量极大,网络数据也呈现海量性,这些情况使目前的入侵检测系统满足不了对实时性和有效性的需求。目前针对以上的问题,一些研究人员着眼于算法的不断改进。然而云计算丰富的计算能力正好可以被利用来处理检测数据量大的问题,目前关于云计算的入侵检测研究还处于起步阶段,本文研究基于云计算的入侵检测系统将非常有意义。 本文首先设计了一个云计算环境下的入侵检测系统模型 CIDS,该模型可以实时采集和检测云环境数据,同时利用云计算技术进行检测数据的分析处理。在该检测系统中,使用改进的 K-means 聚类方法对检测数据进行分析,同时引入主成份分析 PCA 作为特征提取模块,达到不失特征精度和检测率的情况下对海量检测数据进行线性降维的效果。最后本文在 Hadoop 平台上进行整个分析模块检测算法的并行化设计,充分利用了云计算平台的计算资源进行入侵检测的分析,验证了云计算入侵检测系统利用其云资源时,有较好的检测率和实时性,也验证了本文 CIDS 的合理性。 总体来说,入侵检测技术发展到现在是比较成熟的技术,目前也已有很多检测方法,但随着网络数据量的海增和数据的复杂化,检测系统的性能处于了瓶颈状态。云计算作为一项新型的技术,一方面其强大的资源正好可以为入侵检测系统服务,另一方面入侵检测系统也可以检测出云计算遭受的入侵威胁,使云环境能及时做出响应,将损失降到最低,所以基于云计算的入侵检测技术是当前比较热门的研究方向。 主要的检测方法有：（1）基于特征选择的异常检测，从一组特征属性中选出能检测入侵行为的属性，并用它来对入侵行为进行分类（主成分特征分析、独立成分分析）（2）基于统计的异常检测：当前特征与数据库特征进行比较（平均值分析、基于贝叶斯网络推理方法、基于马尔科夫链方法、基于序列分析方法）（3）基于机器学习方法：系统可以通过监督式学习、死记硬背式学习或归纳学习等方式,获取个体、系统和网络的行为特征（4）基于神经网络学习方法：通过神经元权值状态的调整变化分布式计算检测数据,并将检测数据分到不同的类中,实现无监督检测（5）数据挖掘检测方法：从检测数据中挖掘出有用的关联知识,然后用这些知识检测入侵行为 Detection DDos Attacks Based on Neural-Network Using Apache SparkSeven feature are used to DDoS Attack Number of Packets Average of Packet Size Time Interval Variance Packet Size Variance Number of Bytes Packet Rate Bite Rate 数据库 2000 DARPA LLDOS 1.0 ： 攻击流量 Frequency based DDoS attack detection approach using naive Bayes classificationFrequency domain analysis would be a promising alternative for conventinal methods of detection. In this paper we provide a naive Bayes classifier with two frequency based methods of discrete Fourier transform and discrete wavelet transform in order to separate between attack and normal traffics. 背景Most intrusion detection systems (IDS) utilize one of two methods of detection: signature-based (misuse)[基于特征检测的入侵检测] and anomaly analysis [6]. In a signature-based method, the system is trained by a set of known malicious threats. During the analysis, IDS compare the pattern of ongoing traffic with its database and any match reports as intrusion. This method suffers from incapability of detecting new unknown intrusions [7][不能检测未知入侵] In anomaly-based approach, the normal pattern is determined and any activity out of this model is reported as anomalous. Although, this method can detect new intrusions, the detection probability rate is low [6]. [归纳正常情况下的模式，其他异常情况判定为入侵] Packet level analysis and payload examination are the dominant methods which are implemented in most traditional detection systems [8][包等级分析] DDos攻击数据库UDP-based attack dataset 大数据、云计算技术对审计的影响研究大数据或称巨量资料，指的是所涉及的数据量规模大到无法利用现行主流软件工具，在一定的时间内实现收集、分析、处理或转化成为帮助决策者决策的可用信息。互联网数据中心认为大数据(是为了更经济、更有效地从高频率、大容量、不同结构和类型的数据中获取价值而设计的新一代架构和技术，用它来描述和定义信息爆炸时代产生的海量数据，并命名与之相关的技术发展与创新。 大数据具有 4 个特点:第一，数据体量巨大，从 TB 级别跃升到 PB 级第二，处理速度快，这与传统的数据挖掘技术有着本质的不同第三，数据种类多，有图片、地理位置信息、视频、网络日志等多种形式第四，价值密度低，商业价值高，存在单一数据的价值并不大，但将相关数据聚集在一起，就会有很高的商业价值 大数据与云计算的关系从整体上看，大数据与云计算是相辅相成的。大数据主要专注实际业务，着眼于”数据”，提供数据采集、挖掘、分析的技术和方法，强调的是数据存储能力。云计算主要关注”计算”，关注 IT 架构，提供 IT 解决方案，强调的是计算能力，即数据处理能力。如果没有大数据的数据存储，那么云计算的计算能力再强大，也难以找到用武之地; 如果没有云计算的数据处理能力，则大数据的数据存储再丰富，也终究难以用于实践中去。 从技术上看，大数据依赖于云计算。海量数据存储技术、海量数据管理技术、MapReduce编程模型都是云计算的关键技术，也都是大数据的技术基础。而数据之所以会变”大”，最重要的便是云计算提供的技术平台。数据被放到”云”上之后，打破了过去那种各自分割的数据存储，更容易被收集和获得，大数据才能呈现在人们眼前”而巨量的数据也只能依靠云计算强大的数据处理能力，才能够 “淘尽黄沙始得金”。 基于大数据技术的安全审计系统_刘大地一、传统安全审计技术面临的困境随着信息化程度的不断提高，信息系统越来越庞大，越来越复杂，随之而来的是系统中需要安全审计的对象和审计内容更多更复杂，单位时间内需要审计信息增长巨大。在国家重要的行业中，大型信息系统的管理节点动辄达到几十万个，需要审计的重要节点常常会超过上千个，这其中包括服务器、网络设备、安全设备、数据库、应用系统等不同的节点类型，每天的访问、操作日志可达到数亿甚至几百亿条，数据量达到TB数量级 ，这对于传统的安全审计系统的数据采集及分析能力都构成了极大挑战。同时，由于审计的对象种类繁多，不同对象间日志格式可能会有很大差异，使用传统的关系型数据库去保存这些海量的异构数据，数据的有效管理、快速检索以及利用数据挖掘技术对数据进行分析时都会面临诸多较难克服的问题。 二、大数据技术带来的曙光 Google 的 Google File System、Google Bigtable和 Google MapReduce这三篇论文的发表，业界利用廉价的分布式系统进行大数据处理奠定了基础，各种相关的技术和实现不断被提出，形成了蓬勃发展的大数据技术生态系统，越来越多的应用构建其上。人们以比以往低得多的成本，获取了比以往强大得多的计算和存储能力，并且仍在继续快速地提升这一能力。作为一种需要对海量数据进行采集、分析和展现的应用系统，安全审计系统天然地对能够高性能地处理海量异构数据的技术有着强烈的需求。大数据相关技术的出现与不断发展成熟，为其适应网络发展的需求提供了新的技术支撑。使用大数据相关技术改造或开发新的安全审计系统，相对于传统技术的安全审计系统，可以在以下几个方面得到显著改善： （1）系统在采集、检索、分析和存储方面的性能瓶颈将被打破；（2）可以更好地同时应对结构化数据和非结构化数据；（3）可以利用大数据分析的相关算法和模型，对历史数据进行更广泛和更深入的分析，从海量数据中挖掘出更多对用户有价值的信息；（4）由于系统部署在更加便宜的硬件设备上，采购和维护的费用更加低廉，并可根据用户网络应用的发展而灵活实现水平扩展，有效降低了系统的总拥有成本，提高了灵活性，更好地保护了用户投资。 三、基于大数据技术的安全审计系统的设计 使用大数据相关技术解决审计过程中遇到的几方面问题： （一）大数据量的审计数据采集与存储 （二）数据归一化和关联分析 审计数据采集后首先需要对这些海量数据进行分类，按照一定的标准进行归一化，并且可以对数据进行一些简单的清洗和预处理工作。这些与传统的审计产品所采取的事件处理流程一致，所不同的是要处理的数据量非常大，数据量可能会达到500万EPS（Events Per Second，每秒事件数），峰值可能达到1000万EPS。这种性能要求不是传统的审计产品能够做到的，必须要依赖大数据集群并发处理的能力。传统产品在进行实时关联分析时一般使用内存数据库的方式，因单机版内存资源以及SQL语句效率的问题导致事件量大时，规则引擎的并发性以及处理能力均会有较大下降，导致规则引擎无法检测出异常。而使用基于大数据集群的分布式计算框架同时结合基于大数据集群的复杂事件处理流程作为实时规则分析引擎，能够高效并行地运行多种规则，并能够实时检测异常事件。具体实现上可采用Storm+Esper的方式，Storm非常适合对海量数据进行实时的统计计算，并能够快速地反馈统计结果。Storm框架利用严格且高效的事件处理流程保证运算时数据的准确性，并提供多种实时统计接口供使用。利用Storm的内存数据迭代计算框架进行关联分析运算，利用Esper实现的复杂事件处理功能作为实时关联分析的引擎，可提升系统关联分析的实时性及准确性。 （三）历史数据统计分析 对于存储在集群中的海量数据进行离线统计分析是审计系统要解决的另一个重要问题。基于大数据技术的审计系统的离线统计与分析功能主要利用分布式计算集群来对存储于其内的海量数据进行普通的分析和分类汇总等，可以满足大多数常见的分析需求。在Hadoop上层部署Hive+Hbase框架，Hive和Hbase有各自不同的特征，hive是高延迟、结构化和面向分析的，Hbase是低延迟、非结构化和面向编程的。Hive数据仓库在Hadoop上是高延迟的，Hive集成Hbase就是为了使用Hbase的一些特性，使用Hive提供的HiveSQL来简化对Map/Reduce任务的编写，利用Hive与Hbase互补加速对事件分析结果的运算效率，将通过核心模块将该命令解析为Map-Reduce，提交给Hadoop集群之后，生成报表供报表中心展示，从而对存储在HDFS上面的数据进行离线统计分析。 （四）数据挖掘 通过数据挖掘技术，可以发现一些较隐蔽的网络攻击、违规访问和一些系统配置的误配情况。目前，已有很多公开的数据挖掘算法，在技术实现上已无难度，但算法与信息安全行业的模型相结合，仍需要较长时间的训练及调试。 （五）高效便捷的海量事件追溯 追溯系统是审计系统中非常重要的一环，目的是为了在海量数据分析的基础上最终定位并解决用户实际问题，追溯系统可对平台分析出来的各种结果进行事件源定位。 面向云计算的DDoS攻击检测研究_许艺枢★★★★★研究内容，包括DDoS与大数据结合的原因本文的主要研究内容为 DDoS 攻击的检测技术。目前，对 DDoS 攻击检测技术的研究已经较为成熟，但随着云技术的发展，DDoS 攻击在云环境中又呈现出新的特性。云环境所拥有的强大计算能力和存储资源使得 DDoS 攻击在云环境中具有更强的破坏力。本文先对现有 DDoS 攻击原理、检测技术进行充分研究，又对云环境所具有的虚拟化、分布式特定进行分析。在综合以上二者的基础上，设计出基于云环境的 DDoS 攻击入侵检测模型。该模型具有传统入侵检测系统的优点，并加入了资源调度、容错等更适于云环境攻击检测的功能模块。另外，本文对传统 BP 神经网络算法进行改进，并将改进后的算法用于检测模型中，最后通过仿真实验证明其具有更为优越的检测性能。 DDos攻击概述1、攻击原理2、典型DDoS攻击3、DDoS攻击常用工具4、DDoS攻击防御与检测5、僵尸网络 DDoS攻击与大数据结合的原因DDoS（Distributed Denial of Service，分布式拒绝服务）攻击是通过耗尽受害者主机资源使其丧失提供正常网络服务能力的一种攻击。该攻击具有易实施、难防范、隐蔽性强等特点，是当今网络安全领域的研究热点。 随着越来越多的公司使用虚拟化数据中心和云服务，DDoS 攻击开始移师云计算，并且攻击方式由数据暴力泛滥转向为向应用基础设施发起攻击。尽管当前针对 DDoS 攻击的入侵检测系统的研究已经较为成熟，但由于云服务器所具有的一些有别于普通主机的特性，所以不能将已有的入侵检测技术直接应用到云计算中，这就需要对云计算中的分布式拒绝服务攻击入侵检测技术展开专门的研究。 DDoS攻击检测方法DDoS攻击检测时需要注意的问题有：一是这类攻击使用的数据包与合法数据包相似，因而检测过程中容易把合法数据包误报成攻击数据包；二是难以区分网络流量瞬时拥塞和 DDoS 攻击。因此对于 DDoS 攻击检测来说尽早检测到攻击和减少误报成为当前研究的重点。目前常用的入侵检测可分为基于特征的检测与基于异常的检测两类： 基于特征的检测方法是根据已知的攻击行为建立特征库，当出现这些攻击特征时，就认为是发生了攻击。但这种方法只能对已知的攻击模式具有检测力，对未知的攻击则无能为力。常用的基于特征的基于特征的检测技术有专家系统、模式匹配等。 基于异常的检测方法是通过建立主体的正常行为模型，来发现其异常行为，从而对未知攻击也具有检测能力。常用的基于异常的检测技术有量化分析、统计方法、神经网络、遗传算法等 (1) 基于流量自相似性的 DDoS 攻击检测 90 年代初，Leland 等人[13]通过对大量网络数据进行监测与分析发现正常的网络流量具有自相似性。当 DDoS 攻击发生时，会对网络流量的自相似特性产生较大影响，因而可以通过网络流量的自相似程度的变化来对 DDoS 攻击进行检测。 云计算中的 DDoS 攻击防御云计算的概念始于 2007 年，在 Amazon、Google 等 IT 巨头的推动下，在短短几年内便产生了巨大的影响力并成为了当前炙手可热的技术之一。“云”就像一个庞大的资源池，为客户提供许多功能强大、使用方便的服务，云用户可以根据自己的需要来使用这些资源并根据使用量付费。但是在云计算带来诸多好处之时，在云安全方面也面临许多挑战。由于云计算的一些技术还不完善，且在公有云中的云计算服务主要通过互联网提供，便大大增加了遭受 DDoS 攻击的可能性。但是由于云计算本身所具有的一些特点，使其在应对 DDoS 方面也显露了一些优势。如维基解密网站(WikiLeaks)在遭受 DDoS 攻击后，便通过使用亚马逊的云计算服务保护自己远离 DDoS 攻击。本章中，将首先对云计算以及云计算中主要的 DDoS 攻击防御技术做了简要介绍，并在此基础上提出一种将MPLS 技术运用到云计算中的方法，以提高云计算安全性能。 云计算概述1、云计算概念及特点2、云计算架构3、云计算模式 DDoS攻击给云计算带来的威胁随着云计算的发展及云技术的日趋成熟，云安全问题的重要性呈现逐步上升趋势并成为制约云计算发展的重要因素[30]。很多企业选择使用云服务及虚拟化数据中心，与此同时，企业基础设施及存储大量虚拟数据的数据中心成为 DDoS 攻击的重要目标，DDoS攻击成为了云计算所需面临的新威胁 DDoS工具升级具有更大的破坏性 云环境的需求分析★★★★★云计算所具有的超大规模、资源共享及海量数据存储能力，使得云成为攻击者们新的乐土。相较于普通的攻击，在云环境中实施的攻击速度更快，破坏力也更强。根据云环境的特性，所设计的入侵检测模型应满足已下几点基本要求：(1) 可靠性：为了使服务质量得到保障，云计算中的数据采用多副本容错和计算节点同构可互换的措施。因此，所设计的模型必需考虑到云环境的容错特性。(2) 动态性：“云”为用户所提供的资源是动态的，而“云”用户的规模也是动态的，因此，模型需要具有动态性。(3) 完整性：模型除了能够应对普通的 DDoS 攻击，还能检测出针对云环境的一些新的变种攻击，如 H-DoS、X-DoS 等。 除需满足以上需求外，还要考虑云资源所具有的分布式存储特点，因此云计算中的入侵检测模型需采用非集中的管理模式。“云”通过虚拟技术将分布的资源组织起来并实现资源的共享。虚拟机作为云环境中的基本管理单元来处理云用户所提交的任务。因此，入侵检测模型将这些虚拟机作为检测对象，同时作为这些虚拟机的安全管理者，入侵检测模型也通过虚拟技术来实现。 神经网络基于活跃熵的 D o S 攻击检测模型★★★★建立系统正常通信的情况时呈现的活跃熵特性，分析系统在遭受Dos攻击下所呈现的奇异性进行检测 通过数据包中的 I P 地址和端口等信息确定该动作所作用的主体 , 并且更新系统的活跃状态 SYNFlood型DDoS攻击检测与防御研究_李铮★★★基于阈值的攻击检测方法：设定一个阈值，大于这个阈值判断为遭受到Dos攻击。最大的优点是简单，不需要历史访问流量进行学习，缺点是使得部分攻击得逞（攻击流量没有超过阈值的情况下不能检测，使得服务器为正常访问流量提供的服务减少） 基于流量统计的攻击检测方法：tcp协议定义每接收一个数据包就会返回一个数据包，即通信双方传输的数据量是成比例的。如果返回的数据包少（被丢弃），则 2分钟读懂Hadoop和Spark的异同http://www.techweb.com.cn/network/system/2016-01-25/2267414.shtml 解决问题的层面不一样1、Hadoop 将巨大的数据集分派到一个由普通计算机组成的集群中的多个节点进行存储，意味着您不需要购买和维护昂贵的服务器硬件 2、Spark 是一个专门用来对那些分布式存储的大数据进行处理的工具，它并不会进行分布式数据的存储 两者可合可分1、Hadoop除了提供为大家所共识的HDFS分布式数据存储功能之外，还提供了叫做MapReduce的数据处理功能。所以这里我们完全可以抛开Spark，使用Hadoop自身的MapReduce来完成数据的处理。 2、Spark也不是非要依附在Hadoop身上才能生存，但如上所述，毕竟它没有提供文件管理系统，所以，它必须和其他的分布式文件系统进行集成才能运作。里我们可以选择Hadoop的HDFS,也可以选择其他的基于云的数据系统平台。但Spark默认来说还是被用在Hadoop上面的，毕竟，大家都认为它们的结合是最好的。 ★Detection DDoS attacks based on neural-network using Apache SparkThe key objective of this study is to construct a detection system have high accuracy and immedaite, The Artificial neural network(ANNs) is used to identify and detect abnormal traffic, and used famous DDos tools like ARPA 2000 LLDOS 1.0 and self-generated to training ANNs, make our detection system be able to identify the characteristic of abnormal traffic, the feature of ANN is their network will not expand by data volumes, so it is suitable for the huge volume analysis like DDoS detection, and we used Apache Spark an open source cluster computing framework, The feature of this framework is In-Memory computing, break through the bottleneck of hard disk,make run programs up to 100x faster than Hadoop MapReduce in memory. Artificial neural network(ANNs)神经网络介绍 Artificial neural networks are abstract mathematical models of brain structures and fucntions, ANNs could be a prediction ability AI machine, througe high performance computing, the feature of ANNs is their structure will not expand with the number of input and output does not change,so the memory used will be under control, and have high reliability that ability to predict unknow input data. 神经网络种类 Back-propagation Network, Hopfield Network, Radial Basis Function Network 相关研究 Detection of known and unknown DDoS attacks using Artificial Neural Networks使用神经网络-成功率98% An Anomaly-Based Method for DDoS Attacks Detection using RBF Neural Networks基于包特征-神经网络 MLlib： machine learning in apache sparkspark介绍 SYNFlood型DDoS攻击检测与防御研究_李铮开发的防DDoS攻击的系统特点：（1）基于信息熵值得实时攻击检测（2）黑白名单技术（3）自学习子系统：包含蜜罐系统和数据挖掘系统，蜜罐系统旁路收集异常网络流量，通过数据挖掘生成防御规则动态更新异常检测阈值、黑白名单列表和协议分析规则，及时调整系统对后续攻击的相应策略 常见的检测方法：1、基于阈值的攻击检测方法：设置一个阈值，高于阈值认定为发生了DDoS攻击。优点是简单，缺点是若低于阈值，即使存在攻击分组也让其通过，使得部分攻击得逞，消耗了带宽资源。 2、基于流量统计的攻击检测方法：TCP协议每接受一个数据包就会返回一个数据包，因此可以认为发送方和接收方传输的数据量是成比例的。如果返回的数据包数量过少，这类数据包应该是被认为是恶意的然后被丢弃， 基于滑动分组的熵检测方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习]]></title>
      <url>%2F2017%2F01%2F03%2F%5BJava%5D%E5%AE%9E%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[系统总体架构源文件：https://note.youdao.com/yws/res/8735/WEBRESOURCEb9e23c0741530726b0124ee5d3bfd729 1、一个基于Thrift的微服务需要创建三个模块（最终打包成三个Jar包），分别是Core、Server和Adapter core：定义接口。用接口描述语言定义并创建服务 server：Thrift的服务端。依赖core模块，实现core中定义的接口，主要的业务逻辑部分，分为Service层、Dao层、缓存和数据库。微服务就是进行分模块，把各模块放到不同的位置提供服务 adapter：Thrift的客户端。依赖core模块，其他模块如需调用Serve的接口，需引入此jar包 以论坛项目为例，整个论坛项目分为四个模块： bp-forum-core:数据定义和服务创建 bp-forum-server:服务实现 bp-forum-adapter:客户端，与服务器交互 bp-forum-wap:页面显示，通过调用adapter，获取服务 对于每一个微服务都有其各自的core、server、adapter模块 注意：虽然Server和Adapter在同一个工程下，但在实际运行环境中，一般Server运行在A主机，而B主机上的应用程序需要调用A主机上的Server，需要引入Adapter依赖，实现远程服务调用 2、前端数据显示：Freemarker——模板+数据=输出网页 Thrifthttp://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/#ibm-pcon目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架 Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势 Guava Cachehttp://www.cnblogs.com/parryyang/p/5777019.html 当某些值会被多次调用时，将数据缓存在内存中提升速度 Guava Cache是一个全内存的本地缓存实现，它提供了线程安全的实现机制。整体上来说Guava cache 是本地缓存的不二之选，简单易用，性能好。 Guava Cache与ConcurrentMap区别最基本的区别是ConcurrentMap会一直保存所添加的元素，直到显式的移除；Guava Cache为了限制内存的占用，通常都是设定为自动回收元素 创建方式 CacheLoader Callable 相同点：从缓存中取key X的值，如果该值已经缓存过了，则返回缓存中的值，如果没有缓存过，可以通过某个方法来获取这个值。 不同点： cacheloader的定义比较宽泛， 是针对整个cache定义的，可以认为是统一的根据key值获取value的方法 callable的方式较为灵活，允许你在get的时候，针对特定key值指定获取方式 1、CacheLoader public class AppkeyInfoLocalCache { /*在创建cache时指定所有key获取value的方法！！！*/ static LoadingCache&lt;String, AppkeyInfoBasic&gt; cache = CacheBuilder.newBuilder().refreshAfterWrite(3, TimeUnit.HOURS)// 给定时间内没有被读/写访问，则回收。 .expireAfterAccess(APIConstants.TOKEN_VALID_TIME, TimeUnit.HOURS)// 缓存过期时间和redis缓存时长一样 .maximumSize(1000).// 设置缓存个数 build(new CacheLoader&lt;String, AppkeyInfoBasic&gt;() { @Override /** 当本地缓存命没有中时，调用load方法获取结果并将结果缓存 **/ public AppkeyInfoBasic load(String appKey) throws DaoException { return getAppkeyInfo(appKey); } /** 数据库进行查询 **/ private AppkeyInfoBasic getAppkeyInfo(String appKey) throws DaoException { //从数据库取值 return ((AppkeyInfoMapper) SpringContextHolder.getBean(&quot;appkeyInfoMapper&quot;)) .selectAppkeyInfoByAppKey(appKey); } }); } 2、Callable @Test public void testcallableCache() throws Exception{ Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(1000).build(); //设置键jerry取值方式 String resultVal = cache.get(&quot;jerry&quot;, new Callable&lt;String&gt;() { public String call() { String strProValue=&quot;hello &quot;+&quot;jerry&quot;+&quot;!&quot;; return strProValue; } }); System.out.println(&quot;jerry value : &quot; + resultVal); //设置键peida取值方式 resultVal = cache.get(&quot;peida&quot;, new Callable&lt;String&gt;() { public String call() { String strProValue=&quot;hello &quot;+&quot;peida&quot;+&quot;!&quot;; return strProValue; } }); System.out.println(&quot;peida value : &quot; + resultVal); } Mavan多模块http://juvenshun.iteye.com/blog/305865?page=2#comments 所有用Maven管理的真实的项目都应该是分模块的，每个模块都对应着一个pom.xml。它们之间通过继承和聚合相互关联 简单的Maven模块结构一个简单的Maven模块结构是这样的： app-parent |-- pom.xml (pom) | |-- app-util | |-- pom.xml (jar) | |-- app-dao | |-- pom.xml (jar) | |-- app-service | |-- pom.xml (jar) | |-- app-web |-- pom.xml (war) 上述简单示意图中，有一个父项目(app-parent)聚合很多子项目（app-util, app-dao, app-service, app-web）。每个项目，不管是父子，都含有一个pom.xml文件。而且要注意的是，小括号中标出了每个项目的打包类型。父项目是pom,也只能是pom。子项目有jar，或者war。 多模块的好处用项目层次的划分替代包层次的划分能给我们带来如下好处： 方便重用，如果你有一个新的swing项目需要用到app-dao和app-service，添加对它们的依赖即可，你不再需要去依赖一个WAR。而有些模块，如app-util，完全可以渐渐进化成公司的一份基础工具类库，供所有项目使用。这是模块化最重要的一个目的。 由于你现在划分了模块，每个模块的配置都在各自的pom.xml里，不用再到一个混乱的纷繁复杂的总的POM中寻找自己的配置。 如果你只是在app-dao上工作，你不再需要build整个项目，只要在app-dao目录运行mvn命令进行build即可，这样可以节省时间，尤其是当项目越来越复杂，build越来越耗时后。 某些模块，如app-util被所有人依赖，但你不想给所有人修改，现在你完全可以从这个项目结构出来，做成另外一个项目，svn只给特定的人访问，但仍提供jar给别人使用 RPCGRPCThrift Spring获取ApplicationContext需要将ApplicationContext保存至某个静态类中提供接口获取，那必须要在某一个地方将ApplicationContext设置进来。无法直接获取，因为获取ApplicationContext是需要上下文条件限制的。在Web环境下可以直接通过ServletContext获取。如果Bean对象本身被IoC容器所管理可直接通过注解获取。 方法一：非spring管理的类中要获得applicationcontext //获取ServletConetxt实例 HttpServletRequest httprequest = (HttpServletRequest)ServletActionContext.getRequest(); ServletContext sc = httprequest.getSession().getServletContext(); //使用 WebApplicationContextUtils.getWebApplicationContext(ServletContext) ApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(sc); 方法二：新建一个ApplicationContextHolder类，保存ApplicationContext实例 @Autowired private ApplicationContext applicationContext; 方法三：在自己定义的bean中获得 applicationcontext，可以让该bean实现applicationcontextaware接口，记得把这个bean 配置在spring的配置文件里 public class MyApplicationContext implements ApplicationContextAware { private ApplicationContext applicationContext; public void setApplicationContext(ApplicationContext ac) throws BeansException { this.applicationContext = ac; } public ApplicationContext getApplicationContext(){ return applicationContext; } } spring 的配置如下 &lt;bean id=&quot;myapplicationcontext&quot; class=&quot;com.my.utils.MyApplicationContext&quot;&gt; &lt;/bean&gt; 通过上面2种方式都可以获取到ApplicationContext如果楼主需要将ApplicationContext保存至某个静态类中提供接口获取，那必须要在某一个地方将ApplicationContext设置进来。无法直接获取。因为获取ApplicationContext是需要上下文条件限制的。在Web环境下可以直接通过ServletContext获取。如果Bean对象本身被IoC容器所管理可直接通过注解获取。 翻墙工具ShadowSocketlantern 全局gitignore$ git config –global core.excludesFile /c/gitignore$ git config –list 测试环境cd /opt/nuc_git/bp-salt-deploy/服务器ip：10.16.5.231账号：root密码：LXRoxqIqV4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射]]></title>
      <url>%2F2016%2F12%2F30%2F%5BJava%5DJava%E5%8F%8D%E5%B0%84%2F</url>
      <content type="text"><![CDATA[反射的基石-&gt;ClassJava类用于描述一类事物的共性，该类事物有什么属性，没有什么属性，至于这个属性的值是什么，则是由这个类的实例对象来确定，不同的实例对象有不同的属性值。Java程序中的各个Java类属于同一类事物，描述这类事物的Java类名就是Class。 例：众多的人可以用一个Person类来表示，那么众多的Java类也就可以用一个Class类来表示。 Person类代表人，它的实例对象就是张三，李四这样的一个个具体的人，Class类代表Java类，它的各个实例对象又分别对应各个类的内存中的字节码，例如，Person类的字节码，ArrayList类的字节码，等等。 ####什么是字节码 一个类被类加载器加载到内存中，占用一片内存空间，这个空间里面的内容就是类的字节码，不同的类的字节码是不同的，所以它们在内存中的内容是不同的，这个一个个的空间可以分别用一个个的对象来表示，这些对象显然具有相同的类型，这个类型是什么呢？Class类型 ####如何得到各个字节码对应的实例对象（Class类型） 类名.class,例如，System.class 对象.getClass(),例如，new Date().getClass() Class.forName(“类名”),例如，Class.forName(“java.util.Date”); 开发中使用较多的是Class.forName（”类名”）的方式，按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。123456String str1 = "abc";Class c1s1 = str1.getClass();Class c1s2 = String.class;Class c1s3 = Class.forName("java.lang.String");System.out.println(c1s1 == c1s2);//trueSystem.out.println(c1s2 == c1s3);//true 结果说明： 1. 一份字节码可以得到多个实例对象 2. 各个实例对象都将得到同一份字节码 ####九个预定义Class实例对象 isPrimitive() : 字节码是否是基本类型123456System.out.println(String.class.isPrimitive());//falseSystem.out.println(int.class.isPrimitive());//trueSystem.out.println(Integer.class.isPrimitive());//falseSystem.out.println(int.class == Integer.TYPE);//trueSystem.out.println(int[].class.isPrimitive());//falseSystem.out.println(int[].class.isArray());//true ####总结 Java类被类加载器加载到内存中，开辟一段内存空间，这段空间的内容就是类的字节码。不同的类生成不同的字节码，每个字节码可以用一个个对象表示，这些对象具有相同的类型，即Class类型。 ###2. 理解反射的概念 反射就是把Java类中的各种成分映射成相应的Java类。例如，一个Java类中用Class类的对象来表示，一个类中的组成部分：成员变量、方法、构造方法、包等信息也用一个个的Java类来表示。表示Java类的Class类显然要提供一系列的方法，来获取其中的变量、方法、构造方法、修饰符、包等信息，这些信息就是用相应的实例对象来表示，它们是Field、Method、Constructor、Package等等。 例如，System.exit和System.getProperties()方法，分别可以用Method类的methodObj1，methodOjb2表示。 ###3. Constructor类 Constructor类代表某个类中的一个构造方法。 ####得到某个类所有的构造方法 Constructor [] constructors = Class.forName(&quot;java.lang.String&quot;).getConstructors(); ####得到某一个构造方法（根据参数来获取） Constructor constructor = Class.forName(“java.lang.String”).getConstructor(StringBuffer.class); ####创建实例对象 通常方式：String str = new String(new StringBuffer(&quot;abc&quot;)); 反射方式：String str = (String)constructor.newInstance(new StringBuffer(&quot;abc&quot;)); ####Class.newInstance()方法 例子:String obj = (String)Class.forName(&quot;java.lang.String&quot;).newInstance(); 该方法内部先得到默认的构造方法，然后用该构造方法创建实例对象。 该方法内部的具体代码用到了缓存机制来保存默认构造方法的实例对象。 ###4.成员变量的反射(Field类) 1. Field类代表某个类中的一个成员变量 2. 问题：得到的Field对象是对应到类上面的成员变量，还是对应到对象上的成员变量？ 类只有一个，而该类的实例对象有多个，如果是与对象关联，那关联那个对象呢？所以字段Field代表的是类的成员变量，而不是具体的变量。 Field getDeclaredField(String name)返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 Field[] getDeclaredFields()返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 Field getField(String name)返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 Field[] getFields()返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 代码：12345678910111213141516171819202122232425import java.lang.reflect.*;public class ReflectTest &#123; public static void main(String[] args) throws Exception&#123; ReflectPoint pt1 = new ReflectPoint(3,5); Field fieldY = pt1.getClass().getField("y"); //fieldY的值是多少？是5？错，fieldY不是对象身上的变量，而是类上的，要用它去取某个对象上对应的值 System.out.println(fieldY.get(pt1));//5 //fieldX为私有的，.getField("x")取不到，得用.getDeclaredField("x") Field fieldX = pt1.getClass().getDeclaredField("x"); //由于私有，不可访问，使用setAccessible(true)，可以表示可以取 fieldX.setAccessible(true); //能够取到x的值 System.out.println(fieldX.get(pt1));//3 &#125;&#125;class ReflectPoint &#123; private int x; public int y; public ReflectPoint(int x, int y) &#123; super(); this.x = x; this.y = y; &#125;&#125; ####成员变量反射的综合案例代码：12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.*;public class ReflectTest &#123; public static void main(String[] args) throws Exception&#123; ReflectPoint pt1 = new ReflectPoint(3,5); changeStringValue(pt1); System.out.println(pt1); &#125; private static void changeStringValue(Object obj) throws Exception &#123; Field[] fields = obj.getClass().getFields(); for(Field field : fields)&#123; //对应同一份字节码，所以用== if(field.getType()==String.class)&#123; String oldValue = (String)field.get(obj); String newValue = oldValue.replace('b', 'a'); field.set(obj,newValue); &#125; &#125; &#125;&#125;class ReflectPoint &#123; private int x; public int y; public String str1 = "ball"; public String str2 = "basketball"; public String str3 = "itcast"; public ReflectPoint(int x, int y) &#123; super(); this.x = x; this.y = y; &#125; public String toString() &#123; return str1+":"+str2+":"+str3; &#125;&#125; ###5. 成员方法的反射 Method类代表某个类中的一个成员方法 得到类中的某一个方法： Method charAt = Class.forName(&quot;java.lang.String&quot;).getMethod(&quot;charAt&quot;, int.class); 调用方法： 通常方式：System.out.println(str.charAt(1)); 反射方式：System.out.println(charAt.invoke(str, 1)); 如果传递给Method对象的invoke()方法的第一个参数为null，这有着什么样的意义呢？说明该Method对象对应的是一个静态方法！ ####jdk1.4和jdk1.5的invoke方法的区别 Jdk1.5：public Object invoke(Object obj,Object… args) Jdk1.4：public Object invoke(Object obj,Object[] args) 即按jdk1.4的语法，需要将一个数组作为参数传递给invoke方法时，数组中的每个元素分别对应被调用方法中的一个参数，所以，调用charAt方法的代码也可以用Jdk1.4改写为 charAt.invoke(“str”, new Object[]{1})形式。代码：123456789import java.lang.reflect.*;public class ReflectTest &#123; public static void main(String[] args) throws Exception&#123; Method methodCharAt = String.class.getMethod("charAt", int.class); System.out.println(methodCharAt.invoke("abc",1 )); //System.out.println(methodCharAt.invoke(null,1 ));如果为null则为静态方法 //System.out.println(methodCharAt.invoke("abc",new Object[]&#123;2&#125; ));1.5以前，没有可变参数，这么写 &#125;&#125; ###6. 对接收数组参数的成员方法进行反射 问题：平时如何调用一个类的main方法？123456789101112public class ReflectTest &#123; public static void main(String[] args)&#123; TestArgument.main(new String[]&#123;"aa", "bb", "cc"&#125;); &#125;&#125;class TestArgument&#123; public static void main(String[] args)&#123; for(String arg : args)&#123; System.out.println(arg); &#125; &#125;&#125; 问题：当不知道类的名字时（类的名字作为参数），如何调用该类的main方法？ 用反射的方式，这就是反射的作用，可以将类的名字作为参数传入，启动main方法。 启动Java程序的main方法的参数是一个字符串数组，即public static void main(String[] args)，通过反射方式来调用这个main方法时，如何为invoke方法传递参数呢？ 按jdk1.5的语法，整个数组是一个参数，而按jdk1.4的语法，数组中的每个元素对应一个参数，当把一个字符串数组作为参数传递给invoke方法时，javac会到底按照哪种语法进行处理呢？ jdk1.5肯定要兼容jdk1.4的语法，会按jdk1.4的语法进行处理，即把数组打散成为若干个单独的参数。所以，在给main方法传递参数时，不能使用代码mainMethod.invoke(null,new String[]{“xxx”})，javac只把它当作jdk1.4的语法进行理解，而不把它当作jdk1.5的语法解释，因此会出现参数类型不对的问题。 解决办法： mainMethod.invoke(null,new Object[]{new String[]{“xxx”}}); mainMethod.invoke(null,(Object)new String[]{“xxx”}); //编译器会作特殊处理，编译时不把参数当作数组看待，也就不会数组打散成若干个参数了 代码：123456789101112131415161718192021222324252627import java.lang.reflect.*;public class ReflectTest &#123; public static void main(String[] args) throws Exception&#123; TestArguments.main(new String[]&#123;"sadfds","hjhgj"&#125;); System.out.println("-----------------------------"); String startingClassName = args[0]; Method mainMethod = Class.forName(startingClassName).getMethod("main", String[].class); mainMethod.invoke(null, (Object)new String[]&#123;"sadfds","hjhgj"&#125;); System.out.println("-----------------------------"); //不只是main方法，普通方法也一样 Method testMethod = Class.forName(startingClassName).getMethod("test", String[].class); testMethod.invoke(null, new String[]&#123;"sadfds","hjhgj"&#125;); &#125;&#125;class TestArguments&#123; public static void main(String[] args)&#123; for(String arg : args)&#123; System.out.println(arg); &#125; &#125; public static void test(String[] args)&#123; for(String arg : args)&#123; System.out.println(arg); &#125; &#125;&#125; ###7. 数组与Object的关系及其反射类型 具有相同维数和元素类型的数组属于同一个类型，即具有相同的Class实例对象。 代表数组的Class实例对象的getSuperClass()方法返回的父类为Object类对应的Class。 基本类型的一维数组可以被当作Object类型使用，不能当作Object[]类型使用。 非基本类型的一维数组，既可以当做Object类型使用，又可以当做Object[]类型使用。 代码举例：1234567891011121314151617181920212223242526import java.lang.reflect.*;public class ReflectTest &#123; public static void main(String[] args) throws Exception&#123; int[] a1 = new int[3]; int[] a2 = new int[4]; int[][] a3 = new int[2][3]; String[] a4 = new String[3]; System.out.println(a1.getClass()==a2.getClass());//true System.out.println(a1.getClass().getName());//[I(数组整形) //父类的名字 System.out.println(a1.getClass().getSuperclass().getName());//java.lang.Object System.out.println(a2.getClass().getSuperclass().getName());//java.lang.Object System.out.println(a3.getClass().getSuperclass().getName());//java.lang.Object System.out.println(a4.getClass().getSuperclass().getName());//java.lang.Object System.out.println(String.class.getSuperclass().getName());//java.lang.Object System.out.println(StringBuffer.class.getSuperclass().getName());//java.lang.Object //发现a1，a2，a3，a4的super都是objcet所以可以类型转换 //结论：int[]一维数组是Object,String是Object，int是基本类型，不是Object Object aObj1 = a1; Object aObj2 = a4; //Object[] aObj3 = a1;不对 int 不可以直接转为object Object[] aObj4 = a3; Object[] aObj5 = a4; &#125;&#125; Arrays.asList()方法处理int[]和String[]时的差异。12System.out.println(Arrays.asList(a1)); //[[I@55f33675]System.out.println(Arrays.asList(a4)); //[aa, bb, cc] ####数组的反射应用 Array工具类用于完成对数组的反射操作。1234567891011121314printObject(a4);//aa bb cc printObject("zyz");//zyz## 标题 ## private static void printObject(Object obj)&#123; Class clazz = obj.getClass(); if(clazz.isArray())&#123; int len = Array.getLength(obj); for(int i=0;i&lt;len;i++)&#123; System.out.println(Array.get(obj, i)); &#125; &#125;else&#123; System.out.println(obj); &#125; &#125; 获取类的泛型类型public static Class getActualType(Class entity){ //ParameterizedType:参数类型 ParameterizedType parameterizedType = (ParameterizedType) entity.getGenericSuperclass(); //获得真实类型参数数组 [0]表示第一个 Class entityClass = (Class) parameterizedType.getActualTypeArguments()[0]; return entityClass; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正确使用 Volatile 变量]]></title>
      <url>%2F2016%2F12%2F20%2F%5BJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5D%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20Volatile%20%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[http://www.ibm.com/developerworks/cn/java/j-jtp06197.html#ibm-pcon 锁提供了两种主要的特性：互斥和可见性 互斥：一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据 可见性：可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题 Volatile 变量Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值 Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束 正确使用 volatile 变量的条件您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性 正确使用 volatile 的模式模式 #1：状态标志 也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机 volatile boolean shutdownRequested; ... public void shutdown() { shutdownRequested = true; } public void doWork() { while (!shutdownRequested) { // do stuff } } 很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见 这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。 模式 #3：独立观察（independent observation） 安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java多线程与并发库高级应用]]></title>
      <url>%2F2016%2F12%2F14%2F%5BJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5DJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%BA%93%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[多线程与效率 多线程并不一定会提高程序的运行效率，反而会降低效率 多线程的应用不是为了提高运行效率，而是为了提高资源使用效率；当一个资源在等待I/O输入时，另一个线程可以使用处理器，提高了资源的利用率 为什么使用多线程下载速度会变快？多线程下载：并不是自己电脑快了，而是抢到更多服务器资源。例：服务器为一个客户分配一个20K的线程下载，你用多个线程，服务器以为是多个用户就分配了多个20K的资源给你 并行与并发 并行指多个事件在同一时刻发生，并行需要有多个CPU 并行是在同一个CPU上按照时间片的划分运行多个程序，在宏观上看两个任务同时执行，但是在同一时刻只有一个任务在执行 == 传统线程技术回顾 ==传统是相对于JDK1.5而言的 创建线程的两种传统方式继承Thread创建Thread的子类,覆盖其中的run方法,运行这个子类的start方法即可开启线程 public class ThreadTest1 { public static void main(String[] args) { // TODO Auto-generated method stub Thread thread = new Thread() { @Override public void run() { while (true) { // 获取当前线程对象 获取线程名字 System.out.println(Thread.currentThread().getName()); // 让线程暂停，休眠，此方法会抛出中断异常InterruptedException try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }; thread.start(); } } 实现Runnable接口创建Thread时传递一个实现Runnable接口的对象实例(用的比较多，因为符合面向对象编程的思路) public class ThreadTest1 { public static void main(String[] args) { // TODO Auto-generated method stub Thread thread = new Thread(new Runnable() { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }); thread.start(); } } 面试题问题：下边的线程运行的是Thread子类中的run方法还是实现Runnable接口类的run方法 public class ThreadTest1 { public static void main(String[] args) { // TODO Auto-generated method stub new Thread(new Runnable() {////b、传递实现Runnable接口的对象 @Override public void run() { // TODO Auto-generated method stub System.out.println(&quot;2&quot;); } }){//a、覆盖Thread子类run方法 @Override public void run() { System.out.println(&quot;1&quot;); } }.start(); } } 分析：查看Thread的源代码，注意run方法，在如果传入的Runnable对象不为空，则去执行Runnable对象的run方法 public class Thread implements Runnable { private Runnable target; public Thread(Runnable target) { init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); } public void run() { if (target != null) { target.run(); } } } 但是在这里，子类run方法实际就是覆盖父类中的run方法，如果覆盖了就用子类的run方法，不会再找Runnable中的run方法了，所以运行的是子类中的run方法 总结由Thread类中的run方法源代码中看出，两种传统创建线程的方式都是在调用Thread对象的run方法 如果子类重写父类的run方法，则调用子类的run方法 如果Thread对象的run方法没有被覆盖，并且像为Thread对象传递了一个Runnable对象，就会调用Runnable对象的run方法 定时器定时器在游戏上很常用，例如俄罗斯方块下降，贪吃蛇往前移动等 定时器的使用 一段时间后执行，第一个参数为任务，第二个参数为等待时间，单位是毫秒 new Timer().schedule(new TimerTask() { @Override public void run() { System.out.println(&quot;boom!&quot;); } },1000); 一段时间后执行，以后每隔多少时间再次执行，第一个参数为任务，第二个参数为等待多长时间，第三个参数为每隔多长时间执行一次 new Timer().schedule(new TimerTask() { @Override public void run() { System.out.println(&quot;boom!&quot;); } },0, 1000); 显示计时信息： //计时 new Timer().schedule(new TimerTask() { @Override public void run() { // TODO Auto-generated method stub while(true){ System.out.println(new Date().getSeconds()); try { Thread.sleep(1000); } catch (Exception e) { // TODO: handle exception } } } }, 0); 传统线程互斥技术如果多个线程对同一个对象操作，会引起安全问题（多卖票） 代码实现原子性：有一个线程正在使用这个方法的代码，别的线程就不能再使用。就和厕所里的坑一样，已经有人在用了，别人就不能再去用了。Java中某段代码要实现排他性，就将这段代码用synchronized关键字保护起来 synchronized（this）｛ for (int i=0; i&lt;len; i++) System.out.println(name.charAt(i));//逐个字符打印 System.out.println(); } 注意：要实现互斥，在这个位置必须使用的锁必须是同一个对象，这样的话，有一个线程进入保护区域后，没出来的话，别的线程就不能进入保护区域 互斥方法： a、同步代码块 synchronized (lock){} b、同步方法 1、方法返回值前加synchronized，同步方法上边用的锁就是this对象 2、静态同步方法使用的锁是该方法所在的class对象 案例：output1和output2互斥，因为互斥变量都为当前对象12345678910111213141516171819class Outputer &#123; public void output1(String name) &#123; synchronized (this) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) System.out.print(name.charAt(i)); System.out.println(); &#125; &#125; public synchronized void output2(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) System.out.print(name.charAt(i)); System.out.println(); &#125; &#125; 此时为静态函数，要实现互斥，使用Outputer的字节码12345678910111213141516171819static class Outputer &#123; public static void output1(String name) &#123; synchronized (Outputer.class) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) System.out.print(name.charAt(i)); System.out.println(); &#125; &#125; public static synchronized void output2(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) System.out.print(name.charAt(i)); System.out.println(); &#125; &#125; 传统线程同步通信技术线程同步就是线程按照先后的次序运行，即”我执行完之后然后你执行” 面试题：子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序 /** * 面试题：子线程循环10次，接着主线程循环100， * 接着又回到子线程循环10次，接着再回到主线程又循环100， * 如此循环50次，请写出程序 */ /** 解题思路：线程交替运行，这是一个线程同步问题 * 1、首先保证子任务和主任务执行过程中不冲突：将子任务和主任务封装在business类中，使用关键词Synchronized保证代码块的原子性 * 2、子任务、主任务前后执行顺序控制：使用wait/notify机制，使用boolean类型的isSub变量控制当前应该执行哪个任务，如果不该执 * 行则休眠，否则执行；执行结束后必须反转isSub变量，然后通知阻塞进程继续执行 * 3、交替执行50次：子任务和主任务各自循环50次，在第2步时已经保证子任务和主任务的交替运行，完成要求 */ class TwoThreadSynchronized { public static void main(String[] args){ final Bussiness bussiness = new Bussiness(); new Thread(new Runnable() { @Override public void run() { for(int i = 0; i &lt; 50; i++) bussiness.main(i+1); } }).start(); new Thread(new Runnable() { @Override public void run() { for(int i = 0; i &lt; 50; i++) bussiness.sub(i+1); } }).start(); } } class Bussiness{ //共享变量，子任务先开始 boolean isSub = true; public synchronized void main(int loop){ while(isSub){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;第&quot; + loop + &quot;次循环：&quot;); System.out.print(&quot;main：&quot;); for(int i = 0; i &lt; 100; i++){ System.out.print(i + &quot; &quot;); } System.out.println(); isSub = true; notify(); } public synchronized void sub(int loop){ while(!isSub){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;第&quot; + loop + &quot;次循环：&quot;); System.out.print(&quot;sub：&quot;); for(int i = 0; i &lt; 10; i++){ System.out.print(i + &quot; &quot;); } System.out.println(); isSub = false; notify(); } } ThreadLocal实现线程范围内的数据共享 什么是线程范围内的数据共享？一个线程内部的各个函数都能访问该共享变量，而其他线程不能访问（区别于静态变量，静态变量能被所有线程访问，但需要解决线程间数据同步的问题） 应用： 用户访问Web服务器，服务器启动一条线程处理用户请求，不同用户之间不受干扰 用户访问数据库，每个用户使用独立的connection。不然会出现A用户开启事务，操作还没有结束，B用户使用的是相同的connection，提交事务，导致A用户还未完成操作但事务提交了 自己的实现的线程范围内的数据共享使用全局的map，键为线程，值为该线程中需要共享的变量。每次取值时，传入当前的线程，即可取到当前线程共享的变量 public class ThreadLocalTest { //键为当前线程，值为线程范围内的共享变量 static Map&lt;Thread, Integer&gt; map = new HashMap&lt;Thread, Integer&gt;(); public static void main(String[] args){ new Thread(new Runnable() { @Override public void run() { map.put(Thread.currentThread(),1); System.out.println(&quot;A:&quot; + new A().get()); } }).start(); new Thread(new Runnable() { @Override public void run() { map.put(Thread.currentThread(),2); System.out.println(&quot;B:&quot; + new A().get()); } }).start(); } static class A{ public Integer get(){ return map.get(Thread.currentThread()); } } } 使用 ThreadLocal 实现的线程间数据共享public class ThreadLocalTest { static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public static void main(String[] args){ new Thread(new Runnable() { @Override public void run() { threadLocal.set(1); System.out.println(&quot;A:&quot; + new A().get()); } }).start(); new Thread(new Runnable() { @Override public void run() { threadLocal.set(2); System.out.println(&quot;B:&quot; + new A().get()); } }).start(); } static class A{ public Integer get(){ return threadLocal.get(); } } } 原理： 1、1个ThreadLocal代表一个与线程绑定的值2、线程中存储多个ThreadLocal的值，用Map存储 public class ThreadLocal&lt;T&gt; { public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; } return setInitialValue(); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } } 使用 ThreadLocal 实现线程范围内的单例 每个线程都使用一个类的实例，实现这个功能需要结合ThreadLocal，与线程绑定 单例模式无法实现，是在整个应用中保持单例 应用：对于每一个用户请求，对应一个线程，为之创建一个容器，仅供该用户使用。该容器可以使用线程范围内的单例来实现 public class ThreadLocalTest { public static void main(String[] args){ new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread() + " " + Person.getThreadLocalInstance()); System.out.println(Thread.currentThread() + " " + Person.getThreadLocalInstance()); } }).start(); new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread() + " " + Person.getThreadLocalInstance()); System.out.println(Thread.currentThread() + " " + Person.getThreadLocalInstance()); } }).start(); } } class Person{ private static ThreadLocal threadLocal = new ThreadLocal(); public static Person getThreadLocalInstance(){ Person person = threadLocal.get(); if(person == null){ person = new Person(); threadLocal.set(person); } return person; } private String name; private Integer age; public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getName() { return name; } } 多个线程之间共享数据的方式探讨1、两个线程的操作一致，可以使用同一个Runnable对象。火车站买票适用这种情况 public class Method1 { public static void main(String[] args){ Runnable runnable = new sell(); new Thread(runnable).start(); new Thread(runnable).start(); } } class sell implements Runnable{ private int ticket = 1000000; public synchronized void sell(){ if(ticket &gt; 0){ ticket--; System.out.println(Thread.currentThread() + &quot; 剩余票&quot; + ticket); } } @Override public void run() { while (true){ sell(); } } } 2、两个线程操作不一样。此时必须设置第三方共享数据，并调用他的方法进行数据操作（推荐） public class Method1 { public static void main(String[] args){ final TrainCenter trainCenter = new TrainCenter(); new Thread(new Runnable() { @Override public void run() { while(true) trainCenter.sell(); } }).start(); new Thread(new Runnable() { @Override public void run() { while(true) trainCenter.sell(); } }).start(); } } class TrainCenter{ private int ticket = 100000; public int getTicket() { return ticket; } public void setTicket(int ticket) { this.ticket = ticket; } public synchronized void sell(){ if(ticket &gt; 0){ ticket--; System.out.println(Thread.currentThread() + &quot; 剩余 &quot; + ticket); } } } 3、共享数据传入Runnable对象中，进行操作 public class Method1 { public static void main(String[] args){ TrainCenter trainCenter = new TrainCenter(); new Thread(new Train1(trainCenter)).start(); new Thread(new Train2(trainCenter)).start(); } } class Train1 implements Runnable{ private TrainCenter trainCenter; public Train1(TrainCenter trainCenter){ this.trainCenter = trainCenter; } @Override public void run() { while(true){ trainCenter.sell(); } } } class Train2 implements Runnable{ private TrainCenter trainCenter; public Train2(TrainCenter trainCenter){ this.trainCenter = trainCenter; } @Override public void run() { while(true){ trainCenter.sell(); } } } class TrainCenter{ private int ticket = 100000; public int getTicket() { return ticket; } public void setTicket(int ticket) { this.ticket = ticket; } public synchronized void sell(){ if(ticket &gt; 0){ ticket--; System.out.println(Thread.currentThread() + &quot; 剩余 &quot; + ticket); } } } == Java并法库 java.util.concurrent ==java5原子性操作类的应用Atomicxxx 线程池线程池的作用： 根据系统自身的环境情况，有效的限制执行线程的数量，超出数量的任务排队等候，等待有任务执行完毕，再从队列最前面取出任务执行 减少创建和销毁线程的次数，每个工作线程可以多次使用 常见线程池：①newSingleThreadExecutor单个线程的线程池，即线程池中每次只有一个线程工作，单线程串行执行任务②newFixedThreadExecutor(n)固定数量的线程池，没提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成才继续执行③newCacheThreadExecutor（推荐使用）可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行。④newScheduleThreadExecutor大小无限制的线程池，支持定时和周期性的执行线程 实例： ①newSingleThreadExecutor public class TestSingleThreadExecutor { public static void main(String[] args){ //创建一个单个线程的线程池 ExecutorService pool = Executors.newSingleThreadExecutor(); //将任务放入池中并执行 pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); //关闭 pool.shutdown(); } } class Task implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;执行中。。。&quot;); } } result： pool-1-thread-1执行中。。。 pool-1-thread-1执行中。。。 pool-1-thread-1执行中。。。 pool-1-thread-1执行中。。。 pool-1-thread-1执行中。。。 ②newFixedThreadExecutor(n) public class TestFixedThreadPool { public static void main(String[] args){ //创建一个固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); //将任务放入池中并执行 pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); //关闭 pool.shutdown(); } } result： pool-1-thread-1执行中。。。 pool-1-thread-2执行中。。。 pool-1-thread-1执行中。。。 pool-1-thread-2执行中。。。 pool-1-thread-1执行中。。。 ③newCacheThreadExecutor public class TestCachedThreadPool { public static void main(String[] args) { //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newCachedThreadPool(); //将任务放入池中并执行 pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); pool.execute(new Task()); //关闭 pool.shutdown(); } } result： pool-1-thread-1执行中。。。 pool-1-thread-2执行中。。。 pool-1-thread-4执行中。。。 pool-1-thread-3执行中。。。 pool-1-thread-5执行中。。。 JAVA线程池shutdown和shutdownNow的区别 shutDown() 当线程池调用该方法时，线程池的状态则立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。 shutdownNow() 根据JDK文档描述，大致意思是：执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 线程池定时器这种做法从性能方面讲相对于传统的定时器要好 public static void main(String[] args){ Executors.newScheduledThreadPool(1).scheduleAtFixedRate(new Runnable() { @Override public void run() { System.out.println(&quot;测试开始&quot;); } },0,1, TimeUnit.SECONDS); } Callable和FutureCallable和Future，一个产生结果，一个拿到结果。 Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值，下面来看一个简单的例子： public class CallableAndFuture { private FutureTask&lt;Integer&gt; future; public static void main(String[] args) { //复杂操作，需要耗费很长时间，但结果不是立刻需要 Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() { public Integer call() throws Exception { Thread.sleep(10000); return new Random().nextInt(100); } }; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable); new Thread(future).start(); try { Thread.sleep(5000);// 可能做一些事情 if(!future.isDone()){ System.out.println(&quot;任务还没有执行完，先返回默认值0&quot;); } //用户有足够的耐心等待任务执行结束 System.out.println(&quot;任务执行结束：&quot; + future.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到，岂不美哉！这里有一个Future模式的介绍：http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm。 下面来看另一种方式使用Callable和Future，通过ExecutorService的submit方法执行Callable，并返回Future，代码如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试总结]]></title>
      <url>%2F2016%2F12%2F13%2F%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%5D%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Linux命令：wget 要下载文件的url tar -zxvf 解压zip xx 压缩 mount 挂载unmount 卸载 make 根据makefile进行编译make install 根据makefile进行安装 rpm 查看软件 yum install 安装软件 mkdir 建立文件夹rmdir 删除空文件rm -rf 删除文件夹 mv 移动cp 复制 netstat -anp | grep 8080 查询端口 sudo 命令/ sudo su #管理员权限 service mysqld start 启动mysql数据库service mysqld stop 停止 ps -aux 进程列表kill -9 pid 杀进程 权限：chmod 777 文件名 #！！！！！！！！！！chown 用户名 文件名 #修改文件所有者chgrp 组名 文件名 #修改文件所有组 /etc/profile #系统整体配置文件 df 系统分区情况 Java类的成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放 Java内存分为四块，堆，栈，静态区(常量区)和程序代码区。我记得是这四个，new出来的都在堆上，栈里是临时变量，比如int a=3；常量去存放const和static；代码区就不说 方法重写与方法重载所谓方法的重写是指子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型 在重写方法时，需要遵循以下的规则： (一) 父类方法的参数列表必须完全与被子类重写的方法的参数列表相同，否则不能称其为重写而是重载(二) 父类的返回类型必须与被子类重写的方法返回类型相同，否则不能称其为重写而是重载(三) Java中规定，被子类重写的方法不能拥有比父类方法更加严格的访问权限（范围扩大） 类加载器作用是把类的二级制加载进内存中 类加载器的层次关系：Bootstrap、ExtClassLoader、AppClassLoader、用户自定义的类加载器 类加载器的委托机制： 1、当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢? ①首先 当前线程的类加载器 去加载线程中的第一个类. ②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B ③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类. 2、每个类加载器加载类时，又先委托给其上级类加载器 当所有祖宗类加载器没有加载到类，回到发起者类加载器，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。 ArrayList和LinkedList和Vector1、ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构2、对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针3、对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized).因此,开销就比ArrayList要大.正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制 HashMap和HashTable1、历史原因 Hashtable是基于陈旧的Dictionary类的，HashMap是java 1.2引进的Map接口的一个实现 2、同步性 Hashtable是线程同步的。这个类中的一些方法保证了Hashtable中的对象是线程安全的（Synchronized）。而HashMap则是线程异步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率 3、值 HashMap可以让你将空值作为一个表的条目的key或value但是Hashtable是不能放入空值的(null) HashMap底层实现http://zhangshixi.iteye.com/blog/672697 HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表，链表的每一个元素是键-值对。当新建一个HashMap的时候，就会初始化一个数组。 transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; Entry&lt;K,V&gt; next; final int hash; …… } 可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMap的存取实现： 1) 存储： public V put(K key, V value) { // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null; } 从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 动态代理1、必须针对接口进行代理2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类3、自己实现InvocationHandler 接口 多线程1、thread与runnable 如果改写thread的run方法和传入runnable类，使用的是那个run？ Thread的run方法，如果runnable对象不为空，去执行runnable中的run方法，但是如果Thread的run方法被重写，则使用改写的Thread中的run方法 public void run() { if (target != null) { target.run(); } } 2、synchronized，使用的对象锁必须同一个对象，可以this或字符串常量 Synchronized(){ //保护一段代码 } 也可以修饰方法，来保护整个方法（默认对象锁是this） 如果修饰静态方法，静态对象对应的对象锁是类的字节码 Spring MVC 和 Struts2的区别 Struts2的入口是filter，Spring MVC的入口是Servlet，两者的实现机制不同 Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用；Spring MVC是基于方法设计的，参数绑定到方法的形参，并且只有一个方法可以使用 Struts2必须是多例的（Struts2传递到的参数绑定到类的属性，如果是单例会导致不同用户数据的冲突），Spring MVC默认是单例的，所以Spring MVC的性能比Struts2好 重定向与转发的区别 浏览器中的url：转发仍是原来的url，重定向为新的url 重定向发生在浏览器，由浏览器重新发出http请求，转发发生web服务器，请求在web服务器转发 重定向可以到外部网站，重定向只能访问WEB应用个资源 SesssionSession的生命周期 Session存储在服务器端，一般为了防止在服务器的内存中（为了高速存取），Sessinon在用户访问第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session，可调用request.getSession(true)强制生成Session Session什么时候失效？ 1、服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为30分钟。2、调用Session的invalidate方法。 JVM内存结构 图一：java内存结构划分 我感觉这图更形象一点 由上图可知，java内存主要分为6部分，分别是 程序计数器，虚拟机栈，本地方法栈，堆，方法区和直接内存，下面将逐一详细描述。 1、程序计数器线程私有，即每个线程都会有一个，线程之间互不影响，独立存储，代表着当前线程所执行字节码的行号指示器。 2、虚拟机栈线程私有，它的生命周期和线程相同，描述的是 java方法执行的内存模型 ：每个方法在执行的同时多会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口等信息。 每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型和对象引用，所需内存空间在编译期确定。 -Xoss 参数设置本地方法栈大小（ 对于HotSpot无效 ） -Xss 参数设置栈容量 例： -Xss128k 3、本地方法栈同虚拟机栈，只不过本地方法栈位虚拟机使用到的native方法服务。 Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一 4、java堆线程共享 主要用于分配对象实例和数组。 -Xms 参数设置最小值 -Xmx 参数设置最大值 例：VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 若-Xms=-Xmx,则可避免堆自动扩展。 -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出是dump出当前的内存堆转储快照。 5、方法区线程共享 用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据 别名永久代（Permanent Generation） -XX:MaxPermSize 设置上限 -XX:PermSize 设置最小值 例：VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M 运行时常量池(Runtime Constant Pool)是方法区的一部分 。 Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项是 常量池 （Constant Pool Table）,用于存放编译期生成的各种字面量和符号引用，这部分 内容将在类加载后进入方法区的运行时常量池中存放 。 运行时常量池相对于Class文件常量池的一个重要特征是具备动态性：即除了Class文件中常量池的内容能被放到运行时常量池外，运行期间也可能将新的常量放入池中，比如 String类的intern（）方法。 6、直接内存直接内存并不是虚拟机运行时数据区的一部分。 在NIO中，引入了一种基于通道和缓冲区的I/O方式，它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 -XX:MaxDirectMemorySize 设置最大值，默认与java堆最大值一样。 例 ：-XX:MaxDirectMemorySize=10M -Xmx20M 对于32位操作系统来说，系统最大内存为4G。 系统给每个进程的内存是有限制的，譬如32位的windows 限制为2G JVM，多线程ConcurrentHashmaowait和sleep的区别放不放锁呗还有生产者消费者RPCIPC快速排序二叉排序树索引数据结构缓存]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP]]></title>
      <url>%2F2016%2F12%2F06%2F%5B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%5DTCP%2F</url>
      <content type="text"><![CDATA[TCP是在不可靠的端到端网络协议（IP）之上实现的可靠数据传输协议 可靠数据传输的原理完全可靠信道上的可靠数据传输：rdt1.0 rdt发送方只有一个状态，通过rdt_send(data)从较高层接收数据，产生分组，并将分组发送到信道中后，状态又跳回到等待上传调用的状态 rdt接收方只有一个状态，通过rdt_rcv（packet）从底层信道接收一个分组，提取数据，并将数据上传给高层，状态又回到等待下层调用 因为信道完全可靠，接收方不需要提供任何反馈信息给发送方 具有比特差错信道上的可靠数据传输：rdt2.0（不丢包，但包可能受损）人类处理这类情形：报文接受者在听到每句话后会说OK，如果消息接受者听到一句含糊不清的话，他可能要求你重复刚才那句话。这种口述消息协议使用了肯定确认（OK）与否定确认（请重复一遍） 在计算机网络中，基于这种重传机制的可靠数据传输协议称为自动重传请求（ARQ），需要三种协议来处理比特差错： 差错检测 接收方反馈：肯定确认（ACK），否定确认（NAK） 重传 rdt2.0发送方两个状态： 1、等待上层调用：rdt_send事件发生，产生数据包，发送该分组，状态跳到22、等待接收方的ACK或NAK 如果收到ACK分组，则发送发知道最近传输的分组已经被正确接收，因此状态返回等待上层调用 如果收到一个NAK分组，重传最后一个分组，并等待接受方的ACK或NAK rdt2.0接收方的只有一个状态：当分组到达时，接收方要么回答一个ACK，要么回答一个NAK 问题： 1、停等协议：只有当上一个分组发送成功，才能发送下一个分组，效率低2、没有考虑ACK或NAK分组受损（假设分组不丢失），发送方无法知道接收方是否正确接收了上一块发送的数据 rdt2.1：引入序列号解决冗余分组 解决ACK或NAK受损的一种方式是：当发送方收到含糊不清的ACK或NAK分组时，直接重发当前数据分组，但这引入了冗余分组，接收方不知道上次发送的ACK或NAK是否被发送方正确接收到，导致接收方无法知道接收到的分组是新的，还是一次重传（重传的数据包保证该数据包中的数据只提取一次） 解决这个问题的一个简单方法是在数据分组中 添加一个新字段，对于停等协议，1比特就够了，如果接收到的分组序号与最近收到的分组序号相同，知道是在重发，不相同则是一个新分组 发送方状态：当发送完分组0，处于等待ACK或NAK的状态，如果分组受损或收到NAK，重发分组；如果收到ACK，说明接收方正确接收到分组0，状态跳转到等待发送分组1的状态 接收方状态：如果接收到受损包，直接发送NAK；如果收到分组的序号与上一次收到的序号一致，说明是重传包，直接发送ACK；如果收到的分组序号与上一次收到的不一致，发送NAk。具体的，划分出两个状态：等待数据0和等待数据包1 rdt2.2：冗余ACK来代替NAK rdt2.1中接收到受损分组时发送一个NAK，通知发送端重发。如果不发送NAK，而是发送一个对上次正确接收的分组的ACK（即冗余ACK），发送方接收到对同一个分组的两个ACK，就知道接受方没有正确接收到跟在被确认两次的分组后面的分组 发送方状态：在等待ACK0时，若收到损坏的分组或ACK1，则重传，否则状态跳到等待上层调用1 接收方状态：如果接收到受损包，或收到分组的序号与上一次收到的序号一致，说明是重传包，直接发送以上一次的发送的ACK（冗余ACK）；如果收到的分组序号和上一次收到的不一致，则提取数据，发送ACk 具有比特差错的丢包信道上的可靠数据传输：rdt3.0需要考虑两个问题： 如何检测丢包 发生丢包后该做什么 利用校验和、序号、ACK分组和重传可以解决后一个问题，即重传，所以重点是解决如何检测丢包问题 在发送方负责检测和恢复丢包，增加一个倒计时定时器，发送一个分组后（包括重传），便启动一个定时器 发送方状态：上层调用rdt_send(data)时，发送数据包，并开启定时器，状态转移到等待ACK的状态。如果接收到破损包或者上一个分组包的ACK，先不采取任何操作，等到定时器超时后进行重传，这种方式也考虑到包丢失的情况 接收方状态：如果接收到受损包，或收到分组的序号与上一次收到的序号一致，说明是重传包，直接发送以上一次的发送的ACK（冗余ACK）；如果收到的分组序号和上一次收到的不一致，则提取数据，发送ACk（与rdt2.2一样） 流水线可靠数据传输协议停等协议的是一个功能正确的协议，但是它的性能低下，吞吐量低，是网络协议限制底层网络硬件所提供功能的形象示例 解决性能问题的一个简单方法是采用流水线技术，允许发送方发送多个分组而无须等待确认，解决流水线的差错恢复有两种基本方法： 回退N步 选择重传 回退N步（GBN）将基序号（base）定义为最早的未被确认分组的序号，将下一个序号（nextseqnum）定义为下一个待发送的分组序号 序号分为4部分： [0，base-1]内的序号对应于已经发送并确认过的序号 [base，nextseqnum-1]内的序号对应已经发送但未被确认的分组 [nextseqnum，base+N-1]内的序号可用于那些要被立刻发送的分组，其数据来自上层 大于或等于base+N的序号是不能使用的，知道当前流水线中未被确认的分组已得到确认为止 GBN发送方响应的三种类型事件： 上层的调用：如果发送窗口未满，则创建一个分组并发送，否则不传送 收到ACK：采用累积确认，表示接收方已正确接收序号n之前的所有分组 超时时间：GBN协议中，使用的一个定时器当做是最早的已发送但未被确认的分组所使用过的定时器（即base分组），如果超时将重传所有已发送但未被确认的分组（即图中灰色的分组）；如果收到一个ACK，但仍有未被确认的分组，则定时器被重新启动，如果没有已发送但未被确认的分组，则定时器终止 接收方：丢弃所有失序分组。如果期望n分组，而n+1分组却到了，不需要缓存n+1分组，因为如果n分组丢失，发送方将会重新发送n分组和n+1分组，这样设计，接收方不需要缓存任何失序分组，接收方只需要维护下一个按需接收的分组的序号。 选择重传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOS文献]]></title>
      <url>%2F2016%2F11%2F30%2F%5B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%5DDOS%E6%96%87%E7%8C%AE%2F</url>
      <content type="text"><![CDATA[SYNFlood型DDos攻击检测与防御研究Linux系统增加Netfilter防火墙功能，在IP层内提供了另外5个插入点，非常容易捕获并处理网络数据包 防DDos攻击的系统特点： 1、基于信息熵值得实时攻击检测 2、黑白单过滤，减轻防御模块的工作任务 3、协议分析 4、基于SYN Cookie技术的SYN Flood攻击防御模块 5、自学习子系统，包含蜜罐系统和数据挖掘系统，蜜罐系统旁路手机网络异常流量，通过数据挖掘生成防御规则动态更新异常检测阈值、黑白名单列表和协议分析规则，调整后续攻击响应策略 Linux包捕获机制DDos防御系统最基本的功能之一就是对网络数据包进行处理，因此需要捕获数据包并分析过滤，Linux系统环境下数据获取有两种方式： 通过内核防火墙Netfilter/Iptables获取 通过包捕获机制Libpcap旁路获取 选择：正常情况下使用Netfilter/Iptables，会增加不必要的系统开销，因此在正常网络流量环境下，采用Libpcap旁路获取数据包形式 Libpcap是Unix/Linux平台下的网络数据包捕获函数宝，而在Windows系统下有相应的Winpcap库 攻击检测算法与SYN Cookie算法研究基于TCP协议的攻击占了DDos攻击的绝大多数，而SYN Flood攻击又在TCP攻击中扮演着最重要的角色，当前防御SYN Flood攻击最流行的方法是使用SYN Proxy和SYN Cookie DDos攻击防御系统检测阶段的任务就是要在攻击分组到来时及时向防御系统发出警报，从而使防御系统能在短时间做出反应，开启防御策略，实施分组过滤]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instanceof, isinstance,isAssignableFrom的区别]]></title>
      <url>%2F2016%2F11%2F24%2F%5BJava%5Dinstanceof%2C%20isinstance%2CisAssignableFrom%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[类-实例instanceof运算符只被用于对象引用变量，检查左边的被测试对象是不是右边类或接口的实例化。如果被测对象是null值，则测试结果总是false。 形象地：自身实例或子类实例 instanceof 自身类返回true例： String s=new String(“javaisland”); System.out.println(s instanceof String); //true Class-实例Class类的isInstance(Object obj)方法，obj是被测试的对象，如果obj是调用这个方法的class或接口 的实例，则返回true。这个方法是instanceof运算符的动态等价。形象地：自身类.class.isInstance(自身实例或子类实例)返回true例：String s=new String(“javaisland”); System.out.println(String.class.isInstance(s)); //true Class-ClassClass类的isAssignableFrom(Class cls)方法，如果调用这个方法的class或接口 与 参数cls表示的类或接口相同，或者是参数cls表示的类或接口的父类，则返回true。形象地：自身类.class.isAssignableFrom(自身类或子类.class)返回true例：System.out.println(ArrayList.class.isAssignableFrom(Object.class)); //false System.out.println(Object.class.isAssignableFrom(ArrayList.class)); //true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring中你不知道的注入方式]]></title>
      <url>%2F2016%2F11%2F10%2F%5BSpring%5DSpring%E4%B8%AD%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[前言在Spring配置文件中使用XML文件进行配置，实际上是让Spring执行了相应的代码，例如： 使用元素，实际上是让Spring执行无参或有参构造器 使用元素，实际上是让Spring执行一次setter方法 但Java程序还可能有其他类型的语句：调用getter方法、调用普通方法、访问类或对象的Field等，而Spring也为这种语句提供了对应的配置语法： 调用getter方法：使用PropertyPathFactoryBean 调用类或对象的Filed值：使用FiledRetrievingFactoryBean 调用普通方法：使用MethodInvokingFactoryBean https://my.oschina.net/itblog/blog/206481]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat操作Servlet流程]]></title>
      <url>%2F2016%2F11%2F07%2F%5BServlet%5DTomcat%E6%93%8D%E4%BD%9CServlet%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Tomcat调用Servlet的流程 Listener的初始化最早，Filter次之。他俩的初始化都是在容器启动完成之前初始化的。 Servlet没有初始化，原因是没有匹配的请求进来。 如果想要servlet自动初始化，需要在指定的servlet中配置参数，没有此标签，默认启动时servlet不进行初始化。 初始化的顺序跟Listener、Filter、Servlet在web.xml中的顺序无关。而多个Filter或多个Servlet的时候，谁的mapping在前面，谁先初始化。 如果web.xml中配置了，它用于向 ServletContext 提供键值对，即应用程序上下文信息。我们的 listener, filter 等在初始化时会用到这些上下文中的信息，context-param 配置节可写在任意位置，初始化顺序： context-param &gt; Listener &gt; Filter &gt; Servlet 过滤器 Filter的初始化方法在服务器启动时执行,过滤方法在请求发出后立即调用，可以过滤特定的URL 过滤器的URL匹配遵从最大长度匹配原则 一个URL匹配多个过滤器，按照filter-mapping配置节点的出现顺序 依次调用doFilter() 过滤器链： 参考：http://blog.sina.com.cn/s/blog_667ab8240101gfd6.html 有多个过滤器 filter1 filter2 filter3，组成一个过滤器链 FilterChain[filter1,filter2,filter3] 如何做到过滤器的依次执行？调用过滤器链的doFilter参数，获取下一个过滤器链，然后执行下一个Filter的方法 前置方法和后置方法的执行顺序？ 1、前置方法按照过滤器的调用顺序因此按顺序执行2、后置方法的顺序与前置方法相反，即后调用的过滤器的后置方法先执行3、Chain.doFilter前的代码为访问Servlet前执行，Chain.doFilter后的代码访问Servlet后执行（分析源代码） 1、下面是一个简单的时序图 2、对上面时序图中用到的主要类进行分析 1) ApplicationFilterChain类,有两个主要函数，下面是省略过的代码 public voiddoFilter(request, response) {//暴露在外面的调用接口 if( Globals.IS_SECURITY_ENABLED ) { finalServletRequest req = request; finalServletResponse res = response; internalDoFilter(req,res); return null; } else { internalDoFilter(request,response); } } private voidinternalDoFilter(request, response) { if (pos &lt; n) {//判断是否还有filter需要执行 ApplicationFilterConfig filterConfig = filters[pos++]; Filter filter = null; filter = filterConfig.getFilter(); filter.doFilter(request, response, this); return ; //执行过滤器方法时，不执行以下代码，当pos=n，即执行完所有filter后执行servlet } //filter执行完后，执行servlet if ((request instanceofHttpServletRequest) &amp;&amp;(response instanceof HttpServletResponse)) { servlet.service((HttpServletRequest) request,(HttpServletResponse)response); } void addFilter(ApplicationFilterConfig filterConfig) { if (n == filters.length) { ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT]; System.arraycopy(filters, 0, newFilters, 0, n); filters = newFilters; } filters[n++] = filterConfig; } 2) Servlet类的主要方法，以HttpServlet类为例，其主要方法是service(Request,Response) public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException(&quot;non-HTTP request or response&quot;); } service(request, response);//内部的方法 } protected void service(HttpServletRequest , HttpServletResponse) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { doGet(req, resp); //常用的方法 } else { long ifModifiedSince; try { ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); } catch (IllegalArgumentException iae) { ifModifiedSince = -1; } if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp);//常用的方法 } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req,resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req,resp); } else { String errMsg =lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 接口和抽象类区别]]></title>
      <url>%2F2016%2F11%2F01%2F%5BJava%5DJava%20%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[参考http://blog.csdn.net/xw13106209/article/details/6923556 面向接口编程OOP面向对象的编程，如果要提高程序的复用率，增加程序的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，正确地使用接口、抽象类这些有用的抽象类型作为你结构层次上的顶层。 Java接口和抽象类1、[最大区别] Java接口和Java抽象类最大的一个区别，就在于Java抽象类既可以有没有具体实现的抽象方法，也可以提供某些方法的部分实现；而Java接口只能定义方法，不能有方法的实现 2、[抽象类优势] Java的抽象类非常有用，如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而如果向Java接口中加入一个新方法，所有实现这个接口的类都无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点 3、[接口优势] 一个抽象类的实现只能由具体子类给出，但是由于Java的单继承特性，一个具体子类继承了抽象类，这个子类的类型就比较单一；在这一点，Java接口的优势就出来了，任何一个实现了Java接口的的类都可以具有这个接口的类型，而且一个类可以实现多个Java接口，类型就比较多；Java接口是定义混合类型的理想工具，混合类表示一个类不仅仅具有某个主类型的行为，而且具有其他次要行为 4、★★★[总结] 抽象类的优势是抽象类中既可以有具体的实现方法，也可以有没有具体实现的抽象方法，继承的子类都可以拥有抽象类实现的方法，缺点是由于Java的单继承性，实现抽象类的子类类型比较单一；一个类可以实现多个接口，因此一个类就可以拥有多个类型，缺点是接口中只能定义方法的类型，实现接口必须实现接口的全部方法 5、[缺省适配模式] 声明类型的工作仍然由Java接口承担，但是同时给出一个Java抽象类，且实现了这个Java接口；而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类；在层次结构中，Java接口在最上面，然后紧跟着抽象类，这下两个优点都能发挥到极致]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro笔记]]></title>
      <url>%2F2016%2F10%2F17%2F%5BSSM%5DShiro%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[术语（Terminology）Authentication（鉴权，身份验证）：校验Subject（主体）的身份是否合法Authorization（授权）：根据主体的角色和权限来决定允许或拒绝访问请求Cipher：执行加密或解密的算法Principal：一个主体的标识属性，独一无二的标识，可以是昵称、用户ID、安全码……Credential（证书）：验证主体身份的信息Cryptography（密码学）：密码学保护信息不被不比希望让他看的人的看到Hash：数据经过hash方法得到的结果不可逆Permission：描述原始的功能，定义应用程序能够做的一些操作Realm（领域）：可以访问应用程序的安全数据，例如用户、角色和权限的组件。可以当做安全的DAO，将应用程序数据翻译成Shiro能够理解的格式，这样Shiro可以提供简洁的API，不管有多少数据源或者应用程序Role：权限的集合，并取一个独一无二的名字Session：主体与软件交互过程中的有状态数据环境，当用户使用应用程序时可以在Session中增加/读取/删除数据，当用户退出应用程序，Session终止Subject：应用程序用户，但他不一定但指一个人，它也可以代表调用你应用程序的外部进程，或者一个间断执行操作的守护系统账户，它可以抽象表示为操作应用程序的主体 简介Apache Shiro是一个强大易用的Java安全框架，提供鉴权、授权、加密、会话管理的综合解决方法。在实践中达到管理应用程序安全的作用，而减少与应用程序的耦合 Shiro可以在任何环境中运行，从最简单的命令行应用程序到企业级web程序和集群应用程序 Shiro快速入门（j2se）官方地址：http://shiro.apache.org/10-minute-tutorial.html Shiro APIimport org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.*; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.session.Session; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Quickstart { private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) { /* * 创建Shiro SecurityManager，同时设置realms、users、roles、permissions， * 最简单的方式是创建一个.ini，通过它返回一个SecurityManager实例。ini文件见下一节 */ Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); // 设置 SecurityManager 为一个静态实例，可以被 JVM 访问到 SecurityUtils.setSecurityManager(securityManager); // 设置Shiro环境完毕，看下它的操作★★★★★ // 获得当前操作的用户，此时currentUser为空，用户还未登录 Subject currentUser = SecurityUtils.getSubject(); // 用Session存储数据（web或EJB容器不需要！！！） Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if (value.equals(&quot;aValue&quot;)) { log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;); } // 用户登录，校验角色和权限 if (!currentUser.isAuthenticated()) { //获得用户名和密码 UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;); token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { log.info(&quot;There is no user with username of &quot; + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;); } catch (LockedAccountException lae) { log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; + &quot;Please contact your administrator to unlock it.&quot;); } // 捕捉更多的异常，可以是用户自定义 catch (AuthenticationException ae) { //unexpected condition? error? } } // 查看用户标识 log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;); // 测试用户是否具备角色 if (currentUser.hasRole(&quot;schwartz&quot;)) { log.info(&quot;May the Schwartz be with you!&quot;); } else { log.info(&quot;Hello, mere mortal.&quot;); } // 测试用户是否具备某个权限 if (currentUser.isPermitted(&quot;lightsaber:weild&quot;)) { log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;); } else { log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;); } // 测试用户是否具备某个权限 if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) { log.info(&quot;You are permitted to &apos;drive&apos; the winnebago with license plate (id) &apos;eagle5&apos;. &quot; + &quot;Here are the keys - have fun!&quot;); } else { log.info(&quot;Sorry, you aren&apos;t allowed to drive the &apos;eagle5&apos; winnebago!&quot;); } // 注销用户 currentUser.logout(); System.exit(0); } } shiro.ini # 用户和他们分配的角色 [users] # 用户'root'的密码是'secret'，包含'admin'的角色 root = secret, admin # 用户'guest'的密码是'guest'，包含'guest'的角色 guest = guest, guest # 用户'presidentskroob'的密码是'12345'，包含'president'的角色 presidentskroob = 12345, president # 用户'darkhelmet'的密码是'ludicrousspeed'，包含角色'darklord'和schwartz' darkhelmet = ludicrousspeed, darklord, schwartz # 用户'lonestarr'的密码是'vespa'，包含角色'goodguy'和'schwartz' lonestarr = vespa, goodguy, schwartz # 角色和他们分配的权限 [roles] # 'admin'的角色拥有所有权限，用通配符'*'表示 admin = * # 角色'schwartz'拥有lightsaber下的任意权限 schwartz = lightsaber:* # 角色'goodguy'允许'drive' (action) the winnebago (type) with # license plate 'eagle5' (instance specific id) goodguy = winnebago:drive:eagle5 Web应用程序整合官方文档：http://shiro.apache.org/webapp-tutorial.html 开启Shiro环境Shiro可以用多重方式配置，取决于你使用的web应用程序框架，如Spring，Guice等，这里采用Shiro默认，最简单的方式：基于INI文件的配置 添加 shiro.ini 文件位置：src/main/webapp/WEB-INF/shiro.ini [main] cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager securityManager.cacheManager = $cacheManager 这个INI文件只简单包含main部分，和一些最小配置 定义 cacheManager 的实例 在 Shiro securityManager 上配置新的cacheManager的实例 在web.xml文件中支持Shiro加载shiro.ini文件启动新的Shiro环境，使Web应用程序支持Shiro环境 &lt;listener&gt; &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;/filter-mapping&gt; 定义一个 ServletContextListener，应用程序启动时启动Shiro环境（包括Shiro SecurityManager）。监听器默认寻找 WEB-INF/shiro.ini 文件 作为 Shiro 的配置文件 过滤器拦截所有请求，所以Shiro在请求达到应用程序之前，能够执行必要的身份验证和访问控制操作 &lt;filter-mapping&gt;声明确保所有请求类型都能被ShiroFilter拦截，一般filter-mapping声明不需要指定dispatcher元素，但是Shiro需要定义它们，这样可以过滤所有不同的请求类型 运行webappmvn tomcat:run 这些输出指明Shiro确定在你的webapp中运行 15:41:22.296 [main] INFO o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization. 15:41:22.733 [main] INFO o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 435 ms. 连接到用户仓库Realm 在我们登录、退出、执行访问控制等其他安全相关的操作之前，我们需要用户！所有我们会设置Shiro去访问用户仓库 用户仓库会有多种形式：MySQL数据库、MongoDB、LDAP、活动目录、简单文件、其他私有数据仓库，Shiro通过 Realm 来操作这些 Realm扮演Shiro与安全数据之间的桥梁，也可以说是连接器。当用户执行鉴权（登录）或授权（访问控制），Shiro从应用程序配置的所有Realm中寻找数据 Realm 是一个安全DAO，封装了连接细节，Shiro需要数据时通过Realm可以直接获取。Realm可以配置多个，但至少要有一个 默认为iniRealm ini简单配置了两个用户，用户名密码分别为admin：admin，guest：guest [users] admin=admin guest=guest Shiro登录/退出与访问控制ini文件，添加访问控制[main] # 对于Shiro任何默认过滤器都有一个loginUrl属性，authc过滤器会跳转到登录页面 shiro.loginUrl = /login.jsp # 用户 [users] admin = admin guest = guest # 过滤请求，路径相对于应用程序路径[HttpServletRequest.getContextPath()] [urls] # 匹配到请求/login.jsp，开启authc过滤器，跳转到loginUrl页面 /login.jsp = authc # 匹配到请求/logout，开启logout过滤器，跳转到首页 /logout = logout # 匹配到请求/admin/**，开启authc过滤器，跳转到loginUrl页面 /admin/** = authc 登录页面Shiro会默认读取username、password、rememberMe &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Apache Shiro Tutorial Webapp : Login&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- Add some nice styling and functionality. We&apos;ll just use Twitter Bootstrap --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap-theme.min.css&quot;&gt; &lt;style&gt; body{padding-top:20px;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;Please sign in&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form name=&quot;loginform&quot; action=&quot;&quot; method=&quot;POST&quot; accept-charset=&quot;UTF-8&quot; role=&quot;form&quot;&gt; &lt;fieldset&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;Username or Email&quot; name=&quot;username&quot; type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;Password&quot; name=&quot;password&quot; type=&quot;password&quot; value=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input name=&quot;rememberMe&quot; type=&quot;checkbox&quot; value=&quot;true&quot;&gt; Remember Me &lt;/label&gt; &lt;/div&gt; &lt;input class=&quot;btn btn-lg btn-success btn-block&quot; type=&quot;submit&quot; value=&quot;Login&quot;&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/body&gt; &lt;/html&gt; 登录验证页面如果用户/密码正确，跳转到主页面，否则继续跳转到登录页 public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); try{ subject.login(token); }catch (Exception e){ request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response); return; } request.getRequestDispatcher(&quot;/WEB-INF/main.jsp&quot;).forward(request,response); } } 基于角色的权限控制★★★★★[main] # 认证页面 shiro.loginUrl = /login.jsp # 用户没有权限时跳转页面 perms.unauthorizedUrl = /unauthorizedUrl.jsp roles.unauthorizedUrl = /unauthorizedUrl.jspgi [users] # admin的密码是admin，拥有admin角色，包含admin下的所有权限 admin = admin,admin # guest的密码是guest，拥有user角色，包含user下的所有权限 guest = guest,user # qm的密码是qm，不拥有任何角色，即没有任何权限 qm = qm [roles] # admin拥有的权限 admin = admin:*,user:* # user拥有的权限 user = user:* [urls] /login.jsp = annon /logout = logout # /admin/**路径只有拥有admin角色的用户才能访问 /admin/** = authc,roles[admin] # 访问/user/list.jsp必须拥有user:list权限，所以拥有admin或者user的角色都可以访问 /user/list.jsp = authc,perms[user:list] # 访问/user/** 只要认证用户都可以访问 /user/** = authc 当用户访问一个url时，Shiro从上到下扫描权限，如果有一个匹配则不继续往下进行扫描，所以优先级很重要。对于特殊的访问权限，放在上面 Shiro细节认证认证身份流程 流程如下：1、首先调用 Subject.login(token)进行登录，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils. setSecurityManager()设置；2、SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证；3、 Authenticator 才是真正的身份验证者， Shiro API 中核心的身份认证入口点， 此处可以自定义插入自己的实现；4、Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证；5、Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。 自定义realm登录操作 public class realm_test { public static void main(String[] args){ // 设置SecurityManager SecurityManager securityManager = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;).getInstance(); SecurityUtils.setSecurityManager(securityManager); //获取主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;admin&quot;,&quot;admin&quot;); try{ //登录操作，登录不成功会抛出异常 subject.login(token); //输出认证的用户名 System.out.println(subject.getPrincipal()); }catch (UnknownAccountException e){ System.out.println(&quot;用户名不存在&quot;); }catch (IncorrectCredentialsException e){ System.out.println(&quot;用户名密码错误&quot;); } } } 自定义realm public class MyRealm implements Realm{ //模拟数据库，放入一些用户名和密码 private static Map&lt;String,String&gt; DB = new HashMap&lt;String,String&gt;(); static { DB.put(&quot;admin&quot;,&quot;admin&quot;); DB.put(&quot;qm&quot;,&quot;qm&quot;); } @Override //Realm的名称 public String getName() { return &quot;MyRealm&quot;; } @Override //该realm支持哪些token public boolean supports(AuthenticationToken authenticationToken) { return authenticationToken instanceof UsernamePasswordToken; } @Override //执行subject.login操作调用的方法 public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { //获取token中的用户和密码 String username = authenticationToken.getPrincipal().toString(); String password = new String((char[])authenticationToken.getCredentials()); //验证失败 if(!DB.containsKey(username)) throw new UnknownAccountException(&quot;用户名不存在&quot;); if(!password.equals(DB.get(username))) throw new IncorrectCredentialsException(&quot;用户名密码错误&quot;); //System.out.println(username + &quot; &quot; + password); //验证成功返回一个AuthenticationInfo return new SimpleAuthenticationInfo(username, password,getName()); } } 配置使用自定义realm [main] #创建一个MyRealm实例，这句话等同于&lt;bean id = &quot;myRealm&quot; class = &quot;MyRealm&quot;/&gt; myRealm = MyRealm #依赖注入，在securityManager中传入自定义realm的实例 securityManager.realms = $myRealm 多 Realm 配置#声明一个 realm myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1 myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2 #指定 securityManager 的 realms 实现 securityManager.realms=$myRealm1,$myRealm2 securityManager 会按照 realms 指定的顺序进行身份认证。此处我们使用 显示指定顺序的方式 指定了 Realm 的顺序，如果删除”securityManager.realms=$myRealm1,$myRealm2”，那么 securityManager 会按照 realm 声明的顺序进行使用（即无需设置 realms 属性，其会自动发 现），当我们显示指定 realm 后 ， 他没有指定 realm 将被忽 略， 如”securityManager.realms=$myRealm1”，那么 myRealm2 不会被自动设置进去。 Shiro 默认提供的 Realm及开发建议★★★★★ 以后一般继承 AuthorizingRealm （授权）即可； 其继承了 AuthenticatingRealm （即身份验证） ，而且也间接继承了 CachingRealm（带有缓存实现）。其中主要默认实现如下： org.apache.shiro.realm.text.IniRealm： [users]部分指定用户名/密码及其角色； [roles]部分指定角色即权限信息； org.apache.shiro.realm.text.PropertiesRealm：user.username=password,role1,role2 指定用户名/密码及其角色；role.role1=permission1,permission2 指定角色及权限信息； org.apache.shiro.realm.jdbc.JdbcRealm：通过 sql 查询相应的信息，如 “select password from users where username =?”获取用户密码，”select password, password_salt from users where username =?”获取用户密码及盐；”select role_name from user_roles where username =?”获取用户角色；”selectpermission from roles_permissions where role_name =?”获取角色对应的权限信息；也可以调用相应的 api 进行自定义 sql； jdbcRealm使用 1、依赖 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.2.23&lt;/version&gt; &lt;/dependency&gt; 2、配置数据库 查看jdbcReaml源代码，发现其中固定了一个sql语句，要求数据库中有一个users表，并且有username、password两个字段 3、配置 [main] # 数据源 dataSource = com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName = com.mysql.jdbc.Driver dataSource.url = jdbc:mysql://localhost:3306/jdbcRealm dataSource.username = root dataSource.password = root #创建一个jdbcRealm实例，并且注入数据源 jdbcRealm = org.apache.shiro.realm.jdbc.JdbcRealm jdbcRealm.dataSource = $dataSource securityManager.realms = $jdbcRealm 4、验证 public class realm_test { public static void main(String[] args){ // 设置SecurityManager SecurityManager securityManager = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;).getInstance(); SecurityUtils.setSecurityManager(securityManager); //获取主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;admin&quot;,&quot;admin&quot;); try{ //登录操作，登录不成功会抛出异常 subject.login(token); //输出认证的用户名 System.out.println(subject.getPrincipal()); }catch (UnknownAccountException e){ System.out.println(&quot;用户名不存在&quot;); }catch (IncorrectCredentialsException e){ System.out.println(&quot;用户名密码错误&quot;); } } } Authenticator接口及其子类源码分析★★★★★★1、定义接口Authenticator，定义了一个authenticate认证方法 public interface Authenticator { public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; } 2、抽象类AbstractAuthenticator实现Authenticator接口，类的作用是通过doAuthenticate方法来获取AuthenticationInfo并返回；doAuthenticate方法为抽象方法，由子类重写 public abstract class AbstractAuthenticator implements Authenticator, LogoutAware { public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException { AuthenticationInfo info; info = doAuthenticate(token); } protected abstract AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException; } } 3、ModularRealmAuthenticator继承了AbstractAuthenticator，通过调用realm的getAuthenticationInfo方法获得AuthenticationInfo public class ModularRealmAuthenticator extends AbstractAuthenticator { //保存realm的实例 private Collection&lt;Realm> realms; private AuthenticationStrategy authenticationStrategy; protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException { assertRealmsConfigured(); Collection realms = getRealms(); if (realms.size() == 1) { return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken); } else { return doMultiRealmAuthentication(realms, authenticationToken); } } protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) { AuthenticationInfo info = realm.getAuthenticationInfo(token); return info; } protected AuthenticationInfo doMultiRealmAuthentication(Collection realms, AuthenticationToken token) { //若有多个realm，遍历所有realm，根据AuthenticationStrategy 接口指定的策略，返回AuthenticationInfo；默认使用AtLeastOneSuccessfulStrategy策略 AuthenticationStrategy strategy = getAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); for (Realm realm : realms) { aggregate = strategy.beforeAttempt(realm, token, aggregate); AuthenticationInfo info = null; info = realm.getAuthenticationInfo(token); aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; } } 授权角色角色代表了权限的集合，赋予用户角色，这样用户就可以拥有一组权限，赋予权限比较方便 隐式角色：通过 判断用户是否有某个角色 来判断用户有没有操作权限，颗粒度是以角色为单位进行访问控制的，颗粒度较粗，如果应用中允许CTO、技术总监、开发工程师使用打印机，假设某天不允许开发工程师使用打印机了，就需要在相关代码的判断逻辑中移除技术总监角色，造成多处代码的修改 显示角色：程序中 通过权限 控制谁能访问某个资源。假设哪个角色不能访问某个资源，只需要从角色的权限集合中移除即可，颗粒度是以资源/实例为单位的，颗粒度较细 基于角色的访问控制（隐式角色）判断用户是否有某个角色来进行权限控制，颗粒度较大，很多地方对角色进行判断，如果有一天不需要了就要修改代码，在判断这个角色的地方把它删除 ini配置文件： [users] admin = admin,r1,r2 Shiro 提供了 hasRole/hasRole 用于判断用户是否拥有某个角色/某些权限 //判断是否拥有角色 r1 System.out.println(subject.hasRole(&quot;r1&quot;)); //必须同时拥有r1和r2才会true，否则返回false System.out.println(subject.hasAllRoles(Arrays.asList(&quot;r1&quot;,&quot;r2&quot;))); //返回boolean[]数组，相当于判断是否拥有每个角色 System.out.println(Arrays.toString(subject.hasRoles(Arrays.asList(&quot;r1&quot;,&quot;r3&quot;)))); Shiro 提供的 checkRole/checkRoles 和 hasRole/hasAllRoles 不同的地方是它在判断为假的情况下会抛出 UnauthorizedException 异常 subject().checkRole(&quot;role1&quot;); 基于资源的访问控制（显示角色）ini配置文件 [users] admin = admin,r1 [roles] r1=user:create,user:update r2:user:create,user:delete 测试 System.out.println(subject.isPermitted(&quot;user:create&quot;)); System.out.println(subject.isPermittedAll(&quot;user:create&quot;,&quot;user:update&quot;)); checkPermission/checkPermissions会在失败的情况下抛出 UnauthorizedException 异常 规则 基于资源的访问控制（显示角色），也可以叫基于权限的访问控制，这种方式的一般规则是”资源标识符：操作”，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护”用户——角色，角色——权限（资源：操作）”之间的关系 权限规则：”资源标识符：操作：对象实例ID”，即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，”:”表示资源/操作/实例的分割；”,”表示操作的分割；”*”表示任意资源/操作/实例。 1、单个资源单个权限 #ini文件 role1 = system:user:update #测试 subject().checkPermissions(&quot;system:user:update&quot;); 2、单个资源多个权限 #ini文件 role41=system:user:update,system:user:delete #测试 subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;); 3、单个资源全部权限 #ini文件 role52=system:user:* 4、所有资源全部权限 #ini文件 role61=*:view #测试 subject().checkPermissions(&quot;user:view&quot;); 5、实例级别的权限 《跟我我学Shiro》26页 授权流程 流程如下：1、首先调用 Subject.isPermitted/hasRole接口，其会委托给 SecurityManager，而SecurityManager 接着会委托给 Authorizer；2、Authorizer 是真正的授权者，如果我们调用如 isPermitted(“user:view”)，其首先会通过PermissionResolver 把字符串转换成相应的 Permission 实例；3、在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限；4、Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted/hasRole会返回 true，否则返回 false 表示授权失败。 授权源码分析★★★★★1、定义接口Authorizer接口，包括一些isPermitted、checkPermission、hasRole、checkRole一些方法 public interface Authorizer { boolean isPermitted(PrincipalCollection principals, String permission); boolean isPermitted(PrincipalCollection subjectPrincipal, Permission permission); boolean[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions); boolean[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions); boolean isPermittedAll(PrincipalCollection subjectPrincipal, String... permissions); boolean isPermittedAll(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions); void checkPermission(PrincipalCollection subjectPrincipal, String permission) throws AuthorizationException; void checkPermission(PrincipalCollection subjectPrincipal, Permission permission) throws AuthorizationException; void checkPermissions(PrincipalCollection subjectPrincipal, String... permissions) throws AuthorizationException; void checkPermissions(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions) throws AuthorizationException; boolean hasRole(PrincipalCollection subjectPrincipal, String roleIdentifier); boolean[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers); boolean hasAllRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers); void checkRole(PrincipalCollection subjectPrincipal, String roleIdentifier) throws AuthorizationException; void checkRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException; void checkRoles(PrincipalCollection subjectPrincipal, String... roleIdentifiers) throws AuthorizationException; } 2、同样，和认证一样有一个ModularRealmAuthorizer实现，委托给realm的方法去实现 public class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware, RolePermissionResolverAware { &lt;font color=&apos;red&apos;&gt;//保存realm的实例&lt;/font&gt; protected Collection&lt;Realm&gt; realms; protected PermissionResolver permissionResolver; protected RolePermissionResolver rolePermissionResolver; public boolean hasRole(PrincipalCollection principals, String roleIdentifier) { assertRealmsConfigured(); for (Realm realm : getRealms()) { if (!(realm instanceof Authorizer)) continue; if (((Authorizer) realm).hasRole(principals, roleIdentifier)) { return true; } } return false; } } Realm及相关对象★★★★★用户、角色、权限的关系 用户——角色之间是多对多关系，角色——权限之间是多对多关系，用户和权限之间通过角色建立关系 在系统中验证时通过权限验证，角色只是权限集合，即显示角色 realm接口及其子类源码分析1、定义Realm接口，吃、从数据源中获得安全数据（如用户，角色，权限），判断用户身份是否合法，判断用户是否有权限 public interface Realm { //realm的名称 String getName(); //判断此 Realm 是否支持此 Token boolean supports(AuthenticationToken token); //传入用户凭证（用户名、密码），返回AuthenticationInfo AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; } 2、CachingRealm，增加缓存的功能：维护一个CacheManager的成员变量；增加一个name成员变量，实现getName()方法 public abstract class CachingRealm implements Realm, Nameable, CacheManagerAware, LogoutAware { private CacheManager cacheManager; } 3、抽象类AuthenticatingRealm继承CachingRealm，主要功能是：1、从数据源中获取用户信息 2、利用CredentialsMatcher类，将用户传入的密码与数据库返回的密码进行比较（一般我们会自己创建service方法，判断用户名是否存在、密码是否正确，如果出现错误则抛出异常，验证通过返回AuthenticationInfo，此时Shiro会在帮你验证一次，其实没有必要，但框架这么写着你必须使用正确的CredentialsMatcher，使验证通过）；抽象方法doGetAuthenticationInfo需要由子类重写 public abstract class AuthenticatingRealm extends CachingRealm implements Initializable { //CredentialsMatcher用于密码校验 private CredentialsMatcher credentialsMatcher; public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { AuthenticationInfo info = getCachedAuthenticationInfo(token); if (info == null) { //otherwise not cached, perform the lookup: //从数据源获得用户信息 info = doGetAuthenticationInfo(token); log.debug("Looked up AuthenticationInfo [{}] from doGetAuthenticationInfo", info); if (token != null && info != null) { cacheAuthenticationInfoIfPossible(token, info); } } else { log.debug("Using cached authentication info [{}] to perform credentials matching.", info); } if (info != null) { //在Shiro中验证密码 assertCredentialsMatch(token, info); } else { log.debug("No AuthenticationInfo found for submitted AuthenticationToken [{}]. Returning null.", token); } return info; } //从数据源获得用户信息由子类改写 protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //利用CredentialsMatcher验证密码是否正确，默认是SimpleCredentialsMatcher，调用其doCredentialsMatch方法，根据字节来判断密码是否一样 protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException { CredentialsMatcher cm = getCredentialsMatcher(); if (cm != null) { if (!cm.doCredentialsMatch(token, info)) { //not successful - throw an exception to indicate this: String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials."; throw new IncorrectCredentialsException(msg); } } else { throw new AuthenticationException("A CredentialsMatcher must be configured in order to verify " + "credentials during authentication. If you do not wish for credentials to be examined, you " + "can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance."); } } } 4、抽象类AuthorizingRealm，继承AuthenticatingRealm，主要功能是完成Authorizer委托的任务，完成isPermitted、hasRole等方法，所以实现了Authorizer接口；doGetAuthorizationInfo方法需要由子类改写 注意：成员变量PermissionResolver、RolePermissionResolver，由Authorizer传入 public abstract class AuthorizingRealm extends AuthenticatingRealm implements Authorizer, Initializable, PermissionResolverAware, RolePermissionResolverAware { //成员变量PermissionResolver、RolePermissionResolver，由Authorizer传入 private PermissionResolver permissionResolver; private RolePermissionResolver permissionRoleResolver; /* * 1、调用getAuthorizationInfo方法从数据库获得权限信息 * 2、查看用户是否有该操作的权限 */ public boolean hasRole(PrincipalCollection principal, String roleIdentifier) { AuthorizationInfo info = getAuthorizationInfo(principal); return hasRole(roleIdentifier, info); } protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) { return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier); } protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals); //权限：1、调用PermissionResolver，先把权限字符串转换为Permission public boolean isPermitted(PrincipalCollection principals, String permission) { Permission p = getPermissionResolver().resolvePermission(permission); return isPermitted(principals, p); } //2、判断权限 public boolean isPermitted(PrincipalCollection principals, Permission permission) { AuthorizationInfo info = getAuthorizationInfo(principals); return isPermitted(permission, info); } //3、调用Permission的implies方法，将数据库的权限与用户传入的进行对比 protected boolean isPermitted(Permission permission, AuthorizationInfo info) { Collection perms = getPermissions(info); if (perms != null && !perms.isEmpty()) { for (Permission perm : perms) { if (perm.implies(permission)) { return true; } } } return false; } } realm相关对象实际开发过程中，自定义的realm继承AuthorizingRealm，改写doGetAuthenticationInfo和doGetAuthorizationInfo方法 doGetAuthenticationInfo 获取身份验证相关信息：1、调用Subject.login(token)触发方法，根据token获得User信息，没找到用户、密码不正确时抛出异常 2、生成AuthenticationInfo信息并返回 3、父类AuthenticatingRealm 使用 CredentialsMatcher 进行判断密码是否匹配， 如果不匹配将抛出密码错误异常，如果密码重试重试次数太多将抛出重试次数异常 doGetAuthorizationInfo 获取授权信息：根据用户名获得角色及权限信息，并组装成AuthorizationInfo返回 AuthenticationToken AuthenticationToken 用于收集用户提交的身份（如用户名）及凭据（如密码） Shiro 提供了一个直接拿来用的 UsernamePasswordToken，用于实现用户名/密码 Token 组，另外其实现了 RememberMeAuthenticationToken 和 HostAuthenticationToken， 可以实现记住我及主机验证的支持。 AuthenticationInfo AuthenticationInfo 有两个作用：1、如果 Realm 是 AuthenticatingRealm 子类，则提供给 AuthenticatingRealm 内部使用的CredentialsMatcher 进行凭据验证； （如果没有继承它需要在自己的 Realm 中自己实现验证）；2、提供给 SecurityManager 来创建 Subject（提供身份信息）； AuthorizationInfo AuthorizationInfo 用于聚合授权信息的 当我们使用 AuthorizingRealm 时 ， 如果身份验证成功 ， 在进行授权时就通过doGetAuthorizationInfo 方法获取角色/权限信息用于授权验证 Subject Subject 是 Shiro 的核心对象，基本所有身份验证、授权都是通过 Subject 完成。 SecurityManager源码分析★★★★★1、定义SecurityManager接口，同时继承Authenticator、Authorizer、SessionManager，为什么？代理模式，SecurityManager代理Authenticator、Authorize和SessionManager的操作，需要实现三者的接口 public interface SecurityManager extends Authenticator, Authorizer, SessionManager { Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException; void logout(Subject subject); Subject createSubject(SubjectContext context); } 2、CachingSecurityManager维护一个CacheManager成员变量 public abstract class CachingSecurityManager implements SecurityManager, Destroyable, CacheManagerAware, EventBusAware { private CacheManager cacheManager; } 3、RealmSecurityManager，设置realm public abstract class RealmSecurityManager extends CachingSecurityManager { private Collection&lt;Realm&gt; realms; public void setRealm(Realm realm) { if (realm == null) { throw new IllegalArgumentException(&quot;Realm argument cannot be null&quot;); } Collection&lt;Realm&gt; realms = new ArrayList&lt;Realm&gt;(1); realms.add(realm); setRealms(realms); } } 4、AuthenticatingSecurityManager保存一个Authenticator，默认是ModularRealmAuthenticator，代理认证的功能 public abstract class AuthenticatingSecurityManager extends RealmSecurityManager { private Authenticator authenticator; public AuthenticatingSecurityManager() { super(); this.authenticator = new ModularRealmAuthenticator(); } } 5、AuthorizingSecurityManager保存一个Authorizer功能，默认是ModularRealmAuthorizer，代理授权功能 public abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager { private Authorizer authorizer; public AuthorizingSecurityManager() { super(); this.authorizer = new ModularRealmAuthorizer(); } } 6、SessionsSecurityManager保存一个SessionManager，默认是DefaultSessionManager，代理会话管理 public abstract class SessionsSecurityManager extends AuthorizingSecurityManager { private SessionManager sessionManager; public SessionsSecurityManager() { super(); this.sessionManager = new DefaultSessionManager(); applyCacheManagerToSessionManager(); } } 7、DefaultSecurityManager：利用SubjectDAO、SubjectFactory创建、存储Subject public class DefaultSecurityManager extends SessionsSecurityManager { protected RememberMeManager rememberMeManager; protected SubjectDAO subjectDAO; protected SubjectFactory subjectFactory; public DefaultSecurityManager() { super(); this.subjectFactory = new DefaultSubjectFactory(); this.subjectDAO = new DefaultSubjectDAO(); } protected SubjectContext createSubjectContext() { return new DefaultSubjectContext(); } public Subject createSubject(SubjectContext subjectContext) { SubjectContext context = copy(subjectContext); context = ensureSecurityManager(context); context = resolveSession(context); context = resolvePrincipals(context); Subject subject = doCreateSubject(context); save(subject); return subject; } } 8、DefaultWebSecurityManager：增加了一些Session的维护 加密AuthenticatingRealm中的成员变量CredentialsMatcher进行密码验证服务，Shiro 提供了 redentialsMatcher 的散列实现 HashedCredentialsMatcher，它用于密码验证，且可以提供自己的盐 realm认证 //判断认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { //返回AuthenticationInfo后在AuthenticatingRealm的assertCredentialsMatch方法中还需要进行验证 //数据库取出的用户名和密码 String username = &quot;admin&quot;; String password = &quot;b433ce675b32a824e24d762ca0fa1ba9&quot;;//数据库密码md5(&quot;admin&quot;,&quot;user&quot;) String salt = &quot;user&quot;; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, password, getName()); simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(salt)); return simpleAuthenticationInfo; } 设置密码匹配规则 staticRealm = StaticRealm hashedCredentialsMatcher = org.apache.shiro.authc.credential.HashedCredentialsMatcher hashedCredentialsMatcher.hashAlgorithmName = md5 staticRealm.credentialsMatcher = $hashedCredentialsMatcher securityManager.realms = $staticRealm Web集成ShiroFilter入口与 Spring 集成 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; DelegatingFilterProxy 作用是自动到 spring 容器查找名字为 shiroFilter（filter-name）的 bean，并把所有 Filter 的操作委托给它。然后将 ShiroFilter 配置到 spring 容器即可 &lt;bean id=&quot;shiroFilter&quot;class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;propertyname=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!—忽略其他，详见与 Spring 集成部分 --&gt; &lt;/bean&gt; 最后不要忘了使用 org.springframework.web.context.ContextLoaderListener 加载这个 spring配置文件即可 URL匹配[urls] /login=anon /unauthorized=anon /static/**=anon /authenticated=authc /role=authc,roles[admin] /permission=authc,perms[&quot;user:create&quot;] urls中配置格式是：url=拦截器[参数]，拦截器[参数]，即 如果当前请求的 url 匹配[urls]部分的某个 url 模式， 将会执行其配置的拦截器 anon 拦截器表示匿名访问（即不需要登录即可访问） authc 拦截器表示需要身份认证通过后才能访问 roles[admin] 拦截器表示需要有 admin 角色授权才能访问 perms[“user:create”] 拦截器表示需要有“user:create”权限才能访问 url 模式使用 Ant 风格模式，Ant 路径通配符支持 ? 、* 、**，注意通配符匹配不包括目录分隔符”/“： ?：匹配一个字符，如”/admin?”将匹配/admin1，但不匹配/admin 或/admin2； *：匹配零个或多个字符串，如/admin*将匹配/admin、/admin123，但不匹配/admin/1； **：匹配路径中的零个或多个路径，如/admin/**将匹配/admin/a 或/admin/a/b。 url 模式匹配顺序 url 模式匹配顺序是按照在配置中的声明顺序匹配，即从头开始使用第一个匹配的 url 模式对应的拦截器链 拦截器机制Shiro拦截器源码分析Shiro拦截器的基础类图 AbstractFilter：实现Filter接口，类的主要功能是实现Filter接口init方法，保存FilterConfig作为成员变量，在init方法中调用无参的setFilterConfig，子类的初始化方法通过改写onFilterConfigSet方法 NameableFilter：给Filter起个名字。在类中增加一个name成员变量，set/get方法 OncePerRequestFilter：一次请求中，保证过滤链中同一个过滤器只被执行一次，如内部的 forward 不会再多执行一次 doFilterInternal。重写Filter接口的doFilter方法，同时设置了enabled属性，表示是否开启该拦截器，子类需要重写doFilterInternal方法，加上具体的过滤操作 public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException { String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName(); if (request.getAttribute(alreadyFilteredAttributeName) != null || shouldNotFilter(request)) { log.trace("Filter '{}' already executed. Proceeding without invoking this filter.", getName()); // Proceed without invoking this filter... filterChain.doFilter(request, response); } else { // Do invoke this filter... log.trace("Filter '{}' not yet executed. Executing now.", getName()); request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try { //抽象方法，由子类实现 doFilterInternal(request, response, filterChain); } finally { // Once the request has finished, we're done and we don't // need to mark as 'already filtered' any more. request.removeAttribute(alreadyFilteredAttributeName); } } } AbstractShiroFilter：Shiro过滤器前最后一个抽象类，有两个成员变量：WebSecurityManager（存储SecurityManager的引用，以便过滤器使用）、FilterChainResolver（首先拦截所有的url，再根据实际情况判断url是否需要拦截）；重写onFilterConfigSet方法，子类的初始化方法通过重写init方法完成初始化工作;重写doFilterInternal方法，为subject的入口，重点★★★★★ //重写onFilterConfigSet方法，子类重写init方法增加自定义初始化工作 protected final void onFilterConfigSet() throws Exception { //added in 1.2 for SHIRO-287: applyStaticSecurityManagerEnabledConfig(); init(); ensureSecurityManager(); //added in 1.2 for SHIRO-287: if (isStaticSecurityManagerEnabled()) { SecurityUtils.setSecurityManager(getSecurityManager()); } } ShiroFilter、SpringShiroFilter、SpringShiroFilter 实现 AbstractShiroFilter，主要功能是创建过滤器对象，并将SecurityManager和FilterChainResolver属性的注入 另一条过滤器主线：与SpringMVC中的拦截器类似进行设计 AdviceFilter AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor： 1、preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）2、postHandle： 类似于 AOP 中的后置返回增强； 在拦截器链执行完成后执行； 进行后处理 （如记录执行时间之类的）；3、afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触 Subject 与线程的绑定之类的）； //重写doFilterInternal方法 public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { Exception exception = null; try { //前置方法，如果前置返回false，则不执行下一个过滤器 boolean continueChain = preHandle(request, response); if (log.isTraceEnabled()) { log.trace("Invoked preHandle method. Continuing chain?: [" + continueChain + "]"); } if (continueChain) { executeChain(request, response, chain); } //后置方法，访问Servlet后执行 postHandle(request, response); if (log.isTraceEnabled()) { log.trace("Successfully invoked postHandle method"); } } catch (Exception e) { exception = e; } finally { //afterCompletion，不管有没有异常都会执行，可以进行清理资源 cleanup(request, response, exception); } } PathMatchingFilter：提供了基于 Ant 风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”自动根据”，”分割解析到一个路径参数配置并绑定到相应的路径 1、pathsMatch该方法用于 path 与请求路径进行匹配的方法；如果匹配返回 true；2、onPreHandle：在 preHandle 中，当 pathsMatch 匹配一个路径后，会调用 opPreHandler 方法并将路径绑定参数配置传给 mappedValue；然后可以在这个方法中进行一些验证（如角色授权），如果验证失败可以返回 false 中断流程；默认返回 true；也就是说子类可以只实现onPreHandle 即可， 无须实现 preHandle。 如果没有 path 与请求路径匹配， 默认是通过的 （即preHandle 返回 true）。 protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception { if (this.appliedPaths == null || this.appliedPaths.isEmpty()) { if (log.isTraceEnabled()) { log.trace("appliedPaths property is null or empty. This Filter will passthrough immediately."); } return true; } for (String path : this.appliedPaths.keySet()) { // If the path does match, then pass on to the subclass implementation for specific checks //(first match 'wins'): if (pathsMatch(path, request)) { log.trace("Current requestURI matches pattern '{}'. Determining filter chain execution...", path); Object config = this.appliedPaths.get(path); return isFilterChainContinued(request, response, path, config); } } //no path matched, allow the request to go through: return true; } private boolean isFilterChainContinued(ServletRequest request, ServletResponse response, String path, Object pathConfig) throws Exception { if (isEnabled(request, response, path, pathConfig)) { //isEnabled check added in 1.2 if (log.isTraceEnabled()) { log.trace("Filter '{}' is enabled for the current request under path '{}' with config [{}]. " + "Delegating to subclass implementation for 'onPreHandle' check.", new Object[]{getName(), path, pathConfig}); } //The filter is enabled for this specific request, so delegate to subclass implementations //so they can decide if the request should continue through the chain or not: return onPreHandle(request, response, pathConfig); } if (log.isTraceEnabled()) { log.trace("Filter '{}' is disabled for the current request under path '{}' with config [{}]. " + "The next element in the FilterChain will be called immediately.", new Object[]{getName(), path, pathConfig}); } //This filter is disabled for this specific request, //return 'true' immediately to indicate that the filter will not process the request //and let the request/response to continue through the filter chain: return true; } AnonymousFilter：继承PathMatchingFilter，重写preHandle方法，总是返回true，则允许所有请求通过 AccessControlFilter：继承PathMatchingFilter，重写onPreHandle方法 public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue); } 1、isAccessAllowed：表示是否允许访问；mappedValue 就是[urls]配置中拦截器参数部分，如果允许访问返回 true，否则 false；2、onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可 总结： 1、如果用户有访问资源的权限，则isAccessAllowed返回true，onAccessDenied方法不会执行；2、如果没有访问权限，则isAccessAllowed返回false，而且会执行onAccessDenied方法，方法中可以进行页面跳转等操作，方法体一般返回false，表示不需要执行后面的过滤器了 两个方法为抽象方法，都需要都子类重写 另外 AccessControlFilter 还提供了如下方法用于处理如登录成功后/重定向到上一个请求： void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp String getLoginUrl() Subject getSubject(ServletRequest request, ServletResponse response) //获取 Subject 实例 boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求 void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException //将当前请求保存起来并重定向到登录页面 void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请 求 void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 AuthenticationFilter继承AccessControlFilter，并重写isAccessAllowed方法，判断用户是否登录 protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { Subject subject = getSubject(request, response); return subject.isAuthenticated(); } Shiro拦截器源码分析总结1、过滤器设计，顶层是接口，然后一个抽象类实现接口，每个抽象类中值承担一个职责！ AbstractFilter保存filterConfig，并提供一个无参的onFilterConfigSet初始化方法 NameableFilter为过滤器取一个名字 OncePerRequestFilter重写doFilter方法，保证一个过滤器在一次请求中只执行一次，过滤器中个操作转移到doFilterInternal中。 之后过滤器子类分为两个分支，一个是Shiro的主过滤器，配置在web.xml中，为Shiro的入口；另一个是AOP风格的过滤器形式，类时Spring MVC中的拦截器，进入ShiroFilter中先执行完Shiro的一些过滤器，在执行Tomcat中的其他过滤器 ★★★★★AdviceFilter重写doFilterInternal方法，将过滤操作分为preHandle、postHandle、afterCompletion操作。如果preHandle返回true，执行下一个过滤器，否则访问终止 PathMatchingFilter重写preHandle方法，进行路径匹配，路径匹配后是否执行Tomcat其他过滤器由onPreHandle的返回结果决定，供子类改写 AccessControlFilter重写onPreHandle方法，可以重写isAccessAllowed、onAccessDenied来实现访问控制 开发建议：如果我们想进行访问访问的控制就可以继承AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承 PathMatchingFilter 拦截器链Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理；即先走Shiro 自己的 Filter 体系，然后才会委托给 Servlet 容器的 FilterChain 进行 Servlet 容器级别的 Filter 链执行； Shiro 的 ProxiedFilterChain 执行流程：1、 执行 Shiro 自己的 Filter 链； 2、再执行 Servlet 容器的 Filter 链（即原始的 Filter） ★★★★★如何实现先执行Shiro自己的Filter链，然后执行Servlet容器的Filter链？ 1、调用Shiro的主过滤器后，执行AbstractShiroFilter类的doFilterInternal方法 protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain) throws ServletException, IOException { ... subject.execute(new Callable() { public Object call() throws Exception { updateSessionLastAccessTime(request, response); executeChain(request, response, chain); return null; } }); ... } 2、AbstractShiroFilter类的executeChain方法，会返回一个Servlet过滤链的代理类ProxiedFilterChain，当执行doFilter方法时，如果Shiro内部的过滤器没有执行完，先执行内部过滤器，等全部执行完成后，在执行Servlet的下一个过滤器。代理Chain对Servlet是透明的 protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain) throws IOException, ServletException { FilterChain chain = getExecutionChain(request, response, origChain); chain.doFilter(request, response); } 代理过滤器链ProxiedFilterChain的代码如下，包含原来的过滤链和所需要执行的Shiro过滤器；如果Shiro过滤器没有执行完，则首先执行Shiro过滤器，之后再执行 Servlet 过滤器 public class ProxiedFilterChain implements FilterChain { //TODO - complete JavaDoc private static final Logger log = LoggerFactory.getLogger(ProxiedFilterChain.class); //原来的过滤链对象 private FilterChain orig; private List filters; private int index = 0; public ProxiedFilterChain(FilterChain orig, List filters) { if (orig == null) { throw new NullPointerException("original FilterChain cannot be null."); } this.orig = orig; this.filters = filters; this.index = 0; } public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { //如果执行完Shiro的权限过滤器，则继续执行Servlet中的过滤器 if (this.filters == null || this.filters.size() == this.index) { //we've reached the end of the wrapped chain, so invoke the original one: if (log.isTraceEnabled()) { log.trace("Invoking original filter chain."); } this.orig.doFilter(request, response); } else { if (log.isTraceEnabled()) { log.trace("Invoking wrapped filter at index [" + this.index + "]"); } this.filters.get(this.index++).doFilter(request, response, this); } } } 代理过滤链的产生流程 1、AbstractShiroFilter中的getExecutionChain方法，通过FilterChainResolver的getChain方法，获得过滤链 protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) { FilterChain chain = origChain; FilterChainResolver resolver = getFilterChainResolver(); if (resolver == null) { log.debug("No FilterChainResolver configured. Returning original FilterChain."); return origChain; } FilterChain resolved = resolver.getChain(request, response, origChain); if (resolved != null) { log.trace("Resolved a configured FilterChain for the current request."); chain = resolved; } else { log.trace("No FilterChain configured for the current request. Using the default."); } return chain; } 2、FilterChainResolver接口的默认实现是PathMatchingFilterChainResolver，必须实现getChain方法。DefaultFilterChainManager 实现 FilterChainManager 接口，维护着 url 模式与拦截器链的关系，遍历url模式，如果与访问的url匹配，则根据匹配的 url 模式找到相应的过滤器，用来生成过滤器链； public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) { FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) { return null; } String requestURI = getPathWithinApplication(request); for (String pathPattern : filterChainManager.getChainNames()) { if (pathMatches(pathPattern, requestURI)) { if (log.isTraceEnabled()) { log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "]. " + "Utilizing corresponding filter chain..."); } return filterChainManager.proxy(originalChain, pathPattern); } } return null; } PathMatchingFilterChainResolver维护着FilterChainManager和PatternMatcher两个成员变量，FilterChainManager维护着url 模式与拦截器链的关系，默认是DefaultFilterChainManager；PatternMatcher为请求url与url 模式的匹配方式，默认是AntPathMatcher（PathMatchingFilterChainResolver中构造器时赋值） Shiro Filter初始化时，ShiroFilterFactoryBean调用getObject时，createInstance中创建了一些重要的组件，包括SecurityManager、FilterChainResolver（FilterChainManager为其成员变量）。 protected AbstractShiroFilter createInstance() throws Exception { log.debug("Creating Shiro Filter instance."); SecurityManager securityManager = getSecurityManager(); if (securityManager == null) { String msg = "SecurityManager property must be set."; throw new BeanInitializationException(msg); } if (!(securityManager instanceof WebSecurityManager)) { String msg = "The security manager does not implement the WebSecurityManager interface."; throw new BeanInitializationException(msg); } //创建DefaultFilterChainManager FilterChainManager manager = createFilterChainManager(); //Expose the constructed FilterChainManager by first wrapping it in a // FilterChainResolver implementation. The AbstractShiroFilter implementations // do not know about FilterChainManagers - only resolvers: PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver(); chainResolver.setFilterChainManager(manager); //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built //FilterChainResolver. It doesn't matter that the instance is an anonymous inner class //here - we're just using it because it is a concrete AbstractShiroFilter instance that accepts //injection of the SecurityManager and FilterChainResolver: return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver); } 拦截器链总结1、当用户发送请求时，被Shiro Filter拦截，利用FilterChainResolver的getChain方法，获得代理的过滤链，这样可以先执行Shiro 中的一些过滤器，再执行Servlet的其他过滤器2、获得过滤链代理的主要流程是：FilterChainResolver的实现类PathMatchingFilterChainResolver维护着FilterChainManager和PatternMatcher两个成员变量，FilterChainManager维护着url 模式与拦截器链的关系，PatternMatcher为请求url与url 模式的匹配方式，遍历url模式并与请求url进行匹配，获取配置的过滤器，组成代理的过滤器链，并返回 默认拦截器public enum DefaultFilter { anon(AnonymousFilter.class), authc(FormAuthenticationFilter.class), authcBasic(BasicHttpAuthenticationFilter.class), logout(LogoutFilter.class), noSessionCreation(NoSessionCreationFilter.class), perms(PermissionsAuthorizationFilter.class), port(PortFilter.class), rest(HttpMethodPermissionFilter.class), roles(RolesAuthorizationFilter.class), ssl(SslFilter.class), user(UserFilter.class); ... } 自己提出的问题★★★★★1、Shiro Filter中SecurityManager是否需要绑定到内存的问题 详见AbstractShiroFilter.java 如果在Shiro过滤器初始化参数中设置了staticSecurityManagerEnabled的值为true，则SecurityManager与线程绑定 默认是false，即SecurityManager不与线程绑定，设置在WebEnvironment中 2、Shiro Filter中SecurityManager变量依赖注入的方式 Shiro Filter中成员变量SecurityManager实例化的方式有两种： 第一种方式是 SecurityManager 在 Spring 中创建，可以自定义设置SecurityManager的属性，然后依赖注入到Shiro Filter中（单例） 如果没有通过依赖注入的方式得到SecurityManager的实例，Shiro将自动创建默认的SecurityManager（每次调用过滤器都会创建一个默认SecurityManager，不推荐） 详见AbstractShiroFilter.java 3、★★★★在Web.xml中配置 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!--使用[/*]匹配所有请求,保证所有的可控请求都经过Shiro的过滤--&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 在applicationContext-shiro.xml中配置 &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; ... &lt;/bean&gt; 则DelegatingFilterProxy类与ShiroFilterFactoryBean的关系是什么？ 答：DelegatingFilterProxy是一个代理类，具体的操作交给内部的Filter对象delegate去处理，这个delegate通过Spring容器的中的ShiroFilterFactoryBean的工厂方法getBean获取，返回对象类型是SpringShiroFilter，即代理的Filter对象为SpringShiroFilter 处理流程：1、Tomcat扫描web.xml文件，到过滤器节点，遇到DelegatingFilterProxy的配置，生成一个DelegatingFilterProxy的实例，并调用其init方法 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 2、init方法在其父类GenericFilterBean中实现，init方法中调用initFilterBean方法，其在子类DelegatingFilterProxy中改写，代理对象通过语句 this.delegate = initDelegate(wac) 获得3、查看initDelegate方法，有如下语句：Filter delegate = wac.getBean(getTargetBeanName(), Filter.class)，代理对象是从Spring容器中根据id获得，id即为过滤器的名称shiroFilter，你就知道为什么web.xml中过滤器的名称和application-shiro.xml中的bean id要一致了 &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; ... &lt;/bean&gt; 4、在Spring容器中查找id为shiroFilter，类型为Filter的对象，即为ShiroFilterFactoryBean。但ShiroFilterFactoryBean实现了工厂类，上面的delegate真正的对象是通过它的getObject()获取的 public Object getObject() throws Exception { if (instance == null) { instance = createInstance(); } return instance; } 5、真正创建对象的方法在createInstance中，可见代理的过滤器是SpringShiroFilter protected AbstractShiroFilter createInstance() throws Exception { ... return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver); } 6、SpringShiroFilter: ShiroFilterFactoryBean的内部类，继承AbstractShiroFilter private static final class SpringShiroFilter extends AbstractShiroFilter { protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) { super(); if (webSecurityManager == null) { throw new IllegalArgumentException(&quot;WebSecurityManager property cannot be null.&quot;); } setSecurityManager(webSecurityManager); if (resolver != null) { setFilterChainResolver(resolver); } } } 7、每次URL请求，经过代理过滤器DelegatingFilterProxy时，调用SpringShiroFilter实例的doFilter方法 DelegatingFilterProxy.java public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException { // Lazily initialize the delegate if necessary. Filter delegateToUse = this.delegate; if (delegateToUse == null) { synchronized (this.delegateMonitor) { if (this.delegate == null) { WebApplicationContext wac = findWebApplicationContext(); if (wac == null) { throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener registered?"); } this.delegate = initDelegate(wac); } delegateToUse = this.delegate; } } // Let the delegate perform the actual doFilter operation. invokeDelegate(delegateToUse, request, response, filterChain); } 总结： 1、Tomcat创建代理对象，初始化代理对象的时候，代理对象通过bean工厂获得被代理对象，并做成其成员对象；每当来一个客户端请求，代理对象的doFilter方法，代理对象调用被代理对象的doFilter方法 2、DelegatingFilterProxy的主要作用就是一个代理模式的应用,可以把 servlet 容器中的filter同spring容器中的bean关联起来[既可以代理Spring Security的过滤器，也可以代理Shiro中的过滤器] 4、 路径匹配规则 1、路径为空，不进行匹配默认全部通过2、请求url与资源权限路径列表从上到下进行匹配，如果某一个路径匹配，进行权限验证，根据返回结果通过还是拒绝 会话管理会话所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。 public interface Session { /** * 获取当前会话的唯一标识。 */ Serializable getId(); /* 获得属性 */ Object getAttribute(Object key) throws InvalidSessionException; /* 设置属性 */ void setAttribute(Object key, Object value) throws InvalidSessionException; /* 删除属性 */ Object removeAttribute(Object key) throws InvalidSessionException; ... } 会话存储/持久化★★★★★Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现： //如 DefaultSessionManager 在创建完 session 后会调用该方法；如保存到关系数据库/文件 系统/NoSQL 数据库；即可以实现会话的持久化；返回会话 ID ；主要此处返回的 ID.equals(session.getId())； Serializable create(Session session); //根据会话 ID 获取会话 Session readSession(Serializable sessionId) throws UnknownSessionException; //更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用 void update(Session session) throws UnknownSessionException; //删除会话；当会话过期/会话停止（如用户退出时）会调用 void delete(Session session); //获取当前所有活跃用户，如果用户量多此方法影响性能 Shiro 内嵌了如下 SessionDAO 实现： AbstractSessionDAO 提供了 SessionDAO 的基础实现， 如生成会话 ID 等； CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护； 而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。 可以通过如下配置设置 SessionDAO： sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO sessionManager.sessionDAO=$sessionDAO Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群——98页 会话管理器 会话管理器管理着应用中所有 Subject 的会话的创建、维护、删除、失效、验证等工作。是Shiro 的核心组件 顶层组件 SecurityManager 直接继承了 SessionManager，且提供了SessionsSecurityManager 实 现直接把会话管理委托给相应的 SessionManager public abstract class SessionsSecurityManager extends AuthorizingSecurityManager { private SessionManager sessionManager; public Session start(SessionContext context) throws AuthorizationException { return this.sessionManager.start(context); } public Session getSession(SessionKey key) throws SessionException { return this.sessionManager.getSession(key); } ... } Shiro 提供了三个默认实现： DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境； ServletContainerSessionManager： DefaultWebSecurityManager 使用的默认实现，用于 Web环境，其直接使用 Servlet 容器的会话； DefaultWebSessionManager： 用于 Web 环境的实现 ， 可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。 替换默认的会话管理器 在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制，此时我们可以使用 DefaultWebSessionManager来维护会话： #sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板 sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookie sessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager #sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID sessionIdCookie.name=sid #sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名 #sessionIdCookie.domain=sishuok.com #sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下 #sessionIdCookie.path= #sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认-1 表示关闭浏览器时过期 Cookie sessionIdCookie.maxAge=1800 #sessionIdCookie.httpOnly如果设置为 true，则客户端不会暴露给客户端脚本代码，使用HttpOnlycookie 有助于减少某些类型的跨站点脚本攻击； 此特性需要实现了 Servlet2.5 MR6及以上版本的规范的 Servlet 容器支持 sessionIdCookie.httpOnly=true sessionManager.sessionIdCookie=$sessionIdCookie #sessionManager.sessionIdCookieEnabled：是否启用/禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie， 即默认使用了 Servlet 容器的 JSESSIONID， 且通过 URL 重写（URL 中的“;JSESSIONID=id”部分）保存 Session Id。 sessionManager.sessionIdCookieEnabled=true securityManager.sessionManager=$sessionManager 会话监听器会话监听器用于监听会话创建、过期及停止事件 会话验证Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑， 一般情况下都是获取会话时来验证会话是否过期并停止会话的； 但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。 Session源代码 Session是个状态性的数据上下文，可以理解为每个用户都有一个特定数据库，该数据库存储着每个用户自己的数据，在shiro里，它是和Subject绑定在一起的，通常用户通过Subject.getSession来获取使用。它在系统内会存活一段时间为用户提供客户端浏览器和应用服务器通讯的一些功能。以下是一些关于Session的使用场景。 1、用户登陆成功后，应用服务器产生个Session，且返回该Session的唯一标识符ID给客户端保存（可通过cookie，或者uri参数等形式）。这样用户访问需要验证后的URL时，应用服务器就能识别。 注意：shiro在用户第一次通过浏览器第一次访问应用服务器时，就会产生Session了，且返回SessionID，后面如果用户再登陆的话，则会在Session里存储该用户已经登陆的。 2、像网上商城，用户通常都会浏览自己喜欢商品，满意后则添加到购物车，由于Session相当于个人的小数据库，此时可以利用Session存储用户添加到购物车的商品，等用户选择完去付款时，此时从Session中获取该用户购物车的商品进行计费、生成订单付费即可。 Shiro实现了自己的Session，即由shiro来管理Session的生命周期。可以为任意的应用提供Session支持。 具体：http://blog.csdn.net/wojiaolinaaa/article/details/48312299 1、Session public interface Session { //返回Session的标识符 Serializable getId(); //根据key获取Session存储的值 Object getAttribute(Object key) throws InvalidSessionException; //设置值和key到session中 void setAttribute(Object key, Object value) throws InvalidSessionException; //根据key删除值 Object removeAttribute(Object key) throws InvalidSessionException; ... } 2、SimpleSession //SimpleSession实现了ValidatingSession和Serializable接口，支持验证session操作和序列化 public class SimpleSession implements ValidatingSession, Serializable { private transient Map&lt;Object, Object&gt; attributes; //sessonID，用于保持客户端浏览器和服务端Session存储容器之间的标识 private transient Serializable id; public Serializable getId() { return this.id; } public Object getAttribute(Object key) { Map&lt;Object, Object&gt; attributes = getAttributes(); if (attributes == null) { return null; } return attributes.get(key); } public void setAttribute(Object key, Object value) { if (value == null) { removeAttribute(key); } else { getAttributesLazy().put(key, value); } } public Object removeAttribute(Object key) { Map&lt;Object, Object&gt; attributes = getAttributes(); if (attributes == null) { return null; } else { return attributes.remove(key); } } } 3、DelegatingSession 服务端的代理的Session，该DelegatingSession 只是保存了真正的底层Session（SimpleSession）的key，然后根据该key来查找到SimpleSession再代理它的操作。Subject.getSession()获取的就是该DelegatingSession，也许是为了不让用户破坏底层Session的一些特性吧 public class DelegatingSession implements Session, Serializable { private final SessionKey key; //用于根据SessionKey来操作真正的底层Session private final transient NativeSessionManager sessionManager; public Serializable getId() { return key.getSessionId(); } public Object getAttribute(Object attributeKey) throws InvalidSessionException { return sessionManager.getAttribute(this.key, attributeKey); } public void setAttribute(Object attributeKey, Object value) throws InvalidSessionException { if (value == null) { removeAttribute(attributeKey); } else { sessionManager.setAttribute(this.key, attributeKey, value); } } public Object removeAttribute(Object attributeKey) throws InvalidSessionException { return sessionManager.removeAttribute(this.key, attributeKey); } } 4、ProxiedSession 该类主要作用是代理真正的Session，为子类提供可重写方法。如：不可调用代理某个方法，如果调用则抛出异常 public class ProxiedSession implements Session { //真正的Session protected final Session delegate; public Object getAttribute(Object key) throws InvalidSessionException { return delegate.getAttribute(key); } public void setAttribute(Object key, Object value) throws InvalidSessionException { delegate.setAttribute(key, value); } public Object removeAttribute(Object key) throws InvalidSessionException { return delegate.removeAttribute(key); } } 5、ImmutableSession ImmutableProxiedSession 继承与ProxiedSession ，该类主要作用是返回一个不可修改Session的代理Session,对于修改的方法都重写抛异常 public class ImmutableProxiedSession extends ProxiedSession { } 6、StoppingAwareProxiedSession StoppingAwareProxiedSession 主要是增强代理Session的方法 private class StoppingAwareProxiedSession extends ProxiedSession { } 7、HttpServletSession 该Session仅仅只是代理了servlet的HttpSession。方便与ServletContainerSessionManager和shiro实现可易配置。把session交由servlet Container来控制生命周期。 SessionFactory源码分析SessionManager根据SessionContext来创建出一个Session，默认是实现是SimpleSessionFactory 默认的SessionFactory SimpleSessionFactory的创建过程： public Session createSession(SessionContext initData) { if (initData != null) { String host = initData.getHost(); if (host != null) { return new SimpleSession(host); } } return new SimpleSession(); } 如果SessionContext有host信息，就传递给Session，然后就是直接new一个Session接口的实现SimpleSession SessionDAOSessionDAO接口，即对Session进行增删改查 public interface SessionDAO { Serializable create(Session session); Session readSession(Serializable sessionId) throws UnknownSessionException; void update(Session session) throws UnknownSessionException; void delete(Session session); Collection&lt;Session&gt; getActiveSessions(); } create:为Session分配Session-ID，并保存Session readSession:提供Session-ID取出Session SessionDAO 接口继承关系如下： AbstractSessionDAO：有一个重要的属性SessionIdGenerator，它负责给Session创建sessionId，SessionIdGenerator接口如下： public interface SessionIdGenerator { Serializable generateId(Session session); } 很简单，参数为Session，返回sessionId。SessionIdGenerator 的实现有两个JavaUuidSessionIdGenerator、RandomSessionIdGenerator。而AbstractSessionDAO默认采用的是JavaUuidSessionIdGenerator，如下： public AbstractSessionDAO() { this.sessionIdGenerator = new JavaUuidSessionIdGenerator(); } AbstractSessionDAO实现了接口create方法，具体创建Session，存储，传回Session-ID方法由子类实现： public Serializable create(Session session) { Serializable sessionId = doCreate(session); verifySessionId(sessionId); return sessionId; } abstract Serializable doCreate(Session session)； AbstractSessionDAO实现了接口readSession方法，具体根据Session-ID从缓存中获取Session的方法由子类实现： public Session readSession(Serializable sessionId) throws UnknownSessionException { Session s = doReadSession(sessionId); if (s == null) { throw new UnknownSessionException(&quot;There is no session with id [&quot; + sessionId + &quot;]&quot;); } return s; } protected abstract Session doReadSession(Serializable sessionId); MemorySessionDAO：继承了AbstractSessionDAO，它把Session存储在一个ConcurrentMap sessions集合中，key为sessionId，value为Session //Session存储在ConcurrentMap集合中 private ConcurrentMap&lt;Serializable, Session&gt; sessions; public MemorySessionDAO() { this.sessions = new ConcurrentHashMap&lt;Serializable, Session&gt;(); } //重写父类创建Session的方法 protected Serializable doCreate(Session session) { //调用父类的获取Session-ID Serializable sessionId = generateSessionId(session); //为Session设置Session-ID assignSessionId(session, sessionId); //存储Session storeSession(sessionId, session); return sessionId; } protected Session storeSession(Serializable id, Session session) { if (id == null) { throw new NullPointerException(&quot;id argument cannot be null.&quot;); } return sessions.putIfAbsent(id, session); } //重写父类读取Session的方法，从Map中根据键值取出Session protected Session doReadSession(Serializable sessionId) { return sessions.get(sessionId); } CachingSessionDAO：主要配合在别的地方存储session，维护了一个成员变量cacheManager，默认的activeSessionsCacheName名为shiro-activeSessionCache private CacheManager cacheManager; 扩展了AbstractSessionDAO的create方法，在创建Session后，放入缓存 public Serializable create(Session session) { Serializable sessionId = super.create(session); cache(session, sessionId); return sessionId; } 扩展了AbstractSessionDAO的readSession方法，先从缓存中获取，如果不行，再去数据库获取 public Session readSession(Serializable sessionId) throws UnknownSessionException { Session s = getCachedSession(sessionId); if (s == null) { s = super.readSession(sessionId); } return s; } EnterpriseCacheSessionDAO：doCreate操作完成了为Session分配Session-ID protected Serializable doCreate(Session session) { Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); return sessionId; } doReadSession操作不执行任何功能 protected Session doReadSession(Serializable sessionId) { return null; //should never execute because this implementation relies on parent class to access cache, which //is where all sessions reside - it is the cache implementation that determines if the //cache is memory only or disk-persistent, etc. } 如果使用默认的EnterpriseCacheSessionDAO，那么设置的缓存管理器就是内存，与MemorySessionDAO无任何差异，如果使用了外部的缓存管理器，如Ehcache，则将缓存保存到指定的缓存中 public EnterpriseCacheSessionDAO() { setCacheManager(new AbstractCacheManager() { @Override protected Cache&lt;Serializable, Session&gt; createCache(String name) throws CacheException { return new MapCache&lt;Serializable, Session&gt;(name, new ConcurrentHashMap&lt;Serializable, Session&gt;()); } }); } 注意：这些缓存不支持持久化，如果要保存缓存进入数据库，需要自定义SessionDAO的doCreate()和doReadSession()方法，见张开涛的跟我学Shiro SessionManager源代码解析http://www.cnblogs.com/Kavlez/p/4135857.html 正如其名，sessionManager用于为应用中的Subject管理session，比如创建、删除、失效或者验证等，和Shiro中的其他核心组件一样，他由SecurityManager维护。 Shiro为SessionManager提供了3个实现类(顺便也整理一下与SecurityManager实现类的关系)。 DefaultSessionManager DefaultWebSessionManager ServletContainerSessionManager 其中ServletContainerSessionManager只适用于servlet容器中，如果需要支持多种客户端访问，则应该使用DefaultWebSessionManager。 SessionManager的接口关系： ThreadContext、SubjectContext（类似）http://www.codeweblog.com/shiro%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-subject%E5%92%8Csession/ ThreadContext（类似于数据库，共享Subject、SecurityManager）ThreadLocal模式线程内共享Subject、SecurityManager，ThreadLocal模式只能共享一个变量，由于需求要保存多个对象，保存这个变量类型为Map public abstract class ThreadContext { public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + &quot;_SECURITY_MANAGER_KEY&quot;; public static final String SUBJECT_KEY = ThreadContext.class.getName() + &quot;_SUBJECT_KEY&quot;; private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new InheritableThreadLocalMap&lt;Map&lt;Object, Object&gt;&gt;(); ..... } 绑定SecurityManager：如果SecurityManager不为空，向线程局部变量的map中，以键存入SECURITY_MANAGER_KEY，值securityManager存入； public static void bind(SecurityManager securityManager) { if (securityManager != null) { put(SECURITY_MANAGER_KEY, securityManager); } } public static void put(Object key, Object value) { ensureResourcesInitialized(); resources.get().put(key, value); } //如果map没有初始化，新建一个HashMap private static void ensureResourcesInitialized(){ if (resources.get() == null){ resources.set(new HashMap&lt;Object, Object&gt;()); } } 取出SecurityManager：取出线程局部变量中的map，根据资源获得SecurityManager public static SecurityManager getSecurityManager() { return (SecurityManager) get(SECURITY_MANAGER_KEY); } public static Object get(Object key) { Object value = getValue(key); return value; } private static Object getValue(Object key) { Map&lt;Object, Object&gt; perThreadResources = resources.get(); return perThreadResources != null ? perThreadResources.get(key) : null; } 设置、取出Subject同理： public static void bind(Subject subject) { if (subject != null) { put(SUBJECT_KEY, subject); } } public static Subject getSubject() { return (Subject) get(SUBJECT_KEY); } SubjectContext于ThreadContext的设计类似 Subject.getSession(boolean create)整体三大步骤，先创建一个SessionContext ，然后传递SessionContext给securityMa但我们可以看下如何创建Session的nager来创建Session，最后是装饰Session,由于创建Session过程内容比较多，先说说装饰Session。 public class DelegatingSubject implements Subject { public Session getSession(boolean create) { if (this.session == null &amp;&amp; create) { //①创建SessionContext SessionContext sessionContext = createSessionContext(); //②SecurityManager调用SessionManager创建Session Session session = this.securityManager.start(sessionContext); //③装饰Session this.session = decorate(session); } return this.session; } //创建SessionContext protected SessionContext createSessionContext() { SessionContext sessionContext = new DefaultSessionContext(); if (StringUtils.hasText(host)) { sessionContext.setHost(host); } return sessionContext; } protected Session decorate(Session session) { if (session == null) { throw new IllegalArgumentException(&quot;session cannot be null&quot;); } return new StoppingAwareProxiedSession(session, this); } } 装饰Session就是将Session和DelegatingSubject封装起来，返回的Session包含Subject和Session的实例，其中owner表示拥有该Session的Subject，delegate为代理的Session，类型为DelegatingSession private class StoppingAwareProxiedSession extends ProxiedSession { private final DelegatingSubject owner; private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) { super(target); owner = owningSubject; } } Subject调用SessionManager创建Session的具体过程可以参见上节：Session、SessionFactory、SessionDAO、SessionManager SecurityUtils创建SubjectSecurityUtils总体如下，SecurityUtils类中维护一个securityManager变量，它需要由用户自己创建SecurityManager，然后set进入SecurityUtils中进行存储，在应用程序中共享SecurityManager public abstract class SecurityUtils { private static SecurityManager securityManager; public static Subject getSubject() { Subject subject = ThreadContext.getSubject(); if (subject == null) { subject = (new Subject.Builder()).buildSubject(); ThreadContext.bind(subject); } return subject; } public static void setSecurityManager(SecurityManager securityManager) { SecurityUtils.securityManager = securityManager; } public static SecurityManager getSecurityManager() throws UnavailableSecurityManagerException { SecurityManager securityManager = ThreadContext.getSecurityManager(); if (securityManager == null) { securityManager = SecurityUtils.securityManager; } return securityManager; } } 第一次使用SecurityUtils.getSubject()来获取Subject： public static Subject getSubject() { Subject subject = ThreadContext.getSubject(); if (subject == null) { subject = (new Subject.Builder()).buildSubject(); ThreadContext.bind(subject); } return subject; } 首先使用ThreadLocal模式来获取，若没有则使用 Subject subject = (new Subject.Builder()).buildSubject(); 创建一个并绑定到当前线程（Subject与线程绑定） 此时创建使用的是Subject内部类Builder来创建的，Builder会创建一个SubjectContext接口的实例DefaultSubjectContext，最终会委托securityManager来根据SubjectContext信息来创建一个Subject public interface Subject { ..... public static class Builder { private final SubjectContext subjectContext; private final SecurityManager securityManager; public Builder() { this(SecurityUtils.getSecurityManager()); } //Builder会创建一个SubjectContext接口的实例DefaultSubjectContext public Builder(SecurityManager securityManager) { if (securityManager == null) { throw new NullPointerException(&quot;SecurityManager method argument cannot be null.&quot;); } this.securityManager = securityManager; this.subjectContext = newSubjectContextInstance(); if (this.subjectContext == null) { throw new IllegalStateException(&quot;Subject instance returned from &apos;newSubjectContextInstance&apos; &quot; + &quot;cannot be null.&quot;); } this.subjectContext.setSecurityManager(securityManager); } protected SubjectContext newSubjectContextInstance() { return new DefaultSubjectContext(); } //委托securityManager来根据SubjectContext信息来创建一个Subject public Subject buildSubject() { return this.securityManager.createSubject(this.subjectContext); } } } ★★★★★在DefaultSecurityManager的createSubject下面详细说下该过程，在DefaultSecurityManager的createSubject方法中： public Subject createSubject(SubjectContext subjectContext) { SubjectContext context = copy(subjectContext); context = ensureSecurityManager(context); context = resolveSession(context); context = resolvePrincipals(context); Subject subject = doCreateSubject(context); save(subject); return subject; } 首先就是复制SubjectContext，即新建一个SubjectContext实例，与原来的对象具有相同的属性值，SubjectContext的详细介绍见下一节 对于context，把能获取到的参数都凑齐，SecurityManager、Session、Principal，以Session为例，整个过程如下; public class DefaultSecurityManager extends SessionsSecurityManager { //①以获取Session为例 protected SubjectContext resolveSession(SubjectContext context) { //②尝试获取context的map中获取Session if (context.resolveSession() != null) { log.debug(&quot;Context already contains a session. Returning.&quot;); return context; } try { //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to //the session manager: //③若没有再尝试获取sessionId Session session = resolveContextSession(context); if (session != null) { context.setSession(session); } } catch (InvalidSessionException e) { log.debug(&quot;Resolved SubjectContext context session is invalid. Ignoring and creating an anonymous &quot; + &quot;(session-less) Subject instance.&quot;, e); } return context; } protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException { SessionKey key = getSessionKey(context); if (key != null) { return getSession(key); } return null; } protected SessionKey getSessionKey(SubjectContext context) { Serializable sessionId = context.getSessionId(); if (sessionId != null) { return new DefaultSessionKey(sessionId); } return null; } } 首先调用SubjectContext的resolveSession方法，尝试获取context的map中获取Session： 1、首先获取与SubjectContext中Session 2、如果没找到，尝试获取SubjectContext存储的Subject，如果存在的话，调用Subject的getSession方法获取Session（不新建Session，没有返回null） 若没有再尝试获取sessionId,若果有了sessionId则构建成一个DefaultSessionKey来获取对应的Session。 注意：第一次调用SecurityUtil.getSubject()创建Subject的时候不新建Session SubjectContext的参数填充完整后，进行实际的Subject创建工作，调用DefaultSecurityManager的doCreateSubject方法：请按照1，2，3，4的顺序查看 public class DefaultSecurityManager extends SessionsSecurityManager { protected SubjectDAO subjectDAO; protected SubjectFactory subjectFactory; //④SubjectDAO、SubjectFactory默认值 public DefaultSecurityManager() { super(); this.subjectFactory = new DefaultSubjectFactory(); this.subjectDAO = new DefaultSubjectDAO(); } //①创建Subject public Subject createSubject(SubjectContext subjectContext) { //SubjectContext参数的获取 SubjectContext context = copy(subjectContext); context = ensureSecurityManager(context); context = resolveSession(context); context = resolvePrincipals(context); //②具体创建Subject Subject subject = doCreateSubject(context); save(subject); return subject; } //③ //通过SubjectFactory工厂接口来创建Subject的，而DefaultSecurityManager默认使用的SubjectFactory是DefaultSubjectFactory： protected Subject doCreateSubject(SubjectContext context) { return getSubjectFactory().createSubject(context); } } 继续看DefaultSubjectFactory是怎么创建Subject的： public Subject createSubject(SubjectContext context) { SecurityManager securityManager = context.resolveSecurityManager(); Session session = context.resolveSession(); boolean sessionCreationEnabled = context.isSessionCreationEnabled(); PrincipalCollection principals = context.resolvePrincipals(); boolean authenticated = context.resolveAuthenticated(); String host = context.resolveHost(); return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager); } 仍然就是从SubjectContext获取这些属性，传递给新建的Subject实例：DelegatingSubject，也没什么好说的，到此为止创建一个Subject实例DelegatingSubject，维护了Principal、authenticated、host、session，此时除了host全为空，并返回； public class DelegatingSubject implements Subject { private static final Logger log = LoggerFactory.getLogger(DelegatingSubject.class); private static final String RUN_AS_PRINCIPALS_SESSION_KEY = DelegatingSubject.class.getName() + &quot;.RUN_AS_PRINCIPALS_SESSION_KEY&quot;; protected PrincipalCollection principals; protected boolean authenticated; protected String host; protected Session session; } 创建完成之后，就需要将刚创建的Subject保存起来 来看下save方法： protected void save(Subject subject) { this.subjectDAO.save(subject); } 可以看到又是使用另一个模块来完成的即SubjectDAO，SubjectDAO接口的默认实现为DefaultSubjectDAO()，具体的实现类DefaultSubjectDAO是如何来保存的： public Subject save(Subject subject) { if (isSessionStorageEnabled(subject)) { saveToSession(subject); } else { log.trace(&quot;Session storage of subject state for Subject [{}] has been disabled: identity and &quot; + &quot;authentication state are expected to be initialized on every request or invocation.&quot;, subject); } return subject; } 首先就是判断isSessionStorageEnabled，是否要存储该Subject的session到DefaultSubjectDAO：有一个重要属性SessionStorageEvaluator，它是用来决定一个Subject的Session来记录Subject的状态，接口如下 public interface SessionStorageEvaluator { boolean isSessionStorageEnabled(Subject subject); } 其实现为DefaultSessionStorageEvaluator： public class DefaultSessionStorageEvaluator implements SessionStorageEvaluator { private boolean sessionStorageEnabled = true; public boolean isSessionStorageEnabled(Subject subject) { return (subject != null &amp;&amp; subject.getSession(false) != null) || isSessionStorageEnabled(); } } 决定策略就是通过DefaultSessionStorageEvaluator 的sessionStorageEnabled的true或false 和subject是否有Session对象来决定的。如果允许存储Subject的Session的话，下面就说 具体的存储过程： protected void saveToSession(Subject subject) { mergePrincipals(subject); mergeAuthenticationState(subject); } protected void mergePrincipals(Subject subject) { //merge PrincipalCollection state: PrincipalCollection currentPrincipals = null; //SHIRO-380: added if/else block - need to retain original (source) principals //This technique (reflection) is only temporary - a proper long term solution needs to be found, //but this technique allowed an immediate fix that is API point-version forwards and backwards compatible // //A more comprehensive review / cleaning of runAs should be performed for Shiro 1.3 / 2.0 + if (subject.isRunAs() &amp;&amp; subject instanceof DelegatingSubject) { try { Field field = DelegatingSubject.class.getDeclaredField(&quot;principals&quot;); field.setAccessible(true); currentPrincipals = (PrincipalCollection)field.get(subject); } catch (Exception e) { throw new IllegalStateException(&quot;Unable to access DelegatingSubject principals property.&quot;, e); } } if (currentPrincipals == null || currentPrincipals.isEmpty()) { currentPrincipals = subject.getPrincipals(); } Session session = subject.getSession(false); if (session == null) { //只有当Session为空，并且currentPrincipals不为空的时候才会去创建Session //Subject subject = SecurityUtils.getSubject()此时两者都是为空的， //不会去创建Session if (!CollectionUtils.isEmpty(currentPrincipals)) { session = subject.getSession(); session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals); } //otherwise no session and no principals - nothing to save } else { PrincipalCollection existingPrincipals = (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY); if (CollectionUtils.isEmpty(currentPrincipals)) { if (!CollectionUtils.isEmpty(existingPrincipals)) { session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY); } //otherwise both are null or empty - no need to update the session } else { if (!currentPrincipals.equals(existingPrincipals)) { session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals); } //otherwise they&apos;re the same - no need to update the session } } } 上面有我们关心的重点，当subject.getSession(false)获取的Session为空时（它不会去创建Session），此时就需要去创建Session，subject.getSession()则默认调用的是subject.getSession(true),则会进行Session的创建，创建过程上文已详细说明了。 在第一次创建Subject的时候 Subject subject = SecurityUtils.getSubject(); 虽然Session为空，但此时还没有用户身份信息，也不会去创建Session 所以创建的DelegatingSubject实例，成员变量Principal、Session全是空 Subject.login(token)案例中的subject.login(token)该过程则会去创建Session，具体看下过程： 首先DelegatingSubject调用login方法会委托给SecurityManager的securityManager.login(this, token)方法 public void login(AuthenticationToken token) throws AuthenticationException { clearRunAsIdentitiesInternal(); //SecurityManager完成实际的登录操作 Subject subject = securityManager.login(this, token); PrincipalCollection principals; String host = null; if (subject instanceof DelegatingSubject) { DelegatingSubject delegating = (DelegatingSubject) subject; principals = delegating.principals; host = delegating.host; } else { principals = subject.getPrincipals(); } if (principals == null || principals.isEmpty()) { String msg = &quot;Principals returned from securityManager.login( token ) returned a null or &quot; + &quot;empty value. This value must be non null and populated with one or more elements.&quot;; throw new IllegalStateException(msg); } this.principals = principals; this.authenticated = true; if (token instanceof HostAuthenticationToken) { host = ((HostAuthenticationToken) token).getHost(); } if (host != null) { this.host = host; } Session session = subject.getSession(false); if (session != null) { this.session = decorate(session); } else { this.session = null; } } SecurityManager的login方法分为两步：1、对用户名、密码验证 2、创建Subject public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException { //对用户名、密码验证 AuthenticationInfo info; try { info = authenticate(token); } catch (AuthenticationException ae) { try { onFailedLogin(token, ae, subject); } catch (Exception e) { if (log.isInfoEnabled()) { log.info(&quot;onFailedLogin method threw an &quot; + &quot;exception. Logging and propagating original AuthenticationException.&quot;, e); } } throw ae; //propagate } //在该过程会进行Session的创建 Subject loggedIn = createSubject(token, info, subject); onSuccessfulLogin(token, info, loggedIn); return loggedIn; } 对于验证过程这里不再说明，重点还是在验证通过后，会创建一个新的Subject，同时Subject中包含认证信息和Session； 新建SubjectContext，并设置了认证信息 protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) { SubjectContext context = createSubjectContext(); context.setAuthenticated(true); context.setAuthenticationToken(token); context.setAuthenticationInfo(info); if (existing != null) { context.setSubject(existing); } //根据SubjectContext创建Subject，之前详细讲解过 return createSubject(context); } protected SubjectContext createSubjectContext() { return new DefaultSubjectContext(); } 在系统刚启动时，创建Subject时，参数SubjectContext中的Session、Principal都为空，不创建Session；但在调用Subject.login有了认证成功的AuthenticationInfo信息，调用SubjectContext在resolvePrincipals便可以获取用户信息 再次调用createSubject(context）创建Subject，此时resolvePrincipals(context)中，可以获取到刚才认证传入的AuthenticationInfo，并取出Principal。在SubjectContext中Principal不为空，但Session为空 public Subject createSubject(SubjectContext subjectContext) { SubjectContext context = copy(subjectContext); context = ensureSecurityManager(context); context = resolveSession(context); context = resolvePrincipals(context); Subject subject = doCreateSubject(context); save(subject); return subject; } PrincipalCollection不为空了，在save(subject)的时候会得到session为空，同时PrincipalCollection不为空，则会执行Session的创建。也就是说在认证通过后，会执行Session的创建，返回的Session为Subject和Session的封装体，并在Session中存入Principal调用subject.getSession()，回返回一个Subject和Session的封装体，并且设置该Session为Subject的成员变量 protected void mergePrincipals(Subject subject) { PrincipalCollection currentPrincipals = null; if (subject.isRunAs() &amp;&amp; subject instanceof DelegatingSubject) { try { Field field = DelegatingSubject.class.getDeclaredField(&quot;principals&quot;); field.setAccessible(true); currentPrincipals = (PrincipalCollection)field.get(subject); } catch (Exception e) { throw new IllegalStateException(&quot;Unable to access DelegatingSubject principals property.&quot;, e); } } if (currentPrincipals == null || currentPrincipals.isEmpty()) { currentPrincipals = subject.getPrincipals(); } Session session = subject.getSession(false); if (session == null) { if (!CollectionUtils.isEmpty(currentPrincipals)) { //【此处会执行！！！】Principal不为空会创建一个Session //调用subject.getSession()，回返回一个Subject和Session的共同体，并且设置该Session为Subject的成员变量 session = subject.getSession(); //Session中存入Principal session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals); } //otherwise no session and no principals - nothing to save } else { PrincipalCollection existingPrincipals = (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY); if (CollectionUtils.isEmpty(currentPrincipals)) { if (!CollectionUtils.isEmpty(existingPrincipals)) { session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY); } //otherwise both are null or empty - no need to update the session } else { if (!currentPrincipals.equals(existingPrincipals)) { session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals); } //otherwise they&apos;re the same - no need to update the session } } } 委托SecurityManager执行登录操作完毕，回到DelegatingSubject的login函数，返回了新建的Subject Session创建完成之后会进行一次装饰，即用新建一个StoppingAwareProxiedSession对象，其中的delegate为session（也为StoppingAwareProxiedSession类型），owner为Subject，然后又进行如下操作： public class DelegatingSubject implements Subject { public void login(AuthenticationToken token) throws AuthenticationException { clearRunAsIdentitiesInternal(); //★★★★★这里的Subject则是经过认证后创建的并且也含有刚才创建的session Subject subject = securityManager.login(this, token); PrincipalCollection principals; String host = null; if (subject instanceof DelegatingSubject) { DelegatingSubject delegating = (DelegatingSubject) subject; //we have to do this in case there are assumed identities - we don't want to lose the 'real' principals: principals = delegating.principals; host = delegating.host; } else { principals = subject.getPrincipals(); } if (principals == null || principals.isEmpty()) { String msg = "Principals returned from securityManager.login( token ) returned a null or " + "empty value. This value must be non null and populated with one or more elements."; throw new IllegalStateException(msg); } //内部Subject的principal、session、authenticated复制到外部的Subject this.principals = principals; this.authenticated = true; if (token instanceof HostAuthenticationToken) { host = ((HostAuthenticationToken) token).getHost(); } if (host != null) { this.host = host; } Session session = subject.getSession(false); if (session != null) { //在这里可以看到又进行了一次装饰 this.session = decorate(session); } else { this.session = null; } } } subject 创建出来之后，暂且叫内部subject，就是把认证通过的内部subject的信息和session复制给我们外界使用的subject.login(token)的subject中（principals、host、authenticated、Session），这个subject暂且叫外部subject，看下session的赋值，又进行了一次装饰，这次装饰则把session(类型为StoppingAwareProxiedSession，即是内部subject和session的合体)和外部subject绑定到一起 从Cookie、URL、request中根据Token获取Session1、客户端请求到来，调用AbstractShiroFilter中的doFilterInternal方法，创建Subject final Subject subject = createSubject(request, response); 2、调用WebSubject.Builder().buildWebSubject方法 protected WebSubject createSubject(ServletRequest request, ServletResponse response) { return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject(); } 3、创建WebSubject与默认的Subject稍微有差别，但还是调用父类（即Subject接口的Builder中的BuildSubject方法） public WebSubject buildWebSubject() { Subject subject = super.buildSubject(); if (!(subject instanceof WebSubject)) { String msg = &quot;Subject implementation returned from the SecurityManager was not a &quot; + WebSubject.class.getName() + &quot; implementation. Please ensure a Web-enabled SecurityManager &quot; + &quot;has been configured and made available to this builder.&quot;; throw new IllegalStateException(msg); } return (WebSubject) subject; } 4、父类的buildSubject方法，将创建Subject的方法委托为SecurityManager public Subject buildSubject() { return this.securityManager.createSubject(this.subjectContext); } 5、DefaultSecurityManager的createSubject public Subject createSubject(SubjectContext subjectContext) { SubjectContext context = copy(subjectContext); context = ensureSecurityManager(context); context = resolveSession(context); context = resolvePrincipals(context); Subject subject = doCreateSubject(context); save(subject); return subject; } 6、resolveSession(context)解析Session，context.resolveSession()返回的是null，调用Session session = resolveContextSession(context)尝试获取Session protected SubjectContext resolveSession(SubjectContext context) { //① if (context.resolveSession() != null) { log.debug(&quot;Context already contains a session. Returning.&quot;); return context; } try { //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to //the session manager: //② Session session = resolveContextSession(context); if (session != null) { context.setSession(session); } } catch (InvalidSessionException e) { log.debug(&quot;Resolved SubjectContext context session is invalid. Ignoring and creating an anonymous &quot; + &quot;(session-less) Subject instance.&quot;, e); } return context; } 7、具体看resolveContextSession，调用getSessionKey(context) protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException { SessionKey key = getSessionKey(context); if (key != null) { return getSession(key); } return null; } 8、DefaultWebSecurityManager重写getSessionKey(SubjectContext context)方法 protected SessionKey getSessionKey(SubjectContext context) { if (WebUtils.isWeb(context)) { Serializable sessionId = context.getSessionId(); ServletRequest request = WebUtils.getRequest(context); ServletResponse response = WebUtils.getResponse(context); return new WebSessionKey(sessionId, request, response); } else { return super.getSessionKey(context); } } 返回WebSessionKey实例，但WebSessionKey中的sessionId为null 9、回到第7步SessionKey key = getSessionKey(context)，此时key不为空，调用SessionSecurityManager的getSession方法（接口方法） public Session getSession(SessionKey key) throws SessionException { return this.sessionManager.getSession(key); } 10、调用AbstractNativeSessionManager中的getSession public Session getSession(SessionKey key) throws SessionException { Session session = lookupSession(key); return session != null ? createExposedSession(session, key) : null; } 11、进入到lookupSession private Session lookupSession(SessionKey key) throws SessionException { if (key == null) { throw new NullPointerException(&quot;SessionKey argument cannot be null.&quot;); } return doGetSession(key); } 12、doGetSession被子类AbstractValidatingSessionManager重写 protected final Session doGetSession(final SessionKey key) throws InvalidSessionException { enableSessionValidationIfNecessary(); log.trace(&quot;Attempting to retrieve session with key {}&quot;, key); Session s = retrieveSession(key); if (s != null) { validate(s, key); } return s; } 13、retrieveSession也是个抽象方法，被子类DefaultSessionManager重写， protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException { Serializable sessionId = getSessionId(sessionKey); if (sessionId == null) { log.debug(&quot;Unable to resolve session ID from SessionKey [{}]. Returning null to indicate a &quot; + &quot;session could not be found.&quot;, sessionKey); return null; } Session s = retrieveSessionFromDataSource(sessionId); if (s == null) { //session ID was provided, meaning one is expected to be found, but we couldn&apos;t find one: String msg = &quot;Could not find session with ID [&quot; + sessionId + &quot;]&quot;; throw new UnknownSessionException(msg); } return s; } 14、getSessionId被子类DefaultWebSessionManager重写 public Serializable getSessionId(SessionKey key) { Serializable id = super.getSessionId(key); if (id == null &amp;&amp; WebUtils.isWeb(key)) { ServletRequest request = WebUtils.getRequest(key); ServletResponse response = WebUtils.getResponse(key); id = getSessionId(request, response); } return id; } 由于父类的getSessionId返回null，执行getSessionId(request,response) protected Serializable getSessionId(SessionKey sessionKey) { return sessionKey.getSessionId(); } 15、DefaultWebSessionManager的getSessionId protected Serializable getSessionId(ServletRequest request, ServletResponse response) { return getReferencedSessionId(request, response); } 16、★★★★★★★getReferencedSessionId先解析cookie，在解析URL，最后解析 private Serializable getReferencedSessionId(ServletRequest request, ServletResponse response) { String id = getSessionIdCookieValue(request, response); if (id != null) { request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE); } else { //not in a cookie, or cookie is disabled - try the request URI as a fallback (i.e. due to URL rewriting): //try the URI path segment parameters first: id = getUriPathSegmentParamValue(request, ShiroHttpSession.DEFAULT_SESSION_ID_NAME); if (id == null) { //not a URI path segment parameter, try the query parameters: String name = getSessionIdName(); id = request.getParameter(name); if (id == null) { //try lowercase: id = request.getParameter(name.toLowerCase()); } } if (id != null) { request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE); } } if (id != null) { request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id); //automatically mark it valid here. If it is invalid, the //onUnknownSession method below will be invoked and we&apos;ll remove the attribute at that time. request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE); } // always set rewrite flag - SHIRO-361 request.setAttribute(ShiroHttpServletRequest.SESSION_ID_URL_REWRITING_ENABLED, isSessionIdUrlRewritingEnabled()); return id; } SubjectContext、MapContext、Map接口设计: MapContext：实现了Map接口，内部拥有一个类型为HashMap的backingMap属性，大部分方法都由HashMap来实现，然后仅仅更改某些行为，MapContext没有选择去继承HashMap，而是使用了组合的方式，更加容易去扩展，如backingMap的类型不一定非要选择HashMap，可以换成其他的Map实现，一旦MapContext选择继承HashMap，如果想对其他的Map类型进行同样的功能增强的话，就需要另写一个类来继承它然后改变一些方法实现，这样的话就会有很多重复代码。这也是设计模式所强调的少用继承多用组合 public class MapContext implements Map&lt;String, Object&gt;, Serializable { private static final long serialVersionUID = 5373399119017820322L; private final Map&lt;String, Object&gt; backingMap; public MapContext() { this.backingMap = new HashMap&lt;String, Object&gt;(); } public MapContext(Map&lt;String, Object&gt; map) { this(); if (!CollectionUtils.isEmpty(map)) { this.backingMap.putAll(map); } } //略 } SubjectContext接口继承了Map，然后加入了几个重要的SecurityManager、SessionId、Subject、PrincipalCollection、Session、boolean authenticated、boolean sessionCreationEnabled、Host、AuthenticationToken、AuthenticationInfo等众多信息。 MapContext中增加了getTypedValue方法，便于获得参数化的类型： protected &lt;E&gt; E getTypedValue(String key, Class&lt;E&gt; type) { E found = null; Object o = backingMap.get(key); if (o != null) { if (!type.isAssignableFrom(o.getClass())) { String msg = &quot;Invalid object found in SubjectContext Map under key [&quot; + key + &quot;]. Expected type &quot; + &quot;was [&quot; + type.getName() + &quot;], but the object under that key is of type &quot; + &quot;[&quot; + o.getClass().getName() + &quot;].&quot;; throw new IllegalArgumentException(msg); } found = (E) o; } return found; } 可以把Map当做公有基本类，然后SubjectContext在此基础上扩展，类似于公有方法和新添加的方法；Map定义了这个类的功能是存储，SubjectContext在此基础上增加了SecurityManager、Subject、Session的存储 讨论1：首先是SubjectContext为什么要去实现Map？ 实现对数据的存储有设计方式有两种方式：1、继承数据结构，如map，自然就可以调用Map的put/get方法对数据进行存储2、组合方式，即类中存放一个存储型数据结构，如map，调用成员变量的put/get方法实现存储 ThreadContext采用采用的是组合方式，SubjectContext采用的是继承方式 讨论2：SubjectContext接口的作用？ SubjectContext提供了常用的get、set方法，还提供了一个resolve方法，以SecurityManager为例： SecurityManager getSecurityManager(); void setSecurityManager(SecurityManager securityManager); SecurityManager resolveSecurityManager(); 这些get、set方法则用于常用的设置和获取，而resolve则表示先调用getSecurityManager，如果获取不到，则使用其他途径来获取，如DefaultSubjectContext的实现： public SecurityManager resolveSecurityManager() { SecurityManager securityManager = getSecurityManager(); if (securityManager == null) { if (log.isDebugEnabled()) { log.debug(&quot;No SecurityManager available in subject context map. &quot; + &quot;Falling back to SecurityUtils.getSecurityManager() lookup.&quot;); } try { securityManager = SecurityUtils.getSecurityManager(); } catch (UnavailableSecurityManagerException e) { if (log.isDebugEnabled()) { log.debug(&quot;No SecurityManager available via SecurityUtils. Heuristics exhausted.&quot;, e); } } } return securityManager; } 如果getSecurityManager获取不到，则使用SecurityUtils工具来获取。再如resolvePrincipals public PrincipalCollection resolvePrincipals() { PrincipalCollection principals = getPrincipals(); if (CollectionUtils.isEmpty(principals)) { //check to see if they were just authenticated: AuthenticationInfo info = getAuthenticationInfo(); if (info != null) { principals = info.getPrincipals(); } } if (CollectionUtils.isEmpty(principals)) { Subject subject = getSubject(); if (subject != null) { principals = subject.getPrincipals(); } } if (CollectionUtils.isEmpty(principals)) { //try the session: Session session = resolveSession(); if (session != null) { principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY); } } return principals; } 普通的getPrincipals()获取不到，尝试使用其他属性来获取。 SubjectFactory DefaultSubjectFactory: 根据SubjectContext，解析出ecurityManager、Session、PrincipalCollection等信息，生成一个代理Subject：DelegatingSubject public Subject createSubject(SubjectContext context) { SecurityManager securityManager = context.resolveSecurityManager(); Session session = context.resolveSession(); boolean sessionCreationEnabled = context.isSessionCreationEnabled(); PrincipalCollection principals = context.resolvePrincipals(); boolean authenticated = context.resolveAuthenticated(); String host = context.resolveHost(); return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager); } Subject ★★★会话管理总结1、服务器刚启动时，创建Subject，其Principal、Session为空2、用户登录，调用Subject.login获取用户信息，创建Session，在Session中存入Principal信息，更新Subject中的Session、Principal3、下次用户携带Token登录，恢复Session，取出Principal，建立带状态信息的Subject 缓存机制环境导入依赖 &lt;!--shiro与ehcache整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;!--1.3.2--&gt; &lt;/dependency&gt; &lt;!--ehcache,纯Java开源缓存框架--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; ehcache.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;!-- Mandatory Default Cache configuration. These settings will be applied to caches created programmtically using CacheManager.add(String cacheName) --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory：缓存最大个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 maxElementsOnDisk：硬盘最大缓存个数。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 --&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;true&quot; maxElementsOnDisk=&quot;10000000&quot; diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt; &lt;cache name=&quot;shiro&quot; maxEntriesLocalHeap=&quot;2000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;600&quot; timeToLiveSeconds=&quot;600&quot; overflowToDisk=&quot;false&quot; statistics=&quot;true&quot;&gt; &lt;/cache&gt; &lt;/ehcache&gt; OAuth2根据应用场景的不同，目前实现开放授权的方法分为两种：一种是使用OAuth协议；另一种是使用IAM服务 OAuth协议主要适用于针对个人用户对资源的开放授权，比如Google的用户Alice允许别的应用程序（如Facebook）访问他的联系人列表 IAM它的特点是”预先授权”或”离线授权”，客户端通过REST API去访问资源，资源所有者可以预先知道第三方应用所需的资源请求，一次授权之后，很少会更改。IAM服务一般在云计算服务中使用，如阿里云计算服务 OAuth 角色资源拥有者（resource owner）：能 授权 访问受保护资源的一个实体，可以是一个人，我们称之为最终用户，如新浪微博用户、zhangsan 资源服务器（resource server）：存储受保护资源，客户端通过 access token 请求资源，资源服务器响应受保护资源给客户端，存储着用户 zhangsan 的微博等信息 授权服务器（authorization server）：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（Access Token）给客户端 客户端（client）：如新浪微博客户端、微格等第三方应用，也可以是它自己的官方应用，其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来/提交到服务器。”客户端”术语不代表任何特定实现（如应用运行在一台服务器、桌面、手机或其他设备） OAuth2 协议流程 1、客户端从 资源拥有者 那请求授权。授权请求可以直接发给资源拥有者，或间接的通过授权服务器这种中介，后者更可取。（我们常会看到跳出弹框，是否允许第三方授权，需要用户决定是否同意）2、客户端收到一个 授权许可，代表资源服务器提供的授权3、客户端使用它自己的私有证书及授权许可到 授权服务器 验证4、如果验证成功，则下发一个 访问令牌5、客户端使用访问令牌向 资源服务器 请求受保护资源6、资源服务器会验证访问令牌的有效性，如果成功则下发受保护资源 无状态 Web 应用集成在一些环境中，可能需要把 Web 应用做成无状态的，即服务器端无状态，就是说 服务器端不会存储像会话这种东西，而是每次请求时带上相应的用户名进行登录。如一些 REST 风格的 API，如果不使用 OAuth2 协议，就可以使用如 REST+HMAC 认证进行访问。 HMAC（Hash-based Message Authentication Code）：基于散列的消息认证码，使用一个密钥和一个消息作为输入，生成它们的消息摘要。注意该密钥只有客户端和服务端知道，其他第三方是不知道的。 访问时使用该消息摘要进行传播，服务端然后对该消息摘要进行验证。如果只传递用户名+密码的消息摘要， 一旦被别人捕获可能会重复使用该摘要进行认证。解决办法如： 1、每次客户端申请一个 Token，然后使用该 Token 进行加密，而该 Token 是一次性的，即只能用一次；有点类似于 OAuth2 的 Token 机制，但是简单些；2、客户端每次生成一个唯一的 Token，然后使用该 Token 加密，这样服务器端记录下这些Token，如果之前用过就认为是非法请求 权限实例http://www.360doc.com/content/14/0529/10/11298474_381933566.shtml# 权限概述有一个用户管理系统，注册的用户分为normal用户，manager用户，admin用户，有系统管理、用户管理、角色管理三类操作，我们规定： admin 可以访问 /admin/** manager 可以访问 /admin/user/** normal 可以访问 /admin/role/** 用户 admin 拥有 admin、manager、normal 三种角色，可以访问/admin/**，/admin/user/**,/admin/role/**的资源 用户 zhangsan 拥有 manager、normal 两种角色，可以访问 /admin/user/**，/admin/role/** 用户 lisi 拥有 normal 角色，可以访问 /admin/role/** 权限是应用程序的一些基本操作，角色是权限的集合 我们采用下面的逻辑创建权限表结构（不是绝对的，根据需要修改） 用户与角色关系：多对多一个用户可以有多种角色（normal,manager,admin等等）一个角色可以有多个用户（user1,user2,user3等等） 角色与权限关系：多对多一个角色可以有多个权限（save,update,delete,query等等）一个权限可以属于多个角色 数据库设计我们创建五张表： tb_user用户表：设置了3个用户 +----+-----------+---------------------------------- | id | user_name | password +----+-----------+---------------------------------- | 1 | admin | 086bad3456e2653dc05e32a77000ce87 | 2 | zhangsan | 39dd5dcf4b69e917f7a32233462c55d4 | 3 | lisi | a259a0625727a416130cdb03e6e9dfb6 +----+-----------+---------------------------------- tb_role角色表：设置3个角色 +----+-----------+-------------+ | id | role_name | description | +----+-----------+-------------+ | 1 | admin | 系统管理员 | | 2 | manager | 系统顾问 | | 3 | normal | 系统用户 | +----+-----------+-------------+- tb_user_role用户角色表： +----+---------+---------+ | id | user_id | role_id | +----+---------+---------+ | 1 | 1 | 1 | | 2 | 1 | 2 | | 3 | 1 | 3 | | 4 | 2 | 2 | | 5 | 2 | 3 | | 6 | 3 | 3 | +----+---------+---------+ tb_resources权限表： +----+---------------+------------+----------------+ | id | resource_name | permission | url | +----+---------------+------------+----------------+ | 1 | 系统管理 | NULL | /admin/** | | 2 | 用户管理 | NULL | /admin/user/** | | 3 | 角色管理 | NULL | /admin/role/** | +----+---------------+------------+----------------+ select * from tb_role_resource角色权限表： +----+---------+-------------+ | id | role_id | resource_id | +----+---------+-------------+ | 1 | 1 | 1 | | 2 | 2 | 2 | | 3 | 3 | 3 | +----+---------+-------------+]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK源码阅读]]></title>
      <url>%2F2016%2F10%2F13%2F%5BJava%5DJDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[文件IO//类加载根目录String parent = getClass().getClassLoader().getResource(“”).getPath(); BufferedOutputStream要介绍BufferedOutputStream，我们先了解一下OutputStream类抽象类OutputStream类有三个write方法 public abstract void write(int b) public void write(byte b[]) public void write(byte b[], int off, int len) 由上面我们可以看出第一个write方法是让子类覆盖的，而第二个人write（byte b[]）方法源代码如下 public void write(byte b[]) throws IOException { write(b, 0, b.length); } 所以可见最后处理还是调用第三个方法write(byte b[],int off,int len)，该方法源码如下： public void write(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } for (int i = 0 ; i &lt; len ; i++) { //注意这儿，这儿其实调用前面的抽象方法write（int b）,同时还发生了自动转型 write(b[off + i]); } } 我们先不看抽象方法是如何实现的，也就是说OutputStream也具有缓存器功能，我们可以将要写入到流中的数据写到一个byte[] buf数组中，然后调用write(byte b[])或者write(byte b[], int off, int len)也可以，那为什么还要BufferedInputStream类干什么呢，他们有什么区别呢。同时我们知道BufferedInputStream类中还有一个flush()方法，在OutputStream流中没有flush()方法，这又是为什么呢？flush()是不是必须的呢，接下来看一下BufferedOutputStream类； 首先，BufferedOutput将OutputStream类对象作为一个构造方法的参数的。首先看一下 BufferedOutputStream 类源代码 public class BufferedOutputStream extends FilterOutputStream { //这儿定义了一个byte[]数组，用来充当缓存器 protected byte buf[]; //这个变量是重点，他就是用来记录当前缓存器中的字节数量的 protected int count; //我们初始化创建一个对象的时候给了这个buf这个数组8192个字节. public BufferedOutputStream(OutputStream out) { this(out, 8192); } public BufferedOutputStream(OutputStream out, int size) { super(out); if (size &lt;= 0) { throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); } // 这儿创建一个给定大小的数组对象来充当缓存器 buf = new byte[size]; } public synchronized void write(int b) throws IOException { if (count &gt;= buf.length) { flushBuffer(); } buf[count++] = (byte)b; } //该方法是重点 public synchronized void write(byte b[], int off, int len) throws IOException { //如果传进来的数组长度大于buf 数组的长度，则直接调用OutputStream对象的write方法。 if (len &gt;= buf.length) { flushBuffer(); out.write(b, off, len); return; } //验证BufferedOutputStream 类中buf剩下的空间能否装得下传进来的数组。如果不能则先将当前buf数组中数据写入底层io流中 if (len &gt; buf.length - count) { flushBuffer(); } //该处是重点，如果在当前BufferedOutputStream 类中buf数组没有满，则将传进来的数组复制到当前类对象buf数组中，同时更新count的值。 System.arraycopy(b, off, buf, count, len); count += len; //调用flushBuffer方法也就是将不满8192个字节数组中的数据发送出去。同时将count置零。 private void flushBuffer() throws IOException { if (count &gt; 0) { out.write(buf, 0, count); count = 0; } } //强制将buf数据中未满8192个字节的数据写入底层io中。 public synchronized void flush() throws IOException { flushBuffer(); out.flush(); } } 结论： OutputStream的缓存器（数组）与BufferedOutputStream中类的缓存器（数组）本质是一样的，只是BufferedOutputStream类中将要写入到底层io流中的数据先 凑个整，然后再一起写入底层io流中，这样就大大节省了io操作，大大提高了io利用率，写一次io是很费资源的。这样也出现了一个问题，假设向硬盘中写入一个文件，文件最后数据比默认值8192个字节小，则BufferOutputStream就不会将这些数据写入底层io流中，造成文件缺失，因此就需要在close()前调用flush（）方法，强制将还没有装满buf数组的数据写入底层io中。同时也可以看出节点流是不用flush()方法的，而一般的处理流都会采用固定buf这种方式的，比如常用的PrintWriter里面其实操作的就是一个BufferedWriter对象，因此也需要调用flush（）方法来刷新，因为默认是不刷新的。 引用：http://m.blog.csdn.net/article/details?id=51355523]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 Token 的身份验证]]></title>
      <url>%2F2016%2F10%2F11%2F%5BJava%5D%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%2F</url>
      <content type="text"><![CDATA[为什么要身份验证可能你会说，不是有登录接口吗，输入用户名、密码，身份验证通过就可以跳到下一个页面，很简单啊！ 但是，HTTP 是一种没有状态的协议，也就是它并不知道用户是否已经登录验证过。这里我们把用户看成是客户端（可以是浏览器、Android、IOS等），客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求访问其他服务器接口的时候，还得再验证一下，否则的话用户就可以跳过登录页面，直接访问其他服务器接口，登录就失去了意义 传统身份验证方法Cookie+Session的存在主要是为了解决HTTP这一无状态协议下服务器如何识别用户的问题。当用户请求登录的时候，如果验证通过，在服务端创建一个session，session中记录一下登录的用户信息，然后把这个session的 sessionid 号发送给客户端，客户端收到以后把这个 sessionid 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候带着这个 Cookie ，这样服务端会根据 Cookie 里的sessionid恢复session，看看session中是否存有用户信息，如果是，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端创建一个守护程序定期的去清理过期的 Session 基于 Token 的身份验证方法使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 1、客户端使用用户名和密码请求登录2、服务端收到请求，去验证用户名与密码3、验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端4、客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里5、客户端每次向服务端请求资源的时候需要带着服务端签发的 Token6、服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 比起传统的身份验证方法，Token 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上 JWT实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header payload signature 中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc headerheader 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。 { &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot; } 上面的内容要用 Base64 的形式编码一下，所以就变成这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段： iss：Issuer，发行者 sub：Subject，主题 aud：Audience，观众 exp：Expiration time，过期时间 nbf：Not before iat：Issued at，发行时间 jti：JWT ID 比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。 { &quot;iss&quot;: &quot;ninghao.net&quot;, &quot;exp&quot;: &quot;1438955445&quot;, &quot;name&quot;: &quot;wanghao&quot;, &quot;admin&quot;: true } 使用 Base64 编码以后就变成了这个样子： eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ SignatureJWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。 header payload secret var encodedString = base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload); HMACSHA256(encodedString, &apos;secret&apos;); 处理完成以后看起来像这样： SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源 JWT库下载官网下载https://jwt.io/#libraries-io JJWT依赖&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt; &lt;/dependency&gt; 生成tokenimport io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import io.jsonwebtoken.impl.crypto.MacProvider; import java.security.Key; // We need a signing key, so we&apos;ll create one just for this example. Usually the key would be read from your application configuration instead. Key key = MacProvider.generateKey(); String compactJws = Jwts.builder() .setSubject(&quot;Joe&quot;) .signWith(SignatureAlgorithm.HS512, key) .compact(); 校验token1、判断JWT是否有效2、JWT中个数据是否正确，比如判断Subject是否为Joe try { Jwts.parser().setSigningKey(key).parseClaimsJws(compactJws); //OK, we can trust this JWT } catch (SignatureException e) { //don&apos;t trust the JWT! } 参考文件基于 Token 的身份验证(http://ninghao.net/blog/2834)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运输层]]></title>
      <url>%2F2016%2F10%2F11%2F%5B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%5D%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
      <content type="text"><![CDATA[概述运输层服务计算机网络最基本的问题: ● 两个实体怎样才能在一种会丢失或损坏数据的介质上可靠得通信 ● 控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复出来 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（Logic Communication）。通过逻辑，运行不同进程的主机好像直接相连一样，实际上这些主机也许位于地球的两侧，通过很多路由器及都中不同类型的链路相连 运输层协议实在端系统中而不是在网络路由器中实现的。 1、在发送方，运输层将接收到的来自发送应用程序的报文分成较小的块，并为每块加上一个运输层首部。在发送方端系统中，运输层将这些报文段传递给网络层，网络层再将其分装成网络层分组，并向目的地发送。 2、在接收方，网络层从数据报中提取出运输层报文段，并将该报文段向上交给运输层。运输层则处理接受到的报文段，使得接受方应用程序可应用该报文段中的数据 运输层TCP和UDP的分组称为报文段，网络层分组称为数据报 网络层协议叫ip，全程是网际协议，IP为主机之间提供了逻辑通信，IP的服务模型是尽力而为交付服务。他不确保报文段的交付，不保证报文段的按序交付，更不保证报文段中的数据完整性。所以IP成为不可靠服务。 ★★★ UDP提供的服务：进程间数据交付、差错检测（运输层最低限度的两个服务，也是UDP仅有的两个服务） TCP提供附加服务：提供可靠数据传输（流量控制，序号，确认，定时器等技术）、拥塞控制 多路复用与多路分解接收主机中的运输层并没有直接将数据交付给进程，而是通过一个中间的套接字来传递。接收主机上可能有多个套接字，每个套接字都有唯一的标识符。在运输层报文段设置几个字段，接收端检查这些字段并标识出接收套接字。 1、从源主机发送报文段 ● 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解 ● 从源主机的不同套接字中收集数据块，并为每个数据块分装上首部信息从而生成报文段，然后将报文段传递到网络的工作称为多路复用 2、目的主机接受报文段 ● 报文段达到目的主机，根据报文段上的端口号定位到相应进程的套接字（多路分解） ● 运输层收集套接字输出的数据形成运输层报文段（多路复用） 运输层多路复用的要求： ❶ 套接字有唯一标识符 ❷ 每个报文段有特殊字段（源端口、目的端口）来指示该报文段要交付的套接字 ● UDP套接字由一个包含目的IP地址和目的端口号的二元组来标识，如果两个UDP报文段有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字定向到相同的目的进程 ● TCP套接字由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识，两个不同源IP地址或或源端口号的TCP报文会被定向到两个不同的套接字 UDPUDP只是做了运输协议能够做的最少工作，除了多路复用/多路分解功能及一些轻型差错检测，它几乎没有对IP增加别的东西 问题：有些应用程序更适合用UDP，而不是提供可靠数据传输服务的TCP？ 答： ● 应用层能更好地控制要发送的数据和发送时间。应用层将数据交给UDP，UDP就会在数据上附上多路复用/多路分解所需的源端口号和目的端口号，及两个其他字段，并立即将其传递给网络层。而TCP有一个拥塞控制机制，当链路非常拥塞时，遏制运输层TCP发送方，同时TCP会重新发送报文段知道目的主机收到此报文并加以确认，而不管可靠交付时间需要多长。实时应用通常要求最快的发送速率，能容忍一些数据丢失 ● 无需连接确立。TCP在数据传输之前需要经过三次握手，UDP却不需要任何准备即可进行数据传输 ● 无连接状态。TCP需要在端系统中维护连接状态，连接状态包括接受和发送缓存、拥塞控制参数、序号与确认好的参数。UDP不维护连接状态 ● 分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8个字节的开销 ★★★ UDP应用可以实现可靠数据传输，通过在应用程序自身中建立可靠性机制（例如增加确认和重传机制来实现）。这会增加开发人员的工作，但应用程序可以进行可靠通信，而无需受制于TCP拥塞控制机制引起的传输速率约束。 UDP报文结构 UDP首部只有四个字段，每个字段由两个字节组成[源端口号、目的端口号、长度、校验和]，共8个字节，应用层数据占用UDP报文段的数据字段。 ● 源端口和目的端口是执行多路复用/多路分解的必备条件 ● 接受主机使用校验和来检查报文段是否存在差错 ● 长度字段包括首部在内的UDP报文长度，字节为单位 可靠数据传输的原理构建可靠数据传输协议 1、完全可靠信道上的可靠数据传输：rdt1.0 最简单的情况，底层信道是完全可靠的。 图3.9显示了rdt1.0发送方和接收方的有限状态机。初始状态用虚线表示。 ● rdt的发送方通过rdt_send(data)从高层接收数据，产生一个包含该数据的分组（make_pkt(data)）,并且将数据发送到信道中。状态回到等待状态。 ● 接收方，rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中取出数据(经extract(packet,data)动作)，并将数据上传给高层（通过deliver_data(data)动作） 2、具有比特差错信道上的可靠数据传输：rdt2.0 考虑你自己是怎样通过电话口述一条长消息：报文接受者听到、明白每句话都会说OK；如果听到依据含糊不清的话，他可能要求你重复那句话。这种口述消息协议使用了肯定确认（OK），否定确认（请重复一遍）。这些控制报文使得接收方可以让发送方知道哪些内容被正确接受，哪些内容有误需要重传。计算机网络中，基于这种重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议。 ARQ协议处理比特差错： ● 差错检测 ● 接收方反馈：肯定确认（ACK），否定确认（NAK） ● 重传 当rdt_send(data)事件发生时，发送方将产生一个包含待发送数据的分组(sndpkt)，然后经由udp_send(pkt)发送该分组，状态跳转到等待接收方的ACK或NAK分组。如果收到数据包且收到一个ACK，则发送方知道最近传输的分组已被正确接收，状态跳转到等待上层数据状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方的响应。 如果发送一个数据包出现差错，则发送方将会一直重传该数据包，直到接收到ACK。这种行为也成为停等协议 接收方当分组到达时，接收方根据分组是否受损回答ACK或NAK 缺陷：如果ACK或NAK分组受损，发送方无法知道是否正确接收了上一块发送的数据（如果发送数据包后没收到ACK或NAK，则状态一直停留在等待ACK或NAK中） 解决方法：当发送方收到含糊不清的ACK或NAK分组时，只需重新发送当前数据分组即可。但这会引入冗余分组，会造成接收方无法判断接收到的分组是新的还是一次重传。 rdt2.1解决了这个问题，在数据分组中添加一个序号字段，对于停等协议，1比特序号就足够了，前后接受的序号相同则代表是重传分组。 发送方初始状态处于等待来自上层的调用0状态。当事件rdt_send(data)发生时，生成一个序号为0的数据包，向信道发送数据，状态跳转到等待序号为0的数据的ACK或NAK。如果正确接收到一个数据包，但数据包受损或是NAK，则继续等待，直到接收到的数据包没有损坏而且是ACK，说明0号数据包已经被正常接收，状态跳转到等待发送数据包1的状态。之后同理。 在接收方，初始状态为等待数据包0的状态。如果收到的数据包破损，则向发送方发送一个NAK。或者你现在想收到序号为0的数据包，但发送过来一个序号为1的数据包，说明发送方重发了数据包1，则发送一个ACK。因为是重发，所以不需要提取数据包中的数据。如果正确接收到序号为0的分组，则提取出数据，传送给上层，并想发送方发送一个ACK，告知已经成功接收数据包0，状态跳转到等待接收序号为1的数据包。之后同理。 rdt2.2接收到受损的分组，发送一个对上次正确接受的分组的ACK。发送方接收到对同一个分组的两个ACK（冗余ACK），就知道接收方没有正确接收到跟在被确人两次的分组后面的分组。 当发送方处于等待来自上层的调用0的状态时，rdt_send(data)事件发生，生成一个序号为0的数据包，通过udt_send(sndpkt)将数据发送到信道。状态跳转到等待序号为0的数据包的ACK。如果接收到为受损的ACK数据包，状态跳转到等待发送序号为1的数据包的状态。如果收到受损的数据包，或数据包的序号不为0（确认的是之前的序号，则当前发送的数据包接收方没有正确被接收），则继续处于等待序号为0的数据包的ACK。之后同理。 在接收方，注意到初始化时oncethru = 0，如果发送方第一个数据包出现错误，则接收方一直将处于等待来自下层的0这个状态，不用发累计确认ACK。当接收到的数据包没有受损，而且刚好是等待的序号为0的分组，接收方提取出分组的数据，传递给上层，然后向发送方发送序号为0的ACK，通知发送方已经成功接受序号为0的分组，状态跳转到等待序号为1的数据包这个状态。如果之前的情况，向发送方发送序号为0的ACK出现损坏，则发送方会再次发送一个序号为0的数据包。这种情况下接收方会重新发送之前的确认包，告知发送方数据包已经接受，防止重复接受，接收方也就不需要提取数据包的消息。除了重发的情况，如果接受到破损数据，也将重新发送之前的确认包，接收方就知道确认包之后的数据没有被正确接受。之后又同理。 3.具有比特差错的丢包信道上的可靠数据传输：rdt 3.0 rdt2.2已经解决了发生丢包后该做些什么，通过检验和、序号、ACK分组和重传等方式。现在需要解决的问题是怎样检测丢包。 我们让发送方负责检测和恢复丢包。假定发送方传输一个数据分组，该分组丢失或该分组的ACK丢失，这样发送方收不到来自接收方的响应。如果发送方愿意等待足够长的时间以便确认分组已丢失，则只需重传该数据分组即可。 从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失、一个ACK丢失，还是该分组或ACK只是过度时延，所有的情况采取的动作都是同样的：重传。为了实现基于时间的重传机制，需要一个倒计数定时器，在一个给定的时间过期后，可中断发送方。 状态图：初始状态为等待来自上层的调用0状态，当事件rdt_send(data)发生时，生成一个序号为0的数据包，发送到信道，同时启动定时器，状态跳转到等待数据包0的ACK。如果正确无差错的ACK，则数据包0成功被接收，停止计时器，状态跳转到等待上次调用发送序号为1的数据包。若在等待ACK 0的时候，收到受损数据包，或者收到序列为1的ACK（说明当前发送的数据包没有成功接收），需要重传数据包，但先不发送，等到计数器超时后再发送（因为是基于定时器的重发机制），并且重新开启定时器，状态仍为等待ACK 0.在等待来自上层的调用1的时候，此时已经完成数据的接收，但为什么会收到回复？因为如果超时时间过短，会出现过早超时的情形，发送方间隔发送两个相同的数据包，同时连个数据包都得到了回应ACK，会选择接收第一个ACK，第二个则忽略。 流水线可靠数据传输允许发送方发送多个分组而无需等待确认，这种技术称为流水线。 ● 必须增加序号范围，每个传输的分组必须有一个唯一的序号 ● 协议的发送方和接收方必须缓存多个分组 ● 所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式，解决流水线的差错恢复有两种基本的方法：回退N步和选择重传 回退N步（GBN） [0，base-1]内的序号对应于已经发送并确认过的分组，[base，nextseqnum-1]内的序号对应于已经发送，但未被确认的分组。[nextseqnum，base+N-1]内的序号可用于那些要被立即发送的分组，其数据来自上层。 那些已经被发送但还未被确认的分组的序号范围可以看成是一个在序号范围内长度为N的窗口，并且随着协议的运行，该窗口在序好空间向前滑动，因此N常被称为窗口长度，GBN协议被称为滑动窗口协议 GBN发送方必须响应以下三种类型的事件： ● 上层的调用。当上层调用rdt_send()，发送方首先检查发送窗口是否已满。如果未满则创建一个分组将其发送，变量也响应的更新。如果窗口已满，发送方将数据返回给上层，通知上次该窗口已满，然后上层可能会过一会再试 ● ●]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法4笔记]]></title>
      <url>%2F2016%2F10%2F08%2F%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%5D%E7%AE%97%E6%B3%954%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[书本源代码http://algs4.cs.princeton.edu/code/ 算法与数据结构课程介绍 算法是解决问题的方法 数据结构是存储数据的方法 课程内容 第一部分内容： 基本数据类型（栈stack、队列queue、背包bag、并查集union-find、优先队列priority queue） 排序方法（快排quicksort、归并mergesort、堆排序heapsort、基数排序radix sorts） 查找（二叉排序树BST、binary search trees，红黑二叉排序树，red-black BST、哈希表hash table） 第二部分内容： 图算法（BFS、DFS、Prim、Kruskal、Dijkstra） 字符串（KMP、regular expressions，TST、Huffman、LZW） 高级算法（B-tree、suffix array，maxflow） 准备工作算法4 1.1 1.2 递归 递归总有一个最简单的情况——方法的第一条语句总是一个包含return的条件语句 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况 递归调用的父问题和尝试解决的子问题之间不应该有交集，比如两个子问题各自操作的数组部分是不同的 欧几里德算法算法描述计算两个非负整数 p和q的最大公约数：若q是0，则最大公约数是p；否则p除以q得到余数r，p和q的最大公约数即为q和r的最大公约数 实现保证p和q为非负，p和q的大小无要求 public static int gcd(int p, int q){ if(q == 0) return p; return gcd(q, p%q); } 判断一个数是否是素数 如果一个数只能被除了1和本身的数整除，那个这个数就是素数 遍历从2开始，不大于N的平方根，注意是&lt;= 2是最小的素数，小于2的数字肯定不是素数 public static boolean isPrime(int N){ if(N &lt; 2) return false; for(int i = 2; i*i &lt;= N; i++) if(N % i == 0) return false; return true; } 栈固定长度栈 public class FixedCapacityStack&lt;Item&gt;{ private Item[] items; //top指向栈顶元素后一位，top = 0表示空栈，也表示栈中元素个数 private Integer top; public FixedCapacityStack(Integer cap){ items = (Item[]) new Object[cap]; top = 0; } public void push(Item item){ items[top++] = item; } public Item pop(){ return items[--top]; } public Integer size(){ return top; } public boolean isEmpty(){ return top == 0; } public void traverse(){ for(int i = 0; i &lt; top; i++){ System.out.print(items[i] + &quot; &quot;); } System.out.println(); } } 算法1.1 下压（LIFO）栈（能够动态调整数组大小的实现） public class ResizingArrayStack&lt;Item&gt;{ private Item[] items = (Item[]) new Object[1]; //top指向栈顶元素后一位，top = 0表示空栈，也表示栈中元素个数 private Integer top = 0; public void push(Item item){ //栈满了 if(top == items.length){ resize(2*items.length); } items[top++] = item; } public Item pop(){ Item item = items[--top]; //避免对象游离 items[top] = null; //减少长度，使用率不会低于1/4 if(top &gt; 0 &amp;&amp; top == items.length/4) resize(items.length/2); return item; } public void resize(Integer length){ Item[] temp = (Item[]) new Object[length]; //赋值 for(int i = 0; i &lt; top; i++){ temp[i] = items[i]; } items = temp; } public Integer size(){ return top; } public boolean isEmpty(){ return top == 0; } public void traverse(){ for(int i = 0; i &lt; top; i++){ System.out.print(items[i] + &quot; &quot;); } System.out.println(); } } 算法1.2 下压堆栈（链表实现） public class Stack&lt;Item&gt; { private Node top = null; private Integer N = 0; private class Node{ //定义了节点的嵌套类 Item item; Node next; } public void push(Item item){ Node old = top; top = new Node(); top.item = item; top.next = old; N++; } public Item pop(){ Item item = top.item; top = top.next; N--; return item; } public Integer size(){ return N; } public boolean isEmpty(){ return N == 0;//或top == null } public void traverse(){ Node p = top; while(p != null){ System.out.print(p.item + &quot; &quot;); p = p.next; } System.out.println(); } } 队列算法1.3 先进先出队列 public class Queue&lt;Item&gt; { //队头 private Node first; //队尾 private Node last; //元素个数 private int N; private class Node{ private Item item; private Node next; } public void enqueue(Item item){ Node old = last; last = new Node(); last.item = item; last.next = null; //队列为空时处理first指针 if(isEmpty()) first = last; else old.next = last; N++; } public Item dequeue(){ Item item = first.item; first = first.next; //队列为空时处理last指针 if(isEmpty()) last = null; N--; return item; } public boolean isEmpty(){ return first == null; } public Integer size(){ return N; } public void traverse(){ Node p = first; while(p != null){ System.out.print(p.item + &quot; &quot;); p = p.next; } System.out.println(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IDEA在编辑时提示could not autowire]]></title>
      <url>%2F2016%2F10%2F08%2F%5BSSM%5DIDEA%E5%9C%A8%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%90%E7%A4%BAcould%20not%20autowire%2F</url>
      <content type="text"><![CDATA[在开发中我在applicationContext-dao.xml中加入了mapper扫描器 &lt;!--mapper扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.qianlv.ssmdemo.mapper&quot; /&gt; &lt;!--这里不用sqlSessionFactory是因为如果用会导致上面配置的dataSource失效--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; 但是在编辑一个Service中注入mapper会提示could not autowire，但是可以正常执行的。 public class ItemsServiceImpl implements com.qianlv.ssmdemo.service.ItemsService{ @Autowired ItemsMapperCustom itemsMapperCustom; public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception { return itemsMapperCustom.findItemsList(itemsQueryVo); } } 我们需要改一下IDEA的设置 将最右边的Serverity改为Warning 参考：http://blog.csdn.net/xlxxybz1314/article/details/51404700]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMVC-Spring-Mybatis整合]]></title>
      <url>%2F2016%2F10%2F07%2F%5BSSM%5DSpringMVC-Spring-Mybatis%E6%95%B4%E5%90%88%2F</url>
      <content type="text"><![CDATA[导入依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.apeius&lt;/groupId&gt; &lt;artifactId&gt;Demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--集中管理依赖版本号--&gt; &lt;properties&gt; &lt;junit.version&gt;4.10&lt;/junit.version&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt; &lt;jackson.version&gt;2.4.2&lt;/jackson.version&gt; &lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;httpclient.version&gt;4.3.5&lt;/httpclient.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;joda-time.version&gt;2.5&lt;/joda-time.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis.spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--Jackson Json处理工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;${druid.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;${httpclient.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--JSP相关--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;${jstl.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;${servlet-api.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;${jsp-api.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--时间操作组件--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;${joda-time.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--Apache工具组件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;${commons-lang3.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;${commons-io.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; githubhttps://github.com/rhapsody1290/SSM 查询用户列表定义EasyUIPage封装对应的easyUi需要的数据 public class EasyUIPage { private Long total; private List&lt;?&gt; rows; public Long getTotal() { return total; } public void setTotal(Long total) { this.total = total; } public List&lt;?&gt; getRows() { return rows; } public void setRows(List&lt;?&gt; rows) { this.rows = rows; } } controller@RequestMapping(value = &quot;list&quot;) @ResponseBody public EasyUIPage queryAll( @RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;) Integer pageSize) { EasyUIPage esayUIPage = userService.queryAllUser(pageNum,pageSize); return esayUIPage; } 编写userservice@Override public EasyUIPage queryAllUser(Integer pageNum, Integer pageSize) { PageHelper.startPage(pageNum, pageSize); List&lt;User&gt; users = userMapper.queryAllUser(); PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(users); EasyUIPage easyUIPage = new EasyUIPage(); //easyUIPage.setRows(users); easyUIPage.setRows(pageInfo.getList()); easyUIPage.setTotal(pageInfo.getTotal()); return easyUIPage; } 编写userMapperpublic List&lt;User&gt; queryAllUser(); userMapper对应的xml&lt;select id=&quot;queryAllUser&quot; resultType=&quot;User&quot;&gt; select * from tb_user &lt;/select&gt; 页面跳转合并★★★★★★//页面跳转合并 @RequestMapping(value = &quot;/page/{pageName}&quot;) public String toPage(@PathVariable(&quot;pageName&quot;) String pageName){ return pageName; } 添加用户日期格式转换SpringMVC默认不支持字符串转换成Date格式，可以采用SpringMVC自带的转换器，还有一种简单的方法： @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday; 需要导入依赖： &lt;!--时间操作组件--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;${joda-time.version}&lt;/version&gt; &lt;/dependency&gt; 添加失败使用try-catch @RequestMapping(value = &quot;/save&quot;) @ResponseBody public Map&lt;String, String&gt; save(User user){ Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); try{ Integer num = userService.addUser(user); if(num &gt; 0){ map.put(&quot;status&quot;,&quot;200&quot;); }else{ map.put(&quot;status&quot;,&quot;500&quot;); } }catch (Exception e){ map.put(&quot;status&quot;,&quot;500&quot;); } return map; } 导出excel视图除了可以是html、jsp、json等常见视图之外，还可以是excel，其他 poi依赖&lt;!--操作excel--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/dependency&gt; 导入编写好的Excel视图UserExcelView、Constants两个Java文件 声明excel视图&lt;bean name=&quot;userExcel&quot; class=&quot;cn.apeius.usermanage.view.UserExcelView&quot;/&gt; 控制器@RequestMapping(value = &quot;export/excel&quot;) public ModelAndView export(@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer pageNow, @RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;) Integer pageSize){ //1、查询需要导出的数据 EasyUIPage page = this.userService.queryAllUsers(pageNow,pageSize); //2、传递数据 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;userList&quot;,page.getRows()); mv.setViewName(&quot;userExcel&quot;);//定义到自定义的excel视图 return mv; } bean视图解析器数字越小优先级越高 &lt;!--定义视图解析器--&gt; &lt;bean class = &quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; 删除用户控制器@ResponseBody @RequestMapping(value = &quot;/delete&quot;) //springmvc会自动把逗号切割，变成一个数组 public Map&lt;String,String&gt; deleteById(@RequestParam(value = &quot;ids&quot;) Long[] ids){ Integer num = this.userService.deleteUserByIds(ids); Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); if(num &gt; 0){ map.put(&quot;status&quot;,&quot;200&quot;); }else{ map.put(&quot;status&quot;,&quot;208&quot;); } return map; } sql语句&lt;delete id=&quot;deleteUserByIds&quot;&gt; delete from tb_user where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/delete&gt; 通用mapper通用的增删改查操作 导入依赖&lt;dependency&gt; &lt;groupId&gt;com.github.abel533&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;2.3.4&lt;/version&gt; &lt;/dependency&gt; Mybatis配置文件方式在mybatis-config.xml中添加如下配置: &lt;plugin interceptor=&quot;com.github.abel533.mapperhelper.MapperInterceptor&quot;&gt; &lt;!--主键自增方法，默认值为MYSQL，详细说明请看文档--&gt; &lt;property name=&quot;IDENTITY&quot; value=&quot;MYSQL&quot;/&gt; &lt;!--通用mapper接口，多个通用接口用逗号隔开--&gt; &lt;property name=&quot;mappers&quot; value=&quot;com.github.abel533.mapper.Mapper&quot;/&gt; &lt;/plugin&gt; 通用mapper使用继承通用的Mapper,必须指定泛型public interface UserInfoMapper extends Mapper&lt;UserInfo&gt; { //其他必须手写的接口... } 泛型(实体类)的类型必须符合要求★★★★★ 表名默认使用类名,驼峰转下划线(只对大写字母进行处理),如UserInfo默认对应的表名为user_info。 表名可以使用@Table(name = “tableName”)进行指定,对不符合第一条默认规则的可以通过这种方式指定表名. 字段默认和@Column一样,都会作为表字段,表字段默认为Java对象的Field名字驼峰转下划线形式. 可以使用@Column(name = “fieldName”)指定不符合第3条规则的字段名 使用@Transient注解可以忽略字段,添加该注解的字段不会作为表字段使用（关联查询） 建议一定是有一个@Id注解作为主键的字段,可以有多个@Id注解的字段作为联合主键. 通用mapper使用public class UserMapperTest { private UserMapper mapper; @Before public void setUp() throws Exception { ApplicationContext ac = new ClassPathXmlApplicationContext( new String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext-mybatis.xml&quot;,&quot;applicationContext-tx.xml&quot;}); mapper = ac.getBean(UserMapper.class); } @After public void tearDown() throws Exception { } @Test public void testSelectOne() throws Exception { //创建User对象，设置的属性作为查询的约束 User user = new User(); user.setId(1L); //使用selectOne必须保证结果唯一，如果结果太多则会报错 System.out.println(mapper.selectOne(user)); } @Test public void testSelect() throws Exception { User record = new User(); //可以设置属性增加约束 List&lt;User&gt; users = mapper.select(record); for(User user : users) System.out.println(user); } @Test public void testSelectCount() throws Exception { User record = new User(); int count = mapper.selectCount(record); System.out.println(count); } @Test public void testSelectByPrimaryKey() throws Exception { //参数表示主键的值 System.out.println(mapper.selectByPrimaryKey(1L)); } @Test public void testInsert() throws Exception { User record = new User(); record.setUserName(&quot;踩雷&quot;); record.setName(&quot;bajie&quot;); record.setPassword(&quot;123456&quot;); record.setBirthday(new Date()); mapper.insert(record); } @Test public void testInsertSelective() throws Exception { //与testInsert的区别：只添加设置值得字段，其余让数据库默认，推荐！！！ User record = new User(); record.setUserName(&quot;李璇&quot;); record.setName(&quot;bajie&quot;); record.setPassword(&quot;123456&quot;); record.setBirthday(new Date()); mapper.insert(record); } @Test public void testDelete() throws Exception { User record = new User(); record.setName(&quot;xxxx&quot;); mapper.delete(record); } @Test public void testDeleteByPrimaryKey() throws Exception { mapper.deleteByPrimaryKey(66L); } @Test public void testUpdateByPrimaryKey() throws Exception { User record = new User(); record.setId(66L); record.setName(&quot;踩雷&quot;); mapper.updateByPrimaryKey(record); } @Test public void testUpdateByPrimaryKeySelective() throws Exception { //只更新设置的值，推荐！！！！！！！ User record = new User(); record.setId(66L); record.setName(&quot;踩雷&quot;); mapper.updateByPrimaryKeySelective(record); } @Test public void testExampleBasic(){ //进行复杂查询 Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andGreaterThanOrEqualTo(&quot;age&quot;,30); //添加and条件，密码为123456 criteria.andEqualTo(&quot;password&quot;,&quot;123456&quot;); List&lt;User&gt; users = mapper.selectByExample(example); for(User u : users) System.out.println(u); } @Test //SELECT AGE,NAME,UPDATED,USER_NAME USERNAME,BIRTHDAY,ID,CREATED,SEX,PASSWORD FROM tb_user // WHERE ( AGE &gt;= ? and NAME like ? ) or ( PASSWORD = ? and ID in(?,?) ) public void testExampleOr(){ //进行复杂查询，or Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andGreaterThanOrEqualTo(&quot;age&quot;,30); criteria.andLike(&quot;name&quot;,&quot;%xx%&quot;); Example.Criteria criteria12 = example.createCriteria(); //添加and条件，密码为123456 criteria12.andEqualTo(&quot;password&quot;,&quot;123456&quot;); List&lt;Object&gt; ids = new ArrayList&lt;Object&gt;(); ids.add(&quot;1&quot;); ids.add(&quot;2&quot;); criteria12.andIn(&quot;id&quot;,ids); //多个criteria之间是or的关系 example.or(criteria12); List&lt;User&gt; users = mapper.selectByExample(example); for(User u : users) System.out.println(u); } @Test public void testExampleSort(){ Example example = new Example(User.class); example.setOrderByClause(&quot;age desc,id desc&quot;); List&lt;User&gt; users = mapper.selectByExample(example); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[list转string[]]]></title>
      <url>%2F2016%2F09%2F30%2F%5BJava%5Dlist%E8%BD%ACstring%5B%5D%2F</url>
      <content type="text"><![CDATA[方法一：单个元素转换//ArrayList ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;aaa&quot;); array.add(&quot;bbb&quot;); array.add(&quot;ccc&quot;); //转化成Object数组 Object[] objs = array.toArray(); //新建数组 String[] strings = new String[array.size()]; //每个元素类型转换 int i = 0; for(Object obj : objs){ if(obj instanceof String){ strings[i++] = (String)obj; } } for(String s : strings){ System.out.println(s); } 方法二：整个转//ArrayList ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;aaa&quot;); array.add(&quot;bbb&quot;); array.add(&quot;ccc&quot;); String[] strings = new String[array.size()]; array.toArray(strings); for(String s : strings){ System.out.println(s); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java泛型]]></title>
      <url>%2F2016%2F09%2F30%2F%5BJava%5DJava%E6%B3%9B%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[泛型的基本应用 Jdk1.5的集合类希望你在定义集合时，明确表示你要向集合中装哪种类型的数据，无法加入指定类型以外的数据 如下例子，如果不给定参数类型，可以在集合类中加入任意类型的数据，但在取元素时必须由程序员强行转换数据类型，编译器不会报错，出现问题由程序员负责 ArrayList collection1 = new ArrayList(); collection1.add(1); collection1.add(1L); collection1.add(&quot;abc&quot;); 在指定参数后，泛型的基本用法如下，对不是给定类型的数据，编译会报错。另一个好处是取出数据后，不用对数据进行强制转换。 ArrayList&lt;String&gt; collection2 = new ArrayList&lt;String&gt;(); //collection2.add(1); //collection2.add(1L); collection2.add(&quot;abc&quot;); String string = collection2.get(0); 泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带类型说明的集合时会去除掉”类型”信息，使程序运行效率不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样 ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;(); System.out.println(collection1.getClass() == collection2.getClass());//True System.out.println(collection2.getClass() == collection3.getClass());//True 由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可 ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;(); collection3.getClass().getMethod(&quot;add&quot;,Object.class).invoke(collection3, &quot;abc&quot;); System.out.println(collection3.get(0));//abc collection3的参数类型是Integer，但用反射的方法跳过编译器，还是能够加入String类型的数据 泛型的优点 提高了我们程序的使用性.不需要在自己去做强转 将原来在运行阶段处理的问题，放到了编译阶段 提高安全性 泛型的术语ArrayList类定义和ArrayList类引用中涉及如下术语： 整个称为 ArrayList泛型类型 ArrayList中的E称为类型变量或类型参数 整个ArrayList称为参数化的类型 ArrayList中的Integer称为类型参数的实际类型参数或实际类型参数 ArrayList中的&lt;&gt;念typeof ArrayList称为原始类型 参数化类型与原始类型的兼容性 参数化类型可以引用一个原始类型，编译报告警告，例如 Collection&lt;String&gt; c = new Vector(); 原始类型可以引用一个参数化类型的对象，编译报告警告，例如 Collection c = new Vector&lt;String&gt;(); 参数化类型不考虑类型参数的继承关系不要认为String和Object有继承关系就不会报错 Vector v = new Vector();//错误 Vector v = new Vector();//错误 思考，下面的代码会报错误吗？ Vector v1 = new Vector&lt;String&gt;(); Vector&lt;Object&gt; v = v1; 答：不会，第一个语句，原始类型可以引用一个参数化类型的对象，第二个语句，参数化类型可以引用一个原始类型的对象，所以不会报错。 泛型的声明泛型可以声明在类上，可以声明在方法上，可以声明在接口上。声明在类上的泛型，在整个类的范围内都可以使用。声明在方法上的泛型，只能在方法上使用。 什么时候在方法上声明泛型？ 类上已经声明了泛型，但是在方法上我们不使用类上的泛型，而是自定义的一个，那么就可以在方法上声明，注意：在方法上声明时，泛型要定义在方法的返回值前面。 泛型中使用？通配符定义一个printCollection函数，参数是一个集合，类型参数是？通配符，这样可以将任何类型参数的集合作为参数传入，如ArrayList public static void printCollection(Collection&lt;?&gt; collection){ //System.out.println(collection.add(&quot;abc&quot;));//错误，因为它不知道自己未来匹配就一定是String System.out.println(collection.size());//没错，此方法与类型参数无关 for(Object object : collection){ System.out.println(object); } } 总结：使用？通配符可以引用其它各种参数化的类型，？通配符定义的变量主要用作引用，可以调用与参数化 无关 的方法，不能调用与参数化有关的方法 泛型中的 ? 通配符的扩展 &lt;? extends E&gt; 它是用来限定是E类型或是E的子类型. &lt;? super E&gt; 只能是E类型或E的父类型. 限定通配符的上边界 正确：Vector&lt;? extends Number&gt; x = new Vector(); 错误：Vector&lt;? extends Number&gt; x = new Vector(); 限定通配符的下边界 正确：Vector&lt;? super Number&gt; x = new Vector(); 错误：Vector&lt;? super Number&gt; x = new Vector(); 泛型集合的综合应用案例 —— 遍历HashMapHashMap结构 遍历的方式： 单独取出所有键 单独取出所有的值 键和值作为一个组合体，放在一个类中，这个类是Map.Entry 迭代Entry的方式遍历HashMap1、HashMap是不能直接迭代的，需要将它转换成Set集合，API如下： Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 2、Set的类型参数时Map.Entry，遍历 HashMap&lt;String,Integer&gt; hm = new HashMap&lt;String,Integer&gt;(); hm.put(&quot;zxx&quot;,19); hm.put(&quot;lis&quot;,18); //Set中放的东西是Entry,Entry也指定泛型 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; mes = hm.entrySet(); for(Map.Entry&lt;String,Integer&gt; me : mes) { System.out.println(me.getKey()+&quot; &quot;+me.getValue()); } 泛型方法（自定义泛型） 在返回值前加上&lt;T&gt;表示新定义一个类型，返回x+y有错误，因为不确定T类型是否有+这个方法，返回类型为传入类型的最大公共类型，比如传入Integer和Float，返回Numberic，传入Integer和String，返回Object123private static &lt;T&gt;T add(T x, T y)&#123; return null;&#125; 再来一个例子：12345private &lt;T&gt; void swap(T[] a, int i, int j )&#123; T tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125; 12swap(new String[]&#123;"abc","xyz","asd"&#125;,1,2);//正确//swap(new int[]&#123;1,2,3,4,5&#125;,1,2);//报错 泛型的实际类型只能是引用类型，不能是基本类型。T不能被基本类型替换。在案例add(1，2)中会自动装箱，而在swap案例中，数组本身就是Object，不会装箱。 除了在应用泛型时可以使用extends限定符，在定义泛型时也可以使用extends限定符,可以用来指定多个边界，如 &lt; V extends Serializable &amp; cloneable &gt; void method(){}，必须实现Serializable 和cloneable两个接口 普通方法、构造方法和静态方法中都可以使用泛型。 也可以用类型变量表示异常，称为参数化的异常，可以用于方法的throws列表中，但是不能用于catch子句中。例：用下面的代码说明对异常如何采用泛型：123456789101112private static &lt;T extends Exception&gt; sayHello() throws T&#123; try&#123; &#125;catch(Exception e)&#123; throw (T)e; &#125;&#125;``` 在泛型中可以同时有多个类型参数，在定义它们的尖括号中用逗号分，例如：```Javapublic static &lt;K,V&gt; V getValue(K key) &#123; return map.get(key); &#125; 我们在开发中，如果在类上已经声明了泛型，但是我们在方法上不使用类上声明的泛型，我们可以自己在方法上声明泛型。这个在方法上声明的泛型，只能在方法内使用。 如果声明在方法上，必须声明在方法的返回值前面。 泛型声明在类上，那么这个泛型可以在整个类内使用.123456789class Demo9 &#123; public static void main(String[] args) &#123; Student&lt;String&gt; s=new Student&lt;String&gt;(); s.a="hello"; System.out.println(s.print()); &#125;&#125; 123456789101112131415//在类上定义泛型//如果将泛型定义在类上，那么这个泛型可以在整个类内使用.class Student&lt;T&gt; &#123; T a; //泛型做为成员属性 public void show()&#123; System.out.println(a); &#125; public void show(T t)&#123; //泛型作用在方法. System.out.println(t); &#125; public T print()&#123; return a; &#125;&#125; 泛型练习题 自动将Object类型的对象转换成其他类型 public class Generic { public static void main(String[] args){ Object o = &quot;123&quot;; String s = convert(o); System.out.println(s); } public static &lt;T&gt; T convert(Object o){ return (T) o; } } 注意：T由返回类型决定 ##通过反射获取泛型的实际参数类型 Vector&lt;Date&gt; v1 = new Vector&lt;Date&gt;();通过获取v1的字节码来获取Vector的实际参数类型是不可能，因为编译器在编译后会去掉类型信息。但在已知框架中的确有这个应用，它是怎么实现的呢？ 通过变量是无法知道它的参数类型的，但是当把这个变量交给一个方法去使用的时候，方法可以获得它的参数列表，并且是泛型的形式。1234567891011121314public class GenericTest &#123; public static void main(String[] args) throws Exception&#123; //Vector&lt;Date&gt; v1 = new Vector&lt;Date&gt;(); Method applyMethod = GenericTest.class.getMethod("applyVector", Vector.class); Type[] types = applyMethod.getGenericParameterTypes(); ParameterizedType pType = (ParameterizedType)types[0]; System.out.println(pType.getRawType()); System.out.println(pType.getActualTypeArguments()[0]); &#125; public static void applyVector(Vector&lt;Date&gt; v1)&#123; &#125;&#125; 结果： class java.util.Vector class java.util.Date]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jave Web模型2和MVC模式]]></title>
      <url>%2F2016%2F09%2F07%2F%5BSpring%20MVC%5DJave%20Web%E6%A8%A1%E5%9E%8B2%E5%92%8CMVC%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[模型1和模型2介绍 Java Web应用开发中有两种设计模型，为了方便，分别称为模型1和模型2 模型1是通过链接方式进行JSP页面之间的跳转 方式直接，适合小型应用开发 但在中型和大型应用中，这种方式会带来维护上的问题 模型2是基于MVC模式，是Java Web应用的推荐架构 一个MVC模式的应用包括模型、视图 和控制器 3个模块 视图负责应用的展示，模型封装了应用的数据和业务逻辑，控制器负责接收用户输入，改变模型，以及调整视图的显示 Servlet 或者Filter 都可以充当控制器、Spring MVC和Struts1使用一个Servlet作为控制器，而Struts2 则使用一个Filter作为控制器 大部分采用JSP 页面作为应用的视图，当然也有别的技术 模型会采用一个JavaBean 来持有模型状态，并将业务逻辑放到一个Action类中。一个JavaBean必须拥有一个无参的构造器，通过get/set方法来访问参数，同时支持持久化 模型2应用 —— 产品信息保存 githubhttps://github.com/rhapsody1290/SpringMVC_study包名为cn.apeius.product 工程目录 其中红框内的为产品信息保存应用相关文件 ProductForm.jsp —— 填写产品信息表单 ProductForm.jsp文件放在WEB-INF下，不能通过URL直接访问 一个控制器可以对应多个action(url) 通过url：product_input.action指向控制器ControllerServlet，由控制器根据相应的action跳转到页面ProductForm.jsp 页面展示 JSP代码 &lt;!DOCTYPE HTML> &lt;html> &lt;head> &lt;title>Add Product Form&lt;/title> &lt;style type="text/css">@import url(css/main.css);&lt;/style> &lt;/head> &lt;body> &lt;div id="global"> &lt;form action="product_save.action" method="post"> &lt;fieldset> &lt;legend>Add a product&lt;/legend> &lt;p> &lt;label for="name">Product Name: &lt;/label> &lt;input type="text" id="name" name="name" tabindex="1"> &lt;/p> &lt;p> &lt;label for="description">Description: &lt;/label> &lt;input type="text" id="description" name="description" tabindex="2"> &lt;/p> &lt;p> &lt;label for="price">Price: &lt;/label> &lt;input type="text" id="price" name="price" tabindex="3"> &lt;/p> &lt;p id="buttons"> &lt;input id="reset" type="reset" tabindex="4"> &lt;input id="submit" type="submit" tabindex="5" value="Add Product"> &lt;/p> &lt;/fieldset> &lt;/form> &lt;/div> &lt;/body> &lt;/html> 表单的action为product_save.action，这个url会匹配到控制器ControllerServlet，调用相应的service方法完成产品保存工作，并完成页面的跳转，显示产品的详细信息 fieldset可将表单内的元素进行分组 推荐使用标签 &lt;label for = ‘指向的标签name’&gt;标签内容&lt;/label&gt;，点击标签焦点就定位在指向的标签 @import url(css/main.css)：css在web根目录下 main.css —— 样式文件#global { text-align: left; border: 1px solid #dedede; background: #efefef; width: 560px; padding: 20px; margin: 100px auto; } form { font:100% verdana; min-width: 500px; max-width: 600px; width: 560px; } form fieldset { border-color: #bdbebf; border-width: 3px; margin: 0; } legend { font-size: 1.3em; } form label { width: 250px; display: block; float: left; text-align: right; padding: 2px; } #buttons { text-align: right; } 灰色背景为一块 DIV，设置宽度560px，marigin：100px auto使 DIV 居中显示，页面下移100px；高度不用设置，内部标签自动会撑开；另，设置padding为20px，DIV向外扩展，此时灰色面积尺寸为602（加上边框） 字体verdana在小字上仍有结构清晰端整、阅读辨识容易等高品质的表现 怎样使得冒号对齐？关键点是使设置标签长度一致，并使标签内容右对齐；默认label是inline，长度设置无效，可采用如下两种办法： 方法一：使用inline-block来设置长度 form label { width: 250px; display: inline-block; text-align: right; } 方法二：使用block来设置长度 form label { width: 250px; display: block; float: left; /*使用block后label占用一行，使用float让输入框移上来*/ text-align: right; padding: 2px; /*不是关键*/ } 心得：DIV+CSS设计，外层DIV固定尺寸，内部元素相对外层进行设计，这个DIV为一个整体 Product类和ProductForm类Product.java —— 产品信息JavaBean Java规范中说要写入文件或是通过网络传输的对象必须是可序列化的，所以弄个标志接口Serializable 来标识一个类可以被序列化 Product类实现了java.io.Serializationi接口，其实例可以安全地将数据保存到HttpSession中 package cn.apeius.product.domain; import java.io.Serializable; public class Product implements Serializable { private static final long serialVersionUID = 748392348L; private String name; private String description; private float price; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } } ProductForm.java 表单类与HTML表单相映射，是后者在服务器端的代表 Product和ProductForm类似，是否有必要存在？表单对象会传递ServletRequest给其他组件，类似Validator，而ServletRequest是一个Servlet层的对象，不应当暴露给应用的其它层 表单类不需要实现Serialization接口，因为表单对象很少存在HttpSession中 package cn.apeius.product.form; public class ProductForm { private String name; private String description; private String price; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getPrice() { return price; } public void setPrice(String price) { this.price = price; } } ControllerServlet类★★★★★控制器的操作： 1、对URI处理获得action名 2、根据action，创建表单对象，数据校验，创建领域对象，并执行领域对象的业务逻辑，例如将其持久化到数据库 3、根据处理结果，跳转页面 url思考： product_input.action、product_save.acton对应一个Servlet url的形式可以采用模块+操作的形式，举个例子： 用户模块有login和logout操作，一个模块一个控制器 可以采用/user/login.action，/user/logout.action对应匹配规则为/user/*的Servlet 代码 package cn.apeius.product.servlet; import cn.apeius.product.domain.Product; import cn.apeius.product.form.ProductForm; import java.io.IOException; import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ControllerServlet extends HttpServlet { private static final long serialVersionUID = 1579L; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { process(request, response); } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { process(request, response); } private void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { /* 1、URI的形式为：/应用名/资源名，例如/app10a/product_input 2、一个Servlet可以对应多个action，本应用中访问/product_input.action和/product_save.action会进入ControllerServlet 3、这个Servlet命名为ControllerServlet，是遵循了一个约定：所有Servlet类的名称都带有Servlet后缀 */ //1、对URI处理获得action名 String uri = request.getRequestURI(); int lastIndex = uri.lastIndexOf("/"); String action = uri.substring(lastIndex + 1); //2、根据action，创建表单对象，数据校验，创建领域对象，并并执行领域对象的业务逻辑，例如将其持久化到数据库 if (action.equals("product_input.action")) { //不需要调用service类执行业务逻辑 } else if (action.equals("product_save.action")) { //创建表单对象 ProductForm productForm = new ProductForm(); //填充对象属性 productForm.setName(request.getParameter("name")); productForm.setDescription( request.getParameter("description")); productForm.setPrice(request.getParameter("price")); //创建模型 Product product = new Product(); product.setName(productForm.getName()); product.setDescription(productForm.getDescription()); try { product.setPrice(Float.parseFloat( productForm.getPrice())); } catch (NumberFormatException e) { } //调用service层的方法，保存产品，此处略 //将产品模型保存在session，以便后续页面使用 request.setAttribute("product", product); } //3、根据处理结果，跳转页面 String dispatchUrl = null; if (action.equals("product_input.action")) { dispatchUrl = "/WEB-INF/jsp/ProductForm.jsp"; } else if (action.equals("product_save.action")) { dispatchUrl = "/WEB-INF/jsp/ProductDetails.jsp"; } if (dispatchUrl != null) { RequestDispatcher rd = request.getRequestDispatcher(dispatchUrl); rd.forward(request, response); } } } ProductDetails.jsp —— 显示产品详细信息 ProductDetails.jsp 页面通过表达式语言（EL） 访问 HttpServletRequest 所包含的对象 代码 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Save Product&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt;@import url(css/main.css);&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;global&quot;&gt; &lt;h4&gt;The product has been saved.&lt;/h4&gt; &lt;p&gt; &lt;h5&gt;Details:&lt;/h5&gt; Product Name: ${product.name}&lt;br/&gt; Description: ${product.description}&lt;br/&gt; Price: $${product.price} &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 测试可以通过url： http://localhost:8080/SpringMVC_study/product_input.action 访问应用注意，可以将servlet控制器作为默认主页，使得在浏览器地址中仅输入域名+应用名，就可以访问到该Servlet控制器 &lt;jsp:forward page=&quot;/product_input.action&quot;/&gt; 缺点 业务逻辑代码 都写在了Servlet控制器中，随着应用复杂度增加而不断膨胀 哪些是业务逻辑？图中红框所示，根据不同的action，创建表单对象，数据校验，创建领域对象，并执行领域对象的业务逻辑；如果action多了，controller将会变得非常臃肿 解耦控制器代码githubhttps://github.com/rhapsody1290/SpringMVC_study包名为cn.apeius.product2 思路 将原来ControllerServlet中的业务逻辑提取出来 此时的Servlet变得更加专注，作用更像是一个dispatcher，即检查每个url，根据访问的action，调用具体的controller完成业务逻辑，并完成页面跳转，而非一个controller，因此改名为DispatcherServlet 工程目录 DispatcherServlet类一个DispatcherServlet必须能够做如下事情： 根据URI调用相应的action 实例化正确的控制器类 调用控制器对象的响应方法 转到一个视图（JSP页面） public class DispatcherServlet extends HttpServlet { private static final long serialVersionUID = 748495L; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { process(request, response); } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { process(request, response); } private void process(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //1、对URI处理获得action名 String uri = request.getRequestURI(); int lastIndex = uri.lastIndexOf("/"); String action = uri.substring(lastIndex + 1); //2、根据action，调用具体的controller处理，DispatcherServlet只起到分派功能 String dispatchUrl = null; if (action.equals("product_input.action")) { InputProductController controller = new InputProductController(); dispatchUrl = controller.handleRequest(request, response); } else if (action.equals("product_save.action")) { SaveProductController controller = new SaveProductController(); dispatchUrl = controller.handleRequest(request, response); } //3、根据处理结果，跳转页面 if (dispatchUrl != null) { RequestDispatcher rd = request.getRequestDispatcher(dispatchUrl); rd.forward(request, response); } } } Controller接口 面向接口编程的方式，在DispatcherServlet中使用Controller来引用具体实现类，并调用其handleRequest方法完成具体业务逻辑操作 public interface Controller { String handleRequest(HttpServletRequest request, HttpServletResponse response); } InputProductController类和SaveProductController类 两个Controller都实现了Controller接口，Controller接口只有handleRequest方法 Controller接口的实现类需要通过该方法访问到请求的HttpServletRequest和HttpServletResponse handleRequest返回结果为跳转文件路径 InputProductController类 直接返回输入产品的表单页面 public class InputProductController implements Controller { public String handleRequest(HttpServletRequest request, HttpServletResponse response) { return &quot;/WEB-INF/jsp/ProductForm.jsp&quot;; } } SaveProductController类 创建表单对象 创建模型 保存产品信息到数据库 返回跳转页面 public class SaveProductController implements Controller { public String handleRequest(HttpServletRequest request, HttpServletResponse response) { ProductForm productForm = new ProductForm(); //填充表单数据 productForm.setName( request.getParameter(&quot;name&quot;)); productForm.setDescription( request.getParameter(&quot;description&quot;)); productForm.setPrice(request.getParameter(&quot;price&quot;)); //创建模型 Product product = new Product(); product.setName(productForm.getName()); product.setDescription(productForm.getDescription()); try { product.setPrice(Float.parseFloat( productForm.getPrice())); } catch (NumberFormatException e) { } //将产品信息加入数据的代码，此处省略 request.setAttribute(&quot;product&quot;, product); return &quot;/WEB-INF/jsp/ProductDetails.jsp&quot;; } } 校验器 Web应用执行action时，很重要的步骤是进行输入校验 因为校验工作很重要，Java社区专门发布了标准对Java世界的输入检验进行标准化 githubhttps://github.com/rhapsody1290/SpringMVC_study包名为cn.apeius.product2 工程目录 红色部分有修改，增加了ProductValidator类 ProductForm.jsp展示输入校验的错误信息 ProductValidator ProductValidator类中有一个validate方法，保证产品的字符串非空，价格是一个合理的数字 validate返回一个包含错误信息的字符串列表，若返回一个空列表，则表示输入合法 在SaveProductController类中使用ProductValidator类 public class ProductValidator { public List&lt;String&gt; validate(ProductForm productForm) { List&lt;String&gt; errors = new ArrayList&lt;String&gt;(); String name = productForm.getName(); if (name == null || name.trim().isEmpty()) { errors.add(&quot;Product must have a name&quot;); } String price = productForm.getPrice(); if (price == null || price.trim().isEmpty()) { errors.add(&quot;Product must have a price&quot;); } else { try { Float.parseFloat(price); } catch (NumberFormatException e) { errors.add(&quot;Invalid price value&quot;); } } return errors; } } 新版的SaveProductController 首先对变淡类进行校验，如果校验发现有错误，则页面跳转到ProductForm.jsp；若没有错误，则创建一个Product对象 public class SaveProductController implements Controller { public String handleRequest(HttpServletRequest request, HttpServletResponse response) { ProductForm productForm = new ProductForm(); //填充表单属性 productForm.setName(request.getParameter("name")); productForm.setDescription(request.getParameter("description")); productForm.setPrice(request.getParameter("price")); //校验表单 ProductValidator productValidator = new ProductValidator(); List errors = productValidator.validate(productForm); if (errors.isEmpty()) { //创建领域对象Product Product product = new Product(); product.setName(productForm.getName()); product.setDescription(productForm.getDescription()); product.setPrice(Float.parseFloat(productForm.getPrice())); //没有校验错误，执行action方法 //保存产品信息到数据库的代码 //将product存入request域中，便于后面页面显示 request.setAttribute("product", product); return "/WEB-INF/jsp/ProductDetails.jsp"; } else { //保存错误信息，在后续页面显示 request.setAttribute("errors", errors); //保留表单信息，在后续页面显示 request.setAttribute("form", productForm); return "/WEB-INF/jsp/ProductForm.jsp"; } } } 新的ProductForm.jsp 用户提交了非法数据，页面将显示相应地错误信息 &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %> &lt;!DOCTYPE HTML> &lt;html> &lt;head> &lt;title>Add Product Form&lt;/title> &lt;style type="text/css">@import url(css/main.css);&lt;/style> &lt;/head> &lt;body> &lt;div id="global"> &lt;c:if test="${requestScope.errors != null}"> &lt;p id="errors"> Error(s)! &lt;ul> &lt;c:forEach var="error" items="${requestScope.errors}"> &lt;li>${error}&lt;/li> &lt;/c:forEach> &lt;/ul> &lt;/p> &lt;/c:if> &lt;form action="product_save.action" method="post"> &lt;fieldset> &lt;legend>Add a product&lt;/legend> &lt;p> &lt;label for="name">Product Name: &lt;/label> &lt;input type="text" id="name" name="name" tabindex="1"> &lt;/p> &lt;p> &lt;label for="description">Description: &lt;/label> &lt;input type="text" id="description" name="description" tabindex="2"> &lt;/p> &lt;p> &lt;label for="price">Price: &lt;/label> &lt;input type="text" id="price" name="price" tabindex="3"> &lt;/p> &lt;p id="buttons"> &lt;input id="reset" type="reset" tabindex="4"> &lt;input id="submit" type="submit" tabindex="5" value="Add Product"> &lt;/p> &lt;/fieldset> &lt;/form> &lt;/div> &lt;/body> &lt;/html>]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自动装箱与拆箱（张孝祥补充）]]></title>
      <url>%2F2016%2F09%2F06%2F%5BJava%5D%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
      <content type="text"><![CDATA[Integer与int比较 Integer.valueof() 返回的是Integer的对象 Integer.parseInt() 返回的是一个int的值 new Integer.valueof().intValue();返回的也是一个int的值 不同类型比较public static void main(String[] args) { String a = &quot;400&quot;; String b = &quot;400&quot;; //int和Integer比较，Integer自动拆箱，结果true System.out.println(Integer.parseInt(a) == Integer.valueOf(b)); } 相同类型比较单字节（-128-127）的Integer 比较是直接作为基本类型比较，否则是对象比较 Integer c = 100; Integer d = 100; Integer c1 = 200; Integer d1 = 200; System.out.println(c == d); //为true System.out.println(c1 == d1);//为false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IP地址与整数转换]]></title>
      <url>%2F2016%2F09%2F06%2F%5B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%5DIP%E5%9C%B0%E5%9D%80%E4%B8%8E%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[Java中byte, int的转换int -&gt; byte 可以直接使用强制类型转换: byte b = (byte) aInt; 这个操作是直接截取int中最低一个字节，如果int大于255，则值就会变得面目全非了 byte -&gt; int 这里有两种情况，一种是要求保持值不变，例如进行数值计算，可采用强制类型转换：int i = (int) aByte; 另一种是要求保持最低字节中各个位不变，3个高字节全部用 0填充，例如进行编解码操作 ，则需要采用位操作：int i = b &amp; 0xff; 理解★★★★★ Java中使用System.out.println(int);因为println中形参为int类型，会将字符类型强行转化为整型 byte b = (byte) 127; System.out.println(b); 字符类型转化为整型时有两种方式，一种是强转，高位用符号位填充；另一种是通过’与’的方式，高位用0填充 如果采用强转的方式，即int i = (int) aByte；Java默认byte是有符号的，int也是有符号的，强转后int的3个高字节全部用 符号位 填充，直接进行强转强转后数值不变，适合用于数值计算 采用位操作int i = bByte &amp; 0xff 时，bByte和0xff先分别转换成整型，再进行 ‘与’ 操作，得到一个32位整数，此时高位用0填充，常用于编码中 11111111 11111111 11111111 11101010 (a=-22) &amp; 00000000 00000000 00000000 11111111 (0xff) --------------------------------------------------------------------- = 00000000 00000000 00000000 11101010 (234) “字节变量 &amp; 0xff” 相当于将字节转换为无符号整型 Java中byte为有符号类型，占用一个字节，大小范围为-128~127，使用System.out.println(int)，首先会将byte强转为int类型，输出值保持不变；如果超过这个范围，会出现溢出，正数变负数，负数变正数 结果不变byte b = (byte) 127;//结果127，不变 因为127（0111 1111），首位为符号位，127为单字节正数最大，（-128）10000 0000为负数最小 正数变负数byte b = (byte) 128;//结果-128 1000 0000（128），在Java中byte为有符号数，一字节，首位为1，则这个数是负数，打印结果是-128 负数变正数byte b = (byte) -129;//结果127 -129（1 0111 1111），超出范围溢出，首先进行截断，结果为0111 1111，变为正数127 int InputStream.read() 读取字节流内部实现该函数返回一个int类型，范围从0至255，如果到达流末尾，返回-1。通过ByteArrayInputStream的源码可以看到是如何从byte转到int public synchronized int read() { return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1; } int &lt;-&gt; byte[]方法一：（推荐） //将整数转为一个byte数组，字节数组的低位是整型的低字节位 public static byte[] toByteArray(int iSource, int iArrayLen) { byte[] bLocalArr = new byte[iArrayLen]; for (int i = 0; (i < 4) && (i < iArrayLen); i++) { bLocalArr[i] = (byte) ((iSource >> 8 * i) & 0xFF); } return bLocalArr; } 移位 转成整型，与操作，取低字节 截断，转成byte 方法二： private static byte[] int2byte(int i) { byte[] bytes = new byte[4]; bytes[0] = (byte) (0xff &amp; i); bytes[1] = (byte) ((0xff00 &amp; i) &gt;&gt; 8); bytes[2] = (byte) ((0xff0000 &amp; i) &gt;&gt; 16); bytes[3] = (byte) ((0xff000000 &amp; i) &gt;&gt; 24); return bytes; } byte[] &lt;-&gt; int方法一：（推荐） // 将byte数组转为一个整数,字节数组的低位是整型的低字节位 public static int toInt(byte[] bRefArr) { int iOutcome = 0; byte bLoop; for (int i = 0; i < bRefArr.length; i++) { bLoop = bRefArr[i]; iOutcome += (bLoop & 0xFF)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring MVC学习笔记]]></title>
      <url>%2F2016%2F09%2F01%2F%5BSpring%20MVC%5DSpring%20MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Spring MVC简介 SpringMVC是一个基于MVC设计理念的web框架 Spring MVC通过一套MVC注解，让POJO成为处理请求的控制器，无需实现任何接口，同时SpringMVC还支持REST风格的URL请求 Spring MVC在框架设计、扩展性、灵活性等方面全面超越Struts、WebWork等MVC框架，成为MVC的领跑者 Spring MVC框架围绕DispatcherServlet这个核心展开，DispatcherServlet是Spring MVC框架的总导演、总策划，他负责截获请求并将其分派给相应地处理器处理 Spring MVC 整体架构 1、用户发起请求到控制器 DispatcherServlet (请求分派)2、DispatcherServlet 去 handlerMapping 查找 Handler 对应的 Handler（Handler可以理解成struts中的 action）3、HandlerMapper 返回 HandlerExecutorChain 执行链（包含两部分内容：Handler,拦截器集合）4、DispatcherServlet 调用 HandlerAdapter5、HandlerAdapter 调用 Handler6、Handler 处理具体的业务逻辑7、Handler 处理完业务逻辑之后，返回 ModelAndView 给 HandlerAdapter，其中的 View 是视图名称，Modal 是数据模型8、HandlerAdapter 将 ModelAndView 返回给 DispatcherServlet9、DispatcherServlet 通过 ModelAndView 中的视图名称在视图解析器中查找视图10、视图解析器返回真正的 View 视图对象11、渲染视图12、返回用户响应 Spring MVC快速入门★★★★★★githubhttps://github.com/rhapsody1290/SpringMVC_study 导入依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.apeius&lt;/groupId&gt; &lt;artifactId&gt;Demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 全局属性配置,定义变量 --&gt; &lt;properties&gt; &lt;!--用来定义war包名称--&gt; &lt;project.build.name&gt;tools&lt;/project.build.name&gt; &lt;!--用来定义资源文件的编码格式 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Spring MVC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--JSP相关--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; web.xml Spring MVC自带一个Dispatcher Servlet，要是用这个servlet，需要把它配置到部署描述符（web.xml文件） load-on-startup 元素是可选的，如果它存在，则在应用程序启动时 装载该servlet，并调用它的init方法；若它不存在，则在该servlet第一次请求 时进行加载 ★ DispatcherServlet将使用Spring MVC的诸多默认组件，在初始化时它会寻找WEB-INF目录下的配置文件，其命名规则为servletName-servlet.xml url-pattern为/时，拦截所有请求，包括静态资源[不拦截JSP]，此时需要设置annotation-driven和resources &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; spring-mvc的配置添加springmvc-servlet.xml spring-mvc 会默认去WEB-INF的目录下寻找${serlvet-name}-serlvet.xml的文件 所以我们把serlvetmvc的配置文件添加到web-inf的目录下，并且名字与 web.xml 中的servlet-name 相同 可以把配置文件放在应用程序的任意目录，用servlet定义的init-param元素，以便DispatcherServlet加载到该文件 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/config/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 自定义Handler（controller）★★★★★★ 在Spring2.5版本前，开发一个控制器的唯一方法是实现org.springframework.web.servlet.mvc.Controller接口，这个接口公开了一个handleRequest方法 其实现类可以访问请求的HttpServletRequest和HttpServletResponse 还必须返回包含视图路径 或视图路径和模的ModelAndView对象 Controller接口的实现类只能处理一个单一动作（Action）（一个Action对应一个Controller的实现类。调用其handleRequest方法），而一个基于注解的控制器可以同时支持多个请求处理的动作，并且无需实现任何接口 public class Hello implements Controller{ public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); //设置试图名称 mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;这是第一个springmvc程序&quot;); return mv; /*也可以直接 return new ModelAndView(&quot;hello&quot;,&quot;msg&quot;,&quot;这是第一个springmvc程序&quot;); */ } } 在springmvc-servlet.xml 中配置Handler 当DispatcherServlet收到/hello.do的请求时，自动构建控制器Hello，并调用其handleRequest方法，返回ModelAndView &lt;!--配置自定义Handler，name表示对应的访问路径--&gt; &lt;bean name=&quot;/hello.do&quot; class=&quot;cn.apeius.springmvc.controller.Hello&quot;/&gt; 配置HandlerMapping（非必须，需要注释）&lt;!--配置handlerMapping--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 配置handlerAdapter（非必须，需要注释）&lt;!--配置handlerAdapter--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 配置视图解析器 视图解析器可以不设置，但需填入完整路径，如 /WEB-INF/views/hello.jsp 视图解析器负责解析视图 可以通过在配置文件中定义一个ViewResolver来配置视图解析器 视图解析器配置有前缀 和后缀 两个属性，这样一来view路径将缩短，如只需填hello &lt;!--配置试图解析器 Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; &quot;/WEB-INF/jsp/test.jsp--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 定义视图 文件路径在/WEB-INF/views/hello.jsp hello.jsp中可以使用ModelAndView中的对象 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color=&quot;red&quot;&gt;${msg}&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 分析第一个案例的执行过程方法一：看日志导入日志 log4j.properties log4j.rootLogger=DEBUG,A1 log4j.logger.org.mybatis=DEBUG log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n 在web.xml中配置servlet 服务器开启的时候启动 &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 方法二：看源码在DispatcherServlet的doDispatch方法中打断点 精简之后的配置springmvc-servlet.xml &lt;!--配置自定义Handler，name表示对应的访问路径--&gt; &lt;bean name=&quot;/hello.do&quot; class=&quot;cn.apeius.springmvc.controller.Hello&quot;/&gt; &lt;!--配置试图解析器 Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; &quot;/WEB-INF/jsp/test.jsp--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 第一个注解程序★★★★★★基于注解的控制器有以下几个优点： 一个控制器类可以处理多个动作，而一个实现了Controller接口的控制器只能处理一个动作。这就允许将相关的操作都写在同一个控制器内，从而减少应用程序中类的数量 基于注解的控制器的请求映射不需要存储在配置文件中 ，使用RequestMapping注释类型，可以对一个方法进行请求处理 创建注解的步骤1、书写一个类，需要在类上面加上@Controller 用于指示Spring类的实例是一个控制器 Spring使用扫描机制 来找到应用程序中所有基于注解的控制器类 2、@RequestMapping映射一个请求与请求处理方法。一个采用@RequestMapping注释的方法将成为一个请求处理方法，访问相应的URL请求时调用。@RequestMapping使用后面有详解 @Controller public class AnnotationHello { @RequestMapping(value = &quot;/show1&quot;)//可以省略后缀 public ModelAndView test1(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;这是第一个注解程序&quot;); return mv; } } 3、在springmvc的配置文件中，去配置扫描包，使@Controller生效，和spring配置扫描包的方式一样 为了保证Spring能找到你的控制器，需要在Spring MVC的配置文件中声明spring-contextxmlns:context=&quot;http://www.springframework.org/schema/context&quot; 在元素中指定控制器类的基本包&lt;context:component-scan base-package=&quot;cn.apeius.springmvc.controller&quot;/&gt; 4、测试 http://localhost:8080/SpringMVC_study/show1.do 推荐使用的HandlerMapper和HandlerAdapter（什么意思？？） 使用注解驱动替换推荐的配置（什么意思？？） url-pattern为/时，拦截所有请求，包括静态资源，此时需要在springmvc-config.xml中设置annotation-driven和resources元素 annotation-driven 相当于注册了DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter两个bean，配置一些messageconverter，即解决了@Controller注解的使用前提配置 resource 元素则指示Spring MVC哪些静态资源需要单独处理（不通过DispatcherServlet）；如果没有annotation-driven，resource元素会阻止任意控制器被调用；若不使用resources，则不需要annotation-driven &lt;!--配置注解驱动，会默认加载HandlerMapping，HandlerAdapter--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 确保/css目录下所有文件可见--&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt; &lt;!--允许显示所有的.html文件--&gt; &lt;mvc:resources mapping=&quot;/*.html&quot; location=&quot;/&quot;/&gt; 或者使用mvc:default-servlet-handler，过滤掉所有的静态资源 &lt;!--过滤掉所有的静态资源，把静态资直接交给tomcat去处理--&gt; &lt;mvc:default-servlet-handler/&gt; 使用RequestMapping映射请求★★★★★★ 在SpringMVC中的众多Controller以及每个Controller的众多方法，请求是如何映射到具体的处理方法上？这个就是靠@RequestMapping完成的，他完成了一个请求与请求处理方法的映射 @RequestMapping既可以定义在类上也可以定义在方法上，请求映射的规则是：类上面的@RequestMapping.value + 方法上面的@RequestMapping.value 举个例子：—— 控制器： @Controller @RequestMapping(&quot;test&quot;) public class AnnotationHello { @RequestMapping(&quot;show1&quot;)//可以省略后缀 public ModelAndView test1(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;这是第一个注解程序&quot;); return mv; } } —— 访问URL： http://localhost:8080/SpringMVC_study/test/show1.do 五种映射标准URL映射 标准URL映射是最简单的一种映射，例如： @RequestMapping(“hello”)或 @RequestMapping（”/hello”）或 @RequestMapping(“value=”/hello””) 请求URL： http://localhost:8080/web应用名/hello.do value是RequestMapping的注释的默认属性，因此若只有唯一的属性，则可以省略属性名字，即以下两个标注含义相同： @RequestMapping(&quot;show1&quot;) @RequestMapping(value = &quot;show1&quot;) 但如果有超过一个属性时，就必须写入value属性名称 Ant风格的URL映射（通配符） 举例1： @RequestMapping(&quot;/test/*/show2&quot;) public ModelAndView test2(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;/test/*/show2&quot;); return mv; } 能匹配： /test/a/show2.do /test/abc/show2.do /test/show2.do 匹配不到 举例2： @RequestMapping(&quot;/test/**/show3&quot;) public ModelAndView test3(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;/test/**/show3&quot;); return mv; } 能匹配： http://localhost:8080/web应用名/test/a/show3.do http://localhost:8080/web应用名/test/b/a/d/show3.do 占位符映射 Url中可以通过一个或多个{xxxx}占位符映射,通过@PathVariable(“xxx”)绑定到方法的入参中 占位符映射让传递参数多了一种方式 例如： @RequestMapping(&quot;/test/{itemId}/{itemName}&quot;) public ModelAndView test4(@PathVariable(&quot;itemId&quot;) String itemId, @PathVariable(&quot;itemName&quot;) String itemName){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;itemId:&quot; + itemId + &quot; &quot; + &quot;itemName:&quot; + itemName); return mv; } URL: http://localhost:8080/SpringMVC_study/test/2011/iphone6s.do 结果： itemId:2011 itemName:iphone6s 限制请求方法映射若无指定method属性，则请求处理方法可以处理任意HTTP方法 只允许get请求访问 @RequestMapping(value = &quot;test5&quot;, method = RequestMethod.GET) public ModelAndView test5(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;限制只有get请求才能进入&quot;); return mv; } 只允post和get方法 @RequestMapping(value = &quot;test5&quot;, method = {RequestMethod.GET,RequestMethod.POST}) public ModelAndView test5(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;限制只有get、post请求才能进入&quot;); return mv; } 限制参数映射@RequestMapping(value = &quot;/test6&quot;,params = &quot;userId&quot;) public ModelAndView test6(@RequestParam(value=&quot;userId&quot;) String userId){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;限定请求参数，必须要有Userid这个信息；userid：&quot; + userId); return mv; } 请求中必须带userId参数 参数的规则如下 params=”userId”请求参数中必须包含userId params=”!userId”请求参数中不能包含userId params=”userId!=1”请求参数必须包含userId，但其值不能为1 params=”{“userId”,”name”}”必须包含userId和name参数 请求URL http://localhost:8080/SpringMVC_study/test6.do?userId=2 请求响应处理方法的数据绑定 一个请求URL与请求响应方法一一对应 数据绑定是将用户输入 与领域模型 相互绑定 类型总为String 的HTTP请求参数，可用于填充不同类型的对象属性 数据绑定使得form bean变成多余 绑定servlet内置对象非常简单，只需在参数中加入需要使用的内置对象，常用的有HttpServletRequest、HttpServletResponse、HttpSession @RequestMapping(value = &quot;/test7&quot;) public ModelAndView test7(HttpServletRequest request, HttpServletResponse response, HttpSession session){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;Servlet中的对象&quot;); System.out.println(request); System.out.println(response); System.out.println(session); return mv; } @PathVariable获取占位符中的参数 通过@PathVariable可以绑定占位符参数到方法参数中 路径变量的类型可以不是字符串 可以使用多个路径变量 @RequestMapping(&quot;/test/{itemId}/{itemName}&quot;) public ModelAndView test4(@PathVariable(&quot;itemId&quot;) String itemId, @PathVariable(&quot;itemName&quot;) String itemName){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;itemId:&quot; + itemId + &quot; &quot; + &quot;itemName:&quot; + itemName); return mv; } 特殊说明：不要省略@PathVariable中的参数 @RequestParam ★★★★★ 将请求参数传入到方法中，如http://localhost:8080/SpringMVC_study/test8?userId=qm @RequestParam 注解的参数类型不一定是字符串，可以是整型等其他 /** * required：必须要有这个参数 * defautlValue：默认值，如果defaultValue设置了值，那么required失效 * @param userId * @return */ @RequestMapping(value = "/test8") public ModelAndView test8(@RequestParam(value = "userId",required = true,defaultValue = "10") String userId){ ModelAndView mv = new ModelAndView(); mv.setViewName("hello"); mv.addObject("msg","userId：" + userId); return mv; } @CookieValue在Spring MVC中通过@CookieValue可以轻松获取cookie的值 Servlet中如何获取指定的cookie值 Cookie[] cookies = request.getCookies(); //对数组进行遍历，根据cookie中的name 来找到对应的cookie for(Cookie cookie : cookies){ if(&quot;abc&quot;.equals(cookie.getName())) cookie.getValue();//获取cookie中的值 } 使用@CookieValue @RequestMapping(value = &quot;/test9&quot;) public ModelAndView test9(@CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,&quot;JESSIONID：&quot; + JSESSIONID); return mv; } POJO对象绑定参数SpringMVC会将请求过来的 参数名 和POJO实体中的 属性名 进行匹配，如果名称一致，将把值填充到对象中 @RequestMapping(value = &quot;/test10&quot;) public ModelAndView test10(User user){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;hello&quot;); mv.addObject(&quot;msg&quot;,user); return mv; } User.java public class User { private String userName; private String password; public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } @Override public String toString(){ return userName + &quot; &quot; + password; } } 自定义复合对象类型User对象中有ContactInfo属性，Controller中的代码和第3点说的一致，但是，在表单代码中，需要使用“属性名(对象类型的属性).属性名”来命名input的name Model代码： public class ContactInfo { private String tel; private String address; public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } public class User { private String firstName; private String lastName; private ContactInfo contactInfo; public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public ContactInfo getContactInfo() { return contactInfo; } public void setContactInfo(ContactInfo contactInfo) { this.contactInfo = contactInfo; } } Controller代码： @RequestMapping("saysth.do") public void test(User user) { System.out.println(user.getFirstName()); System.out.println(user.getLastName()); System.out.println(user.getContactInfo().getTel()); System.out.println(user.getContactInfo().getAddress()); } 表单代码： &lt;form action="saysth.do" method="post"> &lt;input name="firstName" value="张" />&lt;br> &lt;input name="lastName" value="三" />&lt;br> &lt;input name="contactInfo.tel" value="13809908909" />&lt;br> &lt;input name="contactInfo.address" value="北京海淀" />&lt;br> &lt;input type="submit" value="Save" /> &lt;/form> Java的基本数据类型绑定 表单中input的name值和Controller的参数变量名保持一致，就能完成数据绑定，如果不一致可以使用@RequestParam注解 如果Controller方法参数中定义的是基本数据类型，但是从页面提交过来的数据为null或者””的话，会出现数据转换的异常。也就是必须保证表单传递过来的数据不能为null或””，所以，在开发过程中，对可能为空的数据，最好将参数数据类型定义成包装类型 Java的基本数据类型数组可以自动转换，如String[] interests，但是用户自定义User[] users不行，需要将User[]包装到一个UserForm中，通List操作 表单代码 &lt;form action=&quot;/demos/demo1.action&quot; method=&quot;post&quot;&gt; &lt;div&gt;姓名:&lt;/div&gt; &lt;div&gt;&lt;input name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div&gt;年龄:&lt;/div&gt; &lt;div&gt;&lt;input name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div&gt;收入:&lt;/div&gt; &lt;div&gt;&lt;input name=&quot;income&quot; value=&quot;100000&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div&gt;结婚:&lt;/div&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;isMarried&quot; value=&quot;true&quot; checked=&quot;checked&quot;/&gt;是 &lt;input type=&quot;radio&quot; name=&quot;isMarried&quot; value=&quot;false&quot;/&gt;否&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div&gt;兴趣:&lt;/div&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;听歌&quot; checked=&quot;checked&quot;/&gt;听歌 &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;书法&quot; checked=&quot;checked&quot;/&gt;书法 &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;看电影&quot; checked=&quot;checked&quot;/&gt;看电影 &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;提交表单&quot;/&gt;&lt;/div&gt; &lt;/form&gt; 测试： 集合List绑定 如果方法需要接受的list集合，不能够直接在方法中书写List，List的绑定，需要 将List对象包装到一个类中 才能绑定（如果List中的类型是Java自带的，则可以自动转换，如List &lt;Object&gt;，List，而List &lt;User&gt;不行） 与”自定义复合对象类型”数据绑定类似，但是UserForm对象的属性被定义成List，而不是普通自定义对象，所以在表单中需要指定List的下标 Spring会创建一个以最大下标值为size的List对象，List中的对象，只有在表单中对应有下标的那些才会有值，否则会为null 表单 &lt;form action=&quot;/SpringMVC_study/test11.do&quot;&gt; 用户1：&lt;input type=&quot;text&quot; name=&quot;users[0].userName&quot;/&gt;&lt;br/&gt; 用户2：&lt;input type=&quot;text&quot; name=&quot;users[1].userName&quot;/&gt;&lt;br/&gt; 用户3：&lt;input type=&quot;text&quot; name=&quot;users[2].userName&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;测试&quot;/&gt; &lt;/form&gt; 将List对象包装到一个类中 public class UserForm { private List users; public List getUsers() { return users; } public void setUsers(List users) { this.users = users; } } Action @RequestMapping(value = "/test11") public ModelAndView test11(UserForm userForm){ ModelAndView mv = new ModelAndView(); mv.setViewName("hello"); mv.addObject("msg","List集合"); for(User user : userForm.getUsers()){ System.out.println(user); } return mv; } 集合Set绑定Set和List类似，也需要绑定在对象上，而不能直接写在Controller方法的参数中。但是，绑定Set数据时，必须先在Set对象中add相应的数量的模型对象 Model代码： public class User { private String firstName; private String lastName; public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } } public class UserSetForm { private Set users = new HashSet(); public UserSetForm() { users.add(new User()); users.add(new User()); users.add(new User()); } public Set getUsers() { return users; } public void setUsers(Set users) { this.users = users; } } Controller代码： @RequestMapping(&quot;saysth.do&quot;) public void test(UserSetForm userForm) { for (User user : userForm.getUsers()) { System.out.println(user.getFirstName() + &quot; - &quot; + user.getLastName()); } } 表单代码： &lt;form action="saysth.do" method="post"> &lt;table> &lt;thead> &lt;tr> &lt;th>First Name&lt;/th> &lt;th>Last Name&lt;/th> &lt;/tr> &lt;/thead> &lt;tfoot> &lt;tr> &lt;td colspan="2">&lt;input type="submit" value="Save" />&lt;/td> &lt;/tr> &lt;/tfoot> &lt;tbody> &lt;tr> &lt;td>&lt;input name="users[0].firstName" value="aaa" />&lt;/td> &lt;td>&lt;input name="users[0].lastName" value="bbb" />&lt;/td> &lt;/tr> &lt;tr> &lt;td>&lt;input name="users[1].firstName" value="ccc" />&lt;/td> &lt;td>&lt;input name="users[1].lastName" value="ddd" />&lt;/td> &lt;/tr> &lt;tr> &lt;td>&lt;input name="users[2].firstName" value="eee" />&lt;/td> &lt;td>&lt;input name="users[2].lastName" value="fff" />&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/form> Map绑定Map最为灵活，它也需要绑定在对象上，而不能直接写在Controller方法的参数中 Model代码： public class User { private String firstName; private String lastName; public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } } public class UserMapForm { private Map users; public Map getUsers() { return users; } public void setUsers(Map users) { this.users = users; } } Controller代码： @RequestMapping(&quot;saysth.do&quot;) public void test(UserMapForm userForm) { for (Map.Entry&lt;String, User&gt; entry : userForm.getUsers().entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue().getFirstName() + &quot; - &quot; + entry.getValue().getLastName()); } } 表单代码： &lt;form action="saysth.do" method="post"> &lt;table> &lt;thead> &lt;tr> &lt;th>First Name&lt;/th> &lt;th>Last Name&lt;/th> &lt;/tr> &lt;/thead> &lt;tfoot> &lt;tr> &lt;td colspan="2">&lt;input type="submit" value="Save" />&lt;/td> &lt;/tr> &lt;/tfoot> &lt;tbody> &lt;tr> &lt;td>&lt;input name="users['x'].firstName" value="aaa" />&lt;/td> &lt;td>&lt;input name="users['x'].lastName" value="bbb" />&lt;/td> &lt;/tr> &lt;tr> &lt;td>&lt;input name="users['y'].firstName" value="ccc" />&lt;/td> &lt;td>&lt;input name="users['y'].lastName" value="ddd" />&lt;/td> &lt;/tr> &lt;tr> &lt;td>&lt;input name="users['z'].firstName" value="eee" />&lt;/td> &lt;td>&lt;input name="users['z'].lastName" value="fff" />&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/form> 数据绑定与表单标签库结合（表单不清空）★★★★★ 数据绑定可以将用户表单输入 绑定到一个领域模型，可以自动将HTTP请求参数默认的字符串 类型转化成不同类型 的对象属性，因此不再需要FORM类 数据绑定还有另外一个好处：当输入验证失败时，它会重新生成一个HTML表单。手工编写HTML代码时，必须记着用户之前输入的值，重新填充输入字段。有了Spring的数据绑定和表单标签后，它们会替你完成这些工作 第一步： 访问displayCustomerForm.do时创建一个领域对象并初始化属性，作为表单的默认显示，并添加到Model中，然后跳转到显示表单页面SignUpForm.jsp @RequestMapping(value = "displayCustomerForm", method = RequestMethod.GET) public String displayCustomerForm(ModelMap model) { Customer customer = new Customer(); customer.setName("qm"); customer.setAge(2333); model.addAttribute("customer", customer); return "SignUpForm"; } 第二步：使用表单标签库 commandName定义了模型的名称，其对象属性将用于填充所生成的表单 input标签中个path属性，将这个输入字段绑定到commandName指定对象的一个属性 errors标签可以显示一个特定的字段错误（path=”name”）或所有字段错误（path=”*”） &lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%> &lt;form:form commandName="product" action="product_save" method="post"> &lt;fieldset> &lt;legend>Add a product&lt;/legend> &lt;p class="errorLine"> &lt;form:errors path="name" cssClass="error"/> &lt;/p> &lt;p> &lt;label for="name">*Product Name: &lt;/label> &lt;form:input id="name" path="name" tabindex="1"/> &lt;/p> &lt;p> &lt;label for="description">Description: &lt;/label> &lt;form:input id="description" path="description" tabindex="2"/> &lt;/p> &lt;p class="errorLine"> &lt;form:errors path="price" cssClass="error"/> &lt;/p> &lt;p> &lt;label for="price">*Price: &lt;/label> &lt;form:input id="price" path="price" tabindex="3"/> &lt;/p> &lt;p class="errorLine"> &lt;form:errors path="productionDate" cssClass="error"/> &lt;/p> &lt;p> &lt;label for="productionDate">*Production Date: &lt;/label> &lt;form:input id="productionDate" path="productionDate" tabindex="4"/> &lt;/p> &lt;p id="buttons"> &lt;input id="reset" type="reset" tabindex="5"> &lt;input id="submit" type="submit" tabindex="6" value="Add Product"> &lt;/p> &lt;/fieldset> &lt;/form:form> 转换器和格式化（麻烦，建议使用joda-time，参考ssm整合部分）1、实现一种对象类型转换成另一种对象类型2、Converter是通用元件，可以在应用程序的任意层中使用3、Formatter则是专门为Web层设计的 Converter通过转换器，实现将输入的日期字符串转换成Date类型 实现Converter接口，源数据类型和目标数据类型可以自由指定 public class StringToDateConvert implements Converter { private String datePattern; public StringToDateConvert(String datePattern){ this.datePattern = datePattern; } public Date convert(String s) { SimpleDateFormat dateFormat = new SimpleDateFormat(datePattern); dateFormat.setLenient(false); try { return dateFormat.parse(s); } catch (ParseException e) { throw new RuntimeException("格式错误"); } } } Spring MVC配置文件中编写一个conversionService bean，Bean的类必须为org.springframework.context.support.ConversionServiceFactoryBean，同时配置converters属性，它将列出程序中所有订制的Converter &lt;bean id = &quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.apeius.convert.StringToDateConvert&quot;&gt; &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 表单输入 &lt;form action=&quot;/SpringMVC_study/test22.do&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; &lt;p&gt; &lt;label&gt;出生日期：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;birthday&quot;/&gt; &lt;/p&gt; &lt;p id = &quot;buttons&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试&quot;/&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; 字符串日期自动转换 @RequestMapping(value = &quot;/test22&quot;) public ModelAndView test22(@RequestParam(&quot;birthday&quot;) Date birthday){ return new ModelAndView(&quot;hello&quot;,&quot;msg&quot;,birthday); } Formatter1、Formatter的源类型必须是一个String，适合在Web层转换表单中用户的输入2、Converter源类型可以是任意类型，可以在任意层中使用 以下案例为将一个表单输入的String日期转换成Date： 编写一个实现org.springframework.format.Formatter接口的Java类 public class DateFormatter implements Formatter{ private String datePattern; private SimpleDateFormat simpleDateFormat; public DateFormatter(String datePattern){ this.datePattern = datePattern; simpleDateFormat = new SimpleDateFormat(datePattern); simpleDateFormat.setLenient(false); } /*利用Locale将String解析成目标类型（Date）*/ public Date parse(String text, Locale locale) throws ParseException { return simpleDateFormat.parse(text); } /*利用Locale将目标类型转换成String*/ public String print(Date date, Locale locale) { return simpleDateFormat.format(date); } } 配置conversionService bean，bean的类名必须为org.springframework.format.support.FormattingConversionServiceFactoryBean，注入属性formatters，它将列出程序中所有订制的Formatter &lt;!--配置conversionService bean--&gt; &lt;bean id = &quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.apeius.formatter.Date，它将列出程序中所有订制的Converter&quot;&gt; &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 测试同Converter 用Registrar注册Formatter注册Formatter的另一种方法是使用Registrar： 创建一个实现org.springframework.format.FormatterRegistrar接口的Java类 public class MyFormatterRegistrar implements FormatterRegistrar{ private String datePattern; public MyFormatterRegistrar(String datePattern){ this.datePattern = datePattern; } public void registerFormatters(FormatterRegistry registry) { registry.addFormatter(new DateFormatter(datePattern)); //注册更多的Formatter } } 在配置文件中注册Registrar &lt;!--配置conversionService bean--&gt; &lt;bean id = &quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;formatterRegistrars&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.apeius.formatter.MyFormatterRegistrar&quot;&gt; &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService 选择Convert还是Formatter Converter是一般工具，可以将一种类型转换成另一种类型，Converter既可用在Web层，也可用在其他层中 Formatter只能将String转换成另一种类型，Formatter适用于web层，将表单属性进行类型转换 因此在Spring MVC程序中，选择Formatter比选择Converter更合适 使用joda-time注解对日期格式转换SpringMVC默认不支持字符串转换成Date格式，可以采用SpringMVC自带的转换器，还有一种简单的方法： 注解可以加载javaBean上: @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birthday; 注解接在方法参数上： public void test(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) @RequestParam(&quot;date&quot;) Date date){ System.out.println(date); } 需要导入依赖： &lt;!--时间操作组件--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;${joda-time.version}&lt;/version&gt; &lt;/dependency&gt; 应用@Autowired和@Service进行依赖注入 将依赖注入到Spring MVC控制器的最简单方法是通过注解@Autowired到字段或方法 @Autowired private ProductService productService; 能被作为依赖注入的类必须声明@Service， @Service public class ProductServiceImpl implements ProductService { 在配置文件中还需添加一个元素来扫描依赖基本包 &lt;context:component-scan base-package=&quot;cn.apeius.product5.service&quot;/&gt; 验证器Validator（JSR spring5.0不通过）！！！如果一个程序中既有Formatter，又有Validator（验证器），那么在调用Controller期间，将会有一个或者多个Formatter 试图将字符串转成domain对象中个属性值，一旦转换成功，验证器 就会介入 Spring验证器验证的Product对象public class Product implements Serializable { private static final long serialVersionUID = 748392348L; private String name; private String description; private Float price; private Date productionDate; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Float getPrice() { return price; } public void setPrice(Float price) { this.price = price; } public Date getProductionDate() { return productionDate; } public void setProductionDate(Date productionDate) { this.productionDate = productionDate; } } 实现Validator接口 /*需要实现接口中supports和validate两个方法*/ public class ProductValidator implements Validator { /*如果验证器可以处理指定的Class，supports方法将返回true*/ public boolean supports(Class klass) { return Product.class.isAssignableFrom(klass); } /*validate方法验证目标对象，并将错误填入Errors对象*/ public void validate(Object target, Errors errors) { Product product = (Product) target; /* 1、给Errors对象添加错误最容易的方法是调用Errors对象的一个reject或rejectValue方法， 大多时候只传入一个错误码，Spring会在属性文件中查找错误码，获得相应的错误信息 void reject(String errorcode) void rejectValue(String field, String errorCode) 2、使用ValidationUtils类 if(firstName == null || firstName.isEmpty()) errors.rejectValue("price","xxx") 等效于 ValidationUtils.rejectIfEmpty("price"); */ ValidationUtils.rejectIfEmpty(errors, "name", "productname.required"); ValidationUtils.rejectIfEmpty(errors, "price", "price.required"); ValidationUtils.rejectIfEmpty(errors, "productionDate", "productiondate.required"); Float price = product.getPrice(); if (price != null && price < 0) { errors.rejectValue("price", "price.negative"); } Date productionDate = product.getProductionDate(); if (productionDate != null) { // The hour,minute,second components of productionDate are 0 if (productionDate.after(new Date())) { errors.rejectValue("productionDate", "productiondate.invalid"); } } } } 错误信息属性文件若想要从某个属性文件获取错误消息，则要通过声明messageSource bean告诉spring去那里查找这个文件 messageSource bean &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;/WEB-INF/resource/messages&quot;/&gt; &lt;/bean&gt; messages.properties productname.required.product.name=Please enter a product name price.required=Please enter a price productiondate.required=Please enter a production date productiondate.invalid=Invalid production date. Please ensure the production date is not later than today. price.negative=price should be positive Controller类 @Controller public class ProductController { private static final Log logger = LogFactory .getLog(ProductController.class); @RequestMapping(value = "/product_input") public String inputProduct(Model model) { model.addAttribute("product", new Product()); return "ProductForm"; } @RequestMapping(value = "/product_save") public String saveProduct(@ModelAttribute Product product, BindingResult bindingResult, Model model) {//BindingResult继承Errors接口 logger.info("product_save"); /*实例化Vaildator类，调用其validate方法*/ ProductValidator productValidator = new ProductValidator(); productValidator.validate(product, bindingResult); /*检验该验证器是否生成错误消息，需在BindingResult中调用hasErrors方法*/ if (bindingResult.hasErrors()) { FieldError fieldError = bindingResult.getFieldError(); logger.info("Code:" + fieldError.getCode() + ", field:" + fieldError.getField()); return "ProductForm"; } // save product here model.addAttribute("product", product); return "ProductDetails"; } } JSR 303验证Hibernate Validator 是 Bean Validation 的参考实现。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。 依赖&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt; &lt;/dependency&gt; Product类Prodcut类中的name和productionDate字段用JSR 303标注类型进行标注 public class Product implements Serializable { private static final long serialVersionUID = 78L; @Size(min=1, max=10) private String name; private String description; private Float price; @Past private Date productionDate; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Float getPrice() { return price; } public void setPrice(Float price) { this.price = price; } public Date getProductionDate() { return productionDate; } public void setProductionDate(Date productionDate) { this.productionDate = productionDate; } } Spring MVC 和 Struts2的区别 Struts2的入口是filter，Spring MVC的入口是Servlet，两者的实现机制不同 Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用；Spring MVC是基于方法设计的，参数绑定到方法的形参，并且只有一个方法可以使用 Struts2必须是多例的（Struts2传递到的参数绑定到类的属性，如果是单例会导致不同用户数据的冲突），Spring MVC默认是单例的，所以Spring MVC的性能比Struts2好 jsp 和 jstl 视图解析器userList.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1px&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt; 用户名&lt;/td&gt; &lt;td&gt; 密码&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt; &lt;tr&gt; &lt;td&gt; ${user.userName} &lt;/td&gt; &lt;td&gt; ${user.password} &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; controller代码 @RequestMapping(value=&quot;/test12&quot;) public ModelAndView test12(){ ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;userList&quot;); List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); for(int i = 0 ; i &lt; 3 ; i ++){ User user = new User(); user.setUserName(&quot;user_name&quot;+i); user.setPassword(&quot;123456&quot;); userList.add(user); } mv.addObject(&quot;userList&quot;, userList); return mv; } 使用ResponseBody输出JSON 在实际开发过程中json是最为常用的一种方式，所以Spring MVC提供了一种更为简便的方式输出数据，即使用@ResponseBody注解 需引入Jackson:Json处理工具包 使用步骤导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; 返回json数组 @RequestMapping(value=&quot;/test13&quot;) @ResponseBody public List&lt;User&gt; test13(){ List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); for(int i = 0 ; i &lt; 3 ; i ++){ User user = new User(); user.setUserName(&quot;user_name&quot;+i); user.setPassword(&quot;123456&quot;); userList.add(user); } return userList; } 返回单个json对象 @RequestMapping(value=&quot;/test14&quot;) @ResponseBody public User test14(){ User user = new User(); user.setUserName(&quot;user_name&quot;); user.setPassword(&quot;123456&quot;); return user; } 原理 忽略某个JaveBean的属性// 密码 @JsonIgnore private String password; @RequestBody使用@RequestBody可以将请求的json字符串转化POJO对象 传递json对象 @RequestMapping(value=&quot;/test15&quot;) @ResponseStatus(value= HttpStatus.OK) public void test15(@RequestBody User user){ System.out.println(user); } 传递json数组 @RequestMapping(value=&quot;/test16&quot;) @ResponseStatus(value= HttpStatus.OK) public void test16(@RequestBody List&lt;User&gt; users){ for(User user : users){ System.out.println(user); } } 文件上传添加依赖&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 定义文件上传解析器在springmvc的配置文件中，去定义文件上传的解析器 &lt;!-- 定义文件上传解析器 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 客户端编程&lt;form method=&quot;post&quot; action=&quot;/SpringMVC_study/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; 如果想要上传多个文件，在input元素中加入multiple属性： &lt;input type=&quot;file&quot; name=&quot;file&quot; multiple/&gt; MultipartFile接口上传到Spring MVC程序的文件会被包在一个MultipartFile对象中，具有以下方法： byte[] getBytes() #以字节数组形式返回文件的内容 String getContentType() # 返回文件的内容类型 InputStream getInputStream() # 返回一个InputStream，从中读取文件的内容 String getName() # 以多部分的形式返回参数的名称 String getOriginalFilename() # 返回客户端本地驱动器中个初始文件名 String getSize() # 以字为单位，返回文件的大小 boolean isEmpty() # 表示被上传的文件是否为空 void transferTo(File destination) # 将上传的文件保存到目标目录下 利用注解上传单文件@RequestMapping(value=&quot;/upload&quot;) public String upload(@RequestParam(&quot;file&quot;) MultipartFile multipartFile) throws Exception { if (multipartFile != null) { // multipartFile.getOriginalFilename() 获取文件的原始名称 multipartFile.transferTo(new File(&quot;d:\\tmp\\&quot; + multipartFile.getOriginalFilename())); } return &quot;redirect:/success.html&quot;; } 利用注解上传多文件@RequestMapping(value=&quot;/uploadMultipartFile&quot;) public String uploadMultipartFile(@RequestParam(&quot;files&quot;) MultipartFile[] multipartFiles) throws Exception { for(MultipartFile multipartFile : multipartFiles){ if (multipartFile != null) { // multipartFile.getOriginalFilename() 获取文件的原始名称 multipartFile.transferTo(new File(&quot;d:\\tmp\\&quot; + multipartFile.getOriginalFilename())); } } return &quot;redirect:/success.html&quot;; } 利用domain类上传文件★★★★★Product类中加入了新的属性 List images： public class Product implements Serializable { private static final long serialVersionUID = 74458L; @NotNull @Size(min=1, max=10) private String name; private String description; private Float price; private List&lt;MultipartFile> images; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Float getPrice() { return price; } public void setPrice(Float price) { this.price = price; } public List&lt;MultipartFile> getImages() { return images; } public void setImages(List&lt;MultipartFile> images) { this.images = images; } } 控制器： @RequestMapping(value = &quot;/product_save&quot;) public String saveProduct(HttpServletRequest servletRequest, @ModelAttribute Product product, BindingResult bindingResult, Model model) { List&lt;MultipartFile&gt; files = product.getImages(); List&lt;String&gt; fileNames = new ArrayList&lt;String&gt;(); if (null != files &amp;&amp; files.size() &gt; 0) { for (MultipartFile multipartFile : files) { String fileName = multipartFile.getOriginalFilename(); fileNames.add(fileName); File imageFile = new File(servletRequest.getServletContext() .getRealPath(&quot;/image&quot;), fileName); try { multipartFile.transferTo(imageFile); } catch (IOException e) { e.printStackTrace(); } } } // save product here model.addAttribute(&quot;product&quot;, product); return &quot;ProductDetails&quot;; } 进度条 HTML5 input元素的change事件，当input元素的值发生改变时，就会被触发 HTML5 在XMLHttpRequest对象中添加的progress事件，当异步使用XMLHttpRequest对象上传文件时，就会持续地触发progress对象，直到上传进度完成或取消。通过监听progress事件，可以监控文件上传操作的进度 UploadFile的domain类UploadFile类中包含一个MultipartFile属性，代表一个文件 public class UploadedFile implements Serializable { private static final long serialVersionUID = 72348L; private MultipartFile multipartFile; public MultipartFile getMultipartFile() { return multipartFile; } public void setMultipartFile(MultipartFile multipartFile) { this.multipartFile = multipartFile; } } Html5FileUploadController类 @Controller public class Html5FileUploadController { private static final Log logger = LogFactory .getLog(Html5FileUploadController.class); @RequestMapping(value = "/html5") public String inputProduct() { return "Html5"; } @RequestMapping(value = "/file_upload") public void saveFile(HttpServletRequest servletRequest, @ModelAttribute UploadedFile uploadedFile, BindingResult bindingResult, Model model) { MultipartFile multipartFile = uploadedFile.getMultipartFile(); String fileName = multipartFile.getOriginalFilename(); try { File file = new File(servletRequest.getSession().getServletContext().getRealPath("/file"), fileName); multipartFile.transferTo(file); System.out.println(file.getAbsolutePath()); } catch (IOException e) { e.printStackTrace(); } } } html5.jsphtml5.jsp的用户界面主要包含了一个名为progressBar的div元素，一个表单和另一个名为debug的div元素。progressBar用于展示上传进度，debug用于展示调试信息，表单中有一个类型为file的input元素的一个按钮，有一些注意点： 标识为files的input元素，它有一个multiple属性，用于支持多文件选择 这个按钮不是一个提交按钮，单击它不会提交表单，脚本是利用XMLHttpRequest对象来完成上传的 &lt;!DOCTYPE HTML> &lt;html> &lt;head> &lt;script> /*① * JavaScript代码执行的第一个件事是分配四个变量： * totalFileLength，totalUploaded，fileCount，filesUploaded。 * totalFileLength表示要上传的文件总长度，totalUploaded表示目前已经上传的字节数， * fileCount表示上传的文件数量，filesUploaded表示已经上传的文件数量 */ var totalFileLength, totalUploaded, fileCount, filesUploaded; function debug(s) { var debug = document.getElementById('debug'); if (debug) { debug.innerHTML = debug.innerHTML + '&lt;br/>' + s; } } /*② * 启动时将files input元素的change事件映射到onFileSelect函数， * 从本地目录选择了不同的文件，就会触发change事件； * 将按钮的click事件映射到startUpload函数，点击就执行上传操作 */ window.onload = function() { document.getElementById('files').addEventListener( 'change', onFileSelect, false); document.getElementById('uploadButton'). addEventListener('click', startUpload, false); } /*③ * 每当用户选择本地目录不同文件时就会调用该函数，计算fileCount和totalFileLength */ function onFileSelect(e) { var files = e.target.files; // FileList object var output = []; fileCount = files.length; totalFileLength = 0; for (var i=0; i&lt;fileCount; i++) { var file = files[i]; output.push(file.name, ' (', file.size, ' bytes, ', file.lastModifiedDate.toLocaleDateString(), ')' ); output.push('&lt;br/>'); debug('add ' + file.size); totalFileLength += file.size; } document.getElementById('selectedFiles').innerHTML = output.join(''); debug('totalFileLength:' + totalFileLength); } /*④ * 当用户调用Upload按钮时，就会调用startUpload函数，初始化totalUploaded和filesUploaded， * 随之调用uploadNext函数，上传下一个文件 */ function startUpload() { totalUploaded = filesUploaded = 0; uploadNext(); } /*⑤★★★★★ * 首先创建一个XMLHttpRequest和FormData对象，并将接下来要上传的文件添加到它的后面， * 随后，uploadNext函数将XMLHttpRequest对象的progress事件添加到onUploadProgress函数， * 并将load事件和error事件分别添加到onUploadComplete和onUploadFailed * 接下来打开一个服务器连接，并发出FormData * 在上传期间，会重复得调用onUploadProgress函数，让它有机会更新进度条 */ function uploadNext() { var xhr = new XMLHttpRequest(); var fd = new FormData(); var file = document.getElementById('files'). files[filesUploaded]; fd.append("multipartFile", file); xhr.upload.addEventListener( "progress", onUploadProgress, false); xhr.addEventListener("load", onUploadComplete, false); xhr.addEventListener("error", onUploadFailed, false); xhr.open("POST", "file_upload"); debug('uploading ' + file.name); xhr.send(fd); } /*⑥ * 在上传期间，会重复得调用onUploadProgress函数，让它有机会更新进度条 * 更新包括计算已经上传的总字节数比率，与选择文件的总字节数，得到上传比率 * 更新div元素的宽度 */ function onUploadProgress(e) { if (e.lengthComputable) { var percentComplete = parseInt( (e.loaded + totalUploaded) * 100 / totalFileLength); var bar = document.getElementById('bar'); bar.style.width = percentComplete + '%'; bar.innerHTML = percentComplete + ' % complete'; } else { debug('unable to compute'); } } /*⑦ * 上传完成时，调用onUploadComplete函数，这个事件处理函数会增加totalUploaded， * 即已经上传的文件容量，并添加filesUploaded * 如果所有文件已经上传完毕，弹出文件已经成功完成的提示 * 否则再次调用uploadNext */ function onUploadComplete(e) { totalUploaded += document.getElementById('files'). files[filesUploaded].size; filesUploaded++; debug('complete ' + filesUploaded + " of " + fileCount); debug('totalUploaded: ' + totalUploaded); if (filesUploaded &lt; fileCount) { uploadNext(); } else { var bar = document.getElementById('bar'); bar.style.width = '100%'; bar.innerHTML = '100% complete'; alert('Finished uploading file(s)'); } } function onUploadFailed(e) { alert("Error uploading file"); } &lt;/script> &lt;/head> &lt;body> &lt;h1>Multiple file uploads with progress bar&lt;/h1> &lt;div id='progressBar' style='height:20px;border:2px solid green'> &lt;div id='bar' style='height:100%;background:#33dd33;width:0%'> &lt;/div> &lt;/div> &lt;form> &lt;input type="file" id="files" multiple/> &lt;br/> &lt;output id="selectedFiles">&lt;/output> &lt;input id="uploadButton" type="button" value="Upload"/> &lt;/form> &lt;div id='debug' style='height:100px;border:2px solid green;overflow:auto'> &lt;/div> &lt;/body> &lt;/html> 文件下载 只要把图片或者HTML这样的静态资源放在应用程序的目录下，或者放在应用程序目录的子目录下，而不是放在WEB-INF下，Servlet、JSP容器就会将该资源发送到浏览器，在浏览器中打开正确的URL即可下载 有时候静态资源是保存在应用程序目录外，或者保存在某一个数据库，或者有时候需要控制它的访问权限，方式其他网站交叉引用它，必须通过编程发送资源到浏览器 文件下载概览 对请求处理方法使用void返回类型（如果不需要页面跳转的话），并在方法中添加HttpServletResponse参数 将响应的内容类型设为文件的内容类型，例如 response.setContentType(“application/pdf”)，如果不清楚内容类型，希望浏览器始终显示Save as对话框，则将它设为application/octet-stream 添加一个名为Content-Disposition的HTTP响应标题，并赋值attachment; filename=fileName，这里的fileName是默认文件名，应该出现在File Download对话框中 将文件发送到浏览器 范例1：隐藏资源 @RequestMapping(value="/resource_download") public String downloadResource(HttpSession session, HttpServletRequest request, HttpServletResponse response) { /* * 判断用户是否登录 */ if (session == null || session.getAttribute("loggedIn") == null) { return "LoginForm"; } /* * 判断文件是否存在，并将文件发送到浏览器 */ String dataDirectory = request.getSession(). getServletContext().getRealPath("/WEB-INF/data"); File file = new File(dataDirectory, "secret.pdf"); if (file.exists()) { response.setContentType("application/pdf"); response.addHeader("Content-Disposition", "attachment; filename=secret.pdf"); byte[] buffer = new byte[1024]; int len = 0; FileInputStream fis = null; OutputStream os = null; // if using Java 7, use try-with-resources try { fis = new FileInputStream(file); os = response.getOutputStream(); while((len = fis.read(buffer)) != -1){ os.write(buffer, 0, len); } } catch (IOException ex) { // do something, // probably forward to an Error page } finally { if (os != null) { try { os.close(); } catch (IOException e) { } } if (fis != null) { try { fis.close(); } catch (IOException e) { } } } } return null; } 范例2：防止交叉引用 通过编程控制，是的只有当refer标题中包含你的域名时 才发出资源，这样可以防盗链 但还是有办法下载到这些资源，但是绝对不会像以前那么容易得到 ImageController.java 如果直接在浏览器访问http://localhost:8080/SpringMVC_study/image_get/1返回404 not found 若加入注解 @RequestHeader String referer，直接访问，会导致调用getImage函数失败，根本无法进入函数体，也不进行refer是否为空的判断 通过images.html的超链接跳转，能访问到图片 @Controller public class ImageController { private static final Log logger = LogFactory.getLog(ImageController.class); @RequestMapping(value="/image_get/{id}", method = RequestMethod.GET) public void getImage(@PathVariable String id, HttpServletRequest request, HttpServletResponse response, @RequestHeader String referer) { if (referer != null) { String imageDirectory = request.getSession().getServletContext(). getRealPath("/WEB-INF/image"); File file = new File(imageDirectory, id + ".jpg"); if (file.exists()) { response.setContentType("image/jpg"); byte[] buffer = new byte[1024]; int len = -1; FileInputStream fis = null; OutputStream os = null; // if you're using Java 7, use try-with-resources try { fis = new FileInputStream(file); os = response.getOutputStream(); while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } } catch (IOException ex) { // do something here } finally { if (os != null) { try { os.close(); } catch (IOException e) { } } if (fis != null) { try { fis.close(); } catch (IOException e) { } } } } } } } images.html &lt;a href=&quot;image_get/1&quot;&gt;图片1&lt;/a&gt; 重定向与转发的区别 重定向发生在浏览器，由浏览器重新发出http请求，转发发生web服务器，请求在web服务器转发 重定向可以到外部网站，重定向只能访问WEB应用个资源 方法的返回值为string 如果方法的返回值是string类型，那么此时表示返回值是视图名称viewname 当进行转发时，没有数据的传递，不需要去书写ModelAndView，直接书写返回值是String 重定向的实现 在转发地址前加上redirect：完成重定向，不需要加应用名，直接写URI 转发到外部网站，例 return &quot;redirect:http://www.baidu.com&quot;; 不带参数传递： @RequestMapping(value = &quot;test19&quot;) public String test19(){ System.out.println(&quot;19&quot;); return &quot;redirect:/success.html&quot;; } 参数传递： /* * 1、重定向发生在浏览器，不能直接访问WEB-INF中的文件，书写的URL以/开头 * 2、需要传递的参数会自动拼接在url，本例中http://localhost:8080/SpringMVC_study/login.html?name=zhangsan */ @RequestMapping(value = "/test23") public ModelAndView test23(){ ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("redirect:/login.html"); modelAndView.addObject("name","zhangsan"); return modelAndView; } 数据传递 使用重定向的一个不便是无法轻松传值给目标页面，而采用转发可以将属性添加到Model，使得目标视图可以轻松访问。重定向经过客户端，Model中的一切都会在重定向时丢失 Spring 3.1版本以及更高版本可以通过Flash属性提供一种重定向传值的方法 使用Flash属性，必须在Spring MVC配置中有一个&lt;mvc:annotation-driven/&gt;，并且在方法上添加一个参数类型org.springframework.web.servlet.mvc.support.RedirectAttributes 使用方法：redirectAttributes.addFlashAttribute(“message”, “The product was successfully added.”);可以在转发页面访问到这个属性 转发的实现★★★★★★ Spring MVC中默认是转发，但返回的值默认是试图名称 如需要实现请求方法间跳转、页面跳转，在试图名称之前添加forward: 要访问的路径 @RequestMapping(value = &quot;/test24&quot;) public ModelAndView test24(){ System.out.println(24); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;forward:/test25&quot;); return mv; } @RequestMapping(value = &quot;/test25&quot;) public ModelAndView test25(){ System.out.println(25); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;forward:/login.html&quot;); return mv; } 数据传递 在每次调用请求方法时，都会创建Model类型的一个实例 若打算使用该实例，在请求方法参数中加入org.springframework.ui.Model参数，Spring MVC会在每一个请求方法被调用时创建一个Model实例，用于增加需要显示在视图中的属性 调用model.addAttribute来添加属性 JSP 页面、静态资源url地址（绝对路径和相对路径）Java Web容器中项目部署时的访问路径一般网站部署后，访问路径是不带项目名称的(为什么？一台主机的80端口就运行一个web程序，就没必要写项目名了)，比如最代码的服务器部署目录：/data/www/zuidaima/,在tomcat的conf/server.xml中host的访问配置是： &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context docBase=&quot;/data/www/zuidaima/&quot; path=&quot;/&quot;&gt; &lt;/Host&gt; 这样http的访问地址就是http://www.zuidaima.com/，而在eclipse jee集成tomcat版本本地开发时，eclipse的配置中path的配置是带有项目路径的，所以访问的时候除了要有端口外，还得带上项目路径，比如：http://localhost:8080/zuidaima/ 建议Path设置为空，这样本地debug时，所有访问路径和线上是一致的，不会出现线上访问404的情况 mvc开发中view层中访问路径的问题比如jsp中配置静态页面的地址： &lt;link href=&quot;/resource/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; 则该文件在项目的本地目录则是：/data/www/zuidaima/resource/css/bootstrap.min.css，则其通过http访问是 http://www.zuidaima.com/resource/css/bootstrap.min.css 其中/resource/css/bootstrap.min.css，以/开头则表示是相对于项目根目录而言，则本地访问中，根目录配置是： /data/www/zuidaima/ ，而web网页http访问中根路径是 http://www.zuidaima.com/ 但是如果出现 resource/css/bootstrap.min.css 的不以/开头的配置，则其访问路径是相对于当前访问目录而言的，比如在首页，这样配置，所有文件都是可以访问的，因为首页当前目录就是/根目录，但是如果访问比如: http://www.zuidaima.com/user/2318804493993984.html ，这样访问就404错误，http真实访问目录是： http://www.zuidaima.com/user/resource/css/bootstrap.min.css ，这样对照到服务器资源明显就是错误的路径，所以出现这样的配置： &lt;link href=&quot;../resource/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; ★★★此时仍相对于页面 http://www.zuidaima.com/user/2318804493993984.html 相当于http://www.zuidaima.com/user/../resource/css/bootstrap.min.css ，这样和http://www.zuidaima.com/resource/css/bootstrap.min.css 是一个作用，是否有点豁然贯通了 所以建议在web开发中，尽量是用相对路径的根目录配置法(通过相对路径，定位到根目录)，这样一目了然，http访问路径和服务器配置路径是一一对应的，当然在很多情况下，静态资源和动态请求是分开域名提供服务的，比如最代码的css是：http://static.zuidaima.com/resource/css/bootstrap.min.css， 这样如果不在同一个域名那只能通过绝对路径访问了。 ★★★URL访问出现404时的思路1、静态页面引入资源的时候建议使用相对路径的根目录配置法，相对于访问该JSP的控制器URL，其中”/“表示主机：端口。比如访问控制器/login/getPage，此时访问的资源路径为/css/bind.css &lt;link href=&quot;../css/bind.css&quot; rel=&quot;stylesheet&quot;&gt; 2、配置静态资源的路径，用 $lt;mvc:resources location=””,mapping=””/&gt;，相对根路径配置，其中 “/“ 表示主机：端口/应用名 &lt;mvc:resources location=&quot;/WEB-INF/resources/js/&quot; mapping=&quot;/js/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/resources/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/resources/image/&quot; mapping=&quot;/image/**&quot;/&gt; 3、若相对路径出现问题，可以使用绝对路径 ${pageContext.request.contextPath} &lt;!--使用绝对路径的方式引入CSS文件--&gt; &lt;link rel=&quot;stylesheet&quot;href=&quot;${pageContext.request.contextPath}/css/ueditor.css&quot; type=&quot;text/css&quot;/&gt; &lt;!--使用绝对路径的方式引入JavaScript脚本--&gt; &lt;script type=&quot;text/javascript&quot;src=&quot;${pageContext.request.contextPath}/js/ueditor.config.js&quot;&gt;&lt;/script&gt; Spring MVC静态资源处理优雅REST风格的资源URL不希望带 .html 或 .do 等后缀.由于早期的Spring MVC不能很好地处理静态资源，所以在web.xml中配置DispatcherServlet的请求映射，往往使用 .do 、 .xhtml等方式。这就决定了请求URL必须是一个带后缀的URL，而无法采用真正的REST风格的URL。 如果将DispatcherServlet请求映射配置为”/“，则Spring MVC将捕获Web容器所有的请求，包括静态资源的请求，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。 如何让Spring框架能够捕获所有URL的请求，同时又将静态资源的请求转由Web容器处理，是可将DispatcherServlet的请求映射配置为”/“的前提。由于REST是Spring3.0最重要的功能之一，所以Spring团队很看重静态资源处理这项任务，给出了堪称经典的两种解决方案。 先调整web.xml中的DispatcherServlet的配置，使其可以捕获所有的请求： &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面url-pattern的配置，所有URL请求都将被Spring MVC的DispatcherServlet截获。 采用 &lt;mvc:default-servlet-handler /&gt;在 springMVC-servlet.xml 中配置 &lt;mvc:default-servlet-handler /&gt;后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler ，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。 一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是”default”，则需要通过default-servlet-name属性显示指定： &lt;mvc:default-servlet-handler default-servlet-name=&quot;所使用的Web服务器默认使用的Servlet名称&quot; /&gt; 此时静态资源放在Web根目录下可以访问到 采用 &lt;mvc:resources /&gt; 推荐！&lt;mvc:default-servlet-handler /&gt;将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。而&lt;mvc:resources /&gt;更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。 首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方，如WEB-INF目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。 其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。 在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。 在springMVC-servlet中添加如下配置： &lt;mvc:resources location=&quot;/,classpath:/META-INF/publicResources/&quot; mapping=&quot;/resources/**&quot;/&gt; 以上配置将Web根路径”/“及类路径下 /META-INF/publicResources/ 的目录映射为/resources路径。假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。 假设WebRoot还拥有images/bg1.gif 及 js/test1.js，则也可以在网页中通过 /resources/images/bg1.gif 及 /resources/js/test1.js 进行引用。 配置案例: &lt;mvc:resources location=&quot;/WEB-INF/resources/js/&quot; mapping=&quot;/js/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/resources/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/resources/image/&quot; mapping=&quot;/image/**&quot;/&gt; 其他注解ModelAttribute每次调用请求响应方法时都会创建Model类的一个实例，可以在方法中添加一个Model类型的参数，也可以在方法中添加ModelAttribute注解类型 来访问Model实例 不加ModelAttribute先看一个没有使用@ModelAttribute的Controller方法： @RequestMapping(&quot;/save&quot;) public String save(User user) { user.setUsername(&quot;U love me&quot;); userService.save(user); return &quot;result&quot;; } 等价于： @RequestMapping(&quot;/save&quot;) public String save(Model model,int id,String username) { User user=new User(); //这里是通过反射从request里面拿值再set到user user.setId(id); user.setUsername(username); model.addAttribute(&quot;user&quot;,user); user.setUsername(&quot;U love me&quot;); userService.save(user); return &quot;result&quot;; } 其中User包含id和username两个私有属性,含有公共setter和getter方法 执行此方法时会将key为”user”(注意:这里即使参数名称是user1，key一样还是”user”)，value为user的对象加入到model 用途一： 带ModelAttribute注解的参数会将对象添加到Model中 与不加ModelAttribute的区别：带ModelAttribute注解会先从model去获取key为”user”的对象，如果获取不到会通过反射实例化一个User对象，再从request里面拿值set到这个对象，然后把这个User对象添加到model(其中key为”user”).使用了@ModelAttribute可修改这个key，不一定是”user”，此情况下，用与不用@ModelAttribute没有区别 /* 本例中将用newOrder键值将Order实例添加到Model对象中； 如果为定义键值，则键值将使用对象类型的名字，即用键值order将Order实例添加到Model中*/ public String summitOrder(@ModelAttribute("newOrder") Order order){ } 用途二： 标注一个非请求的处理方法，Spring MVC会每次在调用请求处理方法之前 调用带@ModelAttribute注解的方法 @ModelAttribute注解的方法可以返回一个对象或一个void类型，如果返回一个对象，则返回对象会自动加到Model中，如未指定键值，键值为对象类型的名字 若返回类型为void，若需要将对象放入Model中，则必须添加一个Model类型的参数，并自行将实例添加到Model中 @ModelAttribute public String test23(){ return new String(&quot;qm&quot;); } @RequestMapping public String test24(Model model){ Map&lt;String, Object&gt; map = model.asMap(); for(Map.Entry&lt;String,Object&gt; entry:map.entrySet()){ System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); } return &quot;forward:/WEB-INF/views/hello.jsp&quot;; } 国际化在这个全球化的时代，编写能够支持不同语言的国家和地区的应用程序 越来越重要 国际化应用程序的方式国际化应用程序的具体方式取决于有多少静态数据需要以不同的语言显示出来，这里有两种方式： 如果大量数据是静态的，就要针对每一个语言区域单独创建一个资源版本 如果静态数据有限，可以将文本元素，如元件标签和错误消息隔离成为文本，每个文本文件保存着一个语言区域的译文，随后应用程序会自动获取每一个元素 语言区域 Localejava.util.Locale类表示一个语言区域，一个Locale对象包含3个主要原件：language、country、variant language是最主要的部分 语言本身不能区分一个语言区域，比如讲英语的国家很多，但不同国家讲的英语有区别 variant是一个特定于供应商或特定于浏览器的代号，例如用WIN代表Windows 构造器Locale(String language) Locale(String language, String country) Locale(String language, String country, String variant) 创建一个中国所用的中文Locale对象 Locale locale = new Locale(&quot;zh&quot;,&quot;CN&quot;); 利用Locale类的静态方法来创建Local对象 Locale locale = Locale.CHINA; 利用getDefault方法返回计算机的语言区域 Locale locale = Locale.getDefault(); ResourceBundle读取属性文件区域属性文件值 国际化和本地化应用程序时，需要具备以下条件： 1. 将文本文件隔离成属性文件 2. 选择和读取正确的属性文件 1、将文本文件隔离成属性文件，可以利用如下工具：http://javawind.net/tools/native2ascii.jsp?action=transform ，给出以下两个语言区域属性文件，文件的格式为： basename_languageCode_countryCode MyResources_en_US.properties greetings=hello MyResources_zh_CN.properties greetings=\u4f60\u597d 2、使用ResourceBundle类来读取属性文件中的值 ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;MyResources&quot;, Locale.SIMPLIFIED_CHINESE); System.out.println(resourceBundle.getString(&quot;greetings&quot;));//你好 resourceBundle = ResourceBundle.getBundle(&quot;MyResources&quot;, Locale.US); System.out.println(resourceBundle.getString(&quot;greetings&quot;));//hello 3、在Spring MVC中，不直接使用ResourceBundle，而是利用messageSourceBean告诉Spring MVC要将属性文件保存在哪里 国际化Spring MVC应用程序在Spring MVC中，不直接使用ResourceBundle，而是利用messageSource bean告诉Spring MVC要将属性文件保存在哪里 配置 messageSource bean利用messageSource bean告诉Spring MVC要将属性文件保存在哪里 &lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"> //用两个基准名设置basenames的属性 &lt;property name="basenames" > &lt;list> &lt;value>/WEB-INF/resource/messages&lt;/value> &lt;value>/WEB-INF/resource/labels&lt;/value> &lt;/list> &lt;/property> &lt;/bean> 说明，上面定义的bean的类class有两种实现方式： 一种是ReloadableResourceBundleMessageSource，提供了定时刷新功能，允许在不重启系统的情况下，更新资源的信息；它在应用程序目录下搜索这些属性文件，即WEB目录下搜索 另一种是ResourceBundleMessageSource，它是不能重新加载的，如果在任意属性文件中修改了某一个属性的key或者value，那么要使修改生效，就必须重启JVM；属性文件必须放在类路径 下，即src目录下 还有一个说明，如果只有一组属性文件，则可以用basename属性代替basenames，像下面这样： &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;resource/messages&quot;/&gt; &lt;/bean&gt; 配置 语言区域解析器bean在Spring MVC中选择语言区域，可以使用语言区域解析器bean，它有几个实现，其中AcceptHeaderLocaleResolver是其中最容易使用的一个 &lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&quot;&gt; &lt;/bean&gt; 使用message标签使用message标签，要在使用该标签的JSP页面声明这个taglib指令： &lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt; 使用message标签： &lt;label for=&quot;description&quot;&gt;&lt;spring:message code=&quot;label.description&quot;/&gt;: &lt;/label&gt; 拦截器 HandlerExecutionChain是一个执行链，从HandlerMapping返回给DispatcherServlet 其中包含Handler对象和Interceptor（拦截器）对象 SpringMVC的拦截器定义了三个方法 preHandler：调用handler之前执行 postHandler：调用handler之后执行 afterCompletion：视图渲染完之后执行 拦截器执行过程 在执行Handler前会经过多个拦截器 每个拦截器的前置方法会按照拦截器的顺序依次执行 每个拦截器的后置方法会从后向前执行 每个拦截器的afterCompletion方法会从后往前执行 编写自定义拦截器 public class MyInterceptor implements HandlerInterceptor { //前置方法，如果返回值是false，后面的拦截器不会执行；如果返回true，执行后面的拦截器 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println("前置方法"); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println("后置方法"); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println("完成方法"); } } 配置拦截器&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--拦截器的路径--&gt; &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 配置多个拦截器&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--拦截器的路径--&gt; &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor1&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--拦截器的路径--&gt; &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor2&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 若配置1，2，3，4多个拦截器，如果3的前置方法返回false，则： 拦截器4的所有方法都不会执行 拦截器1，2的完成方法仍会去执行 1，2，3的后置方法不会执行 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java分层思想——Struts+Hibernate+接口编程的方式]]></title>
      <url>%2F2016%2F08%2F22%2F%5BJava%5DJava%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94Struts%2BHibernate%2B%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[接口编程 通过接口(使用动态代理)，就达到web层和业务层的解耦（业务层代码改动，web层不需要重写，达到解耦） 数据库有两张表，分别是users表和message表，对应的在业务层有Users对象、UsersService对象；Message对象、MessageService对象 在web层定义UsersServiceInter接口，业务层实现类UsersServiceImp；同理定义MessageServiceInter解耦，业务层实现类MessageServiceImp 定义一个基础接口BaseServiceInter，把一些通用的方法直接定义到该接口内，子接口继承 BaseService类实现BaseServiceInter接口，包含基础方法 留言板工程githubhttps://github.com/rhapsody1290/NoteBook 程序框架图 工程目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优雅代码解析]]></title>
      <url>%2F2016%2F08%2F18%2F%5BJava%5D%E4%BC%98%E9%9B%85%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[判断两个对象是否相等判断两个对象是否相等代码public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; if (id != null ? !id.equals(employee.id) : employee.id != null) return false; if (name != null ? !name.equals(employee.name) : employee.name != null) return false; if (email != null ? !email.equals(employee.email) : employee.email != null) return false; if (hiredate != null ? !hiredate.equals(employee.hiredate) : employee.hiredate != null) return false; return true; } 其中Employee有如下属性： public class Employee { private Integer id; private String name; private String email; private Date hiredate; } 代码解析判断两个对象是否相等的原则：对象类型相同，而且属性值全部相等 1、如果两个对象地址相等，两个对象一定相等 if( this == o ) return true; 2、两个对象类型不相等，两个一定不相等 if( getClass() != o.getClass() ) return false; 养成一个好习惯，在使用对象前判断对象o是否为空 考虑到如果比较对象o为空null，但当前对象this必然不为null，不相等，可以结合起来： if( o == null || getClass() != o.getClass() ) return false; 3、如果两个对象所有属性相等，两个对象才相等，否则判定为不相等 类型强转:Employee employee = (Employee) o; 如果属性不相等，return false if( !id.equals(employee.id) ) return false; 同样，需要判断id是否为空。如果id为空，不能使用equals作为判断方法，如下 if( id == null &amp;&amp; employee.id != null || id != null &amp;&amp; !id.equals(employee.id) ) return false; 使用三目运算符让代码更加优雅： if( id != null ? !id.equals(employee.id) : employee.id != null) return false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven安装及基础功能]]></title>
      <url>%2F2016%2F08%2F18%2F%5BMaven%5DMaven%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[Maven作用★★★★★ 统一开发规范与工具：项目目录结构，配置文件、单元测试代码位置；项目构建工具，自动完成那个编译、测试、打包等工作 统一管理 jar 包：Maven 中央仓库下载jar包 项目构建过程Maven是一个跨平台的项目管理工具，主要用于基于java平台的项目构建，依赖管理。 如图为项目构建的过程 Maven的安装与配置Maven的安装Jdk的情况 Jdk必须1.6以上的版本 从官网下载maven 从http://maven.apache.org/官网上下载最新版本的maven 设定path路径 1、配置M2_HOME的环境变量，新建一个系统变量：M2_HOME，路径是maven的安装目录 2、配置path环境变量，在path值的末尾添加&quot;%M2_HOME%\bin&quot; 建库 打开conf文件夹下的settings.xml文件，找到第53行，把注释去掉，修改成：&lt;localRepository&gt;D:\Maven\repo&lt;/localRepository&gt;，当然了，前提是在某个路径下，手动建立了一个名为 repo的文件夹，然后把本地仓库指向该路径。 利用命令行检查是否成功 mvn -v maven的约定src/main/java 存放项目的java文件 src/main/resources 存放项目的资源文件，如spring，hibernate的配置文件 src/test/java 存放所有的测试的java文件 src/test/resources 存放测试用的资源文件 target 项目输出位置 pom.xml 项目配置文件 maven的命令12345678910mvn archetype:create ：创建 Maven 项目mvn compile ：编译源代码mvn test-compile ：编译测试代码mvn test ： 运行应用程序中的单元测试mvn site ： 生成项目相关信息的网站mvn clean ：清除目标目录中的生成结果mvn package ： 依据项目生成 jar 文件mvn install ：在本地 Repository 中安装 jarmvn eclipse:eclipse ：生成 Eclipse 项目文件mvn -Dmaven.test.skip=true : 忽略测试文档编译 maven项目快速入门hello项目 在myeclipse建立一个项目Hello，删除自动生成的src文件，建立4个Source Folder文件夹，名字如图所示： 创建一个包cn.itcast.maven，并在该包下创建一个类 Hello 12345public class Hello&#123; public void hello()&#123; System.out.println(&quot;say hello&quot;); &#125;&#125; 在src/test/java中创建一个包cn.itcast.maven，创建一个测试类 HelloTest，测试类中调用Hello类 123456public class HelloTest&#123; public void testHello()&#123; Hello hello = new Hello(); hello.hello(); &#125;&#125; 编辑pom.xml文件 123456789101112131415161718&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用maven命令编译项目 123mvn compile命令行出现BUILD SUCCESS，表明编译成功 target文件夹的变化，可以看到编译后的文件全部放入到了target里。 clean，执行命令mvn clean,可以看到target的目录没有了。 test，执行mvn test命令，自动生成测试报告 说明： target/classes 存放编译后的类 target/test-classes 存放编译后的测试类 target/surefire-reports 存放测试报告 package，执行mvn package，完成打包工作 说明： target/classes 编译后的类的路径 target/test-classes 编译后的测试类的路径 target/surefire-reports 测试报告 target/maven-archiver 执行package的归档 Hello-0.0.1-SNAPSHOT.jar 执行完package命令后打成的jar包 Hellofriend项目 建立HelloFriend项目工程 建立cn.itcast.maven包及HelloFriend类 编辑HelloFriend类，引用之前编写的Hello类 123456public class HelloFriend &#123; public void helloFriend()&#123; Hello hello = new Hello(); hello.hello(); &#125;&#125; 编写pom.xml文件 12345678910111213141516171819202122232425&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;HelloFriend&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 执行mvn compile命令 执行这个命令的时候会出错，因为HelloFriend项目是建立在Hello项目基础之上的，但是现在工程中没有引入Hello.java这个类。所以会出错。 执行mvn clean install命令 1、 打开命令行 2、 把当前路径调节到Hello工程的根目录 3、 执行mvn clean install命令，把Hello整个工程放入到仓库中 如果执行成功，则会在仓库中看到 执行mvn package命令打包HelloFriend工程 可以看到成功以后，在target目录下多了一个jar包 该jar包为当前工程的jar包。 建立cn.itcast.maven包和测试类HelloFriendTest类 编辑HelloFriendTest类 1234567public class testHeloFriend &#123; public void testHelloFriend()&#123; HelloFriend helloFriend = new HelloFriend(); helloFriend.helloFriend(); &#125;&#125; 执行mvn package命令 上图中的”say hello”就是输出的结果。 maven的核心概念项目对象模型 说明： maven根据pom.xml文件，把它转化成项目对象模型(POM)，这个时候要解析依赖关系，然后去相对应的maven库中查找到依赖的jar包。 在clean，compile，test，package等阶段都有相应的Plug-in来做这些事情。 而这些plug-in会产生一些中间产物。 插件的位置在maven解压后的位置D:\Maven\apache-maven-3.0.5-bin\apache-maven-3.0.5有一个bin文件夹，里面有一个文件m2.config文件 set maven.home default ${user.home}/m2，其中该路径指明了仓库的存储位置。 其中settings.xml文件中, &lt;localRepository&gt;D:/Maven/repo&lt;/localRepository&gt; 这个说明了仓库中的位置。 D:\Maven\repo\org\apache\maven\plugins 这里的插件就是执行maven的各种命令所需要的插件。 maven坐标maven坐标的主要组成 groupId：定义当前maven项目属于哪个项目 artifactId：定义实际项目中的某一个模块 version：定义当前项目的当前版本 packaging：定义当前项目的打包方式 根据这些坐标，在maven库中可以找到唯一的jar包 依赖管理具体案例在3 Maven项目。 1、项目HelloSuperFriend依赖项目HelloFriend，项目HelloFriend依赖项目Hello。 2、在HelloSuperFriend依赖项中加入 &lt;dependency&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 3、能够编译通过，体现了依赖的传递性 继承管理★★★★★现有一A项目，B、C项目同时依赖A项目，这是需要用到继承 1、创建一个项目ParentJunit 2、ParentJunit添加一个Junit依赖 3、新建一个项目：HelloJunit，编写POM文件 12345&lt;parent&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;ParentJunit&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 4、只需要继承ParentJunit，所以junit就被引入到HelloJunit中了 仓库管理可以根据maven坐标定义每一个jar包在仓库中的存储位置。 大致为：groupId/artifactId/version/ 仓库的分类： 1、本地仓库 ~/.m2/repository/，每一个用户也可以拥有一个本地仓库 2、远程仓库 2.1 中央仓库：Maven默认的远程仓库，http://repo1.maven.org/maven2 2.2 私服：是一种特殊的远程仓库，它是架设在局域网内的仓库 2.3 镜像：用来替代中央仓库，速度一般比中央仓库快 jar查找顺序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven基础POM配置讲解]]></title>
      <url>%2F2016%2F08%2F18%2F%5BMaven%5DMaven%E5%9F%BA%E7%A1%80POM%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Maven坐标maven坐标的主要组成groupId：定义当前maven项目属于哪个项目 artifactId：定义实际项目中的某一个模块 version：定义当前项目的当前版本 packaging：定义当前项目的打包方式 jar、war 根据这些坐标，在maven库中可以找到唯一的jar包 其中groupId、artifactId、version是必须定义的，packaging是可选的（默认是jar） Maven模块概念1、Maven中，一个项目会被划分成很多模块，比如org.SpringFramework项目，对应的Maven模块有很多：spring-core、spring-context 2、groudId不应该只对应到公司（组织）的名称，而应定义到项目名 POM.xml&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; #这个是POM的版本号，现在都是4.0.0 的，必须得有，但不需要修改。 &lt;groupId&gt;com.smart&lt;/groupId&gt; #定义当前maven项目属于哪个项目 &lt;artifactId&gt;smart-demo&lt;/artifactId&gt; #定义实际项目中的某一个模块 &lt;version&gt;1.0&lt;/version&gt; #定义当前项目的当前版本 &lt;packaging&gt;war&lt;/packaging&gt; #定义当前项目的打包方式 &lt;name&gt;smart-demo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; #name、ur表示该项目的名称与 URL 地址，意义不大，可以省略。 &lt;dependencies&gt; #定义该项目的依赖关系 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; #表示与构建相关的配置，这里的 finalName 表示最终构建后的名称 smart-demo.war，这里的 finalName 还可以使用另一种方式来定义 &lt;finalName&gt;smart-demo&lt;/finalName&gt; &lt;/build&gt; &lt;/project&gt; 树形图表示POM.xml 可见，除了项目的基本信息（Maven 坐标、打包方式等）以外，每个 pom.xml 都应该包括： Lifecycle（生命周期） Plugins（插件） Dependencies（依赖） Lifecycle 是项目构建的生命周期，它包括 9 个 Phase（阶段）。 大家知道，Maven 是一个核心加上多个插件的架构，而这些插件提供了一系列非常重要的功能，这些插件会在许多阶段里发挥重要作用。 依赖Scope（作用域）★★★★★我们可以在 pom.xml 中定义一些列的项目依赖（构件包），每个构件包都会有一个 Scope（作用域），它表示该构件包在什么时候起作用，包括以下五种： compile：默认作用域，在编译、测试、运行时有效 test：对于测试时有效 runtime：对于测试、运行时有效 provided：对于编译、测试时有效，但在运行时无效（jar包在编译运行时有效，但在发布时由容器提供，不需要发布） system：与 provided 类似，但依赖于系统资源 可以一张表格表示： POM模版&lt;dependencies&gt; &lt;!-- JUnit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- AspectJ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Hibernate4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- for JPA, use hibernate-entitymanager instead of hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 以下可选 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-envers&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-proxool&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-infinispan&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt; &lt;version&gt;3.2.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;1.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为了让Hibernate使用代理模式，需要javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.18.1-GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.1.3.GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.spec.javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jboss-annotations-api_1.2_spec&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr&lt;/artifactId&gt; &lt;version&gt;2.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpa-2.0-api&lt;/artifactId&gt; &lt;version&gt;1.0.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- tomcat7.0.35 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt; &lt;version&gt;7.0.35&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Hibernate参考文献Maven 那点事儿http://my.oschina.net/huangyong/blog/194583]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate笔记]]></title>
      <url>%2F2016%2F08%2F12%2F%5BHibernate%5DHibernate%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Hibernate简介 Hibernate是对jdbc进行轻量级封装的ORM框架，位于数据持久层 ORM全称对象关系映射，框架在Java对象与关系数据库之间建立 映射，以实现 直接存取 Java对象 Hibernate参考资料Hibernate3.2API.chmhttps://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/Hibernate3.2API.chm hibernate3.2_reference.pdfhttps://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate3.2_reference.pdf ORM概述 传统数据持久化编程中，需要使用JDBC并配合大量的SQL语句。JDBC API与SQL语句夹杂在一起，开发效率都很低下 后来出现DAO模式，所有的JDBC API和SQL语句均移到了DAO层，但仍然需要编写大量的SQL语句 ORM框架的思路是通过配置文件，将Java对象 映射 到关系型数据库，自动生成SQL语句 并执行 举个例子，插入数据 时就是把POJO的各个属性拼装成SQL语句，保存进数据库；读取数据 时，就是用SQL语句读取数据库，然后拼装成POJO对象返回 为什么需要Hibernate？ 使用jdbc操作数据库，SQL语句编写比较麻烦 切换数据库时需要重写SQL语句 我们程序员希望不关注数据库本身，而是关注业务本身 引入Hibernate后，程序员在业务逻辑中使用hql语句（一种万能语句），Hibernate会自动完成数据库的操作，这种方式程序员只需关注业务本身，提高开发效率，程序也具有很好的移植性 学习Hibernate关键是1、Hibernate API 2、Hibernate核心配置文件 3、对象关系映射文件 Hibernate开发的三种方式 数据库中的表与java domain对象，通过Hibernate的对象关系映射文件关联起来，该文件会说明表和对象的关系，以及对象的属性与表的字段的对应关系 开发方式一：由Domain对象 ——&gt; Mapping ——&gt; DB 开发方式二：由DB开始，用工具生成mapping和Domain object（使用较多） 开发方式三：由映射文件开始 Hibernate快速入门（第二种开发方式）★★★★★★github代码https://github.com/rhapsody1290/Hibernate_Study 创建employee表 开发domain对象 建议domain对象 的名称就是对应表的首字母大写，同时 需要一个无参的构造函数(用于hibernate反射该对象) 应当有一个无业务逻辑的主键属性. 给每个属性提供 get/set 方法. 在domian对象中的属性，只有配置到了对象映射文件后，才会被hibernate管理. 属性一般是private范围 该pojo按照规范应当序列化，目的是可以唯一标该对象。同时可以在网络和文件上传输 public class Employee implements Serializable{ private Integer id; private String name; private String email; private java.util.Date hiredate; public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getHiredate() { return hiredate; } public void setHiredate(Date hiredate) { this.hiredate = hiredate; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 对象关系映射文件对象关系映射文件作用是用于指定domain对象和表的映射关系，该文件的取名有规范：domain对象.hbm.xml，一般我们放在和domain对象同一个文件夹下(包下) &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;cn.apeius.domain&quot;&gt; &lt;class name=&quot;Employee&quot; table=&quot;employee&quot;&gt; &lt;!--id文件用于指定主键属性--&gt; &lt;id name = &quot;id&quot; column=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;generator class=&quot;increment&quot;/&gt; &lt;/id&gt; &lt;!--对其他属性配置--&gt; &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;name&quot; length=&quot;255&quot; not-null=&quot;true&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;email&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;email&quot; length=&quot;255&quot; not-null=&quot;false&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;hiredate&quot; type=&quot;java.util.Date&quot;&gt; &lt;column name=&quot;hiredate&quot; length=&quot;255&quot; not-null=&quot;false&quot;/&gt; &lt;/property&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 细节 对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如 &lt;class table=&quot;?&quot; &gt; table值不配，则以类的小写做表名 &lt;property type=&quot;?&quot;&gt; type不配置，则hibernate会根据类的属性类型，选择一个适当的类型 手动配置我们的hibernate.cfg.xml文件该文件用于配置连接的数据库的类型、driver、用户名、密码、url等，同时管理对象关系映射文件。该文件的名称，我们一般不修改. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--hibernate常用改的配置见：hibernate.properties--&gt; &lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;!--显示出对应的SQL语句--&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;mapping resource=&quot;Employee.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 增加用户import cn.apeius.domain.Employee; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.Configuration; /** * Created by Asus on 2016/8/16. */ public class Main { public static void main(String[] args){ //1、创建configuration，该对象用于读取hibernate.ctf.xml，并完成初始化 Configuration configuration = new Configuration().configure(); //2、创建sessionFactory，这是一个会话工厂，是个重量级的对象，应当保证连接一个数据库SessionFactory是单例 SessionFactory sessionFactory = configuration.buildSessionFactory(); //3、创建session，相当于jdbc connection Session session = sessionFactory.openSession(); //4、在进行增加、删除、修改的时候使用事务提交 Transaction transaction = session.beginTransaction(); //添加一个雇员 Employee employee = new Employee(); employee.setName(&quot;qm1&quot;); employee.setEmail(&quot;qm1@126.com&quot;); employee.setHiredate(new java.util.Date()); //保存 session.save(employee); //提交 transaction.commit(); session.close(); } } 修改用户（先查后改）注意：SessionFactory是个重量级对象，应保证其实单例。在util包中封装了SessionFactory //获取一个会话 Session session = MySessionFactory.getInstatnce().openSession(); Transaction transaction = session.beginTransaction(); //修改用户1、获得要修改的对象2、修改 //load是通过主键属性，获取该对象实例 Employee employee = (Employee) session.load(Employee.class,2);//产生select .. where id = 2 employee.setName(&quot;钱明&quot;);//这句话会产生update语句 transaction.commit(); session.close(); 删除用户//获取一个会话 Session session = MySessionFactory.getInstatnce().openSession(); Transaction transaction = session.beginTransaction(); Employee employee = (Employee) session.load(Employee.class,2); session.delete(employee); transaction.commit(); session.close(); 模版（加入了异常回滚）★★★★★★public static void updateEmployee() { //获取一个会话 //Session session = MySessionFactory.getInstatnce().openSession(); Session session = HibernateUtil.getCurrentSession(); Transaction transaction = null; try{ transaction = session.beginTransaction(); //do... //修改用户1、获得要修改的对象2、修改 //load是通过主键属性，获取该对象实例 Employee employee = (Employee) session.load(Employee.class,3);//产生select .. where id = 2 employee.setName(&quot;钱明&quot;);//这句话会产生update语句 //出现异常 //int i = 9/0; transaction.commit(); }catch (Exception e){ if(transaction != null){ transaction.rollback(); } throw new RuntimeException(e.getMessage()); }finally { //关闭session if(session != null &amp;&amp; session.isOpen()){ session.close(); } } } SessionFactory单例 SessionFactory是个重量级对象，在开发中保证只有一个SessionFactory 一个数据库对应一个SessionFactory对象 //单例模式 public class MySessionFactory { private MySessionFactory(){} private static class HoldClass{ private static final SessionFactory instance = new Configuration().configure().buildSessionFactory(); } public static SessionFactory getInstatnce(){ return HoldClass.instance; } } Maven下载各数据库JDBC及Hibernate配置文件各数据库连接配置与maven依赖安装http://blog.163.com/luowei505050@126/blog/static/119907206201210223827126/ Hibernate切换数据库★★★★★ 使用Hibernate自动完成domain ——&gt; 映射文件 ——&gt; 表的工作 重新配置Hibernate数据库，以sqlserver2000为例 增加属性hibernate.hbm2ddl.auto create : 当我们的应用程序加载hibernate.cfg.xml [ new Configuration().config(); ]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!! update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新. create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致 在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置， 修改主键生成策略 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--hibernate常用改的配置见：hibernate.properties--&gt; &lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;net.sourceforge.jtds.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:jtds:sqlserver://localhost:1433/hibernate&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;sa&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;sa&lt;/property&gt; &lt;!--显示出对应的SQL语句--&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!--让hibernate自动创建表 create:如果没有这张表则创建--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;mapping resource=&quot;Employee.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; Hibernate的核心类和接口★★★★★★★★★★ Configuration 类 读取hibernate.cfg.xml 加载hibernate的驱动、url、用户.. 管理对象关系映射文件 &lt;mapping resource=&quot;&quot;&gt; 管理hibernate配置信息 SessionFactory （会话工厂） 可以缓存sql语句和数据(称为session级缓存)!! 是一个重量级的类，因此我们需要保证一个数据库，有一个SessionFactory 如果某个应用访问多个数据库，则要创建多个会话工厂，一个数据库一个会话工厂实例 通过SessionFactory接口可以获得Session实例，有两种方式： openSession() 是获取一个新的session getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session，这样更利于事务控制 使用 getCurrentSession 需要配置 hibernate.cfg.xml中配置①如果使用本地事务（jdbc事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;②如果使用全局事务（jta事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt; 如何选择①如果需要在同一线程中，保证使用同一个Session，则使用getCurrentSession()②如果在一个线程中，需要使用不同的Session,则使用opentSession() 通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭 如果是通过getCurrentSession()获取sesssion,进行查询需要事务提交. 使用同一个Session案例 在一个http请求中，需要同时进行操作、更新、删除等操作，三个操作在不同service中进行，但要将三个操作在一个事务中进行控制。三个service分别会调用hibernate，使用getCurrentSession，可以将三个操作在一个事务中进行（http请求只要不结束，就看成一个线程） 本地事务与全局事务 本地事务：增对一个数据库的事务 全局事务：跨数据库的事务（JTA）。以银行转账为例，需要在农行账户中增加10元，在工行账户中减去10元，涉及到多个数据库中的事务 session接口的理解 Session(会话)接口的理解：SessionFactory常驻内存，每次连接数据库会化工厂建立与数据库的session，图中横线就是一个session。 如何查看session是否关闭：查看数据库连接端口是否关闭，如mysql 3306端口是否关闭 session接口它的主要功能和作用是: Session一个实例代表与数据库的一次操作(当然一次操作可以是crud组合) Session实例通过SessionFactory获取，用完需要关闭 Session是线程不同步的(不安全),因此要保证在同一线程中使用,可以用 getCurrentSessiong() Session可以看做是持久化管理器,它是与持久化操作相关的接口 Session查询详解★★★★★★ 如果查询不到数据，get 会返回 null,但是不会报错, load 如果查询不到数据，则报错ObjectNotFoundException Employee employee1 = (Employee) session.load(Employee.class,10); System.out.println(employee1);//ObjectNotFoundException Employee employee2 = (Employee) session.get(Employee.class,10); System.out.println(employee2);//null 使用get去查询数据，先到缓存（session缓存、二级缓存）中去查，如果没有就到DB中取查，即立即向db发出查询请求(select …), 如果你使用的是load查询数据，先到缓存(session缓存、二级缓存)中查询，如果没有则返回一个代理对象（不马上到DB中去查）。等后面使用这个代理对象时才到DB中查询，如果后面没有使用查询结果，它不会真的向数据库发select，这个现象我们称为懒加载(lazy)【load是懒加载，返回代理对象，使用时候才去数据库查询】 Employee employee1 = (Employee) session.load(Employee.class,1); System.out.println(employee1);//如果这句话注释，不会向数据库发送sql语句，等到使用给代理对象时才到DB中查询 通过修改配置文件，我们可以取消懒加载&lt;class name=&quot;Employee&quot; lazy=&quot;false&quot; table=&quot;employee&quot;&gt; 如何选择使用哪个：如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高） Hibernate缓存原理★★★★★★ 接受到一个load查询，先去session缓存中查询，如果没有再去二级缓存查找，如果还没有，就不查询了，返回一个代理对象proxy obj = load 如果使用这个代理对象后，就会去数据库查询，并把这条记录放入二级缓存 等到下次查询时，先查询session缓存，找不到，然后去二级缓存中取得对象，并返回结果。同时把这条记录放入一级缓存 get查询也类似，先查询一级缓存，再查询二级缓存 Hibernate缓存机制可以减少对数据库的查询 Employee employee1 = (Employee) session.load(Employee.class,1);//发送select语句，放缓存 System.out.println(employee1); Employee employee2 = (Employee) session.get(Employee.class,1);//从缓存中取，没有select语句 System.out.println(employee2); Employee employee3 = (Employee) session.get(Employee.class,100);//缓存中找不到，向数据库发送select语句 System.out.println(employee3); HibernateUtil（线程局部模式：获取全新的Session或与线程绑定的Session）★★★★★★注意：不再需要配置 hibernate.cfg.xml final public class HibernateUtil { //SqlHelper private static SessionFactory sessionFactory = null; //使用线程局部模式 private static ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;(); static { sessionFactory=new Configuration().configure().buildSessionFactory(); } private HibernateUtil(){} //获取全新的全新的sesession public static Session openSession(){ return sessionFactory.openSession(); } //获取和线程关联的session public static Session getCurrentSession(){ Session session = threadLocal.get(); //判断是否得到 if(session == null){ session = sessionFactory.openSession(); //把session对象设置到 threadLocal,相当于该session已经和线程绑定 threadLocal.set(session); } return session; } } 测试 System.out.println(HibernateUtil.getCurrentSession().hashCode()); System.out.println(HibernateUtil.getCurrentSession().hashCode()); System.out.println(HibernateUtil.openSession().hashCode()); System.out.println(HibernateUtil.openSession().hashCode()); 结果： 725455968 725455968 1473790157 914784201 线程局部模式 在一个线程中，某个时间点通过set将对象放入ThredLocal，又在某个点通过get方法取出对象。这个变量与线程绑定 query接口★★★★★★通过query接口我们可以完成更加复杂的查询任务举例: 通过用户来查询数据. //获取query引用 Query query = session.createQuery(&quot;from Employee where id = 1&quot;); //通过List方法获取结果，这个list会自动封装成domain对象 List&lt;Employee&gt; list = query.list(); for(Employee e : list){ System.out.println(e.getName() + &quot; &quot; + e.getHiredate()); } 注意：Employee是Java对象而不是表名，id也是类的属性名 Criteria接口（不常用）Criteria接口也可用于面向对象方式的查询，关于它的具体用法我们这里先不做介绍,简单看几个案例. Criteria cri = session.createCriteria(Employee.class) .setMaxResults(2) .addOrder(Order.asc(&quot;id&quot;)); List&lt;Employee&gt; list = cri.list(); for(Employee e : list){ System.out.println(e.getId() + &quot; &quot; + e.getName()); } 工具生成domain对象和对象关系映射文件 使用IntelliJ IDEA开发SpringMVC网站（三）数据库配置★★★http://blog.csdn.net/chenxiao_ji/article/details/50849365 在创建工程的时候勾选上hibernate支持。 在主界面右侧找到database，点击添加数据库 在新界面中添加数据库驱动和数据库链接信息 保存后在主面板左侧有persistence，在hibernate图标上点击右键-Generate Persistence Mapping-By Database Scheme 选好数据库，选好包的位置，在下面勾上要生成的表对应的pojo，并且勾上为每一个pojo生成XML即可 IDEA一对多关系设置 模拟一个学生选课系统 ，创建三张表：student、studCourse、course 数据库备份https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate.sql student与studCourse的关系为一对多，即一个学生可以选择多门课程。Student类中有一个studCourse的集合属性，studCourse中有一个Student的成员变量 设置student与studCourse之间的关系 原则：在有外键的表上设置表之间的关系，本例中在studCourse上设置关系 在上图中选中studCourse表，studCourse通过外键sid和cid关联student表和couse表。注意外键不打勾 点击左上角绿色的加号或右键选择add relationship studCourse类中有一个类型为Course的course变量，Course类中有一个名为studCourses的集合，两个表通过cid关联起来 同理设置studCourse与student关系 设置完成后观察属性是否正确 生成的domain对象及hdm文件见githubhttps://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/java/cn/apeius/domainhttps://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/resources HQL语句详解★★★★★★关系模型和对象模型映射 studCourse表有两个外键，一个是与student表关联的sid，另一个是与course关联的cid 一个学生可以选择多门课程，一个课程可以被多名学生选择，两个表是多对多的关系 在对象模型中，一个学生可以选择多个课程，所以它有一个set集合的成员变量，存放studcourse 在对象模型中，一个课程可以可以被多名学生选择，所以它有一个set集合的成员变量，存放studcourses 取出部分属性 在讲解jdbc中，要查询什么字段就查询什么字段，不要select * from.. 但是在Hibernate中，建议把整个对象的属性都查询 查询整个对象的属性list方法返回的是整个Student对象 List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list(); for(Student s : list){ System.out.println(s.getSname() + &quot; &quot; + s.getSid()); } 查询部分属性 因为只是查询部分属性，hibernate没有把返回的结果封装成Student对象，而只是Object数组 List list = session.createQuery(&quot;select sname,sid from Student&quot;).list(); for(int i = 0; i &lt; list.size(); i++){ Object[] obj = (Object[]) list.get(i); System.out.println(obj[0] + &quot; &quot; + obj[1]); } 或（推荐） List&lt;Object[]&gt; list = session.createQuery(&quot;select sname,sid from Student&quot;).list(); for(Object[] obj : list){ System.out.println(obj[0] + &quot; &quot; + obj[1]); } 原理：创建list对象，对于每条记录创建一个对象数组，并加入list中 如果我们返回的是一列数据 //这时我们的取法是直接取出list-&gt;object 而不是 list-&gt;Object[] List&lt;Object&gt; list = session.createQuery(&quot;select sname from Student&quot;).list(); for(Object obj : list){ System.out.println(obj); } 对象模型关联查询查询学生就能查出于课程关联的全部信息 List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list(); for(Student s : list){ System.out.print(s.getSname()); if(s.getStudcourses().size() == 0){ System.out.println(&quot;没有选课&quot;); }else{ System.out.print(&quot;选了&quot;); for(Studcourse studcourse : s.getStudcourses()){ System.out.print(studcourse.getCourse().getCname() + &quot; &quot;); } System.out.println(); } } 请显示所有选择了21号课程的学生信息 String sql = &quot;select student.sname,student.sage from Studcourse where course.cid = 21&quot;; List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null); for(Object[] s : list){ System.out.println(s[0] + &quot; &quot; + s[1]); } uniqueResult方法(只有一个对象)当session.createQuery(&quot;from xxx where cardid=&#39;xxx&#39;&quot;).uniqueResult();返回的结果只有一个对象时，可以使用uniqueResult()得到该对象，效率高。但是，如果结果是多条，使用该方法就会抛出异常。 Student student = (Student) session.createQuery(&quot;from Student where id = 20050003&quot;).uniqueResult(); if(student != null) System.out.println(student.getSname()); else System.out.println(&quot;记录不存在&quot;); 模糊查询String sql = &quot;select sname,sage from Student where sname like &apos;林%&apos;&quot;; List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null); for(Object[] s : list){ System.out.println(s[0] + &quot; &quot; + s[1]); } distinct的用法（过滤重复的记录）比如，显示所有学生的性别和年龄 List list=session.createQuery(&quot;select distinct sage,ssex from Student&quot;).list(); for(int i=0;i&lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString()); } between and年龄在20岁到22岁的学生 List list=session.createQuery(&quot;select distinct sage,ssex,sname from Student where sage between 20 and 22&quot;).list(); for(int i=0;i&lt;list.size();i++){ Object [] objs=(Object[]) list.get(i); System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString()+objs[2].toString()); } in /not in查询计算机系和外语系的学生信息 List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept in (&apos;计算机系&apos;,&apos;外语系&apos;)&quot;).list(); for(Student s:list){ System.out.println(s.getSname()+&quot; &quot;+s.getSaddress()+&quot; &quot;+s.getSdept()); } group by使用显示各个系的学生的平均年龄 List&lt;Object[]&gt; list=session.createQuery(&quot;select avg(sage),sdept from Student group by sdept&quot;).list(); for(Object[] obj:list){ System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString()); } having的使用对分组查询后的结果，进行筛选 1.请显示人数大于3的系名称 //a. 查询各个系分别有多少学生 b.筛选 List&lt;Object[]&gt; list=session.createQuery(&quot;select count(*) as c1,sdept from Student group by sdept having count(*)&gt;3&quot;).list(); //取出1. for 增强 for(Object[] obj:list){ System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString()); } 2.查询女生少于200人的系 List&lt;Object[]&gt; list = session.createQuery(&quot;select count(*),sdept from Student where ssex = &apos;F&apos;group by sdept having count(*) &lt; 200&quot;).list(); for(Object[] obj : list){ System.out.println(obj[0] + &quot; &quot; + obj[1]); } 聚集函数的使用 count(),avg(),max(),min(),sum()1.查询计算机系共多少人 Long count = (Long) session.createQuery(&quot;select count(*) from Student where sdept=&apos;计算机系&apos;&quot;).uniqueResult(); System.out.println(count); 2.查询选修11号课程的最高分和最低分 List&lt;Object[]&gt; list=session. createQuery(&quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11&quot;).list(); for(Object[] obj:list){ System.out.println(obj[0].toString()+&quot; max=&quot;+obj[1].toString()+&quot; min=&quot;+obj[2].toString()); } 3.计算各个科目不及格的学生数量 List&lt;Object[]&gt; list=session.createQuery(&quot;select count(*),course.cname from Studcourse where grade &lt; 60 group by course.cname&quot;).list(); for(Object[] obj:list){ System.out.println(obj[0].toString()+ &quot; &quot; + obj[1]); } 4.显示各科考试不及格学生的名字，科目和分数 List&lt;Object[]&gt; list=session.createQuery(&quot;select student.sname,course.cname,grade from Studcourse where grade &lt; 60&quot;).list(); for(Object[] obj:list){ System.out.println(obj[0].toString()+ &quot; &quot; + obj[1] + &quot; &quot; + obj[2]); } 分页分页原理见Java基础常用 函数使用 List q=session.createQuery(hql).setFirstResultl(从第几条取//从0开始计算).setMaxResult(取出几条).list(); 据用户输入的pageNow 和pageSize显示对象 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = null; int pageNow = 1; int pageSize = 3; int pageCount = 0; int rowCount = 0; try{ transaction = session.beginTransaction(); //do... rowCount = Integer.parseInt(session.createQuery(&quot;select count(*) from Student&quot;).uniqueResult().toString()); pageCount = (rowCount -1)/pageSize + 1; //遍历 for(int i = 0; i &lt;= pageCount; i++){ System.out.println(&quot;***********************************&quot;); List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).setFirstResult(pageSize*i).setMaxResults(pageSize).list(); for(Student s : list){ System.out.println(s.getSname()); } } transaction.commit(); }catch (Exception e){ e.printStackTrace(); if (transaction != null){ transaction.rollback(); } throw new RuntimeException(e.getMessage()); }finally { if(session != null &amp;&amp; session.isOpen()){ session.close(); } } SQL注入select * from student where sage=2412 or 1=1 上面我们使得WHERE恒真，所以该查询中WHERE已经不起作用了 参数绑定使用参数绑定的好处： 可读性提高 效果高 防止sql注入漏洞 面试题: 如果不使用参数绑定，怎样防止登录时， sql注入? 思路: 1. 通过用户名，查询出该用户名在数据库中对应的密码，然后再与用户输入的密码比较，如果相等，则用户和法，否则，非法. 参数绑定有两种形式 Query q=session.createQuery(from Student where sdept=:dept and sage&gt;:age) 如果我们的参数是:冒号形式给出的，则我们的参数绑定应当这样: List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept=:a1 and sage&gt;:sage&quot;).setString(&quot;a1&quot;, &quot;计算机系&quot;).setString(&quot;sage&quot;, &quot;2&quot;).list(); 还有一种形式: Query q=session.createQuery(from Student where sdept=? and sage&gt;?) 如果我们的参数是以 ? 形式给出的则，参数绑定应当: List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept=? and sage&gt;?&quot;).setString(0, &quot;计算机系&quot;).setString(1, &quot;2&quot;).list(); 参数的绑定，可以分开写： Query query=session.createQuery(&quot;from Student where sdept=? and sage&gt;?&quot;); query.setString(0, &quot;计算机系&quot;); query.setString(1, &quot;2&quot;); List &lt;Student&gt; list=query.list(); for(int i=0;i&lt;list.size();i++){ Student s= list.get(i); System.out.println(s.getSname()+&quot; &quot;+s.getSage()); } 把HibernateUtil升级了 多表查询★★★在实际项目中，我们不可能只对一张表进行查询，通常有多张表联合查询 hibernate对象之间关系 one – to – one : 身份证&lt;—&gt;人 one – to – many 部门 &lt;—&gt; 员工 many-to-one 员工&lt;—&gt;部门 many-to-many 学生&lt;—&gt;老师 多对多关系转换成两个一对多 一个学生可以选择多门课程，一门课程可以被多名学生选择，在实际开发中应将其转成两个一对多或多两个多对一。这样程序好控制，同时不会有冗余 对象配置文件可以体现出，Student.hbm.xml和Course.xml中是one-to-many，而Studcourse是many-to-one 举个例子请显示林青霞 选择的所有课程名，和成绩 String sql = &quot;select course.cname,grade from Studcourse where student.sname = &apos;林青霞&apos;&quot;; List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null); for(Object[] s : list){ System.out.println(s[0] + &quot; &quot; + s[1]); } Criteria—略讲//查询年龄大于10岁的学生 //获取一个会话 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = null; try { transaction = session.beginTransaction(); Criteria cri = session.createCriteria(Student.class); //增加检索条件 cri.add(Restrictions.gt(&quot;sage&quot;,10)); List&lt;Student&gt; list = cri.list(); for(Student s : list){ System.out.println(s.getSname()); } transaction.commit(); } catch (Exception e) { if (transaction != null) { transaction.rollback(); } throw new RuntimeException(e.getMessage()); } finally { //关闭session if (session != null &amp;&amp; session.isOpen()) { session.close(); } } hibernate对象的三种状态如果判断一个对象处于怎样的状态？主要的依据是: 1. 看该对象是否处于session管理下 2. 看在数据库中有没有对应的记录 瞬时态: 没有session管理，同时数据库没有对应记录 持久态: 有session管理，同时在数据库中有记录。相关联的session没有关闭，事务没有提交，持久对象状态发生改变，在事务提交时会影响到数据库，即hibernate能检测到变化 脱管态/游离态： 没有session管理，但是在数据库中有记录。脱管对象状态发生改变，hibernate不能检测到 对象三种状态//对象三种状态 Course c1 = new Course();//没有在session管理下，数据库没记录，c1就是瞬时态 c1.setCid(100); c1.setCcredit(3); c1.setCname(&quot;php&quot;); Session session = null; Transaction tx = null; try{ session = HibernateUtil.getCurrentSession(); tx = session.beginTransaction(); session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态 tx.commit(); session.close(); //c1没有处于session管理下，单被保存到数据库中，c1就是脱管态（游离态） System.out.println(c1.getCname()); }catch (Exception e){ e.printStackTrace(); } 持久态中改变属性，反应到数据库中 //对象三种状态 Course c1 = new Course();//c1就是瞬时态 c1.setCid(100); c1.setCcredit(3); c1.setCname("php1"); Session session = null; Transaction tx = null; try{ session = HibernateUtil.getCurrentSession(); tx = session.beginTransaction(); session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态 c1.setCname("php2");//处于持久态，c1的改变有效，加入的数据php2 tx.commit(); session.close(); //这时c1被保存到数据库中，同时没有处于session管理下，c1就是脱管态（游离态） c1.setCname("php3"); System.out.println(c1.getCname());//结果为php3，但数据库中时php2 }catch (Exception e){ e.printStackTrace(); } 持久态中删除记录Course c1 = new Course();//c1就是瞬时态 c1.setCid(100); c1.setCcredit(3); c1.setCname(&quot;php1&quot;); Session session = null; Transaction tx = null; try{ session = HibernateUtil.getCurrentSession(); tx = session.beginTransaction(); session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态 c1.setCname(&quot;php2&quot;);//处于持久态，c1的改变有效，加入的数据php2 session.delete(c1);//删除数据库记录，c1处于瞬时态 tx.commit(); session.close(); //c1对应的记录被删除，同时没有处于session管理下，c1处于瞬时态 c1.setCname(&quot;php3&quot;); System.out.println(c1.getCname()); }catch (Exception e){ e.printStackTrace(); } 对象状态 - 完整版 Hibernate关系映射★★★★★★★多对一（内含懒加载问题）★★★★★★★多对一案例 采用开发方式一：从Domain和对象关系映射文件开始写，自动创建对应表 Department.java package cn.apeius.domain; public class Department implements java.io.Serializable { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Department.hbm.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"> &lt;hibernate-mapping package="cn.apeius.domain"> &lt;class name="Department" lazy="false" table='department'> &lt;!-- 配置主键属性 --> &lt;id name="id" column='id' type="java.lang.Integer"> &lt;!-- 生成策略 --> &lt;generator class="increment"/> &lt;/id> &lt;property name="name" type="java.lang.String"> &lt;column name="name" length="255" not-null="true"/> &lt;/property> &lt;/class> &lt;/hibernate-mapping> Intern.java package cn.apeius.domain; public class Intern implements java.io.Serializable{ private Integer id; private String name; private Department dept; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Department getDept() { return dept; } public void setDept(Department dept) { this.dept = dept; } } Intern.hbm.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"> &lt;hibernate-mapping package="cn.apeius.domain"> &lt;class name="cn.apeius.domain.Intern" table='intern'> &lt;id name="id" column='id' type="java.lang.Integer"> &lt;generator class="increment"/> &lt;/id> &lt;property name="name" type="java.lang.String"> &lt;column name="name" length="255"/> &lt;/property> &lt;!--对于private Department dept;就不能使用property--> &lt;!--column="dept_id" 表示将来自动生成的表的外键名--> &lt;!--class可选，默认是通过反射得到属性类型--> &lt;many-to-one name="dept" class = 'Department' column="dept_id"/> &lt;/class> &lt;/hibernate-mapping> hibernate.cfg.xml &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; Main //创建实习生 Intern intern = new Intern(); intern.setName(&quot;宋江&quot;); //创建部门 Department department = new Department(); department.setName(&quot;财务部&quot;); //实习生分配部门 intern.setDept(department); //保存 session.save(department); session.save(intern); 结论一 应当先保存部门，再保存实习生 保存部门后，产生部门id；当保存实习生时再将部门id存入实习生表中 若先保存实习生，此时还不知道部门id，dept_id的值为null；当保存部门并生成部门id时，在更新实习生表；这样比方式一效率低 懒加载当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性，当用户去使用对象属性 时，才会向数据库 发出再一次的查询.这种现象我们称为lazy现象. Intern intern = (Intern) session.get(Intern.class,3); //System.out.println(intern.getName() + &quot; &quot; + intern.getDept().getName());//可以读出部门名称 transaction.commit(); session.close(); System.out.println(intern.getName() + &quot; &quot; + intern.getDept().getName());//session关闭，不可以读出部门名称 在session未关闭时，可以通过学生名得到部门名 session关闭后，由于懒加载机制，会报错，不能得到部门名 解决懒加载 显示初始化Hibernate.initized(代理对象) Intern intern = (Intern) session.get(Intern.class,3); Hibernate.initialize(intern.getDept()); transaction.commit(); session.close();//关闭session，若没有显示初始化代理对象，则会报错 System.out.println(intern.getName() + " " + intern.getDept().getName());//session关闭，不可以读出部门名称 在department映射文件中加入lazy=’false’ &lt;class name=&quot;Department&quot; lazy=&quot;false&quot;&gt; 通过过滤器(web项目) openSessionInView many-to-one的many这方，如果你配置了 &lt;class name=&quot;Student&quot; lazy=&quot;false&quot;&gt; 那么hibernate就会在 查询学生 many 方时，把它相互关联的对象也查询,这里我们可以看出，对select语句查询影响不大, one-to-many 的one 的这方，如果你配置 &lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt; 当你去查询一个部门的时候，该部门关联的学生全部返回，不管你使用否!!! 如果设置lazy=&quot;true&quot;，在session关闭后如果需要查询部门所在的学生就会报错 矛盾: 如何让我们在需要使用的时候才去查询？即如何让我们的session范围更大？ 一个http请求所在一个session，缺点是session关闭会延时 过滤器配合实现 public class MyFilter1 extends HttpServlet implements Filter { public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { // TODO Auto-generated method stub Session s=null; Transaction tx=null; try { s =HibernateUtil.getCurrentSession(); tx=s.beginTransaction(); arg2.doFilter(arg0, arg1); //代码运行到这，整个请求结束 tx.commit(); } catch (Exception e) { if(tx!=null){ tx.rollback(); } throw new RuntimeException(e.getMessage()); }finally{ HibernateUtil.closeCurrentSession(); } } } HibernateUtil加入关闭session方法 public static void closeCurrentSession() { Session s = getCurrentSession(); if (s != null &amp;&amp; s.isOpen()) { s.close(); threadLocal.set(null); } } 利用Spring可以更好得解决 一对多（内含级联操作）需求：通过一个部门号1，来获取该部门的所有学生? 案例Department.java package cn.apeius.domain; import java.util.Set; public class Department implements java.io.Serializable { private Integer id; private String name; //配置一个set集合，对应多个学生 private Set&lt;Intern> interns; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Set getInterns() { return interns; } public void setInterns(Set interns) { this.interns = interns; } public String getName() { return name; } public void setName(String name) { this.name = name; } public static long getSerialVersionUID() { return serialVersionUID; } } Department.hbm.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"> &lt;hibernate-mapping package="cn.apeius.domain"> &lt;class name="Department" lazy="false" table = 'department'> &lt;!-- 配置主键属性 --> &lt;id name="id" type="java.lang.Integer" column = 'id' > &lt;!-- 生成策略 --> &lt;generator class="increment"/> &lt;/id> &lt;property name="name" type="java.lang.String"> &lt;column name="name" length="255" not-null="true"/> &lt;/property> &lt;!--配置one-to-many的关系--> &lt;set name="interns" cascade="save-update"> &lt;!--指定intern类对应的外键--> &lt;key column="dept_id"/> &lt;!--集合中的类名--> &lt;one-to-many class="Intern"/> &lt;/set> &lt;/class> &lt;/hibernate-mapping> Intern.java package cn.apeius.domain; public class Intern implements java.io.Serializable{ private Integer id; private String name; private Department dept; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Department getDept() { return dept; } public void setDept(Department dept) { this.dept = dept; } } Intern.hbm.xml &lt;?xml version="1.0" encoding="utf-8"?> &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"> &lt;hibernate-mapping package="cn.apeius.domain"> &lt;class name="cn.apeius.domain.Intern"> &lt;id name="id" type="java.lang.Integer" column = 'id'> &lt;generator class="increment"/> &lt;/id> &lt;property name="name" type="java.lang.String"> &lt;column name="name" length="255"/> &lt;/property> &lt;!--对于private Department dept;就不能使用property--> &lt;!--column="dept_id" 表示将来自动生成的表的外键名--> &lt;!--class可选，默认是通过反射得到属性类型--> &lt;many-to-one name="dept" class='Department' column="dept_id"/> &lt;/class> &lt;/hibernate-mapping> 查询部门的实习生 Department department = (Department) session.get(Department.class,1); //取出该部门的实习生 Set&lt;Intern&gt; set = department.getInterns(); for(Intern intern : set) System.out.println(intern.getName()); 部门中添加实习生 //创建部门 Department department = new Department(); department.setName("业务部"); //创建实习生 Intern intern1 = new Intern(); intern1.setName("实习生1"); Intern intern2 = new Intern(); intern2.setName("实习生2"); //部门分配学生 Set set = new HashSet(); set.add(intern1); set.add(intern2); //级联添加，在department.hdm.xml中添加cascade属性 &lt;set name="interns" cascade="save-update"> department.setInterns(set); //保存 session.save(department); 级联操作所谓级联操作就是说，当你进行某个操作(添加/修改/删除…)，就由hibernate自动给你完成 案例:如何配置级联操作，当删除某个部门的时候，我们自动删除其学生. 首先我们在 配置文件中修改: &lt;!-- 配置one-to-many关系 cascade=&quot;delete&quot; 当删除该部门的时候(主对象，则级联删除它的学生从对象) --&gt; &lt;set name=&quot;stus&quot; cascade=&quot;delete&quot;&gt; &lt;!-- 指定Student类对应的外键 --&gt; &lt;key column=&quot;dept_id&quot; /&gt; &lt;one-to-many class=&quot;Student&quot; /&gt; &lt;/set&gt; java代码中操作: //演示删除级联 //获取到某个部分 Department department=(Department) s.get(Department.class, 41); s.delete(department); 演示save-update 配置文件: &lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot;&gt; &lt;!-- 指定Student类对应的外键 --&gt; &lt;key column=&quot;dept_id&quot; /&gt; &lt;one-to-many class=&quot;Student&quot; /&gt; &lt;/set&gt; 代码： //添加学生 Department department=new Department(); department.setName(&quot;业务部门3&quot;); Student stu1=new Student(); stu1.setName(&quot;顺平6&quot;); Student stu2=new Student(); stu2.setName(&quot;小明6&quot;); Set&lt;Student&gt; students=new HashSet&lt;Student&gt;(); students.add(stu1); students.add(stu2); department.setStus(students); s.save(department); 说明: ① 在集合属性和普通属性中都能使用cascade ② 一般讲cascade配置在one-to-many(one的一方,比如Employee-Department),和one-to-one(主对象一方) 一对一基于主键的one-to-one 测试代码如下 生成两张表，person表和idCard表。person中id为主键，idCard表中id既为主键，也为外键 person指定id和name，IdCard的主键由person的id指定 IdCard设置外键可以多对一，但当外键同时也为主键时，可以保证一对一 Person p1 = new Person(); p1.setId(100); p1.setName(&quot;成龙&quot;); IdCard idCard = new IdCard(); idCard.setValidateDte(new Date()); //表示idCard对象是属于p1这个对象 idCard.setPerson(p1); session.save(p1); session.save(idCard); 基于外键的one-to-one 在关系模型中，idCard设置外键person_id，则person与idCard是一对多的关系。如何限制约束使得一个person对应一个idCard，只需在references增加约束unique IdCard关系映射文件，在many-to-one中增加约束unique=’true’，外键名为person_id 测试代码 Person p1 = new Person(); p1.setId(10); p1.setName(&quot;成龙&quot;); IdCard idCard = new IdCard(); idCard.setId(100); idCard.setValidateDte(new Date()); //表示idCard对象是属于p1这个对象 idCard.setPerson(p1); session.save(p1); session.save(idCard); 多对多在操作和性能方面都不太理想，所以多对多的映射使用较少，实际使用中最好转换成一对多的对象模型 Hibernate一级缓存缓存原理图 从上图看出: 当我们去查询对象的时候，首先到一级缓存去取数据，如果有，则不到数据库中取，如果没有则到数据库中取，同时在一级缓存中放入对象. 缓存的细节①什么操作会向一级缓存放入数据 save,update,saveOrUpdate,load,get,list,iterate,lock save 案例: //添加一个学生 Student student=new Student(); student.setName(&quot;小东&quot;); s.save(student);//放入一级缓存 //我马上查询 Student stu2=(Student) s.get(Student.class, student.getId()); //select System.out.println(&quot;你刚刚加入的学生名字是&quot;+stu2.getName()); ②什么操作会从一级缓存取数据 get/load/list get/load会首先从一级缓存中取，如没有,再有不同的操作 get会立即向数据库发请求，而load 会返回一个代理对象，直到用户真的去使用数据，才会向数据库发请求 list会不会从session缓存取数据？ //查询45号学生 Student stu=(Student) s.get(Student.class, 45); System.out.println(&quot;|||||||||||||||||||&quot;); String hql=&quot;from Student where id=45&quot;; Student stu2=(Student) s.createQuery(hql).uniqueResult(); System.out.println(stu2.getName()); 从上面的案例，我看出 query.list() query.uniueResut() 不会从一级缓取数据 ! 但是query.list 或者query.uniqueRestu() 会向一级缓存放数据的 ③一级缓存不需要配置，就可以使用,它本身没有保护机制，所以我们程序员要考虑这个问题,我们可以同 evict 或者 clear来清除session缓存中对象. evict 是清除一个对象，clear是清除所有的sesion缓存对象 ④session级缓存中对象的生命周期, 当session关闭后，就自动销毁 ⑤我们自己用HashMap来模拟一个Session缓存，加深对缓存的深入 import java.util.*； public class MyCache { //使用map来模拟缓存 static Map&lt;Integer,Student&gt; maps=new HashMap&lt;Integer,Student&gt;(); public static void main(String[] args) { // TODO Auto-generated method stub getStudent(1); getStudent(1); getStudent(1); getStudent(1); getStudent(3); getStudent(3); } public static Student getStudent(Integer id){ //s.get() //先到缓存去 if(maps.containsKey(id)){ //在缓存有 System.out.println(&quot;从缓存取出&quot;); return maps.get(id); }else{ System.out.println(&quot;从数据库中取&quot;); //到数据库取 Student stu=MyDB.getStudentFromDB(id); //放入缓存 maps.put(id, stu); return stu; } } } //我的数据库 class MyDB{ static List&lt;Student&gt; lists=new ArrayList&lt;Student&gt;(); //初始化数据库,假设有三个学生 static{ Student s1=new Student(); s1.setId(1); s1.setName(&quot;aaa&quot;); Student s2=new Student(); s2.setId(2); s2.setName(&quot;bbb&quot;); Student s3=new Student(); s3.setId(3); s3.setName(&quot;ccc&quot;); lists.add(s1); lists.add(s2); lists.add(s3); } public static Student getStudentFromDB(Integer id){ for(Student s: lists){ if(s.getId().equals(id)){ return s; } } return null;// 在数据库中没有. } } class Student{ private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Hibernate二级缓存为什么需要二级缓存？因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题，SessionFactory关闭后缓存才消失 需要配置 二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache 二级缓存的对象可能放在内存，也可能放在磁盘. 二级缓存的原理 快速入门案例使用OsCache来演示二级缓存的使用 1、配置二级缓存 &lt;!-- 启动二级缓存 --&gt; &lt;property name=&quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;!-- 指定使用哪种二级缓存 --&gt; &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.OSCacheProvider&lt;/property&gt; &lt;mapping resource=&quot;com/hsp/domain/Department.hbm.xml&quot; /&gt; &lt;mapping resource=&quot;com/hsp/domain/Student.hbm.xml&quot; /&gt; &lt;!-- 指定哪个domain启用二级缓存 特别说明二级缓存策略: 1. read-only只读缓存 2. read-write读写缓存 3. nonstrict-read-write不严格读写缓存 4. transcational事务缓存 --&gt; &lt;class-cache class=&quot;com.hsp.domain.Student&quot; usage=&quot;read-write&quot;/&gt; 2、把oscahe.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小默认1000 3、使用 //通过获取一个sesion,让hibernate框架运行(config-&gt;加载hibernate.cfg.xml) Session s=null; Transaction tx=null; try { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction(); //查询45号学生 Student stu1=(Student) s.get(Student.class, 45);//45-&gt;一级缓存 System.out.println(stu1.getName()); tx.commit(); } catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{ if(s!=null &amp;&amp; s.isOpen()){ s.close(); } } System.out.println(&quot;*********************************&quot;); try { //我们使用基础模板来讲解. s=HibernateUtil.openSession(); tx=s.beginTransaction(); //查询45号学生 Student stu1=(Student) s.get(Student.class, 45); System.out.println(stu1.getName()); Student stu3=(Student) s.get(Student.class, 46); System.out.println(stu3.getName()); tx.commit(); } catch (Exception e) { e.printStackTrace(); if(tx!=null){ tx.rollback(); } }finally{ if(s!=null &amp;&amp; s.isOpen()){ s.close(); } } //完成一个统计，统计的信息在Sessfactory //SessionFactory对象. Statistics statistics= HibernateUtil.getSessionFactory().getStatistics(); System.out.println(statistics); System.out.println(&quot;放入&quot;+statistics.getSecondLevelCachePutCount()); System.out.println(&quot;命中&quot;+statistics.getSecondLevelCacheHitCount()); System.out.println(&quot;错过&quot;+statistics.getSecondLevelCacheMissCount()); 4、在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高 主键增长策略① increment 自增，每次增长1, 适用于所有数据库。但是不要使用在多进程、主键类型是数值型 select max(id) from Student ② identity 自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值 ③ sequence 依赖于底层数据库系统的序列，前提条件:需要数据库支持序列机制（如:oracle等）,而且OID必须为数值类型,比如long,int,short类型。 ④ native 会根据数据类型来选择，使用identity,sequence,hilo select hibernate_sequence.nextval from dual 主键类型是数值long , short ,int &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; ⑤ hilo hilo标识符生成器由Hibernate按照一种high/low算法生成标识符 用法: &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot; column=&quot;ID&quot;&gt; &lt;generator class=&quot;hilo&quot;&gt; &lt;param name=&quot;table&quot;&gt;my_hi_value&lt;/param&gt; &lt;param name=”column”&gt;next_value&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; ⑥ uuid 会根据uuid算法，生成128-bit的字串 主键属性类型不能是数值型，而是字串型 ⑦ assigned 用户自己设置主键值，所以主键属性类型可以是数值，字串 ⑧ 映射复合主键⑨ foreign 在one-to-one的关系中，有另一张表的主键(Person)来决定自己主键/外键(IdCard)[既是主键也是外键] 一个简单选择原则 针对 mysql [主键是 int/long/short 建议使用increment/assigend，如果是字串 UUId/assigned] 针对 sql server [主键是 int/long/short 建议使用 identity/native/assinged，如果主键是字串，使用uuid/assigned ] one-to-one 又是基于主键的则使用foreign Hibernate最佳实践Hibernate不适合的场景 不适合OLAP(On-Line Analytical Processing 联机分析处理 )，以查询分析数据为主的系统；适合OLTP（on-line transaction processing 联机事务处理 ） 对于些关系模型设计不合理的老系统，也不能发挥hibernate优势 数据量巨大，性能要求苛刻的系统，hibernate也很难达到要求, 批量操作数据的效率也不高 Hibernate最佳实践 对于数据量大，性能要求高系统，不太适用使用hiberante 主要用于事务操作比较多的项目(oa/某个行业软件[石油、税务、crm, 财务系统] OLAP-&gt;hibernate用的比较少 OLTP-&gt;hibernate Hibernate开发过程（总结）hibernate.cfg.xml Hibernate快速入门 - hibernate.cfg.xml domain对象 Hibernate快速入门 - 开发domain对象 关系映射文件 Hibernate快速入门 - 手动配置我们的hibernate.cfg.xml文件 基础模版 //获取一个会话 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = null; try{ transaction = session.beginTransaction(); //do... transaction.commit(); }catch (Exception e){ e.printStackTrace(); if(transaction != null){ transaction.rollback(); } throw new RuntimeException(e.getMessage()); }finally { //关闭session if(session != null &amp;&amp; session.isOpen()){ session.close(); } } HibernateUtil（增删改查）https://github.com/rhapsody1290/Hibernate_Study/blob/master/src/main/java/cn/apeius/util/HibernateUtil.java 查询 #查询全部 String sql = &quot;from Student&quot;; List&lt;Student&gt; list = HibernateUtil.executeQuery(sql, null); for(Student s : list) System.out.println(s.getSname()); #条件查询 String sql = &quot;from Student where sdept = ? and sage &gt; ?&quot;; String[] parameters = {&quot;计算机系&quot;, &quot;3&quot;}; List&lt;Student&gt; list = HibernateUtil.executeQuery(sql, parameters); for(Student s : list) System.out.println(s.getSname()); #部分查询 String sql = &quot;select sname, saddress from Student where sdept = ? and sage &gt; ?&quot;; String[] parameters = {&quot;计算机系&quot;, &quot;3&quot;}; List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql, parameters); for(Object[] s : list) System.out.println(s[0] + &quot; &quot; + s[1]); 分页 String sql = &quot;from Student order by sage&quot;; List&lt;Student&gt; list = HibernateUtil.executeQueryByPage(sql, null,4,2); for(Student s : list) System.out.println(s.getSname()); 添加 Course c = new Course(); c.setCid(61); c.setCname(&quot;servlet&quot;); HibernateUtil.save(c); 修改 String sql = &quot;update Course set ccredit = 2 where cid = 61&quot;; HibernateUtil.executeUpdate(sql,null); 删除 String sql = &quot;delete from Course where cid = 61&quot;; HibernateUtil.executeUpdate(sql,null);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis笔记]]></title>
      <url>%2F2016%2F08%2F11%2F%5Bmybatis%5Dmybatis%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[JDBC回顾JDBC连接数据库分为六步1. 加载驱动 2. 创建连接 3. 获取statement对象 4. 执行sql语句 5. 处理结果集 6. 关闭资源 存在的问题及解决方案1、加载驱动问题： ● 每次执行都加载驱动 ● 驱动名称，硬编码到java代码中，如果需要修改驱动，需要修改java文件 —— 解决方案：将驱动名称放入到外部的配置文件 2、数据库的连接信息，硬编码到java代码中 —— 解决方案：外部配置文件 3、sql语句设置参数的问题： 参数下标硬编码了，需要人为的去判断参数的位置 4、遍历结果集：需要人工的判断字段名，以及个位置参数类型，不方便 —— 是否可以将结果集直接映射到一个pojo对象中 5、频繁的创建连接，关闭连接，导致资源浪费，影响性能 —— 解决：连接池。 mybatis介绍★★ mybatis的前身是ibatis，改名后将版本升级为3.X Mybatis是类似Hiberate的 ORM框架，位于持久层 Mybatis是直接基于JDBC做了简单的封装，性能角度来看JDBC &gt; mybatis &gt; Hiberate mybatis整体架构 mybatis-config.xml全局配置文件，包括数据库的连接参数、全局配置项 mapper.xml有多个，配置sql语句 SqlSessionFactory创建SqlSession SqlSession执行crud操作 executor底层的执行器 Mappered Statement为一个个的sql语句 mybatis快速入门(参考官方文档)★★★★★githubhttps://github.com/rhapsody1290/MybatisStudy 安装 想要使用 MyBatis 只需将 mybatis-x.x.x.jar 文件置于 classpath 中 如果使用 Maven 构建项目，则需将下面的 dependency 置于 pom.xml 中 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; 从 XML 中构建 SqlSessionFactory 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的 SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得 SqlSessionFactoryBuilder 可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例（直接从Java程序中创建配置） 从XML配置文件创建SqlSessionFactory实例 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的 InputStream 实例，包括字符串形式或 URL 形式的文件路径来配置。MyBatis 包含一个叫 Resources 的工具类，它包含一些静态方法，可使从 classpath 或其他位置加载资源文件更容易。 String resource = &quot;mybatis-config.xml&quot;;//指定配置文件的路径 InputStream inputStream = Resources.getResourceAsStream(resource);//默认会从classes目录下寻找配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); mybatis-config.xml——XML配置文件核心设置 XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置 ，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例： &lt;!-- mybatis-config.xml --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 注意：上述配置文件采用了Property文件注入的方式，这里为了方便，我们可以直接写死连接数据库的参数 当然，XML 配置文件中还有很多可以配置的，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，需要用来验证 XML 文档正确性。 environment 元素体中包含了事务管理和连接池的环境配置 mappers 元素是包含一组 mapper 映射器（这些 mapper的 XML 文件包含了 SQL 代码和映射定义信息） mapper.xml——映射文件Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心 &lt;!-- mapper.xml --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可--&gt; &lt;mapper namespace=&quot;cn.apeius.User&quot;&gt; &lt;!--sql语句映射，也称作mapperedStatement resultType：结果集对应的java类型，需要书写类的全路径 #{id}：相当于？，表示参数的占位--&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from tb_user where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 从 SqlSessionFactory 中获取 SqlSessionSqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 //获取sqlsession SqlSession session = sqlSessionFactory.openSession(); try { //sqlSession.selectOne(&quot;sql的id&quot;,&quot;sql中需要的参数&quot;) User user = (User) session.selectOne(&quot;cn.apeius.User.selectUser&quot;, 1); System.out.println(user); } finally { //关闭session session.close(); } 可能的错误 问题原因：mybatis没有引入 mapper ，需要在 mybatis-config.xml 中使用mapper引入外部的mapper.xml mybatis使用步骤总结 java代码 添加日志支持导入依赖&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; 编写配置文件log4j.properties log4j.rootLogger=DEBUG,A1 log4j.logger.org.mybatis=DEBUG log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n 完整的CRUD操作(未使用动态代理类)★★★★★创建UserDao接口public interface UserDao { /** * 根据id查询用户信息 * @param id * @return */ public User queryUserById(Long id); /** * 查询所有用户 * @return */ public List&lt;User&gt; queryAllUser(); /** * 添加用户信息 * @param user */ public void addUser(User user); /** * 修改用户信息 * @param user */ public void updateUser(User user); /** * 根据id删除用户信息 * @param id */ public void deleteUserById(Long id); } 创建UserDao的实现类public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public UserDaoImpl(SqlSession sqlSession){ this.sqlSession = sqlSession; } public User queryUserById(Long id) { return sqlSession.selectOne(&quot;user.queryUserById&quot;, id); } public List&lt;User&gt; queryAllUser() { return sqlSession.selectList(&quot;user.queryAllUser&quot;); } public void addUser(User user) { sqlSession.insert(&quot;user.addUser&quot;, user); } public void updateUser(User user) { sqlSession.update(&quot;user.updateUser&quot;, user); } public void deleteUserById(Long id) { sqlSession.delete(&quot;user.deleteUserById&quot;, id); } } 编写User对应的Mapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 1、namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可 2、但为了与Mapper接口进行映射，一般为Mapper接口的完全限定名 --&gt; &lt;mapper namespace=&quot;cn.apeius.mybatis.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt; select * from tb_user where id = #{id} &lt;/select&gt; &lt;!-- resultType为结果集映射的java的类型 --&gt; &lt;select id=&quot;queryAllUser&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt; select * from tb_user &lt;/select&gt; &lt;!-- #{}中的值为domain类中的属性名 --&gt; &lt;insert id=&quot;addUser&quot;&gt; INSERT INTO tb_user VALUES (NULL,#{user_name},#{password},#{name},#{age},#{sex},#{birthday},NOW(),NOW()) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot;&gt; UPDATE tb_user SET user_name = #{user_name},password = #{password},name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday}, updated = NOW() WHERE id=#{id} &lt;/update&gt; &lt;delete id=&quot;deleteUserById&quot;&gt; delete from tb_user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 全部配置文件mybatis-config.xml加入UserMapper.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写测试用例JUNIT★★★★★★★ 在UserDao接口中按快捷键Ctrl + Shift + T，快速创建UserDaoTest测试类 add/update/delete需要commit public class UserDaoTest { UserDao userDao; SqlSession sqlSession; //初始操作 @Before public void setUp() throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream is = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); sqlSession = sqlSessionFactory.openSession(); this.userDao = new UserDaoImpl(sqlSession); } @After public void tearDown() throws Exception{ sqlSession.close(); } @Test public void testQueryUserById() throws Exception { User user = userDao.queryUserById(1l); System.out.println(user); } @Test public void testQueryAllUser() throws Exception { List&lt;User&gt; users = userDao.queryAllUser(); for(User user : users){ System.out.println(user); } } @Test public void testAddUser() throws Exception { User user = new User(); user.setName(&quot;xxx&quot;); user.setAge(18); user.setSex(1); user.setPassword(&quot;123456&quot;); user.setUser_name(&quot;xxxx&quot;); user.setBirthday(new Date()); userDao.addUser(user); //需要事务进行提交 sqlSession.commit(); } @Test public void testUpdateUser() throws Exception { //先查询再更新 User user = userDao.queryUserById(15l); user.setUser_name(&quot;二舅&quot;); userDao.updateUser(user); sqlSession.commit(); } @Test public void testDeleteUserById() throws Exception { userDao.deleteUserById(17l); sqlSession.commit(); } } 解决数据库字段名和实体类属性名不一致的问题查询数据的时候，查不到userName的信息，原因：数据库的字段名是user_name，POJO中的属性名字是username，两端不一致，造成mybatis无法填充对应的字段信息 解决方案1：在sql语句中使用别名 解决方案2： 参考后面的resultMap –mapper具体的配置的时候 解决方案3：参考驼峰匹配 — mybatis-config.xml 的时候 动态代理mapper实现类★★★★★★★思考CURD的dao中的问题 1、上述开发过程为：接口-&gt;实现类-&gt;mapper.xml2、可以发现在实现类中，使用mybatis的方式非常类似 ● 查询 —— selectOne/selectList ● 查询 —— insert ● 修改 —— update ● 删除 —— delete3、sql statement 硬编码到java代码中（举例，函数参数user.queryUserById与mapper.xml中id=”queryUserById对应”） 思考：能否只写接口，不书写实现类，只编写Mapper.xml即可 答：因为在dao（mapper）的实现类中对sqlsession的使用方式很类似，mybatis提供了接口的动态代理 名称空间 mapper.xml 根标签的 namespace 属性 称为名称空间。namespace的定义本身是没有限制的，只要不重复就行 如果希望使用mybatis通过的动态代理的接口，就需要namespace中的值，和需要对应的Mapper(dao)接口的全路径一致 通过sqlSession.getMapper(Class) 在mybatis中，dao层的命名规则，以后都修改成*mapper 要求mapper中的statement,sql中的id 和方法中的名字一模一样才可以去调用 使用步骤定义接口package cn.apeius.mybatis.mapper; public interface UserMapper { /** * 根据id查询用户信息 * @param id * @return */ public User queryUserById(Long id); } 编写mapper.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可--&gt; &lt;mapper namespace=&quot;cn.apeius.mybatis.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt; select * from tb_user where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 调用public class UserMapperTest { UserMapper userMapper; SqlSession sqlSession; @Before public void setUp() throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream is = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); this.sqlSession = sqlSessionFactory.openSession(); //this.userMapper = new UserDaoImpl(sqlSession); this.userMapper = sqlSession.getMapper(UserMapper.class); } @Test public void testQueryUserById() throws Exception { User user = userMapper.queryUserById(1l); System.out.println(user); } } 使用动态代理总结★★★★★★★★★ 在名字空间”cn.apeius.mybatis.mapper.UserMapper”定义了一个名为”queryUserById”的映射语句，这样它就允许使用指定的完全限定名”cn.apeius.mybatis.mapper.UserMapper.queryUserById”来调用映射语句 User user = sqlSession.selectOne(&quot;cn.apeius.mybatis.mapper.UserMapper.queryUserById&quot;,1L); System.out.println(user); 这和使用完全限定名调用Java对象的方法是相似的，这样命名可以直接映射到命名空间同名的Mapper类，并将select语句中的名字、参数和返回类型映射成Mapper类的方法，这样可以调用对应Mapper接口的方法 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.queryUserById(1L); System.out.println(user); 综上所述：namespace与Mapper接口映射，sql语句与mapper接口中的方法映射 一张表对应一个Doamin对象，一个Mapper接口（DAO），一个mapper.xml。例如user表对应User.java、UserMapper.java、UserMapper.xml mybatis-config.xml 配置子标签出现的顺序不能改变 properties(读取外部的资源文件) 编写jdbc.properties文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root mybatis-config.xml属性值注入 &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; settings（设置）mapUnderscoreToCamelCase用法： 开启驼峰匹配：从经典数据库的命名规则，到经典java命名规则的映射 经典数据库的命名规则： 多个单词之间使用下划线分割，例如：user_name java经典命名规则：驼峰样式，多个单词，后续的单词首字母大写 例如：userName 开启驼峰匹配：相当于去掉数据库名字中的下划线，然后在与java中的属性名进行对应 typeAliases类型别名是为 Java 类型命名的一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余 typeAliases的使用1 使用这个配置，”User”可以用在任何使用”cn.apeius.mybatis.domain.User”的地方 大小写不敏感 缺点：每个一个类都去书写别名，麻烦 typeAliases的使用2——扫描包的方式 每一个在包 cn.apeius.mybatis.domain 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名 来作为它的别名。比如cn.apeius.mybatis.domain.User 的别名为 User，且大小写不敏感 若有注解，则别名为其注解值。 @Alias(&quot;xxx&quot;) public class User { ... } plugins（插件，又名拦截器）MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) 图：利用拦截器进行分页 environments（环境）为什么要适应多种环境MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，现实情况下有多种理由需要这么做 开发环境：开发人员日常开发的时候使用的环境 测试环境：测试人员测试的时候使用环境 预发布环境：几乎和线上环境一模一样，在上线之前在进行一次测试 生成环境：线上环境。 正式的java程序运行的环境 不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单： 每个数据库对应一个 SqlSessionFactory 实例 指定创建哪种环境配置多个环境 &lt;environments default="development"> &lt;environment id="development"> &lt;transactionManager type="JDBC"/> &lt;dataSource type="POOLED"> &lt;property name="driver" value="${driver}"/> &lt;property name="url" value="${url}"/> &lt;property name="username" value="${username}"/> &lt;property name="password" value="${password}"/> &lt;/dataSource> &lt;/environment> &lt;environment id="online"> &lt;transactionManager type="JDBC"/> &lt;dataSource type="POOLED"> &lt;property name="driver" value="${driver}"/> &lt;property name="url" value="${url}"/> &lt;property name="username" value="${username}"/> &lt;property name="password" value="${password}"/> &lt;/dataSource> &lt;/environment> &lt;/environments> 代码指定创建那种环境 SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment); mappers映射器mappers映射器将 mapper.xml 文件配置到 mybatis 的环境中 相对于类路径的资源引用 &lt;!-- Using classpath relative resources --> &lt;mappers> &lt;mapper resource="UserMapper.xml"/> &lt;/mappers> 使用mapper接口路径 这里所谓的 mapper接口路径，实际上就是 dao的接口路径 在mybatis中，通常把dao的包叫做mapper类名，也叫做mapper 使用 class 方式去加载的时候，要求 要求 mapper.xml 文件的名字和 mapper 接口的名字一致 要求 mapper.xml 文件和 mapper 接口类在一个目录 &lt;mapper class=&apos;cn.itcast.mybatis.mapper.UserMapper&apos;/&gt; 问题:1、mapper.xml 和 java文件没有分离,明天和 spring 整合之后解决2、需要一个一个的去加载 mapper 使用mapper接口扫描包(常用)扫描指定包下的所有接口，要求mapper.xml和接口在同一个包下，并且名字相同 &lt;!-- Register all interfaces in a package as mappers --> &lt;mappers> &lt;package name="cn.itcast.mybatis.mapper"/> &lt;/mappers> 缺点: 1、如果包的路径有很多？ 明天spring整合的时候解决2、mapper.xml和mapper.java没有分离 Mapper.xml CURD操作select——书写select语句 id属性（必须）：当前名称空间下的statement的唯一标识；要求id和mapper接口中的方法的名字一致 resultType：将结果集映射为java的对象类型，和 resultMap 二选一（必须） parameterType：传入参数类型。可以省略 insert——书写insert语句 id属性：必须的，当前名称空间下的statement的唯一标识(必须属性) parameterType：传入的参数类型，可以省略 标签内部：具体的sql语句 使用#{} 去替换一个变量 如果需要数据库影响的行数，可以直接在接口上定义返回值Integer 即可 获取自增的id的值插入数据后获得自增长的id号 useGenerateKeys：true keyColumn:主键列的名字 keyProperty：实体类对应的属性 测试 update id属性：当前名称空间下的statement的唯一标识(必须属性) parameterType：传入的参数类型，可以省略 标签内部：具体的sql语句 使用#{} 去替换一个变量 delete id属性：当前名称空间下的statement的唯一标识(必须属性) parameterType：传入的参数类型，可以省略 标签内部：具体的sql语句 使用#{} 去替换一个变量 #{}的用法及传入多个参数 #{} 存在mapper.xml中的sql语句部分，标识该位置可以接受参数信息，相当于?占位符 传入的参数和参数名无关，问题：如果有多个参数该怎么办？ 方法一：使用0，1……自然数取出对应的数据，0表示第一个参数 select * from tb_user where user_name = #{0} and password = #{1} 方法二：使用param1，param2……param1表示第一个参数 select * from tb_user where user_name = #{param1} and password = #{param2} 方法三（常用）：在方法的定义上使用@param为传入的参数定义一个名字 在UserMapper接口中声明函数login，使用@param为每个参数定义一个名字 public User login(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); sql语句在#{}中填入定义的名字 select * from tb_user where user_name = #{username} and password = #{password} 测试 @Test public void testLogin(){ User user = userMapper.login(&quot;zhangsan&quot;,&quot;123456&quot;); System.out.println(user); } ${}的用法及传入多个参数${}的用法：仍然是接受传递的参数，但是${}是sql语句的拼接 需求 查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据，希望使用1个方法来完成操作 方法一：$在取值时，使用value表示传入的参数值，不建议写 mapper接口public List&lt;User&gt; queryUserByTableName(String tableName); mapper.xmlselect * from ${value} 测试@Test public void testQueryUsersByTableName(){ List&lt;User&gt; users = userMapper.queryUserByTableName(&quot;tb_user&quot;); for(User u : users){ System.out.println(u); } } 方法二（常用）：$在取值时，可以在mapper接口的参数之前使用@Param主键为当前参数指定一个名字 mapper接口public List&lt;User&gt; queryUserByTableName(@Param(&quot;tableName&quot;) String tableName); mapper.xmlselect * from ${tableName} 测试@Test public void testQueryUsersByTableName(){ List&lt;User&gt; users = userMapper.queryUserByTableName(&quot;tb_user&quot;); for(User u : users){ System.out.println(u); } } 面试题：#{}与${}的区别 resultMap与resultType用法★★★★★★★★从SQL查询结果到领域模型实体 从SQL查询结果集到JavaBean或POJO实体的过程： 通过JDBC查询得到ResultSet对象 遍历ResultSet对象并将每行数据暂存到HashMap实例中，以结果集的字段名或字段别名为键，以字段值为值 根据ResultMap标签的type属性通过反射实例化领域模型 根据ResultMap标签的type属性和id、result等标签信息将HashMap中的键值对，填充到领域模型实例中并返回 resultType 在MyBatis进行查询映射的时候，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值 当提供的返回类型属性是resultType的时候，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性 resultMap返回类型直接是一个ResultMap主要用在进行复杂联合查询上 简单 resultMap 配置 &lt;resultMap id=&quot;BlogResult&quot; type=&quot;com.liulanghan.Blog&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;/&gt; &lt;result column=&quot;content&quot; property=&quot;content&quot;/&gt; &lt;result column=&quot;owner&quot; property=&quot;owner&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlog&quot; parameterType=&quot;int&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog where id = #{id} &lt;/select&gt; 结果集的列比resultMap多会报错么？ —— 不会,只映射resultMap中有的列 结果集的列比resultMap少会报错么？ —— 不会,只映射结果集中有的列 高级结果映射见高级查询 Mybatis学习路线总结★★★★★★★★★★ 一级缓存在mybatis中，一级缓存默认是开启的，并且无法关闭 一级缓存满足条件： 同一个session中 相同的SQL和参数 测试1、测试代码 2、日志输出 使用session.clearCache()强制查询不缓存1、代码 2、日志输出： 向数据库发送两次查询语句 执行update,delete,insert 语句的时候，会刷新缓存1、代码 2、日志 二级缓存mybatis 的二级缓存的 作用域 是一个mapper的namespace ，同一个namespace中查询sql可以从缓存中命中 开启二级缓存需要在mapper.xml 中加入如下： &lt;cache /&gt; 测试二级缓存 查询一次 关闭sqlSession 重新打开sqlSession 继续查询，观察是否发送sql语句 1、代码 2、日志 二级缓存的高级配置 关闭二级缓存在全局的mybatis-config.xml 中去关闭二级缓存 测试 日志会有两次sql语句查询 高级查询★★★★★★官方文档http://blog.csdn.net/tayanxunhua/article/details/19194607 数据库设计1、用户表2、订单表3、产品表 思路： 一个用户可以有多个订单，某个订单只属于一个用户：需在订单表中设置指向用户表的外键 一个订单中有多个产品，一个产品可以属于多个订单，关系是多对多：建立中间表，指向订单表和产品表的外键 表之间的关系，以订单表作为出发点 订单表与用户表：1：1 一个订单只能属于一个人 1：1 一个用户可以有多个订单 1：N 订单表与商品表：N:N 一个订单可以有多个商品 1：N 一个商品可以属于多个订单表 1：N 订单表与订单详情：1：N 一个订单有多个订单详情 一个订单详情只属于一个订单 总结，以订单的角度看，他们的关系是： 订单和人是一对一关系 订单和订单详情是一对多的关系 订单和商品是多对多的关系 自动映射配置：autoMapping详解http://www.cnblogs.com/TheViper/p/4480765.htmlhttp://www.zhihu.com/question/41983738/answer/98829976 一对一查询 查询订单，并且查询出下单人的信息 核心思想：面向对象的思想，在Order对象中添加User对象 association关联元素处理一对一关联，比如：一个博客只有一个作者，一张订单只属于一个用户 方法一：关联的嵌套查询 （select联合查询，懒加载） Domain public class Order { private int id; private User user;//private int user_id; private String order_number; } 定义OrderMapper接口 public interface OrderMapper { public Order queryOrderAndUserLazy(String orderNumber); } Ordermapper.xml &lt;!--1、查询订单，属性中包含对象必须使用resultMap--&gt; &lt;select id=&quot;queryOrderAndUserLazy&quot; resultMap=&quot;lazyOrderUserResultMap&quot;&gt; SELECT * FROM tb_order WHERE order_number = #{order_number} &lt;/select&gt; &lt;!--2、指定Order中user成员变量的详细装配方式，即根据user_id查询User对象--&gt; &lt;resultMap id=&quot;lazyOrderUserResultMap&quot; type=&quot;Order&quot;&gt; &lt;!-- 一个 ID 结果，标记结果作为 ID 可以帮助提高整体效能 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--resultMap必须制定javaType，如果你映射到一个JavaBean，MyBatis通常可以断定类型--&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;user_id&quot; select=&quot;queryUserById&quot;/&gt; &lt;/resultMap&gt; &lt;!--3、查询用户--&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot;&gt; SELECT * FROM tb_user where id = #{id} &lt;/select&gt; 测试 @Test public void testQueryOrderAndUserByOrderNumber() throws Exception { Order order = orderMapper.queryOrderAndUserLazy(&quot;20140921001&quot;); System.out.println(order); System.out.println(order.getUser()); } 有两个查询语句：一个来加载订单，另外一个来加载用户, 而且订单的结果映射描述了”queryUserById”语句应该被用来加载它的 User 属性。 其他所有的属性将会被自动加载，假设它们的列和属性名相匹配。这种方式很简单, 但是对于大型数据集合和列表将不会表现很好，就会出现”N+1”的问题。 “N+1”的问题可以是这样引起的：你执行了一个单独的 SQL 语句来获取结果列表(就是”+1”)——查询Order语句对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是”N”)——查询User语句这个问题会导致成百上千的 SQL 语句被执行，这通常不是期望的 MyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加载,这样的行为可能是很糟糕的。所以还有另外一种方法 方法二：关联查询 方式一：属性全部重命名，手动映射 代替了执行一个分离的语句,我们联合订单表和用户表在一起 所有结果被唯一而且清晰的名字来重命名，这使得映射非常简单 缺点是所有字段都要手动映射，操作简单，但工作量较大，可以使用自动映射 &lt;!--联合查询订单和用户，一对一关系--&gt; &lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt; SELECT o.id as order_id, o.user_id as order_user_id, o.order_number as order_order_number, u.id as user_id, u.user_name as user_user_name, u.password as user_password, u.name as user_name, u.age as user_age, u.sex as user_sex, u.birthday as user_birthday, u.created as user_created, u.updated as user_updated FROM tb_order o LEFT JOIN tb_user u ON u.id = o.user_id WHERE o.order_number = #{order_number} &lt;/select&gt; &lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt; &lt;result property=&quot;order_number&quot; column=&quot;order_order_number&quot;/&gt;&lt;!-- 有顺序要求，必须放在id后--&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;user_name&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;user_password&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;user_age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;user_sex&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;user_birthday&quot;/&gt; &lt;result property=&quot;created&quot; column=&quot;user_created&quot;/&gt; &lt;result property=&quot;updated&quot; column=&quot;user_updated&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 方式二：自动映射，冲突字段自动命名，手动映射，其余元素自动匹配（推荐）★★★★★ 当自动匹配结果的时候，Mybatis会获取列名，并且查找一个相同的属性（忽略大小写）。这意味着命名为ID的列和命名为id的属性被查找到的时候，Mybatis将会把列ID的值赋给属性id 通常数据库列名命名的时候使用大写和下划线并且Java属性常常依据驼峰命名法。为了保证在他们之间的自动匹配要设置属性 mapUnderscoreToCamelCase 为 true 对于每一个result map，所有的在ResultSet中有的并且没有被手动匹配的列将会被自动的匹配。默认不开启，设置 autoMapping=”true”开启 冲突字段重命名，自动赋值，其余元素自动匹配 &lt;!--联合查询订单和用户，一对一关系--&gt; &lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt; SELECT *,u.id as user_id,o.id as order_id FROM tb_order o LEFT JOIN tb_user u ON u.id = o.user_id WHERE o.order_number = #{order_number} &lt;/select&gt; &lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 方式三：外部结果映射 使用外部的结果映射元素来映射关联，使得User结果映射可以重用。如果你不需要重用它的话，或者你仅仅引用你所有的结果映射合到一个单独描述的结果映射中，即方式二 &lt;!--联合查询订单和用户，一对一关系--&gt; &lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt; SELECT *,u.id as user_id,o.id as order_id FROM tb_order o LEFT JOIN tb_user u ON u.id = o.user_id WHERE o.order_number = #{order_number} &lt;/select&gt; &lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;user&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;user&quot; type=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;/resultMap&gt; 一对多查询查询订单，查询出下单人信息并且查询出订单详情 订单表、用户表、订单详情三表联合查询 映射结果为Order类，填充user和orderDetails属性对象 Domain public class Order { private int id; private User user;//private int user_id; private String order_number; private List&lt;OrderDetail&gt; orderDetails; } 定义OrderMapper接口 public interface OrderMapper { public Order queryOrderAndUserAndDetailByOrderNumber(String orderNumber); } OrderMapper.xml &lt;!--collection：1：N--&gt; &lt;select id=&quot;queryOrderAndUserAndDetailByOrderNumber&quot; resultMap=&quot;orderUserDetailResultMap&quot;&gt; SELECT *,o.id as order_id,d.id as detail_id FROM tb_order o LEFT JOIN tb_user u ON u.id = o.user_id LEFT JOIN tb_orderdetail d ON o.id = d.order_id WHERE o.order_number = #{order_number} &lt;/select&gt; &lt;resultMap id=&quot;orderUserDetailResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;/association&gt; &lt;!--collection 定义集合 property：集合的属性名 javaType：集合的类型 ofType：集合中成员类型 子标签内：填id和result --&gt; &lt;collection property=&quot;orderDetails&quot; javaType=&quot;List&quot; ofType=&quot;OrderDetail&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 测试 Order order = orderMapper.queryOrderAndUserAndDetailByOrderNumber(&quot;20140921001&quot;); System.out.println(order); List&lt;OrderDetail&gt; orderDetails = order.getOrderDetails(); for(OrderDetail d : orderDetails) System.out.println(d); 多对多查询查询订单，查询出下单人信息并且查询出订单详情中的商品数据 doamin public class OrderDetail { private int id; private Order order;//private int order_id; private Item item;//private int item_id; private double total_price; private int status; } 定义OrderMapper public interface OrderMapper { public Order queryOrdreAndUserAndDetailAndItemByOrderNumber(String orderNumber); } OrderMapper.xml &lt;!--查询订单，查询出下单人信息并且查询出订单详情中的商品数据 N:N--&gt; &lt;select id=&quot;queryOrdreAndUserAndDetailAndItemByOrderNumber&quot; resultMap=&quot;orderUserDetailItemResultMap&quot;&gt; SELECT * FROM tb_order o LEFT JOIN tb_user u ON u.id = o.user_id LEFT JOIN tb_orderdetail d ON o.id = d.order_id LEFT JOIN tb_item i ON d.item_id = i.id WHERE o.order_number = #{order_number} &lt;/select&gt; &lt;resultMap id=&quot;orderUserDetailItemResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;/association&gt; &lt;collection property=&quot;orderDetails&quot; javaType=&quot;List&quot; ofType=&quot;OrderDetail&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;/&gt; &lt;association property=&quot;item&quot; javaType=&quot;Item&quot; autoMapping=&quot;true&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;item_id&quot;&gt;&lt;/id&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; 测试 @Test public void testQueryOrdreAndUserAndDetailAndItemByOrderNumber(){ Order order = orderMapper.queryOrdreAndUserAndDetailAndItemByOrderNumber(&quot;20140921001&quot;); System.out.println(order); } resultMap的继承 延迟加载(未成功)开启延迟加载&lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; lazyLoadingEnabled：true使用延迟加载，false禁用延迟加载，默认为false aggressiveLazyLoading： 默认true，当有一个进行加载的时候，就会把所有没有加载的属性加载进来 false按需加载，只有调用对应的getter的才会去加载 添加cglib&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; 接口定义public interface OrderMapper { public Order queryOrderAndUserLazy(String orderNumber); } OrderMapper.xml &lt;mapper namespace="cn.apeius.mybatis.mapper.OrderMapper"> &lt;select id="queryOrderAndUserLazy" resultMap="lazyOrderUserResultMap"> SELECT * FROM tb_order WHERE order_number = #{order_number} &lt;/select> &lt;resultMap id="lazyOrderUserResultMap" type="Order" autoMapping="true"> &lt;id property="id" column="id">&lt;/id> &lt;-- columnw中的user_id作为参数传入queryUserById--> &lt;association property="user" javaType="User" column="user_id" select="queryUserById"/> &lt;/resultMap> &lt;select id="queryUserById" resultType="User"> SELECT * FROM tb_user where id = #{id} &lt;/select> &lt;/mapper> 测试@Test public void testQueryOrderAndUserLazy(){ OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class); Order order = orderMapper.queryOrderAndUserLazy(&quot;20140921001&quot;); System.out.println(order.getOrder_number()); System.out.println(order.getUser()); } 分页插件 Mybatis提供了plugin机制，允许我们在mybatis的原有流程上加入自己的逻辑，加上分页逻辑可以方便实现分页 原理是利用了拦截器，mybatis支持的拦截接口有四个：Executor、ParameterHandler、ResultSetHandlet、StatementHandler plugin实现原理 原来的sql语句: select * from tb_user 经过拦截器后，变为: selectd * from tb_user limit 1,10 从而实现分页 使用PageHelper实现分页PageHelper实现了通用的分页查询，其支持的数据库有Mysq、Oracle、DB2、PostgreSQL等主流数据库 导入依赖&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; 配置插件&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;!--设置为true时，使用RowBounds分页会进行count查询，即会去查询出总数--&gt; &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 在执行查询时设置分页参数@Test public void testPage(){ //开启分页，第一个参数：当前的页数；第二个参数：每页几条数据 PageHelper.startPage(2,5); //紧接着的第一个查询会被执行分页 List&lt;User&gt; users = userMapper.queryAllUser(); for(User u : users){ System.out.println(u); } //获取分页信息 PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(users); pageInfo.getList();//与users为同一个引用 System.out.println(&quot;总记录数：&quot; + pageInfo.getTotal()); System.out.println(&quot;总页数 &quot; + pageInfo.getPages()); System.out.println(&quot;当前页数 &quot; + pageInfo.getPageNum()); System.out.println(&quot;每页多少数据 &quot; + pageInfo.getPageSize()); System.out.println(&quot;当前页的数据条目数 &quot; + pageInfo.getSize()); } mybatis和spring整合官方文档https://github.com/rhapsody1290/MybatisStudy/tree/master/doc/%E4%B8%AD%E6%96%87%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/Mybatis-Spring-1.2.2 什么是MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码 无缝地整合 到 Spring 中，使用这个类库中的类, Spring 将会加载必要的 MyBatis 工厂类和 session 类 这个类库也提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean 中 它也会处理事务, 翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常中 最终,它并不会依赖于 MyBatis,Spring 或 MyBatis-Spring 来构建应用程序代码 导入依赖mybatis-spring整合包 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; c3p0依赖，一个开源的JDBC连接池 &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; c3p0.properties(数据源)c3p0.driverClass=com.mysql.jdbc.Driver c3p0.url=jdbc:mysql://localhost:3306/mybatis c3p0.user=root c3p0.password=root 配置spring的配置文件applicationContext.xml 引入配置文件c3p0.properties 配置连接池 配置sqlSessionFactory 引入数据源 引入mybatis的全局配置 包扫描方式配置别名typeAliasesPackage mapper.xml所在路径(Mapper.xml和java代码分离) mapper接口所在的包 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:c3p0.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${c3p0.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${c3p0.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${c3p0.user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${c3p0.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置sqlSessionFactory。SqlSessionFactoryBean 是用于创建 SqlSessionFactory 的--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--引入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--引入mybatis的全局配置--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!--mybatis别名包--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.apeius.mybatis.domain&quot;/&gt; &lt;!--mapper.xml所在路径,可以使mapper接口与mapper.xml分离；可以使用通配符，**表示所有目录--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/**/*.xml&quot; /&gt; &lt;/bean&gt; &lt;!--指定扫描包，mapper接口所在的包--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--多个扫描包可以通过逗号或分号进行分割--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.apeius.mybatis.mapper&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; mybatis-config.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;!--设置为true时，使用RowBounds分页会进行count查询，即会去查询出总数--&gt; &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 问题：为什么配置SqlSessionFactory时，class为SqlSessionFactory 在基本的 MyBatis 中, SqlSessionFactory 可以使用 SqlSessionFactoryBuilder 来创建，而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口，这就说明了由 Spring 最终创建的 bean 不是 SqlSessionFactoryBean 本身 , 而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储 mybatis和spring整合测试ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(UserMapper.class); List&lt;User&gt; users = userMapper.queryAllUser(); for(User user : users){ System.out.println(user.getId() + &quot; &quot; + user.getUser_name()); } mapper整合servcieservcie接口public interface UserServiceInter { public List&lt;User&gt; queryAll(); } service实现@Service public class UserServiceImp implements UserServiceInter { @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; queryAll() { return userMapper.queryAllUser(); } } applicationContext.xml配置使service属性自动注入 &lt;context:component-scan base-package=&quot;cn.apeius.mybatis.service.imp&quot;&gt;&lt;/context:component-scan&gt; 测试ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserServiceInter userServiceInter = context.getBean(UserServiceImp.class); List&lt;User&gt; users = userServiceInter.queryAll(); for(User user : users){ System.out.println(user); } mybatis整合事务管理（未成功）配置事务管理&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 定义事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 定义事务策略 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--所有以query开头的方法都是只读的 --&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt; &lt;!--其他方法使用默认事务策略 --&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;!--pointcut元素定义一个切入点，execution中的第一个星号 用以匹配方法的返回类型， 这里星号表明匹配所有返回类型。 com.abc.dao.*.*(..)表明匹配cn.itcast.mybatis.service包下的所有类的所有方法 --&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* cn.apeius.mybatis.service.*.*(..))&quot; /&gt; &lt;!--将定义好的事务处理策略应用到上述的切入点 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot; /&gt; &lt;/aop:config&gt; &lt;/beans&gt; service@Service public class UserServiceImp implements UserServiceInter { @Autowired protected UserMapper userMapper; @Override public List&lt;User&gt; queryAll() { return userMapper.queryAllUser(); } @Override public void saveUser(User user) { userMapper.addUser(user); //int a = 9 / 0; } } 测试@Before public void setUp(){ ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext-transaction.xml&quot;}); userServiceInter = context.getBean(UserServiceImp.class); } @Test public void testSaveUser(){ User user = new User(); user.setUser_name(&quot;陈冠希&quot;); user.setName(&quot;dsfa&quot;); userServiceInter.saveUser(user); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2笔记]]></title>
      <url>%2F2016%2F08%2F11%2F%5BStruts2%5DStruts2%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[什么是Struts2 Struts2是一个MVC框架 Struts2起源于WebWork框架，Struts2就是WebWork2 Struts2是对Struts1的一个补充，而不是替代品 Struts2快速入门(Action、struts.xml、跳转结果)登录功能Actionpackage cn.apeius.action; import com.opensymphony.xwork2.ActionSupport; import com.sun.net.httpserver.Authenticator; /** * Created by Asus on 2016/8/11. */ public class LoginAction extends ActionSupport { private String account; private String password; public String execute(){ if(&quot;admin&quot;.equals(account) &amp;&amp; &quot;admin&quot;.equals(password)){ return SUCCESS; }else{ return LOGIN; } } public String getAccount() { return account; } public void setAccount(String account) { this.account = account; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 新建LoginAction，Struts2的Action需要继承com.opensymphony.xwork2.ActionSupport LoginAction中有两个属性account、password，代表JSP表单的两个输入框。Struts2会自动把输入框中的内容通过getter、setter方法设置进来 还有一个execute方法，提交数据后会自动调用该方法 返回值代表结果页面的跳转，具体文件见配置文件 Struts2配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;!--定义一个package，所有的result和action等必须配置到package--&gt; &lt;package name=&quot;main&quot; extends=&quot;struts-default&quot;&gt; &lt;!--所有的全局result--&gt; &lt;global-results&gt; &lt;!--名为login的result--&gt; &lt;result name = &quot;login&quot;&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;!--LoginAction--&gt; &lt;action name=&quot;LoginAction&quot; class=&quot;cn.apeius.action.LoginAction&quot;&gt; &lt;!--名为success的result--&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; Struts2所有的result、action等必须配置到package中，自定义的package一般继承struts-default JSP配置在result中。上述配置文件配置了两个result，一个是名为success，配置在action里面，当登录成功后跳转到success.jsp里面；另一个是全局的result，配置在global-results中，名为login，访问任何页面首页跳转到login.jsp JSP登录页面&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;struts&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;struts:form action=&quot;LoginAction&quot;&gt; &lt;struts:label value=&quot;登录系统&quot;&gt;&lt;/struts:label&gt; &lt;struts:textfield name=&quot;account&quot; label=&quot;帐号&quot;/&gt; &lt;struts:password name=&quot;password&quot; label=&quot;密码&quot;/&gt; &lt;struts:submit value=&quot;登录&quot;&gt;&lt;/struts:submit&gt; &lt;/struts:form&gt; &lt;/body&gt; &lt;/html&gt; 配置web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--struts2的filter，所有请求都被映射到struts上--&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--匹配所有URL--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; Struts2使用Filter作为分发器，配置ur-pattern最好配置为/* Struts2工作流程★★★★★ 用户访问JSP页面 login.jsp，跳出登录页面 提交表单后数据提交给LoginAction Struts2拦截所有请求，包括*.action的请求 查找struts.xml，LoginAction对应LoginAction类，生成LoginAction实例，并将提交的数据注入 该实例中（从request中获取参数），调用LoginAction实例的execute方法 根据返回结果，决定跳转 JSP页面 Struts2线程安全 Struts1所有Action都只有一个实例，不是线程安全 Struts2对每个请求生成一个实例，处理完成即销毁，是线程安全的（Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用，Struts2必须是多例的，如果是单例会导致不同用户数据的冲突） Action详解通配符配置ActionBookAction.java public class BookAction extends ActionSupport { public static List&lt;Book&gt; bookList = new ArrayList&lt;Book&gt;(); private String title; private Book book; public String add() { bookList.add(book); title = &quot;&lt;br/&gt;&lt;br/&gt;添加书籍成功&lt;br/&gt;&lt;br/&gt;&quot;; return &quot;success&quot;; } // 书籍列表 @SkipValidation public String list() { return &quot;list&quot;; } // 清空书籍列表 @SkipValidation public String clear() { bookList.clear(); title = &quot;&lt;br/&gt;&lt;br/&gt;清空书籍列表成功&lt;br/&gt;&lt;br/&gt;&quot;; return &quot;list&quot;; } } struts.xml &lt;action name=&quot;*Book&quot; class=&quot;com.helloweenvsfei.struts2.action.BookAction&quot; method=&quot;{1}&quot;&gt; &lt;result&gt;/successBook.jsp&lt;/result&gt; &lt;result name=&quot;{1}&quot;&gt;/{1}Book.jsp&lt;/result&gt; &lt;result name=&quot;input&quot;&gt;/initAddBook.jsp&lt;/result&gt; &lt;result name=&quot;list&quot;&gt;/listBook.jsp&lt;/result&gt; &lt;/action&gt; *代表的内容可以在本Action配置内部使用{1},{2}等引用 举个例子，访问listBook.action时，执行list()方法 常见问题Struts2中关于”There is no Action mapped for namespace / and action name”的总结http://www.cnblogs.com/gulvzhe/archive/2011/11/21/2256632.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令行编译Java程序]]></title>
      <url>%2F2016%2F08%2F09%2F%5BJava%5D%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91Java%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[先说下.java和.class文件，.java文件可以放在任何位置，只要运行javac时，指定你要编译的源文件位置就好，然后javac还有另一个参数是指定.class文件输出到哪个目录。另外javac还有一个option叫 -d，表示编译出来的.class文件，按照包名放进相应层级的目录中去。所以，假设你的.java文件在D:\code\src\com\company\Hello.java，（因为Java要求源文件中的public类与源文件名要相同，类名通常首字母大写，所以源文件通常是Hello.java这样的），并且假如你的Hello.java里写明package com.company;假如你当前置身于D:\code\目录下，执行javac .\src\com\company\Hello.java -d .\bin\表示编译.\src\com\company\Hello.java，将编译好的.class文件按包名层级结构放到.\bin\目录下。于是在D:\code\bin\com\company\下会出现一个Hello.class文件。这时，运行Hello时，跟.java文件就没有关系了。这时如果你置身于D:\code\bin\目录下，最好了，因为我们通常配置环境变量时，CLASSPATH会配置.，也就是当前路径，那你就在D:\code\bin\下执行java，那class也就在当前路径找了：java com.company.Hello，这里java是启动虚拟机的命令，启动时运行哪个类呢？com.company.Hello，这是类名，带着包名，叫全限定名，也就是类的全名，这跟它在哪个目录下没关系，是类名，虚拟机会在CLASSPATH下，也就是当前目录下，去找com.company.Hello这个类，并加载运行。至于它怎么找，你就不用管了。如果你当前正置身于D:\code\下，那你执行java com.company.Hello就失败了，因为虚拟机在CLASSPATH下找不到这个类。那怎么办呢，就要告诉虚拟机，去哪找，也就是要指定CLASSPATH，可以执行：java -classpath .\bin com.company.Hello不知道你能不能理解，你要运行的是com.company.Hello这个类，这是类名，不是目录名，去哪找这个类？用-classpath告诉虚拟机，所以，不能java .\bin\com.company.Hello，这就不伦不类了。 参考http://bbs.csdn.net/topics/390865848]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Log4j笔记]]></title>
      <url>%2F2016%2F08%2F08%2F%5BJava%5DLog4j%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[依赖&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 快速入门1、新建一个JAva工程，导入包log4j-1.2.17.jar，整个工程最终目录如下 2、src同级创建并设置log4j.properties ### 设置### log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ### log4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss,SSS} [%p] method:%l%n%m%n ### 输出DEBUG级别以上的日志到=E://logs/error.log ### log4j.appender.D = org.apache.log4j.DailyRollingFileAppender log4j.appender.D.File = E://logs/log.log log4j.appender.D.Append = true log4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ### 输出ERROR级别以上的日志到=E://logs/error.log ### log4j.appender.E = org.apache.log4j.DailyRollingFileAppender log4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = true log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n 3、设置日志内容 package com.mucfc; import org.apache.log4j.Logger; /** *@author linbingwen *@2015年5月18日9:14:21 */ public class Test { private static Logger logger = Logger.getLogger(Test.class); /** * @param args */ public static void main(String[] args) { // System.out.println(&quot;This is println message.&quot;); // 记录debug级别的信息 logger.debug(&quot;This is debug message.&quot;); // 记录info级别的信息 logger.info(&quot;This is info message.&quot;); // 记录error级别的信息 logger.error(&quot;This is error message.&quot;); } } Log4j的架构Log4j由三个重要的组件构成： 日志写入器：控制日志信息的优先级，日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG 日志输出终端：指定了日志将打印到控制台还是文件中 日志布局模式：控制日志信息的输出格式 Logger类是日志包的核心，Logger的名称是大小写敏感的，并且名称之间有继承关系。子名由父名做前缀，用点号”.”分隔，如x.y是x.y.z的父亲Logger。 Log4j基本使用方法定义配置文件1、配置根Logger，其语法为： log4j.rootLogger = [ level ] , appenderName, appenderName, … level是日志记录的优先级，Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来 appenderName就是指日志信息输出到哪个地方。您可以同时指定多个输出目的地 2.配置日志信息输出目的地Appender，其语法为： log4j.appender.appenderName = org.apache.log4j.DailyRollingFileAppender 其中，Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台）， org.apache.log4j.FileAppender（文件）， org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）， org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）， org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 3.配置日志信息的格式（布局），其语法为： log4j.appender.appenderName.layout = org.apache.log4j.PatternLayout 其中，Log4j提供的layout有以e几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 在代码中使用Log4j1.得到记录器 static Logger logger = Logger.getLogger(Class clazz)；//在某对象中，用该对象所属的类作为参数 2.读取配置文件() PropertyConfigurator.configure ( String configFilename) ：读取使用Java的特性文件编写的配置文件 例如： PropertyConfigurator.configure(&quot;config/properties/log4j.properties&quot;); 在项目下面建立一个文件夹名为config即可，这是标准写法。注意log4j默认的相对路径是工程下面，非src或者bin 3.插入记录信息（格式化日志信息） Logger.debug ( Object message ) ; Logger.info ( Object message ) ; Logger.warn ( Object message ) ; Logger.error ( Object message ) ; 配置文件相对路径log4j.appender.R.File=${user.dir}/logs/log.log commons-logging 和 log4j 之间的关系Log4j与通用日志包commons-logging的结合使用其实commons-logging中默认都支持 Log4j，因此只要同时加载commons-logging包和log4j包，可以不用配置即可用在应用中使用commons-logging的接口方法。 当然，标准的应用的是需要的配置，如果你log4j则这个配置是可选的。下面我说明如何通过配置文件来组合commons-logging和log4j。 配置文件内容很简单，就指定一个日志实现类即可，下面是个示例文件commons-logging.properties： org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger org.apache.commons.logging.LogFactory=org.apache.commons.logging.impl.LogFactoryImpl commons-logging 和 log4j 之间的关系我们在做项目时，日志的记录是必不可少的一项任务，而我们通常是使用 apache 的 log4j 日志管理工具。然而，在项目中，我们经常会看到两个 jar 包：commons-logging.jar 和 log4j.jar。为什么我们在使用 log4j 的同时还要引入 commons-logging.jar 呢，或者说不用 commons-logging.jar 可不可以，这两者之间到底是怎么的一种关系呢？ 作为记录日志的工具，它至少应该包含如下几个组成部分(组件)： Logger 记录器组件负责产生日志，并能够对日志信息进行分类筛选，控制什么样的日志应该被输出，什么样的日志应该被忽略。它还有一个重要的属性 － 日志级别。不管何种日志记录工具，大概包含了如下几种日志级别：DEBUG, INFO, WARN, ERROR 和 FATAL。 Level 日志级别组件。 Appender 日志记录工具基本上通过 Appender 组件来输出到目的地的，一个 Appender 实例就表示了一个输出的目的地。 Layout Layout 组件负责格式化输出的日志信息，一个 Appender 只能有一个 Layout。 我们再来看看 log4j.jar，打开 jar 包，我们可以看到 Logger.class(Logger)，Level.class(Level), FileAppender.class(Appender)， HTMLLayout.class(Layout)。其它的我们先忽略不看，这几个字节码文件正好是记录日志必不可少的几个组件。 接下来看看 commons-logging 中的 org.apache.commons.logging.Log.java 源码： package org.apache.commons.logging; public interface Log { public boolean isDebugEnabled(); public boolean isErrorEnabled(); public boolean isFatalEnabled(); public boolean isInfoEnabled(); public boolean isTraceEnabled(); public boolean isWarnEnabled(); public void trace(Object message); public void trace(Object message, Throwable t); public void debug(Object message); public void debug(Object message, Throwable t); public void info(Object message); public void info(Object message, Throwable t); public void warn(Object message); public void warn(Object message, Throwable t); public void error(Object message); public void error(Object message, Throwable t); public void fatal(Object message); public void fatal(Object message, Throwable t); } 很显然，只要实现了 Log 接口，它就是一个名副其实的 Logger 组件，也验证了 Logger 组件具有日志级别的属性。继续看 commons-logging org.apache.commons.logging.impl 包下的几个类的源码片段： package org.apache.commons.logging.impl; import org.apache.commons.logging.Log; import org.apache.log4j.Logger; import org.apache.log4j.Priority; import org.apache.log4j.Level; import ...... public class Log4JLogger implements Log, Serializable { // 对 org.apache.commons.logging.Log 的实现 ...... } ------------------------------------------------------------------ package org.apache.commons.logging.impl; import org.apache.commons.logging.Log; import java.io.Serializable; import java.util.logging.Level; import java.util.logging.Logger; public class Jdk14Logger implements Log, Serializable { // 对 org.apache.commons.logging.Log 的实现 ...... } 好了，分析到这里，我们应该知道，真正的记录日志的工具是 log4j 和 sun 公司提供的日志工具。而 commons-logging 把这两个(实际上，在 org.apache.commons.logging.impl 包下，commons-logging 仅仅为我们封装了 log4j 和 sun logger)记录日志的工具重新封装了一遍(Log4JLogger.java 和 Jdk14Logger.java)，可以认为 org.apache.commons.logging.Log 是个傀儡，它只是提供了对外的统一接口。因此我们只要能拿到 org.apache.commons.logging.Log，而不用关注到底使用的是 log4j 还是 sun logger。正如我们经常在项目中这样写： // Run 是我们自己写的类，LogFactory 是一个专为提供 Log 的工厂(abstract class) private static final Log logger = LogFactory.getLog(Run.class); 既然如此，我们向构建路径加了 commons-logging.jar 和 log4j.jar 两个 jar 包，那我们的应用程序到底使用的 log4j 还是 sun logger 呢？我们能不能认为由于加了 log4j.jar 包，就认为系统使用的就是 log4j 呢？事实上当然不是这样的，那我还认为我正在使用 jdk 而认为系统使用的是 sun logger 呢。使用 Spring 的朋友可以在 web.xml 中看到如下 listener 片段： &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; 这是由 Spring 为我们提供的实现了标准的 servlet api 中的 javax.servlet.ServletContextListener 接口，用于在 web 容器启动时做一些初始化操作。我们逐层进入 Spring 的源码，可以看到如下代码： Log4jConfigurer.initLogging(location, refreshInterval); 终于找到了 org.springframework.util.Log4jConfigurer，这正是 log4j 提供给我们的初始化日志的类。至此，我们终于明白了我们系统的的确确使用的是 log4j 的日志工具。 可是问题又来了，org.apache.commons.logging.Log 和 org.apache.log4j.Logger 这两个类，通过包名我们可以发现它们都是 apache 的项目，既然如下，为何要动如此大的动作搞两个东西(指的是 commons-logging 和 log4j)出来呢？事实上，在 sun 开发 logger 前，apache 项目已经开发了功能强大的 log4j 日志工具，并向 sun 推荐将其纳入到 jdk 的一部分，可是 sun 拒绝了 apache 的提议，sun 后来自己开发了一套记录日志的工具。可是现在的开源项目都使用的是 log4j，log4j 已经成了事实上的标准，但由于又有一部分开发者在使用 sun logger，因此 apache 才推出 commons-logging，使得我们不必关注我们正在使用何种日志工具。 slf4j-api、slf4j-log4j12以及log4j之间的关系几乎在每个jar包里都可以看到log4j的身影，在多个子工程构成项目中，slf4j相关的冲突时不时就跳出来让你不爽，那么slf4j-api、slf4j-log4j12还有log4j是什么关系？ slf4j:Simple Logging Facade for Java，为java提供的简单日志Facade。Facade门面，更底层一点说就是接口。它允许用户以自己的喜好，在工程中通过slf4j接入不同的日志系统。更直观一点，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 因此slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此slf4j-api本质就是一个接口定义。 下图比较清晰的描述了它们之间的关系，例子为当系统采用log4j作为日志框架实现的调用关系： ①首先系统包含slf4j-api作为日志接入的接口。compile时slf4j-api中public final class LoggerFactor类中private final static void bind()方法会寻找具体的日志实现类绑定，主要通过StaticLoggerBinder.getSingleton()的语句调用。 ②slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法。 ③log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 参考文献http://www.codeceo.com/article/log4j-usage.htmlhttp://blog.csdn.net/hpf911/article/details/5852127http://www.tuicool.com/articles/U7ZjUnihttp://zachary-guo.iteye.com/blog/361177]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dos攻击原理及防御]]></title>
      <url>%2F2016%2F08%2F04%2F%5B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%5DDos%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%8F%8A%E9%98%B2%E5%BE%A1%2F</url>
      <content type="text"><![CDATA[Dos攻击简介DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络 带宽攻击和 连通性攻击。 带宽攻击 指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。 连通性攻击 指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。 DDos攻击简介传统上，攻击者所面临的主要问题是网络带宽，由于较小的网络规模和较慢的网络速度的限制，攻击者无法发出过多的请求。但大多数的DoS攻击还是需要相当大的带宽的，而以个人为单位的黑客们很难使用高带宽的资源。为了克服这个缺点，DoS攻击者开发了分布式的攻击。攻击者简单利用工具集合许多的网络带宽来同时对同一个目标发动大量的攻击请求，这就是DDoS(Distributed Denial of Service)攻击。 攻击表现方式★★★无论是DoS攻击还是DDoS攻击，简单的看，都只是一种破坏网络服务的黑客方式，虽然具体的实现方式千变万化，但都有一个共同点，就是其根本目的是使受害主机或网络无法及时接收并处理外界请求，或无法及时回应外界请求。其具体表现方式有以下几种： 1. 制造大流量无用数据，造成通往被攻击主机的网络拥塞，使被攻击主机无法正常和外界通信。 2. 利用被攻击主机提供服务或传输协议上处理重复连接的缺陷，反复高频的发出攻击性的 重复服务请求，使被攻击主机无法及时处理其它正常的请求。 3. 利用被攻击主机所提供服务程序或传输协议的本身实现缺陷，反复发送 畸形的攻击数据 引发系统错误的分配大量系统资源，使主机处于挂起状态甚至死机。 TCP三次连接及重要概念TCP连接三次握手要理解dos攻击，首先要理解TCP连接的三次握手过程(Three-way handshake)。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手:建立连接时，客户端发送 SYN 包((SYN=i)到服务器，并进入 SYN_SEND 状态，等待服务器确认; 第二次握手:服务器收到SYN包，必须确认客户的SYN (ACK=i+1 )，同时自己也发送一个SYN包((SYN=j)}即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包 ACK (ACK=j+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手，客户端与服务器开始传送数据。 一些重要概念 半连接：收到SYN包而还未收到ACK包时的连接状态 称为半连接，即尚未完全完成三次握手的TCP连接。 半连接队列：在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包(SYN=i)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 Backlog参数：表示半连接队列的最大容纳数目。 SYN-ACK重传次数：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息、从半连接队列中删除。注意，每次重传等待的时间不一定相同。 半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时也称半连接存活时间为Timeout时间、SYN_RECV存活时间。 上面 三个参数 对系统的TCP连接状况有很大影响 常见攻击与防范参考SYN Flood攻击（SYN洪水攻击）大纲： Dos攻击形式解决方法 1、固定源地址发起攻击检测到某个IP地址发起较多报文，加入黑名单 2、伪造IP地址进行攻击方法1失效，原因： 1、单个IP发送的SYN报文不会很多，达不到被拒绝的阈值 2、伪装的IP若被拒绝到，正常用户使用该IP将会无法获得服务 3、可以用三种解决方法方法，如下表 3、僵尸网络固定源地址发起攻击 解决方法问题 方法一：不断监视系统中连接队列，达到阈值就释放系统连接入门级防御SYN Flood方法，正常连接也会淹没在其中而被释放 方法二：延缓TCB分配1、SYS Cache：cache（哈希表）中保存半连接信息，收到正确回应ACK后再分配TCB 2、SYN cookie：根据SYN包按照一定的规则计算SYN+ACK包的初始序列。客户端返回ACK再次校验，若正确才分配TCB 方法三：使用SYN Proxy防火墙防火墙提供SYN代理，验证成功后才放行 原理： 问题就出在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的(第三次握手无法完成)，这种情况下服务器端一般会重试(再次发送SYN+ACK给客户端)，并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级(大约为30秒 - 2分钟); 一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源 数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃 即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求(毕竟客户端的正常请求比率非常之小)，此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击(SYN洪水攻击)。 SYN Flood种类： Direct Attack 攻击方使用 固定的源地址 发起攻击，这种方法对攻击方的消耗最小 Spoofing Attack 攻击方使用变化的源地址发起攻击，这种方法需要攻击方 不停地修改源地址，实际上消耗也不大 Distributed Direct Attack 这种攻击主要是使用僵尸网络进行固定源地址的攻击 防范： 对于第一种攻击的防范可以使用比较简单的方法，即对SYN包进行监视，如果发现某个IP发起了较多的攻击报文，直接将这个IP列入黑名单即可。当然下述的方法也可以对其进行防范。对于源地址不停变化的攻击使用上述方法则不行，首先从某一个被伪装的IP过来的Syn报文可能不会太多，达不到被拒绝的阈值，其次从这个被伪装的IP（真实的）的请求会被拒绝掉，即导致正常用户使用该IP将会无法访问服务。因此必须使用其他的方法进行处理。 1． 无效连接监视释放 这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级防御SYN Flood方法。 2． 延缓TCB分配方法 从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。 Syn Cache技术： 这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。在FreeBSD系统中这种Cache每个半开连接只需使用160字节，远小于TCB所需的736个字节。在发送的SYN ACK中需要使用一个己方的Sequence Number，这个数字不能被对方猜到，否则对于某些稍微智能一点的Syn Flood攻击软件来说，它们在发送Syn报文后会发送一个ACK报文，如果己方的Sequence Number被对方猜测到，则会被其建立起真正的连接。因此一般采用一些加密算法生成难于预测的Sequence Number。 Syn Cookie技术： 对于SYN攻击，Syn Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。 Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。(在接收到syn包后不分配TCB资源，而是根据SYN包计算出一个cookie，这个cookie作为将要返回syn+ack包的序号列，服务器中不存储序列号。下次客户端返回ack包时，再根据包头信息计算cookie，与ack包的序号加一进行对比，如果相等，则说明是正常的连接，分配资源建立连接) 3． 使用SYN Proxy防火墙 Syn Cache技术和Syn Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程： 从上图（左图）中可以看出，防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，在右图中，所有的无效连接均无法到达内部的服务器。而防火墙采用的验证连接有效性的方法则可以是Syn Cookie或Syn Flood等其他技术。 采用这种方式进行防范需要注意的一点就是防火墙需要对整个有效连接的过程发生的数据包进行代理，如下图所示： 因为防火墙代替发出的SYN ACK包中使用的序列号为c，而服务器真正的回应包中序列号为c’，这其中有一个差值|c-c’|，在每个相关数据报文经过防火墙的时候进行序列号的修改。 参考文献什么是Dos攻击？http://blog.csdn.net/justdoitflyer/article/details/12870907SYN Flood攻击及防御方法http://blog.csdn.net/bill_lee_sh_cn/article/details/6065704]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[磁盘分区]]></title>
      <url>%2F2016%2F08%2F01%2F%5BLinux%5D%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%2F</url>
      <content type="text"><![CDATA[磁盘连接方式与设备文件名的关系 计算机常用的磁盘接口有两种，分别是IDE与SATA接口，目前主流是SATA接口 一个IDE电缆可以连接两个IDE设备，通常主机提供两个IDE接口，因此最多可以接四个IDE设备。IDE设备分为主设备（Master）与从设备（Slave），四个IDE设备的文件名分别是/dev/hda、/dev/hdb、/dev/hdc/、/dev/hdd，对应IDE1的主设备、IDE1的从设备、IDE2的主设备、IDE2的从设备 SATA/USB/SCSI接口的磁盘设备文件名都是/dev/sd[a-p]，与IDE接口不同的是，SATA/USB接口没有一定的顺序，根据Linux内核检测到的磁盘顺序决定，即设备文件名与插槽号无关，Linux内核根据SATA插槽顺序进行检测磁盘，USB在开机候才被系统识别 磁盘组成 磁盘由盘片、机械手臂、磁头与主轴马达组成，数据的写入是在盘片上 盘片上可以细分为扇区与柱面两种单位 磁道：盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道 柱面：硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面。磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用 扇区：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，每个扇区可以存放512个字节的信息，磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位 问题1：不同磁道的扇区数是否相同？ 在旧的记录方式，的确每个磁道所拥有的扇区数量都是一样的。因为每个扇区所能容纳的数据量是相同的，都是512字节，而数据量需要平均分配在扇区面积的每个角落，所以外面扇区的数据密度低，里面扇区的速度密度高 新的解决方式认为，既然磁盘越往外面积越大，那就应该划分出更多的扇区，每个扇区的面积都是一样的，容纳的数据量也是一样的 问题2：如果有一块空硬盘，写入一个文件，是不是先写满同一个磁道的所有扇区，然后再换一个磁道写入？ 是的，而且写入的方式是从外到内，先写满最外的磁道，接着再写里面的磁道。为什么硬盘用久了读写速度会变慢？因为外面的磁道使用完了，开始用里面的磁道，越是里面的磁道读写速度越慢，同样的时间，读写头在外面磁道可以扫过10个扇区的面积，读写10个扇区的数据，但在里面的磁道只能扫过1个扇区的面积，读写1个扇区的数据，所以这时该做磁盘整理或者格式化，这会使外面的磁道得到使用 磁盘的第一扇区（主引导分区、分区表）磁盘的第一个扇区记录了两个重要信息，分别是： 主引导分区（MBR），可以安装引导加载程序的地方，有446bytes。MBR是很重要的，系统在开机的时候会主动去读取这个区块的内容，这样系统才知道你的程序放在哪里且如何进行开机。如果你要安装多重引导的系统，MBR这个区块的管理就非常重要了 分区表，记录整块硬盘分区的状态，有64bytes 磁盘分区表 柱面是分割磁盘的最小单位，以开始柱面与结束柱面来标识一个分区 假设上面硬盘的设备文件名为/dev/hda，四个分区的设备文件名会在文件名后再加上一个数字，分别是/dev/hda1，/dev/hda2，/dev/hda3，/dev/hda4 上述硬盘被分为四个分区，第四个分区为301~400柱面的范围，在windows系统中，四个分区分别是C、D、E、F。当你把数据写入F盘时，你的数据会被写入这块磁盘的301~400号柱面之间 分区表总结 所谓的分区就是对64bytes的分区表进行设置而已 分区的最小单位是柱面 分区表默认只能写入四组分区信息，即主分区与扩展分区不超过四个 系统要写入磁盘时，必须参考分区表，才能对某个分区进行数据处理 分区的好处：数据安全，系统性能 分区继续深入 上图中四个分区记录区仅用到两个，P1为主分区，P2为扩展分区 图中这5个由扩展分区切出来的分区叫做逻辑分区 上述分区在Linux下的设备文件名分别是P1：hda1，P2：hda2，L1：hda5，L2：hda6，L3：hda7，L4：hda8，L5：hda9 发现少了hda3，hda4，因为前面四个号码都是保留给主分区和扩展分区用的，所以逻辑分区的设备号从5开始 分区总结 主分区和扩展分区最多有四个 扩展分区最多只有一个（操作系统的限制） 逻辑分区是由扩展分区切割出来的分区 能够被格式化的是主分区和逻辑分区，扩展分区无法格式化 MBR（Master boot Record）主引导分区开机流程 操作系统的作用是控制计算机硬件资源的合理分配，但操作系统也是一个软件，从开机到执行操作系统软件的过程如下： CMOS是记录各项硬件参数且嵌在主板上的存储器，BIOS是写入到主板的一个软件程序，是计算机开机主动执行的第一个的程序 BIOS 会根据用户的设置取得能够开机的硬盘，并读取该硬盘第一个扇区的 MBR 位置，MBR中会放置 引导加载程序，引导加载程序的目的是加载内核文件，内核文件 开始操作系统的功能 多系统 引导加载程序的主要功能是读取内核文件，开始操作系统。在多系统中，引导加载程序能提供用户不同的开机选项，并将加载功能转交给其他引导加载程序 引导加载程序不但可以放置在MBR中，还可以安装在每个分区的引导扇区 如下图是windows和Linux双系统，开机时MBR的引导加载程序提供两个菜单，菜单一（M1）可以直接加载Windows内核文件来开机，菜单二（M2）则将引导加载工作移交给第二个分区的引导加载程序，加载Linux的内核文件来开机 为什么装双系统，最好先装windows再装Linux？ 因为Linux在安装时，可以选择将 引导加载加载程序 安装在MBR还是个别分区的引导扇区 Windows安装时，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA深复制(深克隆)与浅复制(浅克隆)]]></title>
      <url>%2F2016%2F07%2F29%2F%5BJava%5DJAVA%E6%B7%B1%E5%A4%8D%E5%88%B6(%E6%B7%B1%E5%85%8B%E9%9A%86)%E4%B8%8E%E6%B5%85%E5%A4%8D%E5%88%B6(%E6%B5%85%E5%85%8B%E9%9A%86)%2F</url>
      <content type="text"><![CDATA[参考http://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html 浅复制与深复制概念浅复制 被复制的对象的成员变量与原来的对象都有相同的值，但引用其他对象的成员变量仍指向原来的对象，修改引用对象的值，会同时影响原对象与复制对象。换言之，浅复制仅仅复制所考虑的对象，不复制它引用的对象。 深复制 被复制的对象的所有成员变量与原来对象都有相同的值，而且引用其他对象的成员变量将指向被复制过的新对象。换言之，深复制把要复制的对象及所引用的对象都复制了一遍。 java.lang.Object类的clone()方法是浅复制1234567891011121314151617181920212223242526272829303132333435363738394041public class test&#123; public static void main(String[] args)&#123; professor p = new professor(40); student s = new student(&quot;student&quot;, p); student new_s = (student)s.clone(); new_s.p.age = 18; System.out.println(s); System.out.println(new_s); &#125;&#125;class student implements Cloneable&#123; String name; professor p; public student(String name, professor p)&#123; this.name = name; this.p = p; &#125; public Object clone()&#123; Object o = null; try&#123; o = super.clone(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return o; &#125; @Override public String toString()&#123; return name + &quot; &quot; + p.age; &#125;&#125;class professor&#123; int age; public professor(int age)&#123; this.age = age; &#125;&#125; 结果： student 18 student 18 因为复制对象中成员变量引用的对象professor不变，当改变新复制对象的成员变量引用值，对原对象也会有影响。 实现深层次克隆方法1 在复制对象时，对引用的对象也进行复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class test&#123; public static void main(String[] args)&#123; professor p = new professor(40); student s = new student(&quot;student&quot;, p); student new_s = (student)s.clone(); new_s.p.age = 18; System.out.println(s); System.out.println(new_s); &#125;&#125;class student implements Cloneable&#123; String name; professor p; public student(String name, professor p)&#123; this.name = name; this.p = p; &#125; public Object clone()&#123; Object o = null; try&#123; o = super.clone(); ((student)o).p = (professor)this.p.clone();//核心 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return o; &#125; @Override public String toString()&#123; return name + &quot; &quot; + p.age; &#125;&#125;class professor implements Cloneable&#123; int age; public professor(int age)&#123; this.age = age; &#125; public Object clone()&#123; Object o = null; try&#123; o = super.clone(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return o; &#125;&#125; 实现深层次克隆方法2 利用串行化来做深复制，在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。12345678910111213141516171819202122232425262728293031323334353637383940import java.io.*;public class test&#123; public static void main(String[] args) throws Exception&#123; professor p = new professor(40); student s = new student(&quot;student&quot;, p); student new_s = (student)s.deepClone(); new_s.p.age = 18; System.out.println(s); System.out.println(new_s); &#125;&#125;class student implements Serializable&#123; String name; professor p; public student(String name, professor p)&#123; this.name = name; this.p = p; &#125; public Object deepClone() throws Exception&#123; //将对象写到流里 ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); //从流里读出来 ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return oi.readObject(); &#125; @Override public String toString()&#123; return name + &quot; &quot; + p.age; &#125;&#125;class professor implements Serializable&#123; int age; public professor(int age)&#123; this.age = age; &#125;&#125; 结果： student 40 student 18]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java类加载器深入讲解]]></title>
      <url>%2F2016%2F07%2F29%2F%5BJava%5DJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[什么是类加载器? 加载类的工具，把硬盘上.class文件加载到内存，并进行一些处理，得到字节码 类加载器有什么作用? 当程序需要的某个类，那么需要通过类加载器把类的二进制加载到内存中，类加载器也是Java类 类加载器之间的父子关系和管辖范围。 1234567#获得类加载器的名字ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();while (classLoader != null) &#123; System.out.println(classLoader.getClass().getName()); classLoader = classLoader.getParent();&#125;System.out.println(classLoader); ##4. 类加载器的委托机制: 类的加载 当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢? ①首先 当前线程的类加载器 去加载线程中的第一个类. ②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B ③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类. 每个类加载器加载类时，又先委托给其上级类加载器 当所有祖宗类加载器没有加载到类，回到发起者类加载器，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。 委托机制有什么好处? 集中管理，如果我们写了几个类加载器，都去加载某个类，那么内存中就有多份这个类的字节码 安全。系统类由系统的类加载器加载 能不能自己写一个类叫java.lang.System? 为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸优先，也就是使用的永远是爸爸的(系统的)System类，而不是我们写的System类. 编写自己的类加载器123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; String srcPath = args[0]; String destDir = args[1]; FileInputStream fis = new FileInputStream(srcPath); String destFileName = srcPath.substring(srcPath.lastIndexOf('\\')+1); String destPath = destDir + "\\" + destFileName; FileOutputStream fos = new FileOutputStream(destPath); cypher(fis，fos); fis.close(); fos.close(); &#125; /** * 加密方法，同时也是解密方法 * @param ips * @param ops * @throws Exception */ private static void cypher(InputStream ips ，OutputStream ops) throws Exception&#123; int b = -1; while((b=ips.read())!=-1)&#123; ops.write(b ^ 0xff);//如果是1就变成0，如果是0就变成1 &#125; &#125; 然后在新建一个类，通过上面的方法将新建的类的字节码进行加密:12345public class ClassLoaderAttachment extends Date &#123; //为什么要继承Date待会再说? public String toString()&#123; return "hello，itcast"; &#125; &#125; 并在工程里新建一个文件夹，用来保存加密后的class文件. 那么这就需要使用我们自己的类加载器来进行解密了.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyClassLoader extends ClassLoader&#123; public static void main(String[] args) throws Exception &#123; String srcPath = args[0]; String destDir = args[1]; FileInputStream fis = new FileInputStream(srcPath); String destFileName = srcPath.substring(srcPath.lastIndexOf('\\')+1); String destPath = destDir + "\\" + destFileName; FileOutputStream fos = new FileOutputStream(destPath); cypher(fis，fos); fis.close(); fos.close(); &#125; /** * 加密方法，同时也是解密方法 * @param ips * @param ops * @throws Exception */ private static void cypher(InputStream ips ，OutputStream ops) throws Exception&#123; int b = -1; while((b=ips.read())!=-1)&#123; ops.write(b ^ 0xff);//如果是1就变成0，如果是0就变成1 &#125; &#125; private String classDir; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String classFileName = classDir + "\\" + name.substring(name.lastIndexOf('.')+1) + ".class"; try &#123; FileInputStream fis = new FileInputStream(classFileName); ByteArrayOutputStream bos = new ByteArrayOutputStream(); cypher(fis，bos); fis.close(); System.out.println("aaa"); byte[] bytes = bos.toByteArray(); return defineClass(bytes， 0， bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public MyClassLoader()&#123; &#125; public MyClassLoader(String classDir)&#123; this.classDir = classDir; &#125;&#125; 测试运行代码:12345Class clazz = new MyClassLoader("myClass").loadClass("ClassLoaderAttachment");//此处不能在使用ClassLoaderAttachment因为一旦用了之后，//系统的类加载器就会去加载，导致失败，所以该类就继承了Date类了.Date date = (Date)clazz.newInstance();System.out.println(date); 运行结果： 一个类加载器的高级问题: 我们知道tomcat服务器，是一个大大的java程序，那么它就必须在JVM上运行.这个大大的java程序内部也写了很多类加载器，它用这些类加载器去加载一些特定的类.注入servlet类.下面我们新建一个javaweb工程，新建一个servlet程序.123456789101112public void doGet(HttpServletRequest request， HttpServletResponse response) throws ServletException， IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); ClassLoader classload = this.getClass().getClassLoader(); while (classload != null) &#123; out.println(classload.getClass().getName()+"&lt;br&gt;"); classload = classload.getParent(); &#125; out.println(); out.close();&#125; 然后配置服务器，部署应用程序，启动tomcat服务器.在页面访问我们这个servlet，在页面打印的结果如下图所示:这是从小到大排序的.现在呢?我想把该servlet打成jar包，放在ExtClassLoad类加载器加载的路径.通过Eclipse即可完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的事件监听是怎样实现随时监听的]]></title>
      <url>%2F2016%2F07%2F29%2F%5BJava%5Djava%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%97%B6%E7%9B%91%E5%90%AC%E7%9A%84%2F</url>
      <content type="text"><![CDATA[githubhttps://github.com/rhapsody1290/monitor 事件监听机制 Java中的事件监听是整个Java消息传递的基础和关键。牵涉到三类对象：事件源（Event Source）、事件（Event）、事件监听器（Event Listener）。 ● 事件源是事件发生的场所，通常就是各个组件，它可以是一个按钮，编辑框等。 ● 事件监听者负责监听事件源所发生的事件，并对各种事件做出相应的响应。 ● 事件是描述事件源状态改变的对象。 具体实现呢，可以看看Button的源码。可能不好看得懂。那好我们仿照侯捷先生的作法，来模拟一个这样的事件传递： 定义一个自己的事件将事件源中value的最新值告知监听器 public class MyEvent { private int value; public int getValue() { return value; } public void setValue(int value) { this.value = value; } } 做一个监听器接口 Listener当外部响应触发事件源上的事件时，产生一个事件对象，该事件对象会作为参数传递给监听器的事件处理方法 public interface Listener { public void valueChanged(MyEvent e); } 做一个事件发生者 当事件源中的value值发生改变时，会促发事件 监听器在事件源上注册，事件源会保存该监听器，在事件触发时调用监听器的事件处理方法 public class MySource { private int value; private Vector&lt;Listener&gt; listeners = new Vector&lt;Listener&gt;(); /** * 添加监听器 * @param listener */ public void addListener(Listener listener){ listeners.add(listener); } public void setValue(int value){ this.value = value; //发送消息 MyEvent e = new MyEvent(); e.setValue(value); for(int i = 0; i &lt; listeners.size(); i++){ listeners.get(i).valueChanged(e); } } } 注册监听器 如果想监听事件源中value值改变，就在事件源那儿注册一下监听器，然后写消息处理代码就可以了，一般使用匿名内部类的方式定义监听器 这样，当MySource的value真的改变时，就会触发响应 public class Main { /** * @param args */ public static void main(String[] args) { MySource mySource = new MySource(); mySource.addListener(new Listener() { public void valueChange(MyEvent e) { System.out.println(&quot;值改变了：&quot; + e.getValue()); } }); mySource.setValue(1); } } #结果 value changed to:10 Java中AWT/Swing的事件传递的实现，现在版本于上述有所不同，但应该都是这个原理。 总结[图解]★★★★★★ 建议开发顺序： 先编写事件源，事件源中有监听器集合Vector listeners和增加监听器方法addListener 在触发事件源的方法上如setValue，产生事件、并调用监听器方法，将事件以参数传入监听器方法 创建事件类和监听器类 测试，创建事件源——添加监听器——触发事件 思考监听器本质 当调用setValue时，使得value属性的值发生变化，产生事件并调用监听器中对应该属性值改变时做出的处理；而事件不触发时不会产生这个响应，这就起到对一个属性值监控 的作用 使用监听器有什么好处呢？我们可以直接在setValue这个函数中做出响应啊！但是如果直接在serValue中写，这个响应处理不能由程序员自己控制，这是写死的。而采用监听器方法时，通过重写Listener中的事件处理函数，程序员可以自己编写事件处理函数 函数调用顺序是：外界动作调用setValue方法，在这个而方法中去调用监听器中对应的事件处理函数 参考文献[1]. http://www.jcodecraeer.com/a/chengxusheji/java/2012/0822/371.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合]]></title>
      <url>%2F2016%2F07%2F29%2F%5BJava%5DJava%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[集合框架–使用 开发常用 ● 在实际开发过程中，比较常用的是Vector、Stack、ArrayList、LinkedList、HashMap、HashTable ● 集合类基本上在util包中 集合分类 Java集合类主要有以下几种 ● List结构的集合类：ArrayList、LinkedList、Vector、Stack ● Map结构的集合类：HashMap、HashTable ● Set结构的集合类：HashSet、TreeSet ● Queue结构的集合：Queue接口 List结构的集合类ArrayList类的使用(无同步性，线程不安全) 基于动态数组的数据结构，随机访问优于LinkedList123456789101112131415161718192021222324public class ArrayList1. 往list中插入元素 ● boolean add(E e) 元素添加到列表的尾部 ● void add(int index, E element) 元素插入到列表的指定位置2. 返回列表中的元素数 ● int size() 返回列表中的元素数 3. 如果此列表中没有元素，则返回 true ● boolean isEmpty() 4. 返回此列表中指定位置上的元素 ● E get(int index) 5. 用指定的元素替代此列表中指定位置上的元素,返回值是以前位于该位上的元素 ● E set(int index, E element) 6. 移除列表上的元素 ● E remove(int index) 移除此列表中指定位置上的元素 ● boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在） ● protected void removeRange(int fromIndex, int toIndex) 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 ● void clear() 移除列表中所有元素7. 查找元素 ● contains(Object o) 判断list中是否含有指定元素 ● int indexOf(Object o) 返回list中元素第一次出现的位置,若没有则返回-1 ● int lastIndexOf(Object o) 返回arraylist中元素最后一次出现的位置,若没有则返回-18. 返回包含此列表中所有元素的数组（按顺序），相当于数组API和collection API的桥梁,返回一个object的数组 ● Object[] toArray() LinkedList类的使用 基于链表的数据结构，新增add和删除remove操作优于ArrayList12341. 将指定元素插入此列表的开头 ● void addFirst(E e) 2. 将指定元素添加到此列表的结尾 ● void addLast(E e) Vector同理(线程安全具有同步性)Stack123456789101. 测试堆栈是否为空 boolean empty() 2. 查看堆栈顶部的对象，但不从堆栈中移除它 E peek() 3. 移除堆栈顶部的对象，并作为此函数的值返回该对象 E pop() 4. 把项压入堆栈顶部 E push(E item) 5. 返回对象在堆栈中的位置，以 1 为基数 int search(Object o) ArrayList和Vector的区别123456ArrayList和Vector的区别 ArrayList与Vector都是java的集合类，都可以用来存放java对象，这是他们的相同点，但是他们也有区别：1、同步性 Vector是线程同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是线程异步的，因此ArrayList中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销。2、数据增长 从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 Map结构的集合类HashMap（线程不同步），HashTable（线程同步）集合类123456789101112void clear() 从此映射中移除所有映射关系。 V get(Object key) 返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null。 boolean isEmpty() 如果此映射不包含键-值映射关系，则返回 true。 V put(K key, V value) 在此映射中关联指定值与指定键。 V remove(Object key) 从此映射中移除指定键的映射关系（如果存在）。 int size() 返回此映射中的键-值映射关系数。 Map遍历1. Map.Entry&lt;String, String&gt;的数据类型为键值对。 2. map.entrySet(),返回类型为Set&lt;Entry&lt;String, String&gt;&gt; ，即map中非空元素组成的键值对Set集合，可以用图例（key1,value1）,(key2,value2)...(keyn,valuen)表示。 3. Map.Entry&lt;String, String&gt;类型分别通过getKey()、getValue()方法取出键和值。 4. 可以通过map.keySet()方法取出全部键的Set集合，从而通过map.get(Object key)方法取出值，即方法一。 5. 可以通过map.value()得到Collection&lt;String&gt;集合，得到所有值。即方法四 6、方法二中使用迭代器对数据遍历，类型是Map.Entry&lt;String, String&gt;，即仍旧是键值对，集合是map.entrySet().iterator()，比方法三麻烦。 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("1", "value1"); map.put("2", "value2"); map.put("3", "value3"); //第一种：普遍使用，二次取值 System.out.println("通过Map.keySet遍历key和value："); for (String key : map.keySet()) &#123; System.out.println("key= "+ key + " and value= " + map.get(key)); &#125; //第二种 System.out.println("通过Map.entrySet使用iterator遍历key和value："); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println("通过Map.entrySet遍历key和value"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //第四种 System.out.println("通过Map.values()遍历所有的value，但不能遍历key"); for (String v : map.values()) &#123; System.out.println("value= " + v); &#125; &#125; HashMap和Hashtable集合类的区别HashMap与Hashtable都是java的集合类，都可以用来存放java对象，这是他们的相同点，但是他们也有区别。 1、历史原因 Hashtable是基于陈旧的Dictionary类的，HashMap是java 1.2引进的Map接口的一个实现。 2、同步性 Hashtable是线程同步的。这个类中的一些方法保证了Hashtable中的对象是线程安全的。而HashMap则是线程异步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。 3、值 HashMap可以让你将空值作为一个表的条目的key或value但是Hashtable是不能放入空值的(null) List、Map集合框架的选择★（常用）★★★★如何选用集合类？ 1、要求线程安全，使用Vector、Hashtable 2、不要求线程安全，使用ArrayList,LinkedList,HashMap 3、要求key和value键值，则使用HashMap,Hashtable 4、数据量很大，又要线程安全，则使用Vector Set结构的集合类用法123456789101112131415#添加add(Object)#遍历Iterator&lt;String&gt; iterator = hashSet.iterator();while(iterator.hasNext())&#123; System.out.println(iterator.next());&#125;#删除元素删除一个元素 remove(Object)删除所有元素 clear()#包含contain(Object) HashSet与TreeSet区别 HashSet随机存储对象，不能保证先插入的元素出现在前面；TreeSet中元素默认按照元素自然序进行排列，使用compareTo()方法自定义排序 HashSet内部依靠HashMap，而TreeSet依靠TreeMap HashSet可以存储空对象，但TreeSet不允许 性能，HashSet对基本操作add，remove，size有常数的时间复杂度，TreeSet有log(n)的时间复杂度 TreeSet比起HashSet具有更多丰富的功能，例如pollFirst(),pollLast(),first(),last(),celling(),lower()等 比较，HashSet使用equals()方法进行比较，而TreeSet使用compareTo()方法获得排列顺序 HashSet与TreeSet相同点 只能存储独一无二的元素，不允许任何重复的元素 不是线程安全 Clone方法有相同的实现技术 Queue结构的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java面向对象编程的四大特征]]></title>
      <url>%2F2016%2F07%2F29%2F%5BJava%5DJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81%2F</url>
      <content type="text"><![CDATA[抽象 我们在前面去定义一个类时候，实际上就是把一类事物的共有的属性和行为提取出来，形成一个物理模型(模版)。这种研究问题的方法称为抽象。 封装 封装就是把抽象出来的数据和对数据的操作封装在一起。数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作。 ###访问控制修饰符 继承 继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类(比如刚才的Student)，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要继承父类,这样子类就会自动拥有父类定义的某些属性和方法。 父类哪些属性、方法被子类继承 父类的public修饰符的属性和方法；protected修饰符的属性和方法；默认修饰符属性和方法被子类继承了，父类的private修饰符的属性和方法不能被子类继承。 注意事项 1. 子类最多只能继承一个父类(指直接继承) 2. java所有类都是Object类的子类 多态方法重载（overload） 简单的说：方法重载就是在类的同一种功能的多种实现方式，具有相同的方法名，但方法的参数类型、个数、顺序不同。到底采用哪种方式，取决于调用者给出的参数。 注意事项 1. 方法返回类型可以不同(只是返回类型不一样，不能构成重载) 2. 方法的修饰符可以不同(只是控制访问修饰符不同，不能构成重载) 方法覆盖（override） 简单的说：方法覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。 注意事项： 1、子类的方法的返回类型，参数，方法名称，要和父类的返回类型，参数，方法名称完全一样，否则编译出错。 2、子类方法不能缩小父类方法的访问权限，可以放大访问权限。★★★★ 多态概念 所谓多态，就是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的指针，来调用在不同子类中实现的方法。 实现多态有两种方式：1、继承；2、接口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记]]></title>
      <url>%2F2016%2F07%2F15%2F%5BSpring%5DSpring%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Spring是什么 struts是web框架 (jsp/action/actionfrom) hibernate是orm框架，处于持久层 spring是容器框架，用于配置各个层的bean（action/service/domain/dao），并维护bean之间关系的框架 spring中重要概念★★★★★bean Spring管理的对象为bean bean是java中的任何一种对象（javabean/service/action/数据源/dao），spring作用是配置各个层中的组件（bean），并维持组件（bean）之间的关系 JavaBean必须拥有一个无参的构造器，通过get/set方法访问参数，同时支持持久化 控制反转 ioc(inverse of control，控制反转)，控制反转就是把创建对象（bean）和维护对象（bean）的关系的权利从程序中转移到spring容器中（applicationContext.xml），只需配置一下就能完成 使用Spring，程序中几乎所有重要的组件的创建工作和维护组件之间的依赖关系都移交给Spring 依赖注入 di(dependency injection，依赖注入)，实际上di和ioc是同一概念，spring设计者认为di更准确表示spring核心技术 依赖注入接管对象的创建工作，并将该对象的引用注入需要该对象的组件 /* 有两个组件A和B，A依赖于B，且A中的importantMethod方法调用了B的方法， 使用B前，类A必须先获得组件B的实例（具体类可以new一个B实例，但如果B是接口，使用B的一个实现类，会降低A的可重用性） 使用依赖注入，框架会接管对象B的创建工作，并将B对象的引用注入到A中，具体是类A中的setB方法会被框架调用，注入一个B的实例， 这样类A的importantMethod方法在使用B的userfulMethod方法前不再需要创建一个B的实例 */ public class A { private B b; public B getB() { return b; } public void setB(B b) { this.b = b; } public void importantMethod(){ b.userfulMethod(); } } Spring在程序中的位置 Spring层次图如下图所示 Login.jsp与用户交互，将数据传递给Action.java处理器，Action.java一般与表单ActionForm关联，验证成功跳转到ok.jsp。这一层是web层，Struts位于web层 验证过程中，会调用UserService.java，这是业务层。业务层会有一个domain对象，Users.java[或者叫javabean，pojo] 业务层下是DAO层，它是对数据的操作 下面就是数据持久层，hibernate就位于持久层，它是一个orm框架 最底层的就是数据库 model层分为业务层（Service），DAO层和数据持久层，在开发过程中，可以根据实际情况进行选择组合，并不是必须把model层分得这么细 Spring横跨web层、业务层、DAO层、持久层，可以配置各个层的组件（JavaBean），并且维护各个bean之间的关系 具体的来说，spring可以配置web层的action[解决actin单例问题]，业务层的domain/service/dao以及数据持久层配置数据源 在配置文件中，体现出Spring创建各种组件及维持组件之间的关系 &lt;bean id = "bean1" class = "">配置bean &lt;property name = "" value = "">&lt;/property> &lt;/bean> &lt;bean id = "bean2" class = "">维护bean之间的关系(bean2依赖bean1) &lt;property name = "" ref="">&lt;/property> &lt;/bean> Spring快速入门githubhttps://github.com/rhapsody1290/Spring_Study 引入依赖&lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring事务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建组件创建组件A、B，其中A组件依赖B 类A public class A { private B b; public void importantMethod(){ System.out.println(&quot;A:importantMethod&quot;); b.usefulMethod(); } public B getB() { return b; } public void setB(B b) { this.b = b; } } 类B public class B { public void usefulMethod() { System.out.println(&quot;B:usefulMethod&quot;); } } applicationContext.xml中配置beanapplicationContext.xml是spring的一个核心配置文件, [hibernate有核心文件hibernate.cfg.xml struts核心文件 struts-config.xml] &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 在容器文件中配置bean(service/dao/domain/action/数据源) --&gt; &lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象,并放入内存--&gt; &lt;bean id = &quot;A&quot; class=&quot;hello.A&quot;&gt; &lt;!-- 这里就体现出注入的概念，将B对象的引用注入到A中的b属性--&gt; &lt;property name=&quot;b&quot; ref=&quot;B&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt; &lt;/beans&gt; 获得bean并调用方法public class testSpringAPI { private ApplicationContext context; @Before public void setUp() throws Exception { //1.得到spring 的applicationContext对象(容器对象) context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); } @Test public void testName() throws Exception { //2、利用java反射机制获取bean对象 A a = (A) context.getBean(&quot;A&quot;); a.importantMethod(); } } Spring运行原理图 当ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);执行的时候，Spring容器对象将被创建，同时applicationContext.xml中配置的bean就会被创建 UserService us = (UserService)ac.getBean(‘UserService’);调用后取出bean，取出的bean对象是单例 bean的存储结构类似HashMap/HashTable，分为id和bean对象。id对应配置文件中bean元素的id，对象在Spring容器对象创建时创建并存放。若有引用关系，则指向引用对象的id Spring框架扫描XML文件，利用Java反射机制，创建一个个bean对象 可以利用dom4j+java反射机制模拟Spring运行流程。扫描xml文件，检测到bean元素，利用Java反射机制创建对象，并设置属性值，存入HashMap userService = Class.forName("com.service.UserService"); userService.setName("韩顺平"); applicationContext = new HashMap(); applicationContext.put("userService",userService); Spring接口编程spring开发提倡接口编程,配合di技术可以层与层的解耦 举例说明:现在我们体验一下spring的di配合接口编程的，完成一个字母大小写转换的案例:思路: 创建一个接口 ChangeLetter public interface ChangeLetter { public String change(); } 两个类实现接口 public class LowerLetter implements ChangeLetter { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String change() { return str.toLowerCase(); } } public class UpperLeter implements ChangeLetter { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String change() { return str.toUpperCase(); } } 把对象配置到spring容器中 &lt;bean id="changeLetter" class="cn.apeius.inter.UpperLeter"> &lt;property name="str" value="abc">&lt;/property> &lt;/bean> &lt;!-- &lt;bean id="changeLetter" class="cn.apeius.inter.LowerLetter"> &lt;property name="str" value="ABC">&lt;/property> &lt;/bean>--> 使用 ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); ChangeLetter us= (ChangeLetter) ac.getBean("changeLetter"); System.out.println(us.change()); 通过上面的案例，我们可以初步体会到di配合接口编程，的确可以减少层(web层) 和 业务层的耦合度. XML配置文件 配置文件的根元素通常为 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 如果需要更强的Spring配置能力，可以在schemaLocation属性中添加相应地schema 配置文件可以是一份，也可以是多份，ApplicationContext的实现类支持读取多份配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;}); 三种获取ApplicationContext对象引用的方法ApplicationContext对象代表一个Spring控制反转容器，org.springframework.context.ApplicationContext接口有多个实现，包括： 1、ClassPathXmlApplicationContext -&gt; 通过类路径加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 2、FileSystemXmlApplicationContext -&gt; 通过文件路径加载配置文件 ApplicationContext context = new FileSystemXmlApplicationContext("配置文件绝对路径"); 3、XmlWebApplicationContext 从web系统中加载 两个获取bean的方式★★★从ApplicationContex应用上下文容器中获取bean基本模式创建一个bean实例★★★★★Spring通过默认无参的构造器来创建一个bean实例 配置文件 &lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt; 获取bean //1.得到spring 的applicationContext对象(容器对象) ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //从容器中取出一个bean的实例 B b = ac.getBean(&quot;B&quot;, B.class); b.usefulMethod(); 工厂模式创建一个bean实例1、定义一个接口 public interface Animal { public void sayHello(); } 2、接口的两个实现类 Cat public class Cat implements Animal { public void sayHello() { System.out.println(&quot;Cat&quot;); } } Dog public class Dog implements Animal { public void sayHello() { System.out.println(&quot;Dog&quot;); } } 3、AnimalFactory工厂中包含了一个getAnimal的静态方法，该方法将根据传入的参数决定创建哪个对象。这是典型的静态工厂设计模式 public class AnimalFactory { public static Animal getAnimal(String type){ if(&quot;Cat&quot;.equals(type)){ return new Cat(); }else if(&quot;Dog&quot;.equals(type)){ return new Dog(); } return null; } } 4、Spring配置文件中作如下配置 &lt;bean id=&quot;cat&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt; &lt;constructor-arg value=&quot;Cat&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dog&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt; &lt;constructor-arg value=&quot;Dog&quot;/&gt; &lt;/bean&gt; 使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类 需要使用factory-method来指定静态工厂方法名，Spring将调用静态工厂方法来返回一个Bean实例，使用元素来为静态工厂方法指定参数 当使用静态工厂方法来创建Bean时，这个factory-method必须要是静态的 从bean工厂容器中获取bean//如果我们使用beanfactory去获取bean，当你创建Spring容器时bean不被实例化,只有当你去使用getBean某个bean时，才会实时的创建 BeanFactory factory = new XmlBeanFactory( new ClassPathResource(&quot;applicationContext.xml&quot;)); factory.getBean(&quot;A&quot;); 结论 如果使用ApplicationContext ，则配置的bean如果是singlton不管你用不用，都被实例化.(好处就是可以预先加载,缺点就是耗内存) 如果是 BeanFactory ,则当你获取beanfacotry时候，配置的bean不会被马上实例化，当你使用的时候，才被实例(好处节约内存,缺点就是速度) 规定: 一般没有特殊要求，应当使用ApplicatioContext完成(实际项目中90%都采用这种方式) bean的生命周期为什么总是一个生命周期当做一个重点? 例如我们经常需要知道Servlet的生命周期，初始化init和销毁destroy，还有讨论java对象生命周期 不懂servlet的生命周期，你一样可以做开发。但是只有把一个新的技术对应的对象的生命周期弄清楚时，你才能真正的驾驭他。你知道Servlet创建的时候会调用init，才会把初始化工作放在init中，你知道Servlet销毁时会调用destroy，才会把文件备份的工作放在destroy中 bean的生命周期 bean被载入到容器中时，它的生命周期就开始了 ① 实例化★ 当我们的程序加载beans.xml文件，把我们的bean实例化到内存 默认调用无参的构造方法 以上我们考虑的是scope=singleton，单例模式最复杂 ② 调用set方法设置属性★③ 如果你实现了bean名字关注接口BeanNameAware则，可以通过setBeanName获取id号④ 如果你实现了bean工厂关注接口BeanFactoryAware,则可以获取BeanFactory⑤ 如果你实现了ApplicationContextAware接口，则可以获得应用程序上下文 //该方法传递ApplicationContext public void setApplicationContext(ApplicationContext arg0) throws BeansException { // TODO Auto-generated method stub System.out.println(&quot;setApplicationContext&quot;+arg0); } ⑥ 如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。体现AOP（面向切片编程），放置一些公共方法，例如过滤ip，给对象添加属性等★ 自定义一个类myBeanPostProcessor，实现BeanPostProcessor接口，重写before和after两个方法 # myBeanPostProcessor.java public class myBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object o, String s) throws BeansException { //对象o对实例化的bean对象，s为bean的id System.out.println("postProcessBeforeInitialization"); return o; } @Override public Object postProcessAfterInitialization(Object o, String s) throws BeansException { System.out.println("postProcessAfterInitialization"); return o; } } xml文件中配置 &lt;bean id = &quot;myBeanPostProcessor&quot; class=&quot;cn.apeius.beanlift.myBeanPostProcessor&quot;&gt;&lt;/bean&gt; 运行 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); PersonService personService = (PersonService) ac.getBean(&quot;PersonService&quot;); personService.sayHi(); 结果：bean对象创建后会自动调用before和after方法。类似JavaWeb中的过滤器 构造函数被调用 调用set方法 postProcessBeforeInitialization postProcessAfterInitialization 你好啊 钱钱 ⑦ 如果你实现InitializingBean接口，则会调用afterPropertiesSet⑧ 如果自己配置&lt;bean init-method=&quot;init&quot; /&gt;，则可以在bean定义自己的初始化方法init。也可以通过注解的方式@PostConstruct⑨ 如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法⑩ 使用我们的bean⑪ 容器关闭⑫ 可以通过实现DisposableBean接口来调用方法destory⑬ 可以在&lt;bean destory-method=&quot;fun1&quot;/&gt;调用定制的销毁方法。可以通过注解的方式@PreDestroy 小结: 我们实际开发中往往，没有用的这么的过程,常见的是:1-&gt;2-&gt;6-&gt;10-&gt;9-&gt;11 问题:通过BeanFactory来获取bean对象，bean的生命周期是否和 Applicationcontext 是一样吗? 不是一样的，bean是工厂中创建的生命周期会简单一些: 比起ApplicationContext创建bean，通过BeanFactory少了一下步骤 ⑤ 如果你实现了ApplicationContextAware接口，则可以获得应用程序上下文 ⑥ 如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。 ⑨ 如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法 bean装配的细节注入的写法★基础数据类型注入 一个标签 &lt;property name="name" value="财务部"/> 两个标签 &lt;property name="name"> &lt;value>财务部&lt;/value> &lt;/property> 对象注入 # 方法一：利用property的ref属性，这是一种简写方式 &lt;bean id="Department" class="cn.apeius.collections.Department"> &lt;property name="emp" ref="Emp"/> &lt;/bean> &lt;bean id="Emp" class="cn.apeius.collections.Emp"> &lt;property name="id" value="1"/> &lt;property name="name" value="qm"/> &lt;/bean> # 方法二：ref标签 &lt;bean id="Department" class="cn.apeius.collections.Department"> &lt;property name="emp"> &lt;ref bean="Emp"/> &lt;/property> &lt;/bean> &lt;bean id="Emp" class="cn.apeius.collections.Emp"> &lt;property name="id" value="1"/> &lt;property name="name" value="qm"/> &lt;/bean> # 方法三：内部配置 &lt;bean id="Department" class="cn.apeius.collections.Department"> &lt;property name="emp"> &lt;bean class="cn.apeius.collections.Emp"> &lt;property name="id" value="1"/> &lt;property name="name" value="qm"/> &lt;/bean> &lt;/property> &lt;/bean> bean的作用域scope singleton(默认)，单态，尽量使用scope=”singleton”,不要使用prototype,因为这样对我们的性能影响较大，除非有必要. //获取两个student Student s1=(Student) ac.getBean("student"); Student s2=(Student) ac.getBean("student"); System.out.println(s1 == s2);//一样 prototype //获取两个student Student s1=(Student) ac.getBean("student"); Student s2=(Student) ac.getBean("student"); System.out.println(s1 == s2);//不一样 request session global-session 是在web开发中才有意义 如何给集合类型注入值java中主要的集合有几种: map set list / 数组 给数组注入值 &lt;property name=&quot;empName&quot;&gt; &lt;list&gt; &lt;value&gt;小明&lt;/value&gt; &lt;value&gt;小明小明&lt;/value&gt; &lt;value&gt;小明小明小明小明&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 给list注入值 list 中可以有相同的对象 &lt;property name=&quot;empList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;emp2&quot; /&gt; &lt;ref bean=&quot;emp1&quot;/&gt; &lt;ref bean=&quot;emp1&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt; &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; 给set注入值set不能有相同的对象 &lt;property name=&quot;empsets&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;emp1&quot; /&gt; &lt;ref bean=&quot;emp2&quot;/&gt; &lt;ref bean=&quot;emp2&quot;/&gt; &lt;/set&gt; &lt;/property&gt; 给map注入值，key为索引，value指定值，如果为Java对象，则使用ref指定，或者使用bean定义。如果key为对象，使用key-ref属性 &lt;property name=&quot;empMaps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; &lt;entry key = &quot;12&quot; value = &quot;emp2&quot; /&gt; &lt;entry key-ref=&quot;13&quot; value=&quot;emp3&quot; /&gt; &lt;entry key-ref=&quot;14&quot; value-ref=&quot;emp4&quot; /&gt; &lt;/map&gt; &lt;/property&gt; 给属性集合配置，即Property对象 &lt;property name=&quot;pp&quot;&gt; &lt;props&gt; &lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt; &lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 内部bean&lt;bean id=&quot;foo&quot; class=&quot;....Foo&quot;&gt; &lt;property name=&quot;属性&quot;&gt; &lt;!—第一方法引用--&gt; &lt;ref bean=&quot;bean对象名&quot;/&gt; &lt;!—第二种方法，内部bean--&gt; &lt;bean&gt; &lt;properyt name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 继承配置public class Student public class Gradate extends Student 在beans.xml文件中体现配置 &lt;!-- 配置一个学生对象 --&gt; &lt;bean id=&quot;student&quot; class=&quot;com.hsp.inherit.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;顺平&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;30&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Grdate对象 --&gt; &lt;bean id=&quot;grdate&quot; parent=&quot;student&quot; class=&quot;com.hsp.inherit.Gradate&quot;&gt; &lt;!-- 如果自己配置属性name,age,则会替换从父对象继承的数据 --&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;degree&quot; value=&quot;学士&quot;/&gt; &lt;/bean&gt; 通过构造函数注入值★★★ 目前我们都是通过set方式给bean注入值，spring还提供其它的方式注入值，比如通过构造函数注入值! set注入的缺点是无法清晰表达哪些属性是必须的，哪些是可选的；构造注入的优势是通过构造器强制依赖关系 每个constructor-arg配置一个参数，参数有先后顺序，顺序要与构造函数相同 通过参数名传递参数&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;洗衣机&quot;/&gt; &lt;constructor-arg name=&quot;description&quot; value=&quot;家用洗衣服的工具&quot;/&gt; &lt;/bean&gt; 通过指数方式传递参数&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;洗衣机&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;家用洗衣服的工具&quot;/&gt; &lt;/bean&gt; 初始化bean和销毁bean的时候执行某个方法方法一：通过注解@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作 public class DataInitializer{ @PostConstruct public void initMethod() throws Exception { System.out.println(&quot;initMethod 被执行&quot;); } @PreDestroy public void destroyMethod() throws Exception { System.out.println(&quot;destroyMethod 被执行&quot;); } } 方法二：通过 在xml中定义 init-method 和 destory-method 方法★★★★★ DataInitializer public class DataInitializer{ public void initMethod() throws Exception { System.out.println(&quot;initMethod 被执行&quot;); } public void destroyMethod() throws Exception { System.out.println(&quot;destroyMethod 被执行&quot;); } } applicationContext.xml &lt;bean id=&quot;dataInitializer&quot; class=&quot;com.somnus.demo.DataInitializer&quot; init-method=&quot;initMethod&quot; destory-method=&quot;destroyMethod&quot;/&gt; 方法三：通过bean实现InitializingBean和 DisposableBean接口 public class DataInitializer implements InitializingBean，DisposableBean{ @Override public void afterPropertiesSet() throws Exception { System.out.println("afterPropertiesSet 被执行"); } @Override public void destroy() throws Exception { System.out.println("destroy 被执行"); } } 原理 //判断该bean是否实现了实现了InitializingBean接口，如果实现了InitializingBean接口，则只掉调用bean的afterPropertiesSet方法 boolean isInitializingBean = (bean instanceof InitializingBean); if(isInitializingBean) ((InitializingBean) bean).afterPropertiesSet(); 注解装配Bean引入context名称空间，并配置扫描包&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;annotation&quot;/&gt; &lt;/beans&gt; @Component@Component(value = &quot;a&quot;)等价于&lt;bean id = &quot;a&quot; class = &quot;A&quot;&gt; @Component(value = &quot;a&quot;) public class A { public void say(){ System.out.println(&quot;A&quot;); } } 依赖注入简单类型数据注入spring3.0 提供 @Value 注解，可以注入简单数据类型 @Component(value = &quot;a&quot;) public class A { @Value(value = &quot;qm&quot;) private String name; public void say(){ System.out.println(&quot;A&quot; + name); } } 复杂对象类型数据注入第一种：按类型注入，@Autowired A @Component(value = &quot;a&quot;) public class A { @Autowired B b; public void say(){ b.say(); } } B @Component(value = &quot;b&quot;) public class B { public void say(){ System.out.println(&quot;B&quot;); } } 第二种：按名称注入，使用@Autowired 结合 @Qualifier 注解 (Spring 2.0 ) A： @Component(value = &quot;a&quot;) public class A { @Autowired @Qualifier(value = &quot;c_qualifier&quot;) B b; public void say(){ b.say(); } } B： @Component(value = &quot;c_qualifier&quot;) public class B { public void say(){ System.out.println(&quot;B&quot;); } } 第三种： 使用@Resouce注解 （JSR-250标准 ） 按照名称注入 第四种： 使用 @Inject 注解 （JSR-330标准 ） 导入 javax.inject-1.jar 自动装配bean的属性值自动装配只有在属性没有设置时，才会进行 byName的用法:&lt;!-- 配置一个master对象 --&gt; &lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;顺平&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dog对象 --&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt; &lt;/bean&gt; 原理图: property中没有注入dog值，master中的dog为null。但当设置属性autowire=”byName”后，通过检测发现内存中有一个名字为dog的对象，则自动进行引用连接 byType的用法寻找和属性类型相同的bean，此时id为dog11也能够找到并进行装配；找不到、装不上、找到多个抛异常 &lt;!-- 配置一个master对象 --&gt; &lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;顺平&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dog对象 --&gt; &lt;bean id=&quot;dog11&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt; &lt;/bean&gt; constructor的用法与byType类似， 查找和bean的构造参数一致的一个或多个bean，若找不到或找到多个，抛异常。按照参数的类型装配 master写构造函数 public master(Dog dog){ this.dog = dog; } 配置 &lt;!-- 配置一个master对象 --&gt; &lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;constructor&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;顺平&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置dog对象 --&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt; &lt;/bean&gt; autodetect的用法autowire=&quot;autodetect&quot;(3)和(2)之间选一个方式。不确定性的处理与(3)和(2)一致 defualt这个需要在&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;当你在&lt;beans&gt;指定了default-atuowrite后，所有的bean的默认的autowire就是指定的装配方法;如果没有在&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;没有defualt-autorwire=”指定”，则默认是defualt-autorwire=”no” no: 不自动装配这是autowire的默认值 使用spring的特殊bean,完成分散配置将配置文件分成几个分散的配置文件，如一个项目中连接多个数据库，每个数据库各对应一个db.properties文件 引入我们的db.properties文件，并在要注入值的地方用$占位符 &lt;context:property-placeholder location=&quot;classpath:com/hsp/dispatch/db.properties,classpath:com/hsp/dispatch/db2.properties&quot;/&gt; &lt;!-- 配置一DBUtil对象 $占位符号 --&gt; &lt;bean id=&quot;dbutil&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;${name}&quot; /&gt; &lt;property name=&quot;drivername&quot; value=&quot;${drivername}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;pwd&quot; value=&quot;${pwd}&quot; /&gt; &lt;/bean&gt; 注意：当通过context:property-placeholder引入属性文件的时候，有多个需要使用,间隔. db.properties name=scott drivername=oracle:jdbc:driver:OracleDirver url=jdbc:oracle:thin:@127.0.0.1:1521:hsp pwd=tiger 测试 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DBUtil dBUtil = (DBUtil) ac.getBean(&quot;dbutil&quot;); System.out.println(dbUtil.getDrivername()); AOP编程 AOP(Aspect Oriented Programming )，面向切面编程：AOP编程就是将共有的代码，如日志记录、权限控制、事务控制等全部抽取出来，放在某个地方集中管理，若需要使用这些功能，由容器动态织入这些共有代码，这样的好处：1、程序员在编写业务逻辑时只需关心核心的业务逻辑处理方法，提高工作效率，使代码变得简洁2、业务逻辑代码和共有代码分开存放，使维护工作变得轻松 举个例子，在开发过程中，很多对象需要做同一类的操作，例如权限控制、日志记录、事务控制等，AOP编程就是把相同工作剥离出来，若对象需要使用其中的一个功能，则将其织入进去 AOP编程，实际上在开发框架本身用的多，在实际项目中，用的不是很多，但是将来会越来越多，这是一个趋势 参考：http://blog.csdn.net/liujiahan629629/article/details/18864211 AOP技术的实现原理 AOP技术是建立在 Java语言的反射机制 与 动态代理机制 之上的 业务逻辑组件在运行过程中，AOP容器 会动态创建一个 代理对象(Service的代理对象) 供使用者调用，该代理对象已经按Java EE程序员的意图将 切面 成功切入到 目标对象 的 连接点 上，从而使 切面的功能 与 业务逻辑的功能 同时得以执行 从原理上讲，调用者直接调用的其实是AOP容器动态生成的代理对象，再由代理对象调用目标对象完成原始的业务逻辑处理，而代理对象则已经将切面与业务逻辑方法进行了合成 现将图6-6中涉及到的一些概念解释如下：(切面包括通知和切入点，容器将切面切入到目标对象的连接点上，返回一个代理对象，这个过程叫做织入) 切面（Aspect）：其实就是共有功能的实现，包括通知和切入点,如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。通知（Advice）： 是切面的具体实现。以目标方法为参照点，根据 放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、环绕通知（Around）、异常通知（AfterThrowing）、最终通知（After）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。、切入点（Pointcut）：*用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的 正则表达式* 来定义的 连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。织入（Weaving）： 将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。 举个例子解释术语： AOP编程可以在不增加原来业务逻辑方法代码的情况下，扩展某个方法，传统的方法是采用 继承 的方式，现在可以采用动态代理技术 连接点表示哪些方法 可以被扩展（拦截）；切入点表示哪些方法 需要被扩展（拦截）；织入是把通知应用到目标上，生成动态代理类的过程；切面表示公用的业务逻辑，包括多个切入点和多个通知 AOP底层实现JDK动态代理动态代理可以让一个类 代理多个不同的目标类，而且可以 代理不同的方法 详见Java——设计模式版块~http://qianmingxs.com/2016/07/06/[%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F]%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0/ 1、必须针对接口进行代理2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类3、自己实现InvocationHandler 接口 说明： Cglib动态代理机制JDK只能对接口进行代理，如果目标对象没有接口，无法使用JDK动态代理，则可以使用cglib 什么是CGLIB？ CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。Cglib可以对接口或者类进行代理 ！ Spring AOPSpring AOP 就是基于JDKProxy 和 CglibProxy 1、如果目标对象有接口，优先使用JDK Proxy2、如果目标对象没有接口， 使用CglibProxy 面试题：spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术. Spring AOP三种配置详细介绍AOP框架三足鼎立： AspectJ Jboss AOP Spring AOP Spring提供4种AOP支持 基于代理的经典AOP 纯POJO切面（使用XML） @AspcetJ注解驱动的切面 注入式AspcetJ切面 基于代理的经典AOP 现在有个需求，在调用sayHello()方法前写日志，思路如下： 1、面向接口编程，定义一个TestServiceInter接口，声明函数sayHello()2、两个类Test1Service和Test2Service实现这两个接口3、传统的方式很简单，在sayHello()方法前加入日志操作的代码，但如果有多个业务逻辑方法都需要写日志操作，是会有很多冗余代码。可以引入一个类，它的功能是写日志， Test1Service t1 = new Test1Service(); //采用传统方法，此处写日志操作 t1.sayHello(); Test2Service t2 = new Test2Service(); //采用传统方法，此处写日志操作 t2.sayHello(); 4、Service类与日志类如何关联起来呢，需引入一个代理类，Spring提供一个代理对象类ProxyFactoryBean 步骤1、定义接口 TestServiceInter.java public interface TestServiceInter { public void sayHello(); } 2、编写对象(也称作被代理对象或目标对象)，实现接口 Test1Service.java public class Test1Service implements TestServiceInter { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public void sayHello() { System.out.println(&quot;Hi &quot; + name); } } 3、编写通知（以前置通知为例，前置通知在目标方法调用前调用） # MyMethodBeforeAdvice.java public class MyMethodBeforeAdvice implements MethodBeforeAdvice { @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(&quot;记录日志：&quot; + method.getName()); } } 4、在beans.xml文件配置（分三部分：通知、被代理对象、代理对象） 4.1 配置目标对象 4.2 配置通知 4.3 配置代理对象 是 ProxyFactoryBean的对象实例 4.3.1 代理接口集 4.3.2 织入通知 4.3.3 配置目标对象 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置前置通知，比如日志--&gt; &lt;bean id=&quot;MyMethodBeforeAdvice&quot; class=&quot;cn.apeius.AOP.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt; &lt;!--配置目标对象--&gt; &lt;bean id=&quot;Test1Service&quot; class=&quot;cn.apeius.AOP.Test1Service&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;钱明&quot;/&gt; &lt;/bean&gt; &lt;!--配置代理对象,spring提供--&gt; &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;!--配置代理接口集--&gt; &lt;property name=&quot;proxyInterfaces&quot;&gt; &lt;list&gt; &lt;value&gt;cn.apeius.AOP.TestServiceInter&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--通知--&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;!--相当于包MyMethodBeforeAdvice前置通知和代理对象关联，我们也可以把通知看成拦截器--&gt; &lt;value&gt;MyMethodBeforeAdvice&lt;/value&gt; &lt;/property&gt; &lt;!--配置被代理对象--&gt; &lt;property name=&quot;target&quot; ref=&quot;Test1Service&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 通知类型除了四种基本通知外，还有引入通知 前置通知 public class MyMethodBeforeAdvice implements MethodBeforeAdvice { @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(&quot;记录日志：&quot; + method.getName()); } } 后置通知 public class MyAfterReturningAdvice implements AfterReturningAdvice { @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(&quot;关闭资源&quot;); } } 环绕通知 public class MyMethodInterceptor implements MethodInterceptor { @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable { System.out.println(&quot;环绕前&quot;); Object o = methodInvocation.proceed(); System.out.println(&quot;环绕后&quot;); return o; } } 异常通知 ThrowsAdvice为标记接口，在接口中没有任何方法，因为方法被反射机制调用，实现类必须实现以下形式，见文档 public class MyThrowsAdvice implements ThrowsAdvice { public void afterThrowing(Exception e){ System.out.println(&quot;出大事了&quot; + e.getMessage()); } } 引入通知 引入通知不需要编写相应的类，只需要进行配置，目的是用来指定哪些方法需要执行相应的通知，如，我们想指定只有sayHello（）方法执行前置通知， &lt;bean id=&quot;myMethodBeforeAdviceFilter&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name=&quot;advice&quot; ref=&quot;myMethodBeforeAdvice&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mappedNames&quot;&gt; &lt;list&gt; &lt;value&gt;sayHello&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 拦截器名集中引入 &lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt; 传统AOP切面编程极大简化了spring切面的配置工作，同时也让程序透明化，隐藏了切面的很多细节。上面所有内容都可以作为理解 spring配置AOP的基础，是最原始的配置方式，也体现了spring处理的过程。 使用ProxyFactoryBean配置有些欠优雅，在spring2.0里新的xml配置元素体现了改进。Spring2.0在aop命名空间里提供了一些配置元素，简化了把类转化为切面的操作。 本质的使用同上，只是简化配置，隐藏细节 AspectJ切入点传统AOP切入点，使用正则表达式语法，不推荐使用。AspectJ切入点，是通过函数进行配置 常用语法说明简介:execution 执行，语法：execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* *(..)) 第一个* 任意返回类型 ， 第二个* 任意方法名 , .. 任意参数 execution(* cn.itcast.service.UserService.*(..)) 匹配UserService所有方法 第一个星 任意返回类型 execution(* cn.itcast.service.UserService+.*(..)) 匹配UserService子类所有方法 + 子类 execution(* cn.itcast.service..*.*(..)) 第一个.. 任意子包 *.*任何类的任何方法 within 根据包匹配 语法：within(包名..*) within(cn.itcast.service..*) 拦截service下所有类的方法 this根据目标类型匹配 语法：this(类名) this(cn.itcast.service.UserService) 拦截 UserService所有方法 (包括代理对象) target 根据目标类型匹配 语法 ：target(类名) target(cn.itcast.service.UserService) 拦截UserService所有方法 （不包括代理对象 ） args 根据参数匹配 args(java.lang.String) 拦截所有参数为String类的方法 bean 根据bean name匹配 bean(userService) 拦截bean id/name为userService对象所有方法 步骤接口 public interface IAopService { public void withAop() throws Exception; } 实现 public class AopServiceImpl implements IAopService { public void withAop() throws Exception { System.out.println(&quot;业务逻辑处理中&quot;); } } 通知 public class MyMethodInterceptor implements MethodInterceptor{ public Object invoke(MethodInvocation methodInvocation) throws Throwable { System.out.println(&quot;环绕前&quot;); Object o = methodInvocation.proceed(); System.out.println(&quot;环绕后&quot;); return o; } } 配置文件 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--1、目标--&gt; &lt;bean id=&quot;aopServiceImpl&quot; class=&quot;AOP.AopServiceImpl&quot;/&gt; &lt;!--2、通知--&gt; &lt;bean id=&quot;myMethodInterceptor&quot; class=&quot;AOP.MyMethodInterceptor&quot;/&gt; &lt;!--&lt;aop:config&gt; 配置切面=通知+切入点--&gt; &lt;aop:config&gt; &lt;!--aop:pointcut配置切入点--&gt; &lt;aop:pointcut id=&quot;service&quot; expression=&quot;execution(* AOP.*.*(..))&quot;/&gt; &lt;!--aop:advisor配置传统Spring AOP切面，只能有一个切入点和一个通知--&gt; &lt;aop:advisor advice-ref=&quot;myMethodInterceptor&quot; pointcut-ref=&quot;service&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试 public class AopRun { public static void main(String[] args) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); IAopService hello = (IAopService) context.getBean(&quot;aopServiceImpl&quot;); hello.withAop(); } } AspectJ AOP切面编程接口 public interface IAopService { public void withAop() throws Exception; } 实现 public class AopServiceImpl implements IAopService { public void withAop() throws Exception { System.out.println(&quot;业务逻辑处理中&quot;); } } 通知 public class MyAspect { public void before1(JoinPoint jointPoint){ System.out.println(&quot;before1&quot;); } public void before2(JoinPoint jointPoint){ System.out.println(&quot;before2&quot;); } } 配置 &lt;!--1、目标--&gt; &lt;bean id=&quot;aopServiceImplAspectJ&quot; class=&quot;AOP.AspectJ.AopServiceImpl&quot;/&gt; &lt;!--2、通知--&gt; &lt;bean id=&quot;myMethodInterceptorAspectJ&quot; class=&quot;AOP.AspectJ.MyAspect&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;myMethodInterceptorAspectJ&quot;&gt; &lt;!--标签before决定前置通知--&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt; &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;serviceAspectJ&quot; expression=&quot;execution(* AOP.AspectJ.*.*(..))&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 public class AopRun { public static void main(String[] args) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); IAopService hello = (IAopService) context.getBean(&quot;aopServiceImplAspectJ&quot;); hello.withAop(); } } @AspcetJ注解驱动的切面1、接口 public interface IAopService { public void withAop() throws Exception; } 2、实现 @Service(&quot;aopServiceImpl&quot;) public class AopServiceImpl implements IAopService { public void withAop() throws Exception { System.out.println(&quot;业务逻辑处理中&quot;); } } 3、通知 @Component @Aspect //表示当前类是一个通知 public class MyAspect { @Before(value = &quot;bean(aopServiceImpl)&quot;) public void before1(JoinPoint jointPoint){ System.out.println(&quot;before1&quot;); } public void before2(JoinPoint jointPoint){ System.out.println(&quot;before2&quot;); } } 4、配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;AOP.AspectJAnnotation&quot;/&gt; &lt;!--开启AspectJ注解开发的配置--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 5、测试 public class AopRun { public static void main(String[] args) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); IAopService hello = (IAopService) context.getBean(&quot;aopServiceImpl&quot;); hello.withAop(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSP笔记]]></title>
      <url>%2F2016%2F07%2F14%2F%5BServlet%5DJSP%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[常用Java片段 &lt;%! %&gt; jsp声明，在这里面声明的变量是全局变量，也可以函数定义 &lt;% %&gt; Java片段，在这里面声明的变量是局部变量， 注释 &lt;%-- --%&gt;，&lt;%// % &gt;，&lt;%/* */% &gt; &lt;%= %&gt; 表达式 JSP简介 在web开发过程中，发现servlet做界面比较麻烦（out.println），于是又有一个新的技术JSP JSP（Java Servlet Page）运行在服务器的语言，响应客户端请求，动态生成网页的技术 JSP原理 如果是第一次访问jsp文件，web服务器就会把showTime.jsp 翻译 成一个showTime_jsp.java（IDEA中showTIme_jsp.java的目录：C:\Users\Asus\.IntelliJIdea15\system\tomcat\Unnamed_JSP_Study\work\Catalina\localhost\JSP_Study\org\apache\jsp\showTime_jsp.java） 再将其编译成一个showTime_jsp.class，并把class加载到内存 然后创建一个该Servlet的实例，调用其jspInit方法，该方法在Servlet生命周期中只被执行一次，并调用实例的jspService()方法 如果是第二次或者以后，就直接访问内存中的实例的jspService()方法。JSP也是单例，所以第一次访问JSP网站速度比较慢，后面访问JSP的速度就变快了 如果某个JSP文件被修改了，就相当于重新访问JSP（相当于第一次访问） JSP显示页面Jsp页面中的html排版标签是如何被发送到客户端的？答：JSP中被翻译成Servlet时，HTML标签会以out.write()的形式打印出来，例如： out.write(&quot;&lt;table border=1&gt;\r\n&quot;); out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;); out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;); out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;); out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;); out.write(&quot;&lt;/table&gt;\r\n&quot;); JSP中的Java片段Jsp页面中的java代码，服务器是如何执行的？比如JSP中的Java代码: &lt;% int i=90; int j=i+90; %&gt; &lt;h1&gt;测试.&lt;/h1&gt; &lt;% out.println(&quot;j=&quot;+j); %&gt; 当被翻译成Servlet后，格式如下 public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException { int i=90; int j=i+90; out.println(&quot;j=&quot;+j); } 就是有多个&lt;% %&gt; 其实相当于是一个大的 &lt;% %&gt;，所有代码会放在一个_jspService函数中 在&lt;% %&gt; 中定义的变量，会成为service函数的局部变量. JSP九大内置对象Web服务器在调用jsp时，会给jsp提供一些内置对象，这些内置对象无需创建可直接使用。前五个较常用，分别与Servlet中的几个对象对应 对象名 类型 作用域 request：请求对象 javax.servlet.ServletRequest的子类 Request response：响应对象 javax.servlet.ServletResponse的子类 Page pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面 javax.servlet.jsp.PageContext Page session：会话对象，用于保存用户信息，跟踪用户行为 javax.servlet.http.HttpSession Session application：应用程序对象，多个用户共享该对象，可以做计数器 javax.servlet.ServletContext Application out：输出对象 javax.servlet.jsp.JspWriter Page config：配置对象 javax.servlet.ServletConfig Page page：页面对象，代表JSP实例本身，使用较少 java.lang.Object Page exception：异常对象 java.lang.Throwable Page JSP的语法指令元素 概念: 用于从jsp发送一个信息到容器，比如设置全局变量,文字编码,引入包 ①page指令&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt; 常用的属性 language = &quot;xx&quot;，jsp中嵌入代码语言，通常是java import = &quot;包.类名&quot;，在jsp页面引入类 errorPage=&quot;err.jsp&quot;，当JSP页面出现错误时，自动跳转到指定页面 contentType 和 pageEncoding的区别： contentType = &quot;text/html;charset=utf-8&quot; 指定网页以什么方式显示页面 pageEncoding=&quot;utf-8&quot; 指定Servlet引擎以什么方法翻译jsp-&gt;servlet并指定网页以什么方式显示页面 ②include指令 &lt;%@ include file="文件路径" %&gt; 该指令用于引入一个文件（通常是JSP文件），JSP引擎会把两个JSP文件翻译成一个Servlet文件，因此也称为静态引入 被引入的JSP文件，只需保留page指令即可，html，body等均可省略★★★ ③taglib指令 允许在JSP页面使用自定义的标签 &lt;mytag:yourTag num1 = &quot;123&quot; /&gt; 脚本元素(理解为脚本片段)java片段&lt;% java 代码 %&gt; 表达式&lt;%=表达式 %&gt;，例如&lt;%=i*78-23%&gt; 定义变量全局变量 &lt;%! int i=90; %&gt; 局部变量 &lt;% int i=90;%&gt; 定义函数★★★★★&lt;%! public int getResult(int a,int b){ return a+b; } %&gt; 注意：函数不能在&lt;% %&gt; 定义. 动作元素jsp:forward &lt;jsp:forword file=&quot;xxx&quot;&gt;&lt;/jsp:forword&gt;页面跳转 在开发JSP的过程中，我们通常把JSP放入WEB-INF目录，目的是为了防止用户直接访问这些jsp文件. 在WebRoot下我们有一个入口页面,它的主要转发 &lt;jsp:forword file=&quot;/WEB-INF/xx.jsp&quot;&gt;&lt;/jsp:forword&gt; jsp:incluce &lt;%@ include file=&quot;&quot;%&gt; 静态引入 &lt;jsp:incluce file=&quot;&quot;&gt;&lt;/jsp:incule&gt; 动态引入 相同点： 把一个文件引入到另外一个文件 区别： 静态引入，把两个jsp翻译成一个Servlet,所以被引入的文件不要包含&lt;body&gt;&lt;html&gt; 动态引入，把两个jsp分别翻译,所以被引入的jsp包含有&lt;html&gt;&lt;body&gt;也可以 EL表达式语言 EL表达式语言可以方便读取应用程序中的数据，JSP2.0以上版本即使没有JSTL（JSP标准标签库）也能使用EL EL表达式以 ${ 开头，并以 } 结束，如${x + y}，从左向右取值，返回结果类型为String EL表达式写在JSP的HTML代码中，而不能写在”&lt;%%&gt;”引起的JSP脚本中 使用 [] 和 . 运算符来访问对象的属性，形式可以是${object.peopertyName}或${object[“peopertyName”]} EL内置对象我们知道jsp有九个内置对象，而EL表达式有11个对象，这些内置对象无需创建可直接使用 pageContextpageContext对象表示当前JSP页面的javax.servlet.jsp.PageContext，包含了9大JSP内置对象 对象名 类型 作用域 request：请求对象 javax.servlet.ServletRequest的子类 Request response：响应对象 javax.servlet.ServletResponse的子类 Page pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面 javax.servlet.jsp.PageContext Page session：会话对象，用于保存用户信息，跟踪用户行为 javax.servlet.http.HttpSession Session application：应用程序对象，多个用户共享该对象，可以做计数器 javax.servlet.ServletContext Application out：输出对象 javax.servlet.jsp.JspWriter Page config：配置对象 javax.servlet.ServletConfig Page page：页面对象，代表JSP实例本身，使用较少 java.lang.Object Page exception：异常对象 java.lang.Throwable Page 例：获得客户端IP ${pageContext.request.remoteAddr} initParam包含所有初始化参数的Map，可以获取初始化参数 例，设置初始化参数 &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/context-param&gt; 获得初始化参数 ${initParam.encoding} param包含所有参数的Map，可以获取参数，返回String 例：url http://localhost:8080/SpringMVC_study/?name=xxx 获得参数 ${param.name} paramValues包含所有参数的Map，可获取参数数组，返回String[] 例：请求url http://localhost:8080/SpringMVC_study/?name=aaa&amp;name=bbb 提交的参数name有多个值{“aaa”,”bbb”}，使用param只能获取第一个值，二使用paramValues能够获得其他的值 ${paramValues.name[0]} ${paramValues.name[1]} header包含所有头信息的Map，可以获取头信息 例：获得请求主机 ${header.host} cookie包含所有Cookie的Map，key为Cookie的name ${cookie.JSESSIONID.value} applicationScope，sessionScope，requestScope，pageScope分别是包含application，session，request，page作用域变量的Map 以requestScope为例： 使用声明person对象后，${pageScope.person.age}将输出person的age属性，useBean域默认的作用域为request 若输出session域中的变量，声明使 JSTLJSP标准标签库，用来解决遍历map或集合，格式化数字和日期等常见问题 依赖&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; JSTL核心标签库JSTL 核心标签库标签共有13个，功能上分为4类： 表达式控制标签：out、set、remove、catch 流程控制标签：if、choose、when、otherwise 循环标签：forEach、forTokens URL操作标签：import、url、redirect JSTL核心库使用标签时，一定要在jsp文件头加入以下代码： &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; 完整JSTL标签使用http://www.cnblogs.com/lihuiyy/archive/2012/02/24/2366806.html 遍历行为：&lt;c:forEach&gt;语法：&lt;c:forEach var=”name” items=”Collection” varStatus=”statusName” begin=”begin” end=”end” step=”step”&gt;&lt;/c:forEach&gt; 该标签根据循环条件遍历集合 Collection 中的元素。 var 用于存储从集合中取出的元素；items 指定要遍历的集合； 遍历list &lt;% List a=new ArrayList(); a.add("贝贝"); a.add("晶晶"); a.add("欢欢"); a.add("莹莹"); a.add("妮妮"); request.setAttribute("a",a); %> &lt;c:forEach var="fuwa" items="${a}"> &nbsp;&lt;c:out value="${fuwa}"/>&lt;br> &lt;/c:forEach> 遍历Map &lt;% Map&lt;String, String&gt; capitals = new HashMap&lt;String,String&gt;(); capitals.put(&quot;Indonesia&quot;,&quot;Jakarta&quot;); capitals.put(&quot;Malaysia&quot;,&quot;Kuala Lumpur&quot;); capitals.put(&quot;Thailand&quot;,&quot;Bangkok&quot;); request.setAttribute(&quot;capitals&quot;,capitals); %&gt; &lt;c:forEach var=&quot;capital&quot; items=&quot;${capitals}&quot;&gt; ${capital.key} ${capital.value} &lt;br/&gt; &lt;/c:forEach&gt; forEach嵌套 &lt;% Map&lt;String, String[]&gt; bigCities = new HashMap&lt;String,String[]&gt;(); bigCities.put(&quot;Australia&quot;,new String[]{&quot;Sydney&quot;,&quot;Melbourne&quot;,&quot;Perth&quot;}); bigCities.put(&quot;New Zealand&quot;,new String[]{&quot;Auckland&quot;,&quot;Christchurch&quot;,&quot;Wellington&quot;}); bigCities.put(&quot;Indonesia&quot;,new String[]{&quot;Jakarta&quot;,&quot;Surabaya&quot;,&quot;Medan&quot;}); request.setAttribute(&quot;bigCities&quot;,bigCities); %&gt; &lt;c:forEach var=&quot;mapItem&quot; items=&quot;${bigCities}&quot;&gt; ${mapItem.key} : &lt;c:forEach var=&quot;city&quot; items=&quot;${mapItem.value}&quot;&gt; ${city} &lt;/c:forEach&gt; &lt;br/&gt; &lt;/c:forEach&gt; 格式化日期和时间&lt;b&gt;格式化日期&lt;/b&gt;&lt;br/&gt; default：&lt;fmt:formatDate value=&quot;${now}&quot;/&gt; &lt;br/&gt; short：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;short&quot;/&gt; &lt;br/&gt; medium：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;medium&quot;/&gt; &lt;br/&gt; long：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;long&quot;/&gt; &lt;br/&gt; full：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt; &lt;b&gt;格式化时间&lt;/b&gt;&lt;/br/&gt; default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot;/&gt; &lt;br/&gt; short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt; medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt; long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt; full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt; &lt;b&gt;格式化日期和时间&lt;/b&gt;&lt;/br/&gt; default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot;/&gt; &lt;br/&gt; short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt; medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt; long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt; full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt; &lt;b&gt;定制格式化日期和时间&lt;/b&gt;&lt;/br/&gt; &lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;br/&gt; &lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yy/MM/dd HH:mm:ss&quot;/&gt; &lt;br/&gt; 浏览器显示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java中配置文件放在哪里]]></title>
      <url>%2F2016%2F07%2F13%2F%5BJava%5DJava%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%2F</url>
      <content type="text"><![CDATA[绝对路径与相对路径 Java中路径可分为相对路径和绝对路径两种方式。相对路径是相对当前工作目录，例如当使用命令 C:\Users\Asus&gt;java MyClass xxx.properties 要求在C:\Users\Asus目录下有xxx.properties文件，而在使用 C:\&gt;java MyClass xxx.properties 时则要求在C盘根目录下有xxx.properties文件，所以使用相对路径是飘忽不定的，不建议使用。 但如果给出绝对路径，D:\xxx.properties,当工程给用户时，若用户没有D盘，就会出现问题。 综上所述，仍旧采用绝对路径的方式来确定资源文件的地址，但是需要通过函数方法得到项目路径,在通过字符串连接的方式拼接得到绝对路径。 //此时config.properties文件放在工程文件根目录下，即选择工程右键后，新建config.properties文件 InputStream ips = new FileInputStream(&quot;config.properties&quot;); Properties properties = new Properties(); properties.load(ips); System.out.println(properties.getProperty(&quot;name&quot;)); Java中比较常用的加载资源的方式 类加载器把字节码加载到内存中，即它可以加载.class文件，也可以加载普通文件。 当工程完成后，不会将工程目录下中的Src目录给用户（怎么可能会把源代码给用户），而是将bin目录下的文件，一些字节码等文件在用户电脑上运行。 eclipse会自动将Java文件编译，并存放字节码在 工程目录/bin/包名目录下，Java文件对应编译后的字节码，普通文件(如config.properties文件)仍原封不动拷贝过去。 类加载器会在classPath中搜索。 使用类加载器时，默认的主目录是src public class ReflectTest { public static void main(String[] args) throws Exception{ /*InputStream ips = new FileInputStream(&quot;config.properties&quot;); Properties properties = new Properties(); properties.load(ips); System.out.println(properties.getProperty(&quot;name&quot;)); */ InputStream ipsInputStream = ReflectTest.class.getClassLoader().getResourceAsStream(&quot;com/qianming/config.properties&quot;); //在class类中直接有一个getResourceAsStream方法，路径名相对当前包名的相对路径，所以这里可以直接写config.properties //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;config.properties&quot;); //如果路径中写上&apos;/&apos;，则此时需相对根目录写路径 //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;/com/qianming/config.properties&quot;); Properties properties = new Properties(); properties.load(ipsInputStream); System.out.println(properties.getProperty(&quot;name&quot;)); } } 注意: 这里使用的路径是com/qianming/config.properties，即在包/资源文件的形式不能在com前加 “/“,记忆就行，否则会报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA分层思想]]></title>
      <url>%2F2016%2F07%2F08%2F%5BJava%5DJAVA%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"><![CDATA[用户管理系统系统框架【需改造】存在的问题 LoginClServlet中太过臃肿，既有业务逻辑，又有对数据库的操作，后期难以进行维护 指导思想① 业务逻辑代码和界面分离② 把常用的代码(对数据库的连接和操作)封装到工具类SqlHelper【有时也称为DAO，数据访问对象，是对数据库进行操作】 具体的方法① 每一张表对应一个domain类(表示数据)，还要对应一个Service类（表示操作）比如 users 表 对应 Users 类(domain 类)，UserService类(该类会封装对users表的各种操作) 每个表对应一个domain对象和Service类，将关系模型转化为对象模型（如下图），实际上这里体现出数据和操作分离的思想② view负责与用户进行交互，并将数据传递给controller③ controller接收view中传递的数据，进行数据校验，并调用service方法，根据返回结果的不同跳转到不同的显示页面 改造后系统框架 web层，structs位于web层，体现MVC的数据输入、数据处理、数据显示分离，当然web层需要调用service层中的方法完成数据处理。显示页面为MVC中的V，控制器为MVC中的C model层可以划分为业务层（service）、DAO层、数据持久层，这里强调一下，在一个项目中不一定全部有，可以根据实际情况选择 hiberate（orm框架），处于数据持久层，主要解决关系模型和对象模型之间的阻抗，体现oop 详细文档 https://github.com/rhapsody1290/servlet_study_usersmanager_MVC_change/blob/master/doc/%E5%88%86%E5%B1%82.xls 举个例子完成分页的mvc模式改写 首先在UsersService类中添加方法getUsersByPage,然后再为什么要返回ArrayList ,而不是我们想到 ResultSet? 1. ArrayList 中封装 User对象，更加符合面向对象的编程方式 OOP 2. 我们通过Resulst-&gt;User对象-&gt;ArrayList这样ArrayList和 Resultset没有关系，就可以及时关闭数据库资源 //按照分页来获取用户列表 public ArrayList&lt;Users&gt; getUsersByPage(int pageNow, int pageSize){ ArrayList&lt;Users&gt; al = new ArrayList&lt;Users&gt;(); ResultSet rs = SqlHelper.executeQuery(&quot;select * from users limit &quot; + (pageNow - 1) * pageSize + &quot;,&quot; + pageSize, null); try { while(rs.next()){ Users user = new Users(); user.setId(rs.getInt(&quot;id&quot;)); user.setUsername(rs.getString(&quot;username&quot;)); user.setEmail(rs.getString(&quot;email&quot;)); user.setGrade(rs.getInt(&quot;grade&quot;)); user.setPasswd(rs.getString(&quot;passwd&quot;)); al.add(user); } } catch (SQLException e) { e.printStackTrace(); }finally { SqlHelper.close(rs,SqlHelper.getPs(),SqlHelper.getCt()); } return al; } Web-Service-DAO（数据访问层）大讨论 mvc规定我们应该怎样去开发软件（把数据输入，数据处理，数据显示分离） web(jsp V/Servlet C)-servie(M)-dao(M)这是一种mvc的具体实现 web(jsp V/Servlet C)-service(M)开发方式也是一种具体的实现 举个例子，UserService.java中只包含业务逻辑，UserBean.java为数据对象，而对数据库的操作放在UserDao.java中 这种分层的好处是使数据和操作分离 将整个model层分为service层和dao层（数据访问层） 若UserService中业务需要对多张表进行操作，可以通过多个DAO的组合操作来实现 但在实际项目中，很多持久化逻辑本身就是业务逻辑（比如增加一个用户，增加用户信息到数据库时持久化逻辑，增加用户是业务逻辑），省略DAO层有时候更方便，更实用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java基础常用]]></title>
      <url>%2F2016%2F07%2F08%2F%5BJava%5DJava%E5%9F%BA%E7%A1%80%E5%B8%B8%E7%94%A8%2F</url>
      <content type="text"><![CDATA[读取文件根目录根目录在工程目录 InputStream ips = new FileInputStream(&quot;src/xx.properties&quot;); 类加载器根目录在src下 InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;); maven项目根目录为resources InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;); 读取文本文件//读取文件 String realPath = this.getServletContext().getRealPath(&quot;record.txt&quot;); FileReader fileReader = new FileReader(realPath); BufferedReader br = new BufferedReader(fileReader); String nums = br.readLine(); //一定要关闭流 br.close(); fileReader.close(); out.println(nums); //写入文件 FileWriter fileWriter = new FileWriter(realPath); BufferedWriter bw = new BufferedWriter(fileWriter); bw.write(String.valueOf(Integer.parseInt(nums) + 1)); bw.close(); fileWriter.close(); 从控制台读取数据BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(br.readLine()); Java读取资源文件/** * 文件类型是UTF-8，在String生成字符时需指定解码方式为utf-8； */ InputStream ips = null; try { ips = MyServer.class.getClassLoader().getResourceAsStream(&quot;com/main/戏曲.txt&quot;); int hasRead = 0; byte[] buffer = new byte[1024]; StringBuffer content = new StringBuffer(); while((hasRead = ips.read(buffer)) &gt; 0){ content.append(new String(buffer, 0, hasRead, &quot;utf-8&quot;)); } System.out.println(content); } catch (Exception e) { e.printStackTrace(); }finally{ if (ips != null) { try { ips.close(); } catch (IOException e) { e.printStackTrace(); } } } 字符串四舍五入 float totalMoney = 123.124f; BigDecimal b = new BigDecimal(totalMoney); totalMoney = b.setScale(2,BigDecimal.ROUND_HALF_UP).floatValue(); 保留两位小数 String.format(&quot;%.2f&quot;, totalMoney) 生成指定长度的随机字符串//生成指定长度的随机字符串 public static String GenRandomString(int length){ Random random = new Random(); char[] charArray = &quot;abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray(); char[] randomChar = new char [length]; for(int i = 0; i &lt; randomChar.length; i++){ randomChar[i] = charArray[random.nextInt(charArray.length)]; } return new String(randomChar); } JDBCMAVEN依赖：http://blog.csdn.net/earbao/article/details/44900083 连接步骤：http://www.cnblogs.com/hongten/archive/2011/03/29/1998311.html JDBC查询 //到数据库中验证 /* * 1.加载驱动 * 2.得到连接 * 3.创建PrepareStatment * 4.执行操作 * 5.根据结果做处理 * */ Connection connection = null; PreparedStatement ps = null; ResultSet rs = null; try { //1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获得连接 connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/servlet_users_manager&quot;,&quot;root&quot;,&quot;root&quot;); //3.创建prepareStatement ps = connection.prepareStatement(&quot;select * from users where username = ? and passwd = ?&quot;); ps.setObject(1,username); ps.setObject(2,password); //4.执行操作 rs = ps.executeQuery(); //5.根据结果做处理 if(rs.next()){ //说明用户合法 System.out.println(rs.getString(&quot;username&quot;) + &quot; &quot; + rs.getString(&quot;passwd&quot;)); request.getRequestDispatcher(&quot;/MainFrame&quot;).forward(request,response); }else{ request.getRequestDispatcher(&quot;/Login&quot;).forward(request,response); } } catch (Exception e) { e.printStackTrace(); }finally { //关闭资源 if(rs != null){ // 关闭记录集 try{ rs.close(); }catch(Exception e){ e.printStackTrace() ; } } if(ps != null){ // 关闭声明 try{ ps.close() ; }catch(Exception e){ e.printStackTrace() ; } } if(connection != null){ // 关闭连接对象 try{ connection.close() ; }catch(Exception e){ e.printStackTrace() ; } } } 分页定义四个分页变量 pageNow 表示第几页,该变量是由用户来决定,因此变化 pageSize 每页显示几条记录,由程序指定,也可以由用户定制 pageCount 表示共有多少页, 该变量是计算出来-&gt;思考 怎样确定 rowCount 共有多少条记录,该变量是查询数据库得到 如何确定pageCount (1) if(rowCount% pageSize==0){ pageCount=rowCount/pageSize; }else{ pageCount= rowCount/pageSize+1; } 试试: 比如 users表 9 条记录 pageSize=3 =&gt;pageCount=3 比如 users表 10 条记录 pageSize=3 =&gt;pageCount=4 (2) 上面的算法等价于 pageCount=rowCount% pageSize==0 ? rowCount/pageSize: rowCount/pageSize+1; 该运算称为三目运算 (3) 更简单的算法是:★★★★★ pageCount=(rowCount-1)/pageSize+1; 试试: 比如 users表 9 条记录 pageSize=3 =&gt;pageCount=3 比如 users表 11 条记录 pageSize=3 =&gt;pageCount=4 为什么？ 如果pageSize整除rowCount，值不需要加一； 如果pageSize不整除rowCount，值需要加一。 我们可以使rowCount-1，保证每次都不能整除，这样可以得到统一公式: pageCount = （rowCount-1）/pageSize + 1 项目中传递参数客户端传递：pageNow、pageSize（为保证程序健壮性，服务器中设置pageNow和pageSize的默认值）服务器传递：数据和rowCount MD5利用Java自带的MD5加密 class MD5Util { public final static String MD5(String s) { char hexDigits[] = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; }; try { byte[] strTemp = s.getBytes(); MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) { byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; } return new String(str); } catch (Exception e) { return null; } } public static void main(String[] args) { // MD5_Test aa = new MD5_Test(); System.out.print(MD5Util.MD5(&quot;qm&quot;)); } } 验证码public class check_code extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 7.禁止浏览器缓存随机图片 response.setDateHeader(&quot;Expires&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); // 6.通知客户机以图片方式打开发送过去的数据 response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;); // 1.在内存中创建一副图片 BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB); // 2.向图片上写数据 Graphics g = image.getGraphics(); // 设背景色 g.setColor(Color.BLACK); g.fillRect(0, 0, 60, 30); // 3.设置写入数据的颜色和字体 g.setColor(Color.RED); g.setFont(new Font(null, Font.BOLD, 20)); // 4.向图片上写数据 String num = makeNum(); //这句话就是把随机生成的数值，保存到session request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了 g.drawString(num, 5, 22); // 5.把写好数据的图片输出给浏览器 ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); } //该函数时随机生成4位数字 public String makeNum() { Random r = new Random(); //9999999 可以生成7位 String num = r.nextInt(9999) + &quot;&quot;; StringBuffer sb = new StringBuffer(); //如果不够4位，前面补零 for (int i = 0; i &lt; 4 - num.length(); i++) { sb.append(&quot;0&quot;); } num = sb.toString() + num; return num; } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } list转string[]方法一：单个元素转换 //ArrayList ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;aaa&quot;); array.add(&quot;bbb&quot;); array.add(&quot;ccc&quot;); //转化成Object数组 Object[] objs = array.toArray(); //新建数组 String[] strings = new String[array.size()]; //每个元素类型转换 int i = 0; for(Object obj : objs){ if(obj instanceof String){ strings[i++] = (String)obj; } } for(String s : strings){ System.out.println(s); } 方法二：整个转 //ArrayList ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;aaa&quot;); array.add(&quot;bbb&quot;); array.add(&quot;ccc&quot;); String[] strings = new String[array.size()]; array.toArray(strings); for(String s : strings){ System.out.println(s); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IDEA快捷键]]></title>
      <url>%2F2016%2F07%2F08%2F%5BIDEA%5DIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[参考http://blog.csdn.net/dc_726/article/details/42784275 智能提示 Alt + /基本代码提示 CTRL+空格(和系统输入法冲突，请在Settings-&gt;Keymap-&gt;mainmenu -&gt; code -Completion-&gt;basic，右键添加自己的快捷键)，可以设置为Alt + / Ctrl + Alt + /更智能地按类型信息提示 默认为Ctrl+Shift+Space ALT + Enter 快速修复，类似Eclipse中的Quick Fix功能 Ctrl+Shift+Enter 自动补全末尾的字符，例如敲完if/for时也可以自动补上{}花括号 F2/ Shift+F2 移动到有错误的代码 重构 Ctrl+Shift+Alt+T 重构功能大汇总快捷键，叫做Refactor This Shift+F6 直接就是改名 Ctrl+Alt+V 提取变量 代码生成 Ctrl+J 可以查看所有模板 Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等 编辑 Ctrl + Shift + 上下 ： 上下移动当前行 Ctrl + Shift + 左右 ：代替鼠标选中代码 Ctrl + Alt + 上下 ： 复制一行 Alt + 上下 ： 光标函数间跳转 Alt + 左右 ： tab切换 Ctrl + D ： 删除一行 Ctrl + / ： 注释 Ctrl + / Ctrl + Shift + / ： 折叠代码 Ctrl + ‘+’ Ctrl + Shift + ‘+’： 展开代码 Ctrl+N / Ctrl+Shift+N 可以打开类或资源 Shift+Shift 在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等 Ctrl+F/Ctrl+Shift+F 在当前窗口或全工程中查找 F3/Shift+F3前后移动到下一匹配处 格式化代码 格式化import列表：Ctrl+Alt+O 格式化代码：Ctrl+Alt+L 自动代码 CTRL+ALT+L 格式化代码 CTRL+E或者ALT+SHIFT+C 最近更改的代码 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+ALT+T 代码模版 Ctrl+Shift+T 自动生成测试类 其他 CIRL+U 大小写切换 CTRL+Z 倒退 CTRL+SHIFT+Z 向前 CTRL+ALT+F12 资源管理器打开文件夹在WINDOW窗口快速定位到文件或者文件夹的位置 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+/ 注释// CTRL+SHIFT+/ 注释 CTRL+B 快速打开光标处的类或方法 page up 和 page down ALT+ ←/→ 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT ←/→ 返回上次编辑的位置 SHIFT+F6 重构-重命名 CTRL+H 显示类结构图 CTRL+Q 显示注释文档 ALT+1 快速打开或隐藏工程面板 ALT + 4 Run Console ALT + 5 Debug Console 在任何工具窗口里使用Escape键都可以把焦点移到编辑器上,Shift-Escape不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口 CTRL+W 选中代码，连续按会有其他效果（我去掉了） CTRL+F4 关闭当前打开文件（我修改为CTRL + W） Ctrl + Shift + F12 关闭所有工具栏 Ctrl+H 查看类的继承关系，打开类层次窗口 Ctrl+F12 查看当前类的所有方法 Ctrl+B/Ctrl+Alt+B 在继承层次上跳转，分别对应父类或父方法定义和子类或子方法实现 Ctrl + tab 切来切去 Ctrl + Shift + A 发号施令 CTRL+G 定位行 JDK doc绑定CTRL + Q 查看注释文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Intellij IDEA15创建Maven管理的Java Web项目]]></title>
      <url>%2F2016%2F07%2F07%2F%5BServlet%5DIntellij%20IDEA%E5%88%9B%E5%BB%BAMaven%E7%AE%A1%E7%90%86%E7%9A%84Java%20Web%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[本文的思路是先创建Maven项目，再加上Java Web模块支持 创建Maven项目File - New - Project，创建Maven项目 Next，填写GroupId，ArtifactId和Version Next，这里在Properties中添加一个参数archetypeCatalog=internal，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。 来自网上的解释： archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。 Next，填写项目名和module名称，项目名和模块名可以不一样（还不是很清楚两者的区别） 点击Finsh，项目的目录结构如下： Maven规定，src文件下有main和test两个文件夹。其中： main文件为项目主体目录，main下的java文件夹为源代码目录，resource为所需资源目录 test为项目测试目录，test下的java文件夹为测试代码目录，resources为测试所需资源目录 发现生成的Maven项目，没有Web目录！在项目名称右击，选择Add Framework Support 在Add Framework Support对话框中勾选Web Application，版本选择3.0并勾选Create web.xml 点击OK后，看到如下界面，项目中出现了web文件夹，是不是很熟悉了，和MyEclipse中的项目结构类似 配置Tomcat服务器点击右上角的倒三角，选择Edit Configurations，弹出服务器配置页面 如下图，选择Local，然后点击Configure，在弹出的对话框中选择Tomcat安装目录 选择Tomcat Server，然后点击绿色的“+”号 点击“+”后选择Local，刚刚已经配置好了Local的Tomcat服务器 这里会新建一个Tomcat服务，输入任意名字即可。Update的快捷键是Ctrl+F10 点击Deployment，然后点击右边的“+”，添加Artifact部署 输入应用程序Context，输入路径:/工程名 点击界面上方的启动按钮就可以启动Tomcat服务器，启动后服务器自动打开浏览器 回到主界面，如图，点击Run打开服务器视图，能看到项目的部署情况了，而且可以完成服务器重启/关闭，项目部署等操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet笔记]]></title>
      <url>%2F2016%2F07%2F06%2F%5BServlet%5DServlet%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[常用#网页输出 PrintWriter out = response.getWriter(); out.println(&quot;Hello World&quot;); #请求头 request.getHeader(&quot;host&quot;)//参数见http请求头那节 //获取所有请求体 Enumeration&lt;String&gt; names = request.getHeaderNames(); while(names.hasMoreElements()){ String name = names.nextElement(); System.out.println(name + &quot;：&quot; + request.getHeader(name)); } #浏览器返回 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); #获得请求参数 String username = request.getParameter(&quot;username&quot;); Enumeration&lt;String&gt; e = request.getParameterNames() #跳转 1、request.getRequestDispatcher(&quot;/资源URI&quot;).forward(request,response) 2、response.sendRedirect(&quot;/web应用/资源URI&quot;); #获得web应用根路径 String path = this.getServletContext().getRealPath(&quot;/&quot;); #获得资源路径 String path = this.getServletContext().getRealPath(&quot;/image/无标题.png&quot;); #session，可以存字符串和对象 request.getSession().setAttribute(&quot;username&quot;,username); request.getSession().getAttribute(&quot;username&quot;) 为什么需要Servlet技术？ 普通的java技术很难完成网站开发，sun 就开发了servlet技术供程序员使用 servlet的介绍 servlet 其实就是java程序(java类) 该 java程序(java 类)要遵循servlet开发规范，继承servlet类 serlvet是运行在服务端 serlvet功能强大,几乎可以完成网站的所有功能 是学习jsp基础 Tomcat 和 servlet 在网络中的位置 Tomcat三大功能 Web服务器，与浏览器通信，解析和处理HTTP请求，处理静态页面 Servlet容器（Catalina），处理Servlet JSP容器，把JSP页面翻译成一般的Servlet Servlet容器与Servlet关系★★★★★ Servlet技术的核心是Servlet，所有的Servlet类必须直接或间接实现Servlet接口 Servlet接口定义了Servlet与Servlet容器之间的契约，即Servlet容器将Servlet类载入内存，并在Servlet实例是调用具体的方法，如用户请求时Servlet调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例 Web程序目录结构 静态页面、jsp直接放在web目录下 Servlet是Java程序，必须放在WEB-INF/classes目录下 Servlet工作流程★★★ 用户输入的URL为http://localhost:8088/hspWeb1/MyFirstServlet 浏览器解析主机名（host文件，dns） 浏览器尝试连接web服务器（三次握手） 浏览器发送http请求 web服务器开始工作，首先解析主机名，选择使用哪个主机（引擎下有多个主机，有默认主机） web服务器解析web应用，确定使用主机下的context web服务器解析资源名，一个web应用下有多个资源，这里是MyFirstServlet 查询web.xml文件，确定MyFirstServlet在哪个包下 Web服务器利用反射机制，创建实例，并调用init方法（该方法只调用一次） web服务器把接收到的http请求封装成Request对象，作为service的参数传入。service会被调用多次，没访问一次Servlet，它的service就会被调用一次 Servlet获得response对象，返回结果 web服务器把request的信息拆除，形成http响应格式 当在某些情况下（tomcat重启、reload该webapp、重启电脑）web服务器会调用Servlet的destroy方法，将该servlet销毁 面试题: 请简述servlet的生命周期(工作流程)答: 当第一次访问某个servlet，web服务器将会创建一个该servlet的实例，并且调用 servlet的init()方法，init函数只会被调用一次；如果当服务器已经存在了一个servlet实例，那么，将直接使用此实例；每次请求都会调用service()方法，service()方法将根据客户端的请求方式来决定调用对应的doXXX()方法；当 web应用 reload 或者 关闭 tomcat 或者 关机，web服务器将调用destroy()方法，将该servlet从服务器内存中删除。 开发Servlet程序开发servlet有三种方法★★★ (1) 实现 Servlet接口(对Servlet的工作过程有清晰的认识) (2) 通过继承 GenericServlet (3) 通过继承 HttpServlet ①实现servlet接口的方式需求如下: 请使用实现接口的方式，来开发一个Servlet，要求该Servlet可以显示Hello，world，同时显示当前时间 步骤1、在webapps下建立一个web应用my2、在my下建立 WEB-INF-&gt;web.xml [web.xml可以从 ROOT/WEB-INF/web.xml拷贝]3、在WEB-INF下建立 classes 目录(我们的Servlet 就要在该目录开发)，建立lib文件夹4、开发MyServlet.java package com.apeius; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; public class MyServlet implements Servlet { //该函数用于初始化servlet,就是把该servlet装载到内存中,该函数只会被调用一次 /*调用这个方法，Servlet容器会传入一个ServletConfig， * 一般会将ServletConfig赋给一个类级对象，这样可以在Servlet类中其他点来使用， * 但Servlet实例会被一个应用程序的所有用户共享，使用类级变量须是只读的，或者是 * java.util.concurrent.atomic包的成员 * / public void init(ServletConfig config) throws ServletException{ } //得到ServletConfig对象 public ServletConfig getServletConfig(){ return null; } //该函数是服务函数,我们的业务逻辑代码就是写在这里 //该函数每次都会被调用 public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException{ //在控制台输出时间 System.out.println(new java.util.Date()); } //该函数时得到servlet配置信息 public java.lang.String getServletInfo(){ return null; } //销毁该servlet,从内存中清除,该函数被调用一次 public void destroy(){ } } 5、编译 如果使用javac去编译一个带package的java文件，则需要带命令参数javac –d . java文件 6、根据Servlet规范，我们还需要部署Servlet &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt; &lt;servlet&gt; &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--③--&gt; &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt; &lt;servlet-class&gt;com.apeius.MyServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt; &lt;/servlet&gt; &lt;!--Servlet的映射--&gt; &lt;servlet-mapping&gt; &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--②--&gt; &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt; &lt;url-pattern&gt;/ABC&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 服务器调用流程：http://localhost:8088/my/ABC---&gt;①---&gt;②---&gt;③---&gt;④ 7、在浏览器中测试 在浏览器中输入http://localhost:8080/my/ABC ②使用GenericServlet开发servlet（了解即可）为什么使用GenericServlet1、实现Servlet接口必须实现接口中的所有方法，即使有一些方法根本没有包含任何代码2、此外还需要将ServletConfig对象保存到类级变量中 GenericServlet完成的任务 将init方法中个ServletConfig赋给一个类级变量，以便可以通过getServletConfig获取 为Servlet接口中的所有方法提供默认的实现 提供方法，包围ServletConfig中的方法 GenericServlet原理GenericServlet通过将ServletConfig赋给init方法中的类级变量private transient ServletConfig config；来保存ServletConfig public void init(ServletConfig config) throws ServletException { this.config = config; this.init(); } 但是，如果在子类中覆盖了这个方法，就会调用Servlet中的init方法，并且还必须调用super.init(servletConfig)来保存ServletConfig，为了避免上述麻烦，GenericServlet提供了第二个init方法，它不带参数。这个方法是在ServletConfig被赋给servletConfig后，由第一个init方法调用，子类改写后调用的是子类的无参数init方法 总结：Tomcat调用Servlet接口的init(ServletConfig config)方法，其实现类是用户继承的子类，该子类重写了无参数的init方法进行初始化工作。首先调用父类中的init(ServletConfig config)方法，将config对象保存为类级变量，然后调用this.init()方法，this指针指向子类实例，init方法被重写，所以调用子类的init方法，若需要访问GenericServlet中的无参数init方法，则需要在子类中使用super.init()； 开发步骤继承GenericServlet package com.hsp; import javax.servlet.*; import javax.servlet.http.*; import java.io.*; public class MyGenericServlet extends GenericServlet { public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException{ res.getWriter().println(&quot;hello,world,i am geneirc servlet&quot;); } } 将该Servlet部署到web.xml文件中: &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt; &lt;servlet&gt; &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt; &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt; &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt; &lt;servlet-class&gt;com.hsp.MyGenericServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--Servlet的映射--&gt; &lt;servlet-mapping&gt; &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt; &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt; &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分,默认命名规范: 就是该Servlet的名字--&gt; &lt;url-pattern&gt;/MyGenericServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ③使用继承 HttpServlet 的方法来开发Serlvet 在软件公司 90%都是通过该方法开发. 举例说明，还是显示 hello,world 当前日期 原理 HttpServlet类继承了GenericServlet类，并重写了service(ServletRequest req,ServletResponse res)方法，Tomcat调用Servlet接口的service(ServletRequest req,ServletResponse res)方法，实际调用的是HttpServlet类中的的service(ServletRequest req,ServletResponse res)方法，方法体内将ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse，并调用新添加的service方法 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException(&quot;non-HTTP request or response&quot;); } service(request, response); } HttpServlet中扩展了一个protected void service(HttpServletRequest req, HttpServletResponse resp)方法，根据不同的请求方法，调用不同的doXXX方法 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn&apos;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp); } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req,resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req,resp); } else { // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); } } 子类继承后，通过改写doGet和doPost方法，实现方法的调用 开发步骤代码 package com.apeius; import javax.servlet.*; import javax.servlet.http.*; import java.io.*; public class MyHttpServlet extends HttpServlet { //在HttpServlet 中，设计者对post 提交和 get提交分别处理 //回忆 &lt;form action=&quot;提交给?&quot; method=&quot;post|get&quot;/&gt;,默认是get protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, java.io.IOException{ resp.getWriter().println(&quot;i am httpServet doGet()&quot;); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, java.io.IOException{ resp.getWriter().println(&quot;i am httpServet doPost() post name=&quot;+req.getParameter(&quot;username&quot;)); } } 还有一个login.html &lt;html&gt; &lt;body&gt; &lt;form action=&quot;/my/MyHttpServlet&quot; method=&quot;post&quot;&gt; u:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 部署 &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt; &lt;servlet&gt; &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt; &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--③--&gt; &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt; &lt;servlet-class&gt;com.apeius.MyHttpServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt; &lt;/servlet&gt; &lt;!--Servlet的映射--&gt; &lt;servlet-mapping&gt; &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt; &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--②--&gt; &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt; &lt;url-pattern&gt;/MyHttpServlet&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt; &lt;/servlet-mapping&gt; 使用myeclipse来开发servlet，IDEA类似(1) 建立web工程 (2) 在Src 目录下创建了一个包 com.hsp.servlet 添加Package，方法一般只需创建doGet()和doPost()方法，修改Servlet/JSP Mapping URL (3) 开发一个Servlet MySerlvet 的代码: public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;hello &quot;+new java.util.Date().toString() ); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 使用IDEA来开发Servlet程序 见另一篇博文:Intellij IDEA15创建Maven管理的Java Web项目 Servlet的细节问题[映射、单例、通配符、自启动]① 一个已经注册的Servlet可以被多次映射即:&lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;!-- servlet的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet类的全路径(包名+类名) --&gt; &lt;servlet-class&gt;com.hsp.servlet.MyServlet1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 对一个已经注册的servlet的映射 --&gt; &lt;!-- 映射1 --&gt; &lt;servlet-mapping&gt; &lt;!-- servelt的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet的访问路径 --&gt; &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 映射2 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/hsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ② 映射一个servlet时候，可以多层，比如&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt; 从这里还可以看出，后缀名是 html 不一定就是 html,可能是假象. ③ 用通配符在servlet映射到URL中有两种格式: 第一种格式 *.扩展名，比如 *.do，*.ss 第二种格式 以 / 开头，同时以 /* 结尾。比如 /*,/news/* 在匹配的时候，要参考的标准: 看谁的匹配度高，谁就被选择 *.do的优先级最低 通配符练习题： ● Servlet1 映射到 /abc/* ● Servlet2 映射到 /* ● Servlet3 映射到 /abc ● Servlet4 映射到 *.do 问题(面试题)： 当请求URL为&apos;/abc/a.html&apos;，&apos;/abc/*&apos;和&apos;/*&apos;都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为&apos;/abc&apos;时，&apos;/abc/*&apos;和&apos;/abc&apos;都匹配，哪个servlet响应 Servlet引擎将调用Servlet3。 当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet1。 当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应 Servlet引擎将调用Servlet2。 ④Servlet单例问题 当Servlet被第一次访问后，就被加载到内存，以后该实例对各个请求服务，即在使用中是单例 Servlet实例会在一个应用程序中被所有用户共享，因此不建议使用类级变量 ，除非它们是只读的，或者是java.util.concurrent.atomic包的成员 证明： 在Servlet中定义一个变量i，当浏览器访问时i++，并输出i；如果Servlet是单例，则每次输出i都会增加 问题： 因为 Servlet是单例，因此会出现线程安全问题: 比如:售票系统. 如果不加同步机制，则会出现问题: 原则: （1）如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制 synchronized (对象){ //同步代码 } （2）如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题 ⑤servlet中的&lt;load-on-startup&gt;配置需求 当我们的网站启动的时候，可能会要求初始化一些数据，(比如创建临时表), 在比如：我们的网站有一些要求定时完成的任务[ 定时写日志，定时备份数据.. 定时发送邮件..] 解决方法 可以通过 &lt; load-on-startup &gt; 配合线程知识搞定. 一般在有用户访问该Servlet时才会被加载进内存，现在需要在网站启动的时候自动启动Servlet。首先在web.xml下，该Servlet下进行配置&lt;load-on-startup &gt;1（数字Servlet启动优先级）&lt;/load-on-startup&gt; 这样该Servlet在网站启动时将会被自动创建. ServletConfig对象 调用Servlet的init方法时，Servlet容器会传入一个ServletConfig实例，该对象主要用于读取 servlet的配置信息 案例 &lt;servlet&gt; &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.hsp.servlet.ServletConfigTest&lt;/servlet-class&gt; &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 获得配置参数 String encoding=this.getServletConfig().getInitParameter(&quot;encoding&quot;); 补充说明 这种配置参数的方式，只能被某个Servlet独立使用.如希望让所有的Servlet都去读取某个参数,这样配置: &lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt; &lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/context-param&gt; 获得配置参数 String encoding = this.getServletContext().getInitParameter(&quot;encoding&quot;) 如果要把所有的参数都读取，则使用 如下方法 ： Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames(); while(names.hasMoreElements()){ String name=names.nextElement(); System.out.println(name); System.out.println(this.getServletConfig().getInitParameter(name)); } ServletContext★★★★★（包含读取文件路径）在访问某个网站时，首页会显示您是第几个浏览者，这个怎么实现的？除了数据库，文件等方式，最方便的是使用ServletContext。 ServletContext是一个公共的空间，可以被所有客户访问 Web容器在启动时，它会为每个Web应用程序创建一个对应的ServletContext对象，它代表当前Web应用。当web应用关闭/tomcat关闭/对web应用reload会造成servletContext销毁. ServletContext对象通过ServletConfig.getServletContext方法获得对ServletContext对象的引用，也可以通过this.getServletContext()来获得其对象的引用 每个Web应用程序只有一个上下文，一个Web应用中所有的Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象实现通讯。ServletContext对象通常也被称为context域对象，公共聊天室就会用到它 基本使用获取: this.getServletContext(); #在HttpServlet中直接获取 this.getServletConfig().getServletContext(); # 在ServletConfig中获取 request.getSession().getServletContext(); #通过HttpRequest获得 添加属性: servletcontext.setAttribute(string,object); 取出属性 servletcontext.getAttribute(“属性名”) 删除 setvletContext.removeAttribute(“属性名”); ServletContext的应用获取WEB应用的初始化参数&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt; &lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;scott&lt;/param-value&gt; &lt;/context-param&gt; 如何获取 String val= this.getServletContext().getInitParameter(&quot;name&quot;); 使用ServletContext实现跳转//目前我们跳转到下一个页面的方法 //1 response.sendRedirect(&quot;/web应用名/资源名&quot;); //2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response); /* * 区别1. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器 * 2. 如果request.setAttribute(&quot;name&quot;,&quot;顺平&quot;) 希望下一个页面可以使用 属性值，则使用 getRequestDispatcher * 3. 如果session.setAttribute(&quot;name2&quot;,&quot;顺平3&quot;), 希望下一个页面可以使用 属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher * 4. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect */ //3.这种方法和2一样 this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response); 读取文件，和获取文件全路径 读Web目录下和WEB-INF目录下的文件 //首先读取到文件dbinfo.properties放在web根目录下 InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;); //创建Properties Properties pp=new Properties(); pp.load(inputStream); out.println(&quot;name=&quot;+pp.getProperty(&quot;username&quot;)); 如果文件放在src目录下(如果是maven项目，则resources目录下为根目录)，则使用类加载器 //如果文件放在上述目录下，我们应该使用类加载器来读取 InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;) //如果放在包下，则带上包名，例如cn/apeius/xx.properties 获取文件全路径（以WEB目录为根目录） //如果读取到一个文件的全路径（dbinfo.properties在web目录下） String path=this.getServletContext().getRealPath(&quot;dbinfo.properties&quot;); out.println(&quot;paht = &quot;+path); 网站计数器 我们建立一个文件recoder.txt文件，用于保存访问量,可以可以保证稳定增长. 建立InitServlet,Web项目启动时自动加载该Servlet，读取record.txt，初始化Servletcontext中的访问量，和在关闭tomcat时保存访问量如record.txt 如果我们的tomcat异常退出，使用线程定时把ServletContext的值，刷新到recorder.txt http请求消息头1. Accept: text/html,image/* [告诉服务器，我可以接受 文本，网页，图片] 2. Accept-Charset: ISO-8859-1 [接受字符编码 iso-8859-1] 3. Accept-Encoding: gzip,compress [可以接受 gzip,compress压缩后数据.] 4. Accept-Language: en-us,zh-cn [浏览器支持中，英文] 5. Host: www.sohu.com:80 [我要找主机是 www.sohu.com:80] 6. If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT [ 告诉服务器，我的缓冲中有这个资源文件，该文件的时间是 。。。，文件有更新才发送] 7. Referer: http://www.sohu.com/index.jsp [告诉服务器，我来自哪里,该消息头，常用于防止盗链] 8. User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)[告诉服务器，浏览器内核] 9. Cookie [cookie后面介绍] 10. Connection: close/Keep-Alive [保持连接，发完数据后，我不关闭连接] 11. Date: Tue, 11 Jul 2000 18:23:51 GMT [浏览器发送该http请求的时间] http响应消息头Location: http://www.baidu.org/index.jsp 【让浏览器重新定位到url】 Server:apache tomcat 【告诉浏览器我是tomcat】 Content-Encoding: gzip 【告诉浏览器我使用 gzip】 Content-Length: 80 【告诉浏览器会送的数据大小80节】 Content-Language: zh-cn 【支持中文】 Content-Type: text/html; charset=GB2312 [内容格式text/html; 编码gab2312] Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 【告诉浏览器，该资源上次更新时间】 Refresh: 1;url=http://www.baidu.com 【过多久去，刷新到 http://www.baidu.com】 Content-Disposition: attachment; filename=aaa.zip 【告诉浏览器，有文件下载】 Transfer-Encoding: chunked [传输的编码] Set-Cookie:SS=Q0=5Lb_nQ; path=/search[后面详讲] Expires: -1[告诉浏览器如何缓存页面IE] Cache-Control: no-cache [告诉浏览器如何缓存页面火狐] Pragma: no-cache [告诉浏览器如何缓存页面] Connection: close/Keep-Alive [保持连接 1.1是Keep-Alive] Date: Tue, 11 Jul 2000 18:23:51 GMT http响应的状态行200 就是整个请求和响应过程没有发生错误，这个最常见. 302: 表示当你请求一个资源的时候，服务器返回302 表示，让浏览器转向到另外一个资源，比如: response.sendRedirect(“/web应用/资源名”) 案例: response.setStatus(302); response.setHeader(&quot;Location&quot;, &quot;/servletPro/Servlet2&quot;); // 上面两句话等价 response.sendRedirect(&quot;/servletPro/Servlet2&quot;); 404： 找不到资源 500: 服务器端错误 http响应头应用★★★[防盗链、定时、文件下载、缓存]防盗链 - Referer//获取用户浏览器Referer String referer=request.getHeader(&quot;Referer&quot;); if(referer==null||!referer.startsWith(&quot;http://localhost:8088/servletPro&quot;)){ response.sendRedirect(&quot;/servletPro/Error&quot;); return; } 定时刷新Refresh使用response.setHeader(&quot;Refresh&quot;, &quot;5;url=/servletPro/Servlet2&quot;); 文件下载 Content-Dispositionpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); //★★★需要注释 //PrintWriter out = response.getWriter(); //演示下载文件 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=winter.jpg&quot;); //打开文件.说明一下web 站点下载文件的原理 //1.获取到要下载文件的全路径 String path=this.getServletContext().getRealPath(&quot;/images/Winter.jpg&quot;); //System.out.println(&quot;path=&quot;+path); //2创建文件输入流 FileInputStream fis=new FileInputStream(path); //做一个缓冲字节数组 byte buff[]=new byte[1024]; int len=0;//表示实际每次读取了多个个字节 OutputStream os=response.getOutputStream(); while((len=fis.read(buff))&gt;0){ os.write(buff, 0, len); } //关闭 os.close(); fis.close(); } 缓存讲解 提出问题：浏览器默认情况下，会缓存我们的页面，这样出现一个问题：如果我们的用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用cache中取数据（刷新还是会重新向服务器请求数据）。 （1）有些网站要求及时性很高，因此要求我们不缓存页面 //指定该页面不缓存 Ie response.setDateHeader(&quot;Expires&quot;, -1);//【针对IE浏览器设置不缓存】 //为了保证兼容性. response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//【针对火狐浏览器等】 response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//【其他浏览器】 （2）有些网站要求网页缓存一定时间,比如缓存一个小时 response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+3600*1000*24);后面一个参数表示设置的缓存保持时间，-1表示永远缓存 HttpServletResponse的再说明HttpServletResponse中输出流两个方法： getWriter() getOutputStream() 区别 1、 getWriter() 用于向客户机回送字符数据 PrintWriter out = response.getWriter(); out.println(&quot;hello,world&quot;); 2、 getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据(二进制数据)，但也可以输出文本内容 OutputStream os=response.getOutputStream(); os.write(&quot;hello,world&quot;.getBytes()); 如何选择: 如果我们是回送字符数据，则使用PrintWriter对象,效率高 如果我们是回送字节数据(binary date),则只能使用OutputStream 这两个流不能同时使用. 比如： OutputStream os=response.getOutputStream(); os.write(&quot;hello,world&quot;.getBytes()); PrintWriter out=response.getWriter(); out.println(&quot;abc&quot;); 就会报错: java.lang.IllegalStateException: getOutputStream() has already been called for this response 注意： Web服务器会自动检查并关闭流，为什么我们没有主动关闭流，程序也没有问题的原因.当然：你主动关闭流，更好. 参数的传递方式sendRedirect()和session() 需求: 当用户登录成功后，把该用户名字显示在登录成功页面; 解决方法 使用 java 基础 static，专门用一个类来存储静态数据 使用 sendRedirect()，在url上加上需要传递的参数 response.sendRedirect("/UsersManager/MainFrame?uname="+username+"&pwd="+password); 说明: 基本格式: response.sendRedirect("/Context/servlet的?参数名=参数值&参数名=参数值..."); 使用session传递 session既可以传递字符串，也可以传递对象 A.传递字符串 放入session request.getSession.setAttribute(&quot;loginUser&quot;,username); 取出session 在JSP中通过session取出 request.getSession.getAttribute(&quot;loginUser&quot;); B．传递对象 User user= new User(); user.setName(&quot;xiaoli&quot;); user.setPassWord(“123”); 放入session request.getSession.setAttribute(&quot;userObj&quot;,userObj); 取出session User user=(User)request.getSession.getAttribute(&quot;userObj&quot;); 中文乱码处理 发生中文乱码有三种情况，我们应当尽量使用post方式提交 ①表单form (1)表单以post方式提交 浏览器把请求发送给web服务器[utf-8]，web服务器以ISO-8859-1编码方式进行接收，产生乱码，之后进行传递也都是乱码。 在接收参数时，采用正确的编码，即可解决问题，在服务器端设置成浏览器端的编码方式。 request.setCharacterEncoding("utf-8"); //gbk gb2312 big5 (2)表单以get方式提交 请求内容是以请求行URL进行提交，而不是用请求体，所以使用setCharacterEncoding无效 写一个工具类: package com.hsp.utils; public class MyTools { public static String getNewString(String str) { String newString=&quot;&quot;; try { newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); } catch (Exception e) { e.printStackTrace(); // 把iso-8859-1 转换成 utf-8 } return newString; } } ②超链接 数据以get方式进行传递，该方法和get处理方法一样. &lt;a href=”http://www.sohu.com?name=函数后”&gt;测试&lt;/a&gt; ③sendRedirect() 发生乱码 客户端会重新发送一个http请求，该方法和get处理方法一样 response.sendRedirect(&quot;servlet地址?username=顺平&quot;); 版本低导致的乱码 特别说明，如果你的浏览器是 ie6 或以下版本，则我们的 ② 和 ③中情况会出现乱码(当中文是奇数的时候)解决方法是 ： String info=java.net.URLEncoder.encode(&quot;你好吗.jpg&quot;, &quot;utf-8&quot;); &lt;a href=&quot;http://www.sohu.com?name=&quot;+ info &gt;测试&lt;/a&gt; response.sendRedirect(&quot;servlet地址?username=&quot; + info); ★★★★返回浏览器显示乱码 在服务端是中文，在response的时候，也要考虑浏览器显示是否正确,一般我们通过 response.setContentType(&quot;text/html;charset=utf-8&quot;); 下载提示框中文乱码 补充一个知识点: 当我们下载文件的时候，可能提示框是中文乱码 String temp=java.net.URLEncoder.encode(&quot;传奇.mp3&quot;,&quot;utf-8&quot;); response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename=&quot;+temp); HttpServletRequest对象的详解 该对象表示浏览器的请求(http请求), 当web服务器得到该请求后，会把请求信息封装成一个HttpServletRequest 对象 getRequestURL方法返回客户端发出请求时的完整URL。 getRequestURI方法返回请求行中的资源名部分。 getQueryString方法返回请求行中的参数部分(参数名+值)。该函数可以获取请求部分的数据，比如http://localhost/web名?username=abc&amp;pwd=123request.getQueryString();就会得到 username=abc&amp;pwd=123 getRemoteAddr方法返回发出请求的客户机的IP地址 getRemoteHost方法返回发出请求的客户机的完整主机名，如果该客户机没有在dns注册，则返回ip地址 getRemotePort方法返回客户机所使用的网络端口号，客户机的端口号是随机选择的，web服务器的端口号是一定的 getLocalPort方法返回web服务器所使用的网络端口号 getLocalAddr方法返回WEB服务器的IP地址。 getLocalName方法返回WEB服务器的主机名 url 和 uri 的区别比如： Url=http://localhost:8088/servletPort3/GetinfoServlet 完整的请求 Uri=/servletPort3/GetinfoServlet web应用的名称+资源的名称 请求转发getRequestDispatcher#请求转发 requeset.getRequestDispatcher(资源地址).forward(request,response); #可以在request的域对象中存储数据，request中的attribute在一次请求中有效 request.setAttribute(&quot;username&quot;,username); 资源地址：不需要项目名。因为它只是在WEB服务器内部转发。 Servlet接收到数据后，可以把数据放入到request域对象，Request中的Attribute在一次请求有效。 一次请求：浏览器发送一次http请求到接收到响应成为一次http请求，只要没有停止，也没有回到浏览器重定向，就算一次 请求转发的的(uml)图 使用forward不能转发到该web应用外的url 因为 forward 是发生在web服务器，所以 Servlet1 和 Servlet 2使用的是用一个request 和response. 使用sendRedirect() 方法不能通过request.setAttribute() 把 属性传递给下一个Servlet 面试题：请问sendRedirect和 forward的区别是什么？答: 1. 叫法sendRedirect()请求重定向，转发forward()叫请求转发 2. 实际发生的位置不一样 sendRedirect发生在浏览器，由浏览器重新发出http请求 forward发生web服务器，请求在web服务器转发 3. 用法不一样 request.getRequestDispatcher(“/资源URI”).forward(request,response) response.sendRedirect(“/web应用/资源URI”); 4. 能够去URL范围不一样 sendRedirect可以去外边URL forward只能去当前的WEB应用的资源 会话技术cookie什么是会话 基本概念: 指用户开一个浏览器，访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话。比如打电话 为什么需要cookie技术(会话技术) 如何保存用户上次登录时间 如何显示用户浏览历史 如何把登录的用户名和密码电脑，下次登录，不需要重新输入 cookie的原理图 创建cookie//创建cookie Cookie cookie = new Cookie(&quot;name&quot;,&quot;qm&quot;); //设置cookie的生命周期 cookie.setMaxAge(3600); //把cookie会写给浏览器 response.addCookie(cookie); 读取cookieCookie[] cookies = request.getCookies(); System.out.println(cookies.length); for(Cookie c : cookies){ out.println(c.getName() + &quot; &quot; + c.getValue() + &quot;&lt;br/&gt;&quot;); } cookie的小结★★★ cookie 是在服务端创建 cookie 是保存在浏览器这端 cookie 的生命周期可以通过cookie.setMaxAge(2000);如果不设置setMaxAge则该cookie的生命周期当浏览器关闭时，就消亡 同一个浏览器多个实例共享cookie，若cookie没到期，关闭浏览器后还能共享该cookie。当然不同浏览器之间是不能共享cookie的，因为每个浏览器存放cookie的路径不一样(与session的区别，session在关闭浏览器后，不采取任何方式，无法访问到session) 我们可以把cookie想成一张表 如果cookie重名就会替换存在的cookie值 一个web应用可以保存多个cookie,但保存在客户端浏览器下同一个cookie文本中 浏览器访问web应用时，会携带该web应用相关的cookie cookie存放的时候是以明文方式存放，因此安全较低，我们可以通过加密后保存[MD5算法见Java基础常用-MD5] 举例 - 保存上次登录时间★★★//先获取cookie // 假设我们 保存上次登录时间的cookie &quot;lasttime&quot; &quot;2011-11-11 12:12:12&quot;; // 这里我们要考虑一个情况: 用户第一次登录 &apos;您是第一次登录..&apos; Cookie[] cookies = request.getCookies(); boolean b = false;//假设没有lasttime cookie if (cookies != null) { //保证有cookie,取遍历 for (Cookie cookie : cookies) { //取出名 String name = cookie.getName(); if (&quot;lasttime&quot;.equals(name)) { //显示 out.println(&quot;您上次登录时间是 &quot; + cookie.getValue()); //更新时间 //把当前日期保存cookie SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String nowTime = simpleDateFormat.format(new java.util.Date()); cookie.setValue(nowTime); cookie.setMaxAge(7 * 3600 * 24);//保存一周 response.addCookie(cookie); b = true; break; } } } if (!b) { //没有找到 out.println(&quot;您是第一次登录..&quot;); //把当前日期保存cookie SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String nowTime = simpleDateFormat.format(new java.util.Date()); Cookie cookie = new Cookie(&quot;lasttime&quot;, nowTime); cookie.setMaxAge(7 * 3600 * 24);//保存一周 response.addCookie(cookie); } cookie的细节★★★① 一个浏览器最多放入300cookie，一个web站点，最多20cookie，而且一个cookie大小限制子4k② cookie生命周期的再说明: cookie默认生命周期是会话级别，即浏览器关闭，cookie生命周期结束 通过setMaxAge() 可以设置生命周期 setMaxAge(正数)，即多少秒后该cookie失效 setMaxAge(0)，删除该cookie setMaxAge(负数)，相当于该cookie生命周期是会话级别 cookie的生命周期，指的是累计时间，例如设置生命周期为30s，那么在30s之后cookie消亡（与session区别，session是发呆时间，即在一段时间内没有访问session就会消亡） 案例 ： //先得到该cookie Cookie cookies[]=request.getCookies(); for(Cookie cookie: cookies){ if(cookie.getName().equals(&quot;id&quot;)){ System.out.println(&quot;id&quot;); //删除 cookie.setMaxAge(0); response.addCookie(cookie);//一定带上这句话，否则不能删除 } } 特别说明: 如果该web应用只有一个cookie ，则删除该cookie后，在浏览器的临时文件夹下没有该cookie文件，如果该web应用有多个cookie,则删除一个cookie后，文件还在，只是该cookie没有 ③ cookie存放中文，怎么处理 进行URLEncoder 存放: String val=java.net.URLEncoder.encode(&quot;顺平&quot;,&quot;utf-8&quot;); Cookie cookie=new Cookie(&quot;name&quot;,val); 取出: String val=java.net.URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;); out.println(&quot;name =&quot;+val); 会话技术session（生成验证码）session有什么用? 问题1: 如何实现在不同的页面，可以去查看信息(比如说购物车)，同时还要实现不同的用户看到的信息是自己. Session是服务端技术，可以为每一个用户的浏览器创建一个独享的session对象 session工作原理图 session对象一行就代表一个属性，键值对 request.getSession()获得session，若第一次访问session会自动被创建，该浏览器第二次访问时将字节返回之前创建的session，不会创建新的。 一个浏览器关联一个session。如果此时有新的浏览器2访问Servlet1，那么就会创建一个新的sesssion与浏览器2对应 session默认的生命周期是30分钟 session中使用setAttribute时使用相同的属性名，属性值会被替换 session基本使用//访问session[当发现没有session时候，就会自动创建session] HttpSession session = request.getSession(); //向session中添加属性 session.setAttribute(&quot;name&quot;,&quot;姓名&quot;); //从session中得到某个属性 String name = (String) session.getAttribute(&quot;name&quot;); out.println(name + &quot;&lt;br/&gt;&quot;); //从session中删除某个属性 session.removeAttribute(&quot;name&quot;); out.println((String) session.getAttribute(&quot;name&quot;) + &quot;&lt;br/&gt;&quot;); session小结① session是存在服务器的内存中② 一个用户浏览器，独享一个session域对象（不能浏览器会创建新的session）③ session中的属性的默认生命周期是30min，你可以通过web.xml来修改④ 3种session生命周期的设置 （1）一个地方是 tomcat/conf/web.xml &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;//表示30分钟的意思 &lt;/session-config&gt; 对所有的web应用生效 （2）另外一个地方，就是在单个web应用的下去修改 web.xml &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;session精确到分钟,cookie精确到秒 &lt;/session-config&gt; 如果发生冲突，则以自己的web应用优先级高 （3）session.setMaxInactiveinterval(60) 六十秒为发呆时间，即在这六十秒内没有访问过session，则session中所有属性失效 session周期是发呆时间，如果我们设置session是10s，是指在10s内，没有访问过session，session属性失效，如果在9s时候，你访问session，session就会重新计时 如果重启tomcat，或者reload web应用，或者关机了，session失效 我们也可以通过函数，让session失效。invalidate()方法让所有属性失效，通常用于用户安全退出 如果你希望某个session属性失效，可以使用方法removeAttribute ⑤ session中可以存放多个属性⑥ session可以存放对象⑦ 如果session.setAttribute(“name”,val)，如果名字重复，则会替换该属性. session的更深入理解为什么服务器能够为不同的浏览器提供不同session？ 图中浏览器A第一次访问Servlet1的时候，没有携带JSESSIONID，调用getSession()就会自动给你创建一个session，id为110，并创建cookie：JSESSIONID=110. 第二次浏览器访问Servlet2时，携带cookie：JSESSIONID=110，说明session已经创建，getSession（）方法返回id=110的session，能够获得session中的数据 同理，浏览器B访问servlet1时会新建一个新的session，id=119 每个浏览器独享一个session对象 session自动返回的cookie不会被写入文件，所以不同浏览器访问servlet会获取不同的session 生成验证码案例public class check_code extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 7.禁止浏览器缓存随机图片 response.setDateHeader(&quot;Expires&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); // 6.通知客户机以图片方式打开发送过去的数据 response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;); // 1.在内存中创建一副图片 BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB); // 2.向图片上写数据 Graphics g = image.getGraphics(); // 设背景色 g.setColor(Color.BLACK); g.fillRect(0, 0, 60, 30); // 3.设置写入数据的颜色和字体 g.setColor(Color.RED); g.setFont(new Font(null, Font.BOLD, 20)); // 4.向图片上写数据 String num = makeNum(); //这句话就是把随机生成的数值，保存到session request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了 g.drawString(num, 5, 22); // 5.把写好数据的图片输出给浏览器 ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); } //该函数时随机生成4位数字 public String makeNum() { Random r = new Random(); //9999999 可以生成7位 String num = r.nextInt(9999) + &quot;&quot;; StringBuffer sb = new StringBuffer(); //如果不够4位，前面补零 for (int i = 0; i &lt; 4 - num.length(); i++) { sb.append(&quot;0&quot;); } num = sb.toString() + num; return num; } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } IE上购买商品后关闭，再打开IE，要求上次的商品还在分析 设session生命周期为30min,该session不会随浏览器的关闭而自动销毁。而会到30min后，才会被服务器销毁 关闭浏览器后，再打开。由于服务器端传回来的cookie：JSESSIONID没有设置生命周期，那么在浏览器关闭后cookie的生命周期结束。下次打开浏览器时，没有携带cookie：JSESSIONID，访问Servlet又会创建一个新的session 我们使用代码来实现该功能(session + cookie结合使用) 分析实现的思路: public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); //创建一个session，并放入一个属性 HttpSession session = request.getSession(); session.setAttribute(&quot;name&quot;, &quot;xxx&quot;); out.println(&quot;创一个session并放入姓名属性&quot;); //把session_id保存在cookie，cookie名字必须按照规范命名，必须大写JSESSIONID Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); ////如果不设置时间生命周期，cookie在浏览器关闭后就消亡 cookie.setMaxAge(60*30); response.addCookie(cookie); } ie禁用cookie后使用session的方法简易购物车的实例 思路 当用户点击购买商品时，我们把该商品保存到session中，该session的结构是: name val mybookds hashMap对象 而hashmap的结构是 key val 书号 书对象. 若禁用cookie后，每次访问Servlet不携带cookie数据，创建一个新的session，购物车商品不能保存 解决方法 URL重写 response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写 response.encodeRedirectURL(java.lang.String url)用于对sendRedirect方法后的url地址进行重写 Servlet.java request.getSession();//必须访问一下sesion String url = response.encodeURL(&quot;/ServletStudy/cl&quot;); out.println(&quot;&lt;form method = &apos;post&apos; action = &apos;&quot;+url+&quot;&apos;&gt;&quot;); out.println(&quot;&lt;input type = &apos;submit&apos;/&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); cl.java HttpSession session = request.getSession(); ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;) session.getAttribute(&quot;array&quot;); if(null == array){ array = new ArrayList&lt;String&gt;(); session.setAttribute(&quot;array&quot;,array); } SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String time = simpleDateFormat.format(new java.util.Date()); array.add(time); for(String s : array){ out.println(s + &quot;&lt;br/&gt;&quot;); } String url = response.encodeURL(&quot;/ServletStudy/Servlet&quot;); out.println(&quot;&lt;a href = &apos;&quot;+url+&quot;&apos;&gt;返回&lt;/a&gt;&quot;); cookie vs session存在的位置 cookie存在客户端的临时文件夹 session存在服务器的内存中，一个sessio与对象为一个用户浏览器服务 安全性 cookie是以明文方式存放在客户端，安全性弱，可以通过加密md5再存放 session是存放在服务端的内存中，安全性好 网络传输量 cookie会传递信息，给服务端 session的属性值不会给客户端 生命周期 cookie的生命周期是累计时间，即如果我们给cookie设置setMaxAge（30），则cookie在30s后失效 session额生命周期是间隔时间，如果我们设置session 20min，指在20min内，如果没有访问session，则session失效（指的是session属性失效），在关闭tomcat,reload web应用，时间到，invalidate也会让session失效 使用原则 因为session会占用服务器的内存，因此不要向session存放过多的对象，会影响性能 过滤器 Filter 客户端请求request在抵达Servlet之前、服务器响应response在从Servlet抵达客户端浏览器会经过过滤器，过滤器用于在Servlet之外对request或者response进行修改 Filter体现的是设计模式中的Filter模式 过滤器链 FilterChain一个过滤器链包括多个Filter，客户端请求request在抵达Servlet之前会经过FilterChain里的所有Filter，服务器响应response在从Servlet抵达客户端浏览器之前也会经过FilterChain里的所有Filter 防盗链Filterpublic class ImageRedirectFilter implements Filter { public void init(FilterConfig config) throws ServletException { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; // 禁止缓存 response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;); response.setHeader(&quot;Pragrma&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); // 链接来源地址 String referer = request.getHeader(&quot;referer&quot;); if (referer == null || !referer.contains(request.getServerName())) { /** * 如果 链接地址来自其他网站，则返回错误图片 */ request.getRequestDispatcher(&quot;/error.gif&quot;).forward(request, response); } else { /** * 图片正常显示 */ chain.doFilter(request, response); } } public void destroy() { } } 配置： &lt;filter&gt; &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.filter.ImageRedirectFilter &lt;/filter-class&gt; &lt;/filter&gt; 字符编码 Filter自定义public class CharacterEncodingFilter implements Filter { private String characterEncoding; private boolean enabled; @Override public void init(FilterConfig config) throws ServletException { characterEncoding = config.getInitParameter(&quot;characterEncoding&quot;); enabled = &quot;true&quot;.equalsIgnoreCase(characterEncoding.trim()) || &quot;1&quot;.equalsIgnoreCase(characterEncoding.trim()); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (enabled || characterEncoding != null) { request.setCharacterEncoding(characterEncoding); response.setCharacterEncoding(characterEncoding); } chain.doFilter(request, response); } @Override public void destroy() { characterEncoding = null; } } 配置： &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;characterEncoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;enable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; Spring mvc自带&lt;!-- 编码过滤器，UTF8编码，对POST有效 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 异常捕捉 Filterpublic class ExceptionHandlerFilter implements Filter { public void destroy() {} public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { chain.doFilter(request, response); } catch (Exception e) { Throwable rootCause = e; while (rootCause.getCause() != null) { rootCause = rootCause.getCause(); } String message = rootCause.getMessage(); message = message == null ? &quot;异常：&quot; + rootCause.getClass().getName() : message; request.setAttribute(&quot;message&quot;, message); request.setAttribute(&quot;e&quot;, e); if (rootCause instanceof AccountException) { request.getRequestDispatcher(&quot;/accountException.jsp&quot;).forward( request, response); } else if (rootCause instanceof BusinessException) { request.getRequestDispatcher(&quot;/businessException.jsp&quot;).forward( request, response); } else { request.getRequestDispatcher(&quot;/exception.jsp&quot;).forward(request, response); } } } public void init(FilterConfig arg0) throws ServletException { } } 内容替换 Filter需求：有时候需要对网站的内容进行控制，防止输出非法内容或者敏感内容解决方案： 方案一：在Servlet里输出到客户端时进行内容替换，这种方案需要对每个Servlet都进行替换，工作量大，业务耦合比较严重 方案二：在Servlet将内容输出到response时，response将内容缓存起来，在Filter中进行替换，然后再输出到客户端浏览器。但是默认的response并不能严格的缓存输出内容，因此需要自定义一个具有缓存功能的response 要点：自定义的一个response只是一个伪装的response。Servlet会通过它输出内容到客户端，但是它内部只是将内容缓存起来了（使用自己创建的PrintWriter），并没有真正输出到客户端。最终输出到客户端还是通过原来的resonse完成的 框图： 具体操作： 1、通过扩展HttpServletResponseWrapper类来实现自定义的response，该类覆盖了getWriter()方法，当Servlet使用该response对象调用getWriter()莱输出内容时，内容将被输出到CharArrayWriter对象中，达到缓存的效果 public class HttpCharacterResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter charArrayWriter = new CharArrayWriter(); public HttpCharacterResponseWrapper(HttpServletResponse response) { super(response); } @Override public PrintWriter getWriter() throws IOException { return new PrintWriter(charArrayWriter); } public CharArrayWriter getCharArrayWriter() { return charArrayWriter; } } 2、Filter将自定义的response传进Servlet中 public class OutputReplaceFilter implements Filter { private Properties pp = new Properties(); public void init(FilterConfig config) throws ServletException { String file = config.getInitParameter("file"); String realPath = config.getServletContext().getRealPath(file); try { pp.load(new FileInputStream(realPath)); } catch (IOException e) { } } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { // 自定义的 response HttpCharacterResponseWrapper response = new HttpCharacterResponseWrapper( (HttpServletResponse) res); // 提交给 Servlet 或者下一个 Filter chain.doFilter(req, response); // 得到缓存在自定义 response 中的输出内容 String output = response.getCharArrayWriter().toString(); // 修改，替换 for (Object obj : pp.keySet()) { String key = (String) obj; output = output.replace(key, pp.getProperty(key)); } // 输出 PrintWriter out = res.getWriter(); out.write(output); out.println(""); } public void destroy() { } } GZIP 压缩 FilterServlet中操作输入输出流： String path = request.getSession().getServletContext().getRealPath("/error.jpg"); InputStream inputStream = new FileInputStream(path); int len = -1; byte[] buffer = new byte[1024]; OutputStream outputStream = response.getOutputStream(); while((len = inputStream.read(buffer)) != -1){ outputStream.write(buffer,0,len); } outputStream.close(); inputStream.close(); 要点：1、替换response，并且替换的response中重写response中的getOutputStream()方法[也需要重写getWrite()，因为除了压缩二进制文件，还要压缩文本文件]2、重写ServletOutputStream，当调用write方法时，使用JDK自带的GZIPOutputStream类进行数据压缩★★★★★★★★（核心） 总体操作框图： ①自定义的GZipResponseWrapper替换tomcat传入的respone GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response); chain.doFilter(request, gzipResponse); ②Servlet中调用response中的getOutputStream()获得输出流，数据写入缓存，调用close方法进行压缩 OutputStream outputStream = response.getOutputStream(); while((len = inputStream.read(buffer)) != -1){ outputStream.write(buffer,0,len); } outputStream.close(); inputStream.close(); ③输出压缩数据 gzipResponse.finishResponse(); GZIPOutputStream类API： void finish() 完成将压缩数据写入输出流的操作，无需关闭底层流。 void write(byte[] buf, int off, int len) 将字节数组写入压缩输出流。 1、GZipFilter，如果客户端支持GZip自动解压，则进行GZIP压缩，否则不压缩 public class GZipFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; String acceptEncoding = request.getHeader("Accept-Encoding"); System.out.println("Accept-Encoding: " + acceptEncoding); if (acceptEncoding != null && acceptEncoding.toLowerCase().indexOf("gzip") != -1) { // 如果客户浏览器支持 GZIP 格式, 则使用 GZIP 压缩数据 GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response); chain.doFilter(request, gzipResponse); /* * 输出压缩数据，一般由用户在调用outputStream.close()自己关闭输出流， * 此处调用是为了防止用户忘记 */ gzipResponse.finishResponse(); } else { // 否则, 不压缩 chain.doFilter(request, response); } } public void init(FilterConfig arg0) throws ServletException { } } 2、GZipResponseWrapper伪装response，GZipOutputStream为它的成员变量，Servlet中的输出就是对GZipOutputStream的操作 GZipResponseWrapper为自定义的response类，内部将对输出的内容进行GZIP压缩。它继承HttpServletResponseWrapper，也是一个伪装的response，不真正输出内容到客户端 由于该response要处理二进制内容，又要处理字符内容，因此需要覆盖getOutputStream和getWriter GZipResponseWrapper中的方法是实现对GZipOutputStream的操作 public class GZipResponseWrapper extends HttpServletResponseWrapper { /* * 传入默认的response，保存起来作为成员变量 */ private HttpServletResponse response; /* * 可以不保存，如果用户自己关闭输入流，则无需调用finishResponse方法来关闭文本或二进制输出流。 * 但是为了增加可靠性，在response抵达客户端浏览器前进行关闭流操作 */ // 自定义的 outputStream, 执行close()的时候对数据压缩，并输出 private GZipOutputStream gzipOutputStream; // 自定义 printWriter，将内容输出到 GZipOutputStream 中 private PrintWriter writer; public GZipResponseWrapper(HttpServletResponse response) throws IOException { super(response); this.response = response; } public ServletOutputStream getOutputStream() throws IOException { if (gzipOutputStream == null) gzipOutputStream = new GZipOutputStream(response); return gzipOutputStream; } public PrintWriter getWriter() throws IOException { if (writer == null) writer = new PrintWriter(new OutputStreamWriter( new GZipOutputStream(response), "UTF-8")); return writer; } // 压缩后数据长度会发生变化 因此将该方法内容置空 public void setContentLength(int contentLength) { } public void flushBuffer() throws IOException { gzipOutputStream.flush(); } public void finishResponse() throws IOException { if (gzipOutputStream != null) gzipOutputStream.close(); if (writer != null) writer.close(); } } 3、自定义GZipOutputStream类，继承ServletOutputStream，使用JDK自带的GZIP压缩类将数据缓存起来，之后调用finish函数进行数据压缩，并输出到客户端浏览器 public class GZipOutputStream extends ServletOutputStream { private HttpServletResponse response; // JDK 自带的压缩数据的类 private GZIPOutputStream gzipOutputStream; // 将压缩后的数据存放到 ByteArrayOutputStream 对象中 private ByteArrayOutputStream byteArrayOutputStream; /* * GZipResponseWrapper中调用构造函数，创建实例，数据缓存在ByteArrayOutputStream */ public GZipOutputStream(HttpServletResponse response) throws IOException { this.response = response; byteArrayOutputStream = new ByteArrayOutputStream(); gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream); } /* * Servlet中调用write方法，将数据写入缓存 */ public void write(int b) throws IOException { gzipOutputStream.write(b); } /* * Servlet中调用close方法，并不是直接关闭输入流，而是先执行压缩操作，然后调用浏览器本身的输出流，在写入到客户端浏览器 */ public void close() throws IOException { // 压缩完毕 一定要调用该方法 gzipOutputStream.finish(); // 将压缩后的数据输出到客户端 byte[] content = byteArrayOutputStream.toByteArray(); // 设定压缩方式为 GZIP, 客户端浏览器会自动将数据解压 response.addHeader("Content-Encoding", "gzip"); response.addHeader("Content-Length", Integer.toString(content.length)); // 输出 ServletOutputStream out = response.getOutputStream(); out.write(content); out.close(); } public void flush() throws IOException { gzipOutputStream.flush(); } public void write(byte[] b, int off, int len) throws IOException { gzipOutputStream.write(b, off, len); } public void write(byte[] b) throws IOException { gzipOutputStream.write(b); } } 图像水印 Filter使用Filter在图像上动态打上一个水印LOGO，工作原理与GZIP压缩类似，先把图像数据缓存起来，然后对图像进行水印处理后输出到客户端浏览器 图像水印Filter需要自定义response与servletOutputStream 1、WaterMarkFilter，在Filter初始化参数里设置水印图片文件路径 public class WaterMarkFilter implements Filter { // 水印图片，配置在初始化参数中 private String waterMarkFile; public void init(FilterConfig config) throws ServletException { String file = config.getInitParameter("waterMarkFile"); waterMarkFile = config.getServletContext().getRealPath(file); } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; // 自定义的response WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile); chain.doFilter(request, waterMarkRes); // 打水印，输出到客户端浏览器 waterMarkRes.finishResponse(); } public void destroy() { } } 2、WaterMarkResponseWrapper继承HttpServletResponseWrapper，改写了getOutputStream方法，finishResponse方法将缓存的数据进行水印处理，并输出到客户端浏览器。水印处理的代码被封装到ImageUtil类的静态方法waterMark()中 public class WaterMarkResponseWrapper extends HttpServletResponseWrapper { // 水印图片位置 private String waterMarkFile; // 原response private HttpServletResponse response; // 自定义servletOutputStream，用于缓冲图像数据 private WaterMarkOutputStream waterMarkOutputStream; public WaterMarkResponseWrapper(HttpServletResponse response, String waterMarkFile) throws IOException { super(response); this.response = response; this.waterMarkFile = waterMarkFile; this.waterMarkOutputStream = new WaterMarkOutputStream(); } // 覆盖getOutputStream()，返回自定义的waterMarkOutputStream public ServletOutputStream getOutputStream() throws IOException { return waterMarkOutputStream; } public void flushBuffer() throws IOException { waterMarkOutputStream.flush(); } // 将图像数据打水印，并输出到客户端浏览器 public void finishResponse() throws IOException { // 原图片数据 byte[] imageData = waterMarkOutputStream.getByteArrayOutputStream() .toByteArray(); // 打水印后的图片数据 byte[] image = ImageUtil.waterMark(imageData, waterMarkFile); // 将图像输出到浏览器 response.setContentLength(image.length); response.getOutputStream().write(image); waterMarkOutputStream.close(); } } 3、WaterMarkOutputStream类将图像数据缓存起来 public class WaterMarkOutputStream extends ServletOutputStream { // 缓冲图片数据 private ByteArrayOutputStream byteArrayOutputStream; public WaterMarkOutputStream() throws IOException { byteArrayOutputStream = new ByteArrayOutputStream(); } public void write(int b) throws IOException { byteArrayOutputStream.write(b); } public void close() throws IOException { byteArrayOutputStream.close(); } public void flush() throws IOException { byteArrayOutputStream.flush(); } public void write(byte[] b, int off, int len) throws IOException { byteArrayOutputStream.write(b, off, len); } public void write(byte[] b) throws IOException { byteArrayOutputStream.write(b); } public ByteArrayOutputStream getByteArrayOutputStream() { return byteArrayOutputStream; } } 4、ImageUtil类使用JDK的图像处理类完成添加水印的操作 public class ImageUtil { /** * * @param imageData * JPG 图像文件 * @param waterMarkFile * 水印图片 * @return 加水印后的图像数据 * @throws IOException */ public static byte[] waterMark(byte[] imageData, String waterMarkFile) throws IOException { // 水印图片的右边距 下边距 int paddingRight = 10; int paddingBottom = 10; // 原始图像 Image image = new ImageIcon(imageData).getImage(); int imageWidth = image.getWidth(null); int imageHeight = image.getHeight(null); // 水印图片 Image waterMark = ImageIO.read(new File(waterMarkFile)); int waterMarkWidth = waterMark.getWidth(null); int waterMarkHeight = waterMark.getHeight(null); // 如果图片尺寸过小，则不打水印，直接返回 if (imageWidth < waterMarkWidth + 2 * paddingRight || imageHeight < waterMarkHeight + 2 * paddingBottom) { return imageData; } BufferedImage bufferedImage = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics g = bufferedImage.createGraphics(); // 绘制原始图像 g.drawImage(image, 0, 0, imageWidth, imageHeight, null); // 绘制水印图片 g.drawImage(waterMark, imageWidth - waterMarkWidth - paddingRight, imageHeight - waterMarkHeight - paddingBottom, waterMarkWidth, waterMarkHeight, null); g.dispose(); // 转成JPEG格式 ByteArrayOutputStream out = new ByteArrayOutputStream(); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out); encoder.encode(bufferedImage); byte[] data = out.toByteArray(); out.close(); return data; } } 5、配置文件 &lt;filter&gt; &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.filter.ImageRedirectFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;waterMarkFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.watermark.WaterMarkFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;waterMarkFile&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/logo.png&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 内容替换、GZIP、图像水印 Filter 总结★★★★★★以图像水印 Filter 为例 1、过滤器中自定义response包裹类，将原生response作为参数传入。自定义的response替换原生response传入Servlet；response返回客户端之前，调用新定义的finishResponse方法，输出到客户端浏览器 // 自定义的response WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile); chain.doFilter(request, waterMarkRes); // 打水印，输出到客户端浏览器 waterMarkRes.finishResponse(); 2、自定义response包裹类有一个存放原生response的成员变量，一个自定义的输出流，起到缓存数据的功能。重写getOutputStream()方法或getWriter()方法，返回自定义输出流，添加finishResponse方法，将缓存中的数据进行处理，输出到客户端浏览器 3、重写ServletOutputStream类对数据进行，对数据缓存 缓存 Filter对于访问量比较大的网站（淘宝），反复地查询数据库要消耗很多时间。如果第一次访问某页面查询了数据库，那么就可以把页面的内容缓存起来，下一次访问的时候直接返回缓存结果就行。使用缓存能将数据库读写次数较少都最少，从而提高服务器的响应速度 缓存Filter的工作流程：1、截获浏览器提交的request2、如果request为POST方式，则不进行缓存3、如果request为GET方式，且请求的页面有缓存并且缓存没有过期，则直接返回缓存结果，这样就避免读取数据库4、如果没有缓存或者缓存已过期，则重新请求Servlet，将Servlet返回的内容缓存并输出到客户端浏览器 使用缓存注意点： 1、缓存Filter不易用于数据会实时变化的数据，如报表、股票等，它适用于数据变化不大，但是访问次数多的内容，如论坛、博客、新闻等2、缓存Filter不能用于POST方式提交数据，如登录、发表文章等3、当缓存更新后，要更新缓存，或者直接将缓存删掉4、被缓存的内容不能依赖于Session，而要依赖于Cookie。即要使用Cookie来记录客户身份而不要使用Session，并且无论客户身份是管理员还是普通浏览者，Servlet输出内容都是一样的，只能在浏览器使用js根据cookie来决定显示什么内容。但是注意：由于菜单的显示与否并没有在服务器端进行权限检查，因此当客户单击链接操作的时候，一定要做权限检查，否则会引发安全问题 框图： ①如果存在缓存文件，直接缓存文件中读取数据并输出到客户端浏览器，不进入Servlet②没有缓存或缓存过期，在Servlet将输出的内容缓存起来③缓存Filter将缓存内容写入到缓存文件，并读取缓存文件将数据输出 程序流程图： 1、缓存Filter public class CacheFilter implements Filter { private ServletContext servletContext; // 缓存文件夹，使用Tomcat工作目录 private File temporalDir; // 缓存时间，配置在Filter初始化参数中 private long cacheTime = Long.MAX_VALUE; public void init(FilterConfig config) throws ServletException { temporalDir = (File) config.getServletContext().getAttribute( "javax.servlet.context.tempdir"); servletContext = config.getServletContext(); cacheTime = new Long(config.getInitParameter("cacheTime")); } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; // 如果为 POST, 则不经过缓存 if ("POST".equals(request.getMethod())) { chain.doFilter(request, response); return; } // 请求的 URI，忽略应用程序名称 String uri = request.getRequestURI(); if (uri == null) uri = ""; uri = uri.replace(request.getContextPath() + "/", ""); uri = uri.trim().length() == 0 ? "index.jsp" : uri; uri = request.getQueryString() == null ? uri : (uri + "?" + request .getQueryString()); // 对应的缓存文件 File cacheFile = new File(temporalDir, URLEncoder.encode(uri, "UTF-8")); System.out.println(cacheFile); // 如果缓存文件不存在 或者已经超出缓存时间 则请求 Servlet if (!cacheFile.exists() || cacheFile.length() == 0 || cacheFile.lastModified() < System.currentTimeMillis() - cacheTime) { CacheResponseWrapper cacheResponse = new CacheResponseWrapper( response); chain.doFilter(request, cacheResponse); // 将内容写入缓存文件 char[] content = cacheResponse.getCacheWriter().toCharArray(); temporalDir.mkdirs();//递归创建文件夹 cacheFile.createNewFile();//创建文件 Writer writer = new OutputStreamWriter(new FileOutputStream( cacheFile), "UTF-8"); writer.write(content); writer.close(); } // 请求的ContentType String mimeType = servletContext.getMimeType(request.getRequestURI()); response.setContentType(mimeType); // 读取缓存文件的内容，写入客户端浏览器 Reader ins = new InputStreamReader(new FileInputStream(cacheFile), "UTF-8"); StringBuffer buffer = new StringBuffer(); char[] cbuf = new char[1024]; int len; while ((len = ins.read(cbuf)) > -1) { buffer.append(cbuf, 0, len); } ins.close(); // 输出到客户端 response.getWriter().write(buffer.toString()); } public void destroy() { } } 2、CacheResponseWrapper强Servlet中输出的内容缓存起来，然后被缓存Filter写入到缓存文件中。本缓存Filter只缓存字符类网页，因此只覆盖了getWriter()方法 public class CacheResponseWrapper extends HttpServletResponseWrapper { // 缓存字符类输出 private CharArrayWriter cacheWriter = new CharArrayWriter(); public CacheResponseWrapper(HttpServletResponse response) throws IOException { super(response); } @Override public PrintWriter getWriter() throws IOException { return new PrintWriter(cacheWriter); } @Override public void flushBuffer() throws IOException { cacheWriter.flush(); } public void finishResponse() throws IOException { cacheWriter.close(); } public CharArrayWriter getCacheWriter() { return cacheWriter; } public void setCacheWriter(CharArrayWriter cacheWriter) { this.cacheWriter = cacheWriter; } } 3、配置 &lt;filter&gt; &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.cache.CacheFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cache&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cacheTime&lt;/param-name&gt; &lt;param-value&gt;1000000&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;/filter-mapping&gt; XSLT 转换 FilterXSLT转换时XML文件的功能之一，是利用XSLT样式文件将XML文件转换成其他格式，使用XSLT 转换 Filter，浏览器访问请求XML格式，返回浏览器时已经是转换后的HTML文件了 1、该Filter使用JDK自带的标准XML工具包进行XML格式转换。MSN的聊天记录是用XML形式保存的，浏览器访问XML格式，返回转换后的HTML文件 public class XSLTFilter implements Filter { private ServletContext servletContext; public void init(FilterConfig config) throws ServletException { servletContext = config.getServletContext(); } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; // 格式样本文件：/book.xsl Source styleSource = new StreamSource(servletContext .getRealPath(&quot;/MessageLog.xsl&quot;)); // 请求的 xml 文件 Source xmlSource = new StreamSource(servletContext.getRealPath(request .getRequestURI().replace(request.getContextPath() + &quot;&quot;, &quot;&quot;))); try { // 转换器工厂 TransformerFactory transformerFactory = TransformerFactory .newInstance(); // 转换器 Transformer transformer = transformerFactory .newTransformer(styleSource); // 将转换的结果保存到该对象中 CharArrayWriter charArrayWriter = new CharArrayWriter(); StreamResult result = new StreamResult(charArrayWriter); // 转换 transformer.transform(xmlSource, result); // 输出转换后的结果 response.setContentType(&quot;text/html&quot;); response.setContentLength(charArrayWriter.toString().length()); PrintWriter out = response.getWriter(); out.write(charArrayWriter.toString()); } catch (Exception ex) { } } public void destroy() { } } 2、配置 &lt;filter&gt; &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.helloweenvsfei.xml.XSLTFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/msn/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器 ListenerListener用于监听Java Web程序中的事件，例如创建、修改、删除Session、request、context等 Listener使用使用Listener需要实现相应的Listener接口，触发Listener事件时，Tomcat会自动调用Listener的方法 实现Listener接口创建Session服务器会调用sessionCreated()方法，销毁Session（包括sesson超时自动销毁）服务器会调用sessionDestroyed()方法 public class SessionListenerTest implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) { //Session创建时被调用 HttpSession session = httpSessionEvent.getSession(); System.out.println(&quot;创建了一个session：&quot; + session); } @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) { //销毁Session前被调用 HttpSession session = httpSessionEvent.getSession(); System.out.println(&quot;销毁了一个Session：&quot; + session); } } Listener配置&lt;listener&gt;标签一般配置在&lt;servlet&gt;前面 &lt;listener&gt; &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt; &lt;/listener&gt; Listener的分类★★★★★★监听对象的创建与销毁 HttpSessionListener：监听Session的创建与销毁。创建Session时执行sessionCreated方法，超时或执行session.invalidate()时执行sessionDestroyed方法。该Listener可以收集在线者信息 ServletContextListener：监听context的创建与销毁。context代表当前的Web应用程序，服务器启动或者热部署war包时执行contextInitialized，服务器关闭或关闭该Web时会执行contextDestroyed方法。该Listener可用于启动时读取web.xml里配置的初始化参数 ServletRequestListener：监听request的创建与销毁，用户每次请求都会执行requestInitialized方法，request处理完毕自动销毁前执行requestDestroyed。注意如果一个HTML页面包含多个图片，则一次请求可能会多次触发request事件 实例：监听Session、request、servletContext自定义监听器类同时实现HttpSessionListener、ServletContextListener、ServletRequestListener接口，使得多种监听器一块工作 public class SessionListenerTest implements HttpSessionListener, ServletContextListener, ServletRequestListener { //Log log = LogFactory.getLog(getClass()); Logger log = Logger.getLogger(SessionListenerTest.class); // 创建 session public void sessionCreated(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(&quot;新创建一个session, ID为: &quot; + session.getId()); } // 销毁 session public void sessionDestroyed(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(&quot;销毁一个session, ID为: &quot; + session.getId()); } // 加载 context public void contextInitialized(ServletContextEvent sce) { ServletContext servletContext = sce.getServletContext(); log.info(&quot;即将启动&quot; + servletContext.getContextPath()); } // 卸载 context public void contextDestroyed(ServletContextEvent sce) { ServletContext servletContext = sce.getServletContext(); log.info(&quot;即将关闭&quot; + servletContext.getContextPath()); } // 创建 request public void requestInitialized(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre .getServletRequest(); String uri = request.getRequestURI(); uri = request.getQueryString() == null ? uri : (uri + &quot;?&quot; + request .getQueryString()); request.setAttribute(&quot;dateCreated&quot;, System.currentTimeMillis()); log.info(&quot;IP &quot; + request.getRemoteAddr() + &quot; 请求 &quot; + uri); } // 销毁 request public void requestDestroyed(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre .getServletRequest(); long time = System.currentTimeMillis() - (Long) request.getAttribute(&quot;dateCreated&quot;); log.info(request.getRemoteAddr() + &quot;请求处理结束, 用时&quot; + time + &quot;毫秒. &quot;); } } 配置到web.xml &lt;listener&gt; &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt; &lt;/listener&gt; 监听对象的属性变化 另一类Listener用于监听Session、context、request的属性变化，接口名称格式为xxxAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener 当想被监听对象中添加、更新、移除属性时，会分别执行xxxAdded()、xxxReplace()、xxxRemoved()方法，xxx分别代表Session、Context、request public class SessionAttributeListenerTest implements HttpSessionAttributeListener { Log log = LogFactory.getLog(getClass()); // 添加属性 public void attributeAdded(HttpSessionBindingEvent se) { HttpSession session = se.getSession(); String name = se.getName(); log.info(&quot;新建session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue()); } // 删除属性 public void attributeRemoved(HttpSessionBindingEvent se) { HttpSession session = se.getSession(); String name = se.getName(); log.info(&quot;删除session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue()); } // 修改属性 public void attributeReplaced(HttpSessionBindingEvent se) { HttpSession session = se.getSession(); String name = se.getName(); Object oldValue = se.getValue(); log.info(&quot;修改session属性：&quot; + name + &quot;, 原值：&quot; + oldValue + &quot;, 新值：&quot; + session.getAttribute(name)); } } 监听Session内的对象除了上面的6中Listener，有两种Listener用于监听Session内的对象，分别是HttpSessionBindingListener、HttpSessionActivationListener，他们的触发时机是： HttpSessionBindingListener：当对象被放到Session里是执行valueBound方法，当对象从Session里移除时执行valueUnbound，对象必须实现该Listener接口 HttpSessionActivationListener：服务器关闭时，会将Session里的内容保存到硬盘上，这个过程叫做钝化。服务器重启时，会将Session里的内容从硬盘上重新加载，钝化时会执行sessionWillPassivate方法，对象被重新加载时执行sessionDidActivate方法，对象必须实现该Listener接口 这两个Listener监听的是Session中的对象而非Session等，因此不需要再web.xml中声明 PersonInfo对象被放进、移出Session或者启动、关闭服务器都会触发PersonInfo内的Listener时间： public class PersonInfo implements HttpSessionActivationListener, HttpSessionBindingListener, Serializable { private static final long serialVersionUID = -4780592776386225973L; Log log = LogFactory.getLog(getClass()); private String name; private Date dateCreated; public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getDateCreated() { return dateCreated; } public void setDateCreated(Date dateCreated) { this.dateCreated = dateCreated; } // 从硬盘加载后 public void sessionDidActivate(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(this + &quot;已经成功从硬盘中加载。sessionId: &quot; + session.getId()); } // 即将被钝化到硬盘时 public void sessionWillPassivate(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(this + &quot;即将保存到硬盘。sessionId: &quot; + session.getId()); } // 被放进session前 public void valueBound(HttpSessionBindingEvent event) { HttpSession session = event.getSession(); String name = event.getName(); log.info(this + &quot;被绑定到session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name + &quot;属性上&quot;); // 记录放到session中的时间 this.setDateCreated(new Date()); } // 从session中移除后 public void valueUnbound(HttpSessionBindingEvent event) { HttpSession session = event.getSession(); String name = event.getName(); log.info(this + &quot;被从session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name + &quot;属性上移除&quot;); } @Override public String toString() { return &quot;PersonInfo(&quot; + name + &quot;)&quot;; } } Listener使用案例单态登录 单态登录就是一个账号只能在一台机器上登录，如果在其他机器上登录了，则原来的登录无效 单态登录的目的是为了防止多台机器同时使用一个账号 Listener方式实现 见JavaWeb王者归来205页 思路：当成功验证用户信息，准备往session中存放用户的信息时，被监听器监听到，调用attributeAdded或attributeReplaced方法，方法中需要判断用户是否在别的机器上登录过，如果登录了则使以前的登录失效 使用这种方式Listener与登录模块没有代码耦合，部署Listener后将实现单态登录，拆掉该Listener后登录模块照常工作，只是不再保证是单态登录 public class LoginSessionListener implements HttpSessionAttributeListener { Log log = LogFactory.getLog(this.getClass()); Map map = new HashMap(); public void attributeAdded(HttpSessionBindingEvent event) { String name = event.getName(); // 登录 if (name.equals("personInfo")) { PersonInfo personInfo = (PersonInfo) event.getValue(); if (map.get(personInfo.getAccount()) != null) { // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效 HttpSession session = map.get(personInfo.getAccount()); PersonInfo oldPersonInfo = (PersonInfo) session .getAttribute("personInfo"); log.info("帐号" + oldPersonInfo.getAccount() + "在" + oldPersonInfo.getIp() + "已经登录，该登录将被迫下线。"); session.removeAttribute("personInfo"); session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。"); } // 将session以用户名为索引，放入map中 map.put(personInfo.getAccount(), event.getSession()); log.info("帐号" + personInfo.getAccount() + "在" + personInfo.getIp() + "登录。"); } } public void attributeRemoved(HttpSessionBindingEvent event) { String name = event.getName(); // 注销 if (name.equals("personInfo")) { // 将该session从map中移除 PersonInfo personInfo = (PersonInfo) event.getValue(); map.remove(personInfo.getAccount()); log.info("帐号" + personInfo.getAccount() + "注销。"); } } public void attributeReplaced(HttpSessionBindingEvent event) { String name = event.getName(); // 没有注销的情况下，用另一个帐号登录 if (name.equals("personInfo")) { // 移除旧的的登录信息 PersonInfo oldPersonInfo = (PersonInfo) event.getValue(); map.remove(oldPersonInfo.getAccount()); // 新的登录信息 PersonInfo personInfo = (PersonInfo) event.getSession() .getAttribute("personInfo"); // 也要检查新登录的帐号是否在别的机器上登录过 if (map.get(personInfo.getAccount()) != null) { // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效 HttpSession session = map.get(personInfo.getAccount()); session.removeAttribute("personInfo"); session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。"); } map.put("personInfo", event.getSession()); } } } 自己的实现 如果没有要求单态登录，成功验证用户信息后，返回客户端token，在服务器端创建session，并将用户信息存入到session，之后客户端再次访问，根据token恢复session，如果session中存放了用户信息，则用户合法，否则退回登录页面 实现单态登录，需要在验证用户信息后，判断账号是否在别的机器上登录。 具体实现：用一个HashMap存储在线用户信息，主键为用户名，键值为session。成功验证用户信息后，根据用户名获取session，如果session不为空，说明用户已经在别的机器上登录，则使sesson无效，在HashMap上移除该值，这样之前登录的用户操作前，会检查session中没有用户信息，则必须重新登录，做到强制退出的目的 图示：红框是单态登录加入的模块 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); String action = request.getParameter("action"); if("login".equalsIgnoreCase(action)){ String name = request.getParameter("name"); String password = request.getParameter("password"); User user = new User(); user.setName(name); user.setPassword(password); if("qm".equals(name) && "123".equals(password)){ //判断帐号是否在别的机器登录 HttpSession oldSession = map.get(name); if(oldSession != null){//1、别的机器登录 2、重复登录 oldSession.removeAttribute("user"); //oldSession.invalidate();不要删除session除了用户信息的其他属性，下次用户在本机登录还能获得先前的数据 map.remove(name); } HttpSession session = request.getSession(); session.setAttribute("user",user); map.put(name,session); out.println("登录成功"); }else{ out.println("登录失败"); } }else if("logout".equalsIgnoreCase(action)){ HttpSession session = request.getSession(); User user = (User) session.getAttribute("user"); if(user == null){ out.println("请先登录"); return; } //session.invalidate(); session.removeAttribute("user"); map.remove(user.getName()); out.println("注销成功"); }else if("main".equalsIgnoreCase(action)){ HttpSession session = request.getSession(); User user = (User) session.getAttribute("user"); if(user == null){ out.println("请先登录"); return; } //往session添加其他属性 Integer count = (Integer) session.getAttribute("count"); if(count == null){ count = 0; session.setAttribute("count", count); } count ++; session.setAttribute("count",count); //在线用户 out.println(session.getAttribute("count")); } } 显示在线用户存放服务器信息、用户信息的类： public class ApplicationConstants { // 所有的 Session，session_id与session组成键值对 public static Map&lt;String, HttpSession&gt; SESSION_MAP = new HashMap&lt;String, HttpSession&gt;(); // 当前登录的用户总数 public static int CURRENT_LOGIN_COUNT = 0; // 历史访客总数 public static int TOTAL_HISTORY_COUNT = 0; // 服务器启动时间 public static Date START_DATE = new Date(); // 最高在线时间 public static Date MAX_ONLINE_COUNT_DATE = new Date(); // 最高在线人数 public static int MAX_ONLINE_COUNT = 0; } 使用ServletContextListener来监听服务器的启动与关闭，记录服务器启动时间等 public class MyContextListener implements ServletContextListener { public void contextInitialized(ServletContextEvent event) { // 启动时，记录服务器启动时间 ApplicationConstants.START_DATE = new Date(); } public void contextDestroyed(ServletContextEvent event) { // 关闭时，将结果清除。也可以将结果保存到硬盘上，下次启动时再加载到ApplicationConstants中 ApplicationConstants.START_DATE = null; ApplicationConstants.MAX_ONLINE_COUNT_DATE = null; } } 对Session的监听，维护在线用户列表、总访问人数： 使用Map来索引所有的Session，Session创建的时候放到Map中，Session销毁时从Map中剔除 什么时候用户数改变？成功验证用户信息后往session中存入用户信息、用户注销、用户被强退，attributeAdded和attributeReplaced的区别就是用户人数是否需要增加 public class MySessionListener implements HttpSessionListener, HttpSessionAttributeListener { public void sessionCreated(HttpSessionEvent sessionEvent) { HttpSession session = sessionEvent.getSession(); // 将 session 放入 map ApplicationConstants.SESSION_MAP.put(session.getId(), session); // 总访问人数++ ApplicationConstants.TOTAL_HISTORY_COUNT++; // 如果当前在线人数超过历史记录，则更新最大在线人数，并记录时间 if (ApplicationConstants.SESSION_MAP.size() > ApplicationConstants.MAX_ONLINE_COUNT) { ApplicationConstants.MAX_ONLINE_COUNT = ApplicationConstants.SESSION_MAP .size(); ApplicationConstants.MAX_ONLINE_COUNT_DATE = new Date(); } } public void sessionDestroyed(HttpSessionEvent sessionEvent) { HttpSession session = sessionEvent.getSession(); // 将session从map中移除 ApplicationConstants.SESSION_MAP.remove(session.getId()); } public void attributeAdded(HttpSessionBindingEvent event) { if (event.getName().equals("personInfo")) { // 当前登录用户数++ ApplicationConstants.CURRENT_LOGIN_COUNT++; HttpSession session = event.getSession(); // 查找该帐号有没有在其他机器上登录 for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) { // 如果该帐号已经在其他机器上登录，则以前的登录失效 if (event.getValue().equals(sess.getAttribute("personInfo")) && session.getId() != sess.getId()) { sess.invalidate(); } } } } public void attributeRemoved(HttpSessionBindingEvent event) { // 注销 当前登录用户数-- if (event.getName().equals("personInfo")) { ApplicationConstants.CURRENT_LOGIN_COUNT--; } } public void attributeReplaced(HttpSessionBindingEvent event) { // 重新登录，但人数不用增加 if (event.getName().equals("personInfo")) { HttpSession session = event.getSession(); for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) { // 如果新帐号在其他机器上登录过，则以前登录失效 if (event.getValue().equals(sess.getAttribute("personInfo")) && session.getId() != sess.getId()) { sess.invalidate(); } } } } } 监听request主要是记录客户的IP地址、访问次数等，也可以记录用户访问的URI： public class MyRequestListener implements ServletRequestListener { public void requestDestroyed(ServletRequestEvent event) { } public void requestInitialized(ServletRequestEvent event) { HttpServletRequest request = (HttpServletRequest) event .getServletRequest(); /* * 如果session为空，则重新创建一个session，主要是之前session.invalidate()会销毁session */ HttpSession session = request.getSession(true); // 记录IP地址 session.setAttribute("ip", request.getRemoteAddr()); // 记录访问次数，只记录访问 .html, .do, .jsp, .action 的累计次数 String uri = request.getRequestURI(); String[] suffix = { ".html", ".do", ".jsp", ".action" }; for (int i=0; i&lt;suffix.length; i++) { if (uri.endsWith(suffix[i])) { break; } if(i == suffix.length-1) return; } Integer activeTimes = (Integer) session.getAttribute("activeTimes"); if (activeTimes == null) { activeTimes = 0; } session.setAttribute("activeTimes", activeTimes + 1); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat笔记]]></title>
      <url>%2F2016%2F07%2F06%2F%5BTomcat%5DTomcat%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Tomcat的目录结构文件 bin: 启动和关闭tomcat的bat文件 conf: 配置文件 --&gt;server.xml : 该文件用于配置和 server 相关的信息, 比如 tomcat启动端口后,配置Host, 配置Context 即web应用 --&gt;web.xml : 该文件配置与 web应用(web应用就相当于是一个 web站点) --&gt;tomcat-users.xml: 该文件用户配置tomcat 的用户密码 和 权限 lib目录: 该目录放置运行tomcat 运行需要的jar包 logs目录：存放日志, 当我们需要去查看日志的时候，很有用!,当我们启动tomcat错误时候，可以查询信息. webapps目录: 该目录下，放置我们的web应用(web 站点) work: 工作目录: 该目录用于存放jsp被访问后 生成的对应的 server文件 和.class文件 首页面设置及目录规范结构 配置访问首目录 ①在web文件夹下配置WEB-INF文件夹 ②在 web.xml 文件中添加配置的代码: &lt;welcome-file-list&gt; &lt;welcome-file&gt;hello1.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; ③通过http://localhost:8088/web1来访问hello1.html 目录结构 web-inf目录下的 classes目录将来是存放 class文件 lib 目录将来时存放 jar文件 web.xml 配置当前这个web应用的信息. Tomcat体系 理解服务、引擎、host（主机）、Web应用[Context]概念 查看Tomcat中的server.xml文件，最外面节点为Server，Service下一个节点服务&lt;Service name = &quot;Catalina&quot;&gt;，所以我们有时把Tomcat服务叫做Catalina服务。 服务下有引擎（engine）&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;，它可以管理多个主机host。 主机下有多个Web应用[Context] 与引擎并列的有连接器（connector），有支持不同类型协议（http、https等）的连接器。不同协议使用不同的连接器 配置默认主机 当我们在浏览器中输入http://127.0.0.1:8080/web应用，引擎是如何知道用户要访问那个`主机`下的web应用？答：配置一个默认主机 在tomcat/conf/server.xml 文件 &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;主机名&quot;&gt; 默认是localhost，即在webapps目录下，查找web应用 &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; 配置域名[host]步骤： (1) 在C:\WINDOWS\system32\drivers\etc 下的host文件 添加127.0.0.1 www.sina.com.cn[浏览器向Tomcat发送请求，但Tomcat认为自己不是www.sina.com，可以拒绝，所以需添加主机名] (2) 在tomcat 的server.xml文件添加主机名 &lt;Host name=&quot;www.sina.com&quot; appBase=&quot;d:\web3”&gt; &lt;Context path=&quot;/&quot; docBase=&quot;d:\web3&quot; /&gt; &lt;/Host&gt; (3) 在d:\web3 加入了一个 /WEB-INF/web.xml 把 hello2.html设为首页面 如果连端口都不希望带，则可以吧tomcat的启动端口设为80即可. (4) 重启生效 CATALINA_BASE与CATALINA_HOME的区别 CATALINA_HOME是Tomcat的安装目录，CATALINA_BASE是Tomcat的工作目录 如果我们想要运行Tomcat的多个实例，但是不想安装多个Tomcat软件副本。那么我们可以配置多个工作目录，每个运行实例独占一个工作目录，但是共享同一个安装目录 Tomcat每个运行实例需要使用自己的conf、logs、temp、webapps、work和shared目录，因此CATALINA_BASE就指向这些目录。 而其他目录主要包括了Tomcat的二进制文件和脚本，CATALINA_HOME就指向这些目录 Tomcat管理虚拟目录[context]需求 当我们把 web 应用放到 webapps目录，tomcat会自动管理，如果我们希望tomcat可以管理其它目录下的web应用? -&gt; 虚拟目录配置 假设我在d盘有一个web应用文件夹web2 步骤 1、找到server.xml文件 2、编辑host节点，在Host节点中添加Context 在server.xml中添加：&lt;Context path=&quot;/myweb2&quot; docBase=&quot;d:\web2&quot;/&gt; myweb2：是访问时输入的web名,实际取出的是web2中的资源（★★★★url与文件夹有映射关系） &quot;d:\web2&quot;：web应用文件夹在计算机中绝对路径 实际访问时输入的地址：http://localhost:8088/myweb2/hello2.html 定义上下文显式定义1、在Tomcat的conf/Catalina/localhost目录下创建一个XML文件。例如把一个commerce.xml文件放在conf/Catalina/localhost目录下，那么应用程序的上下文路径就是commerce，下面给出一个范例： &lt;Context docBase=&quot;C://apps/commerce&quot; reloadable=&quot;true&quot;/&gt; docBase是必要的属性，用来定义应用程序的位置；reloadable属性是可选的，如果值为true，一旦应用程序中Java类文件或者其他资源有增加、减少或者更新，Tomcat都会侦测到，就会重新加载应用程序 2、在Tomcat的conf/server.xml文件中添加一个Context元素[同Tomcat管理虚拟目录] &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;Context path = &quot;/commerce&quot; docBase=&quot;C:/apps/commerce&quot; reloadable=&quot;true&quot; /&gt; &lt;/Host&gt; 隐式定义通过将一个war文件或者整个应用程序复制到Tomcat的webapps目录下，就可以隐式地部署应用程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式的艺术之道笔记]]></title>
      <url>%2F2016%2F07%2F06%2F%5B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%5D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Java反射Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。 在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的newInstance()方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例 XMLUtil//工具类XMLUtil.java import javax.xml.parsers.*; import org.w3c.dom.*; import org.xml.sax.SAXException; import java.io.*; public class XMLUtil { //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean() { try { //创建DOM文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;config.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode=nl.item(0).getFirstChild(); String cName=classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; } catch(Exception e) { e.printStackTrace(); return null; } } } 文件 &lt;!— config.xml --&gt; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;config&gt; &lt;className&gt;FileLoggerFactory&lt;/className&gt; &lt;/config&gt; 第4章：集中式工厂的实现——简单工厂模式设计思想1、定义抽象产品类，将产品 公共的代码 移至抽象产品类，并在抽象产品类中声明一些 抽象方法，供不同的具体产品类来实现2、具体产品类继承抽象产品类，实现抽象类中抽象方法3、工厂类提供一个创建产品的工厂方法，根据传入参数不同创建不同具体产品的对象 类图 抽象产品类 abstract class Product { //所有产品类的公共业务方法 public void methodSame() { //公共方法的实现 } //声明抽象业务方法 public abstract void methodDiff(); } 具体产品类 class ConcreteProduct extends Product { //实现业务方法 public void methodDiff() { //业务方法的实现 } } 工厂类 class Factory { //静态工厂方法 public static Product getProduct(String arg) { Product product = null; if (arg.equalsIgnoreCase(&quot;A&quot;)) { product = new ConcreteProductA(); //初始化设置product } else if (arg.equalsIgnoreCase(&quot;B&quot;)) { product = new ConcreteProductB(); //初始化设置product } return product; } } 简单工厂模式的简化 将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中 创建对象与使用对象与一个对象相关的职责通常有3类：对象本身所具有的职责、创建对象的职责、使用对象的职责 在Java语言中，通常有以下几种创建对象的方式： 1、使用new关键字直接创建对象2、通过反射机制创建对象3、通过clone方法创建对象4、通过工厂类创建对象 第5章：多态工厂的实现——工厂方法模式简单工厂虽然简单，但存在一个很严重的问题，当系统中需要引入新产品时，由于静态工厂方法 通过传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，违背开闭原则 在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂 工厂方法模式结构图 具体产品实现抽象产品接口，具体产品和具体工厂之间一一对应 与简单工厂模式相比，工厂方式模式组重要的区别是引入了抽象工厂角色，在抽象工厂中声明工厂方法，由具体工厂类实现 客户端针对抽象工厂编程，在运行时再指定具体工厂类，不同的具体工厂可以创建不同的具体产品 具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以 负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 使用工厂方法模式设计的日志记录器 抽象产品： //日志记录器接口：抽象产品 interface Logger { public void writeLog(); } 具体产品： //数据库日志记录器：具体产品 class DatabaseLogger implements Logger { public void writeLog() { System.out.println(&quot;数据库日志记录。&quot;); } } //文件日志记录器：具体产品 class FileLogger implements Logger { public void writeLog() { System.out.println(&quot;文件日志记录。&quot;); } } 抽象工厂： //日志记录器工厂接口：抽象工厂 interface LoggerFactory { public Logger createLogger(); } 具体工厂： //数据库日志记录器工厂类：具体工厂 class DatabaseLoggerFactory implements LoggerFactory { public Logger createLogger() { //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; } } //文件日志记录器工厂类：具体工厂 class FileLoggerFactory implements LoggerFactory { public Logger createLogger() { //创建文件日志记录器对象 Logger logger = new FileLogger(); //创建文件，代码省略 return logger; } } 客户端测试: class Client { public static void main(String args[]) { LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); //可引入配置文件实现 logger = factory.createLogger(); logger.writeLog(); } } 第6章：产品族的创建——抽象工厂模式工厂方法模式中每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销，此时可以考虑将一些相关的产品组成一个”产品族”，由同一个工厂统一生产（抽象工厂中声明多个工厂方法，用于创建不同类型的产品，这些产品构成了一个产品族） 产品等级结构与产品族(1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则 抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 (2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如 海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机 位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构 抽象工厂模式结构图 在抽象工厂模式中，每一个具体的工厂都提供了 多个工厂方法 用于产生多种不同类型的产品，这些产品构成了一个产品族 抽象工厂的典型代码如下： abstract class AbstractFactory { public abstract AbstractProductA createProductA(); //工厂方法一 public abstract AbstractProductB createProductB(); //工厂方法二 …… } 具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂创建的产品对象构成了一个产品族： class ConcreteFactory1 extends AbstractFactory { //工厂方法一 public AbstractProductA createProductA() { return new ConcreteProductA1(); } //工厂方法二 public AbstractProductB createProductB() { return new ConcreteProductB1(); } …… } 完整解决方案使用抽象工厂模式来重构界面皮肤库的设计，要求同一风格的具体界面组件要一起显示，其基本结构如图所示： 总结优点： 能够保证客户端始终使用只使用同一个产品族中的产品 增加新的产品族很方便，无需修改已有系统 缺点： 增加新的等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层的代码 使用场景： 属于同一产品族的产品要在一起使用，这一约束必须在系统的设计中体现出来，例如： 1、同一操作系统下的按钮和文本，按钮和文本没有直接关系，但他们都属于某一操作系统，此时具有一个 约束条件 就是：同一个操作系统 第8章：复杂对象的组装与创建——建造者模式建造者模式是为了解决这类问题：如何一步一步地创建一个包含多个组个组成部分的复杂对象 建造者模式将包含多个组成部分的复杂对象的创建过程分离 不同具体的建造者定义了不同的创建过程 建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性 有Director的建造者模式Director类有两个作用： 隔离了客户与创建过程，客户只要与Director类进行交互 控制产品的创建过程，传入不同具体的建造者，输出产品 Builder类的作用：创建对象的各个组件 Actor：定义输出的对象类型 public class Actor { private String type; private String sex; public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getType() { return type; } public void setType(String type) { this.type = type; } @Override public String toString() { return &quot;Actor{&quot; + &quot;sex=&apos;&quot; + sex + &apos;\&apos;&apos; + &quot;, type=&apos;&quot; + type + &apos;\&apos;&apos; + &apos;}&apos;; } } AbstractActorBuilder：抽象的对象创建方法，对象的组建过程分为两步：buildtType、buildSex，然后调用getResult方法输出，组建方法需要由子类改写 public abstract class AbstractActorBuilder{ protected Actor actor = new Actor(); public abstract void buildtType(); public abstract void buildSex(); public Actor getResult() { return actor; } } HeroActorBuilder、AngelActorBuilder：定义了不同的组建过程 public class HeroActorBuilder extends AbstractActorBuilder{ @Override public void buildtType() { actor.setType(&quot;英雄&quot;); } @Override public void buildSex() { actor.setSex(&quot;男&quot;); } } public class AngelActorBuilder extends AbstractActorBuilder{ @Override public void buildtType() { actor.setType(&quot;Angle&quot;); } @Override public void buildSex() { actor.setSex(&quot;女&quot;); } } Director：导演类封装了复杂对象的组建过程，客户端只需调用contruct方法，并传入对应的组建类，就可以得到所需要创建的类 public class Director { public Actor contruct(AbstractActorBuilder builder){ builder.buildtType(); builder.buildSex(); return builder.getResult(); } } 省略DirectorAbstractActorBuilder需要承担创建复杂对象各个部分的职责，还要控制整个对象组建的顺序，但对系统的灵活性和可扩展性并没有任何影响 建议将construct方法单独封装在Director中，这样做更符合单一职责原则 public abstract class AbstractActorBuilder{ protected Actor actor = new Actor(); public abstract void buildtType(); public abstract void buildSex(); public Actor construct() { buildtType(); buildSex(); return actor; } } 钩子方法的引入通过Director类可以更加精细地控制产品的创建过程，比如说增加一类钩子方法来控制是否调用某个build方法 钩子方法的返回类型一般是boolena类型，方法名一般是isXXX（） 钩子方法定义在抽象建造类中 下面案例，定义了一个钩子方法hasType()，默认都是返回true；可以在子类中改写 public abstract class AbstractActorBuilder{ protected Actor actor = new Actor(); public abstract void buildtType(); public abstract void buildSex(); public Actor getResult() { return actor; } public boolean hasType(){ return true; } } 在Director中调用钩子方法hasType，如果返回结果是true，则调用buildType方法，否则不调用 public class Director { public Actor construct(AbstractActorBuilder builder){ if(builder.hasType()){ builder.buildtType(); } builder.buildSex(); return builder.getResult(); } } 第9章：适配器模式背景有的笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何才能让20V的笔记本电脑能够在220V的电压下工作，答案是引入一个电源适配器 适配器模式的使用场景 应用程序定义了一个接口，且已经有开发人员面向该接口进行编程，所以目标接口不能修改 代码库中有已经实现类似该接口的功能，但接口不一致（请求参数、方法名不同），为了开发效率决定重用代码库中的类 引入一个适配器类，通过适配器类来调用代码库中的接口 类图 应用程序调用适配器的方法时，适配器内部将调用适配者类的方法 适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来适配者接口和抽象目标类的接口 具体实现代码请见清单 1-4。清单 1. 客户端使用的接口 /* * 定义客户端使用的接口，与业务相关 */ public interface Target { /* * 客户端请求处理的方法 */ public void request(); } 清单 2. 被适配的对象 /* * 已经存在的接口，这个接口需要配置 */ public class Adaptee { /* * 原本存在的方法 */ public void specificRequest(){ //业务代码 } } 清单 3. 适配器实现 /* * 适配器类 */ public class Adapter implements Target{ /* * 持有需要被适配的接口对象 */ private Adaptee adaptee; /* * 构造方法，传入需要被适配的对象 * @param adaptee 需要被适配的对象 */ public Adapter(Adaptee adaptee){ this.adaptee = adaptee; } @Override public void request() { // TODO Auto-generated method stub adaptee.specificRequest(); } } 清单 4. 客户端代码 /* * 使用适配器的客户端 */ public class Client { public static void main(String[] args){ //创建需要被适配的对象 Adaptee adaptee = new Adaptee(); //创建客户端需要调用的接口对象 Target target = new Adapter(adaptee); //请求处理 target.request(); } } 电脑适配器的例子电 public interface Electricity { public void support(); } public class ElectricityImpl implements Electricity { private Integer value; public ElectricityImpl(Integer value){ this.value = value; } public void support(){ System.out.println(&quot;提供&quot;+ value +&quot;电&quot;); } } 适配器 public interface Adapter { public void transform(); } public class Adapter220To12V implements Adapter{ private Electricity electricity; public Adapter220To12V(Electricity electricity){ this.electricity = electricity; } public void transform(){ electricity.support(); System.out.println(&quot;220V电压转成12V&quot;); } } public class Adapter330To12V implements Adapter{ Electricity electricity; public Adapter330To12V(Electricity electricity){ this.electricity = electricity; } @Override public void transform() { electricity.support(); System.out.println(&quot;330V转成12V&quot;); } } 电脑 public interface Computer { public void work(); } public class ComputerImpl implements Computer{ private Adapter adapter; public ComputerImpl(Adapter adapter){ this.adapter = adapter; } public void work(){ adapter.transform(); System.out.println(&quot;电脑运行需要12v&quot;); } } 测试 public class App { public static void main(String[] args){ //电 Electricity electricity = new ElectricityImpl(220); //适配器 Adapter adapter = new Adapter220To12V(electricity); //电脑 ComputerImpl computer = new ComputerImpl(adapter); computer.work(); System.out.println(&quot;---------------------------&quot;); //电 electricity = new ElectricityImpl(330); //适配器 adapter = new Adapter330To12V(electricity); //电脑 computer = new ComputerImpl(adapter); computer.work(); } } 结果 提供220电 220V电压转成12V 电脑运行需要12v --------------------------- 提供330电 330V转成12V 电脑运行需要12v 本质面向接口编程，程序有扩展性和灵活性 缺省适配器模式当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并未接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称单接口适配器模式 第12章：扩展系统功能——装饰模式http://blog.csdn.net/lovelion/article/details/7425873 根据合成复用的原则，在实现功能复用的时候，要多用关联，少用继承 装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系 装饰模式结构图 1、可以将一个具体构件注入装饰器类，再通过具体装饰类进行装饰2、可以将一个已经装饰过Decorator子类的对象再注入其中进行多次装饰，从而对原有功能进行多次扩展 客户端调用： Component c = new ConcreteComponent(); Component component = new ConcreteDecoratorA(c); component.operation(); 只有一个具体构建类的装饰模式 优点 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加 可以对一个对象进行多次装饰，采用继承的方式在单继承语言中无法复用多个父类的功能 课后题Sunny软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高 级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加 密。试使用装饰模式设计该多重加密系统。 类图： 抽象构件类 /** * 抽象构件类&lt;br&gt; * 加密字符串抽象类 * */ public abstract class StrEncrypt { /** * 加密字符串 * * @param str 需要加密的字符串 * @return String 加密后的字符串 */ public abstract String encryptStr(String str); } 具体构件类 /** * 具体构件类&lt;br&gt; * 加密字符串实现类 * */ public class StrEncryptOperate extends StrEncrypt { @Override public String encryptStr(String str) { String encrypt = &quot;**&quot; + str + &quot;**&quot;; return encrypt; } } 抽象装饰类 /** * 抽象装饰类&lt;br&gt; * 加密字符串抽象装饰类 * */ public class StrEncryptDecorator extends StrEncrypt { private StrEncrypt strEncrypt; public StrEncryptDecorator(StrEncrypt strEncrypt){ this.strEncrypt = strEncrypt; } @Override public String encryptStr(String str) { return strEncrypt.encryptStr(str); } } 具体装饰类 - 逆向加密字符串 /** * 具体装饰类&lt;br&gt; * 逆向加密字符串实现类 * */ public class ReverseEncryptDecorator extends StrEncryptDecorator { public ReverseEncryptDecorator(StrEncrypt strEncrypt) { super(strEncrypt); } @Override public String encryptStr(String str) { return this.reverseStr(super.encryptStr(str)); } /** * 逆向加密字符串 * * @param str 需要加密的字符串 * @return String 加密后的字符串 */ public String reverseStr(String str){ String encrypt = &quot;$$&quot; + str + &quot;$$&quot;; return encrypt; } } 具体装饰类 - 高级加密字符串 /** * 具体装饰类&lt;br&gt; * 高级加密字符串实现类 * */ public class AdvanceEncryptDecorator extends StrEncryptDecorator { public AdvanceEncryptDecorator(StrEncrypt strEncrypt) { super(strEncrypt); } @Override public String encryptStr(String str) { return this.advanceStr(super.encryptStr(str)); } /** * 高级加密字符串 * * @param str 需要加密的字符串 * @return String 加密后的字符串 */ public String advanceStr(String str){ String encrypt = &quot;&amp;&amp;&quot; + str + &quot;&amp;&amp;&quot;; return encrypt; } } 测试 public class Test { public static void main(String[] args) { String str = &quot;aa&quot;; //加密字符串 StrEncrypt strEncrypt = new StrEncryptOperate(); //逆向加密 StrEncrypt reverse = new ReverseEncryptDecorator(strEncrypt); //高级加密 StrEncrypt advance = new AdvanceEncryptDecorator(reverse); System.out.println(advance.encryptStr(str)); } } 执行结果：&amp;&amp;$$aa$$&amp;&amp; 第13章：提供统一入口——外观模式有时候客户端需要与多个子系统进行复杂的交互，而增加一个外观角色后，客户端只需要直接与外观角色交互，客户端与子系统之间原有的复杂关系由外观角色来实现，从而降低了系统的耦合度 总结： 外观模式通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便 外观模式并不给系统增加任何新功能，它的作用就是简化调用接口 第15章：代理模式客户端使用对象时，返回这个对象的代理对象，这个代理对象控制对原对象的引用，对于客户端的使用是透明的 实现步骤 1、定义接口Subject public interface Subject { public void request(); } 2、实现接口 public class Proxy implements Subject{ public void request() { } } public class RealSubject implements Subject{ public void request() { System.out.println(&quot;处理请求&quot;); } } 3、代理类中存放目标类的实例，并且添加新的方法、调用目标类的方法 public class Proxy implements Subject{ private RealSubject realSubject; public Proxy(RealSubject realSubject){ this.realSubject = realSubject; } public void request() { preRequest(); realSubject.request(); postRequest(); } private void postRequest() { System.out.println(&quot;记录时间&quot;); } private void preRequest() { System.out.println(&quot;日志记录&quot;); } } 4、测试 public class Run { public static void main(String[] args){ RealSubject realSubject = new RealSubject(); Subject proxy = new Proxy(realSubject); proxy.request(); } } 结果： 日志记录 处理请求 记录时间 在不增加目标类的情况下，扩展了方法 Java 动态代理 通常情况下，代理类所实现的接口和所代理的方法都被固定，这种代理称之为 静态代理 静态代理若需要对不同目标对象进行代理，或者对同一目标类代理不同的方法，都需要增加新的代理类，这就造成类的个数急剧增加 动态代理可以让一个类 代理多个不同的目标类，而且可以 代理不同的方法 步骤1、调用处理函数程序类，传入目标对象、调用目标函数的方法、扩展方法 class SubjectHandler implements InvocationHandler{ //目标类的引用 private Object target; public SubjectHandler(Object target){ this.target = target; } /* * 调用代理对象的方法时，调用此方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { preHandler(); Object o = method.invoke(target, args); postHandler(); return o; } private void postHandler() { System.out.println(&quot;后置方法&quot;); } private void preHandler() { System.out.println(&quot;前置方法&quot;); } } 2、创建动态代理 public class Client { public static void main(String[] args){ //目标类 RealSubject realSubject = new RealSubject(); //调用处理处理程序 InvocationHandler invocationHandler = new SubjectHandler(realSubject); /** 创建代理类的实例 * 第一个参数表示代理类的类加载器 * 第二个参数表示代理类所实现的接口列表 * 第三个参数为调用处理程序类，可以是new Class[]{Subject.class}， * 也可以 RealSubject.class.getInterfaces() */ Subject proxy = (Subject) Proxy.newProxyInstance(Client.class.getClassLoader(), new Class[]{Subject.class},invocationHandler); proxy.request(); } } 为什么这么设计1、动态代理需要 代理不同的目标对象 和 同一目标对象的不同方法，所以动态代理类中需要传入代理方法（接口）和代理对象2、在Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)方法中直接传入接口，和InvocationHandler的实例，其中实例中传入目标对象，和调用处理方法，根据要求对不同方法进行代理 其他的代理类型1、远程代理：位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机，也可以在另一台主机中。在Java语言中，可以通过RMI机制来实现远程代理 2、虚拟代理：如果需要创建一个资源消耗较大的资源，先创建一个消耗相对较小的对象来表示，真是对象只是在需要时才会被真正创建。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象 第22章：对象间的联动——观察者模式观察者模式定义对象之间的一种一对多依赖关系，使得 当一个对对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新 在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者 观察者模式示意代码定义一个抽象目标Subject import java.util.*; abstract class Subject { //定义一个观察者集合用于存储所有观察者对象 protected ArrayList observers&lt;Observer&gt; = new ArrayList(); //注册方法，用于向观察者集合中增加一个观察者 public void attach(Observer observer) { observers.add(observer); } //注销方法，用于在观察者集合中删除一个观察者 public void detach(Observer observer) { observers.remove(observer); } //声明抽象通知方法 public abstract void notify(); } 具体目标类ConcreteSubject（如果无须扩展目标类，则具体目标类可省略） class ConcreteSubject extends Subject { //实现通知方法 public void notify() { //遍历观察者集合，调用每一个观察者的响应方法 for(Object obs:observers) { ((Observer)obs).update(); } } } 抽象观察者角色一般定义为一个接口，通常只声明一个update()方法 interface Observer { //声明响应方法 public void update(); } 具体观察者ConcreteObserver中实现了update()方法 class ConcreteObserver implements Observer { //实现响应方法 public void update() { //具体响应代码 } } 多人联机对战游戏结构图 抽象观察类 interface Observer { public String getName(); public void setName(String name); public void help(); //声明支援盟友方法 public void beAttacked(AllyControlCenter acc); //声明遭受攻击方法 } 战队成员类：具体观察者类 class Player implements Observer { private String name; public Player(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } //支援盟友方法的实现 public void help() { System.out.println(&quot;坚持住，&quot; + this.name + &quot;来救你！&quot;); } //遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver()来通知盟友 public void beAttacked(AllyControlCenter acc) { System.out.println(this.name + &quot;被攻击！&quot;); acc.notifyObserver(name); } } 战队控制中心类：目标类 abstract class AllyControlCenter { protected String allyName; //战队名称 protected ArrayList&lt;Observer&gt; players = new ArrayList&lt;Observer&gt;(); //定义一个集合用于存储战队成员 public void setAllyName(String allyName) { this.allyName = allyName; } public String getAllyName() { return this.allyName; } //注册方法 public void join(Observer obs) { System.out.println(obs.getName() + &quot;加入&quot; + this.allyName + &quot;战队！&quot;); players.add(obs); } //注销方法 public void quit(Observer obs) { System.out.println(obs.getName() + &quot;退出&quot; + this.allyName + &quot;战队！&quot;); players.remove(obs); } //声明抽象通知方法 public abstract void notifyObserver(String name); } 具体战队控制中心类：具体目标类 class ConcreteAllyControlCenter extends AllyControlCenter { public ConcreteAllyControlCenter(String allyName) { System.out.println(allyName + &quot;战队组建成功！&quot;); System.out.println(&quot;----------------------------&quot;); this.allyName = allyName; } //实现通知方法 public void notifyObserver(String name) { System.out.println(this.allyName + &quot;战队紧急通知，盟友&quot; + name + &quot;遭受敌人攻击！&quot;); //遍历观察者集合，调用每一个盟友（自己除外）的支援方法 for(Object obs : players) { if (!((Observer)obs).getName().equalsIgnoreCase(name)) { ((Observer)obs).help(); } } } } 编写如下客户端测试代码： class Client { public static void main(String args[]) { //定义观察目标对象 AllyControlCenter acc; acc = new ConcreteAllyControlCenter(&quot;金庸群侠&quot;); //定义四个观察者对象 Observer player1,player2,player3,player4; player1 = new Player(&quot;杨过&quot;); acc.join(player1); player2 = new Player(&quot;令狐冲&quot;); acc.join(player2); player3 = new Player(&quot;张无忌&quot;); acc.join(player3); player4 = new Player(&quot;段誉&quot;); acc.join(player4); //某成员遭受攻击 Player1.beAttacked(acc); } } JDK对观察者模式的支持 (1)Observer接口在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示： void update(Observable o, Object arg); 当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。 (2)Observable类java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象 实例： 观察者： public class Listener implements Observer { @Override public void update(Observable o, Object arg) { System.out.println(&quot;update&quot;); } } 观察目标： public class Source extends Observable { public void fire(){ setChanged(); notifyObservers(); } } 测试： public class APP { public static void main(String[] args){ Observer listener = new Listener(); Source source = new Source(); source.addObserver(listener); source.fire(); } } ThreadLocal设计模式https://my.oschina.net/pingpangkuangmo/blog/376321 ThreadLocal设计模式：（1）ThreadLocal所操作的数据是线程间不共享的。它不是用来解决多个线程竞争同一资源的多线程问题（2）ThreadLocal所操作的数据主要用于线程内共享数据，可以避免同一线程内函数间的传参数问题 ThreadLocal更像是一个操作线程数据的工具类，哪个线程调用它，它就操作哪个线程的数据。 其中ThreadUtil就是用ThreadLocal来实现的，ThreadLocal完全可以这样理解，它就是操作线程数据的工具类，哪个线程调用它的get或set方法，它就会操作调用它的线程中的数据如下： public class ThreadUtil { private static ThreadLocal&lt;String&gt; nameLocal=new ThreadLocal&lt;String&gt;(); public static String getName(){ return nameLocal.get(); } public static void setName(String name){ nameLocal.set(name); } }]]></content>
    </entry>

    
  
  
</search>
