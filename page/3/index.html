<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>


  <title> Mr.Qian's Home </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Qian's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/11/[mybatis]mybatis笔记/" itemprop="url">
                  mybatis笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-11T00:00:00+08:00" content="2016-08-11">
              2016-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mybatis/" itemprop="url" rel="index">
                    <span itemprop="name">mybatis</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h2><h3 id="JDBC连接数据库分为六步"><a href="#JDBC连接数据库分为六步" class="headerlink" title="JDBC连接数据库分为六步"></a>JDBC连接数据库分为六步</h3><pre><code>1. 加载驱动
2. 创建连接
3. 获取statement对象
4. 执行sql语句
5. 处理结果集
6. 关闭资源
</code></pre><p><img src="http://i.imgur.com/I20xxTm.png" alt=""></p>
<h3 id="存在的问题及解决方案"><a href="#存在的问题及解决方案" class="headerlink" title="存在的问题及解决方案"></a>存在的问题及解决方案</h3><pre><code>1、加载驱动问题：
　　● 每次执行都加载驱动
　　● 驱动名称，硬编码到java代码中，如果需要修改驱动，需要修改java文件
        —— 解决方案：将驱动名称放入到外部的配置文件
2、数据库的连接信息，硬编码到java代码中
        —— 解决方案：外部配置文件
3、sql语句设置参数的问题： 参数下标硬编码了，需要人为的去判断参数的位置
4、遍历结果集：需要人工的判断字段名，以及个位置参数类型，不方便
        —— 是否可以将结果集直接映射到一个pojo对象中
5、频繁的创建连接，关闭连接，导致资源浪费，影响性能
        —— 解决：连接池。
</code></pre><h2 id="mybatis介绍★★"><a href="#mybatis介绍★★" class="headerlink" title="mybatis介绍★★"></a>mybatis介绍★★</h2><p><img src="http://i.imgur.com/rupfMQb.png" alt="xxxx"></p>
<ul>
<li>mybatis的前身是ibatis，改名后将版本升级为3.X</li>
<li>Mybatis是类似Hiberate的 <strong><em>ORM框架</em></strong>，位于<strong><em>持久层</em></strong></li>
<li>Mybatis是直接<strong><em>基于JDBC做了简单的封装</em></strong>，性能角度来看JDBC &gt; mybatis &gt; Hiberate</li>
</ul>
<h2 id="mybatis整体架构"><a href="#mybatis整体架构" class="headerlink" title="mybatis整体架构"></a>mybatis整体架构</h2><p><img src="http://i.imgur.com/pHNaWys.png" alt="xxxx"></p>
<ul>
<li>mybatis-config.xml全局配置文件，包括数据库的连接参数、全局配置项</li>
<li>mapper.xml有多个，配置sql语句</li>
<li>SqlSessionFactory创建SqlSession</li>
<li>SqlSession执行crud操作</li>
<li>executor底层的执行器</li>
<li>Mappered Statement为一个个的sql语句</li>
</ul>
<h2 id="mybatis快速入门-参考官方文档-★★★★★"><a href="#mybatis快速入门-参考官方文档-★★★★★" class="headerlink" title="mybatis快速入门(参考官方文档)★★★★★"></a>mybatis快速入门(参考官方文档)★★★★★</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/MybatisStudy" target="_blank" rel="external">https://github.com/rhapsody1290/MybatisStudy</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>想要使用 MyBatis 只需将 mybatis-x.x.x.jar 文件置于 classpath 中</li>
<li>如果使用 Maven 构建项目，则需将下面的 dependency 置于 pom.xml 中  </li>
</ul>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;3.2.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h3><ul>
<li>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的</li>
<li><strong>SqlSessionFactory</strong> 的实例可以通过 <strong>SqlSessionFactoryBuilder</strong> 获得</li>
<li>SqlSessionFactoryBuilder 可以从 <strong>XML 配置文件</strong>或<strong>一个预先定制的 Configuration 的实例</strong>构建出 SqlSessionFactory 的实例（直接从Java程序中创建配置）</li>
</ul>
<p><strong><em>从XML配置文件创建SqlSessionFactory实例</em></strong></p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的 InputStream 实例，包括字符串形式或 URL 形式的文件路径来配置。MyBatis 包含一个叫 Resources 的工具类，它包含一些静态方法，可使从 classpath 或其他位置加载资源文件更容易。</p>
<pre><code>String resource = &quot;mybatis-config.xml&quot;;//指定配置文件的路径
InputStream inputStream = Resources.getResourceAsStream(resource);//默认会从classes目录下寻找配置文件
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</code></pre><p><strong><em>mybatis-config.xml——XML配置文件核心设置</em></strong></p>
<p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的<strong><em>核心设置</em></strong> ，包含<strong><em>获取数据库连接实例的数据源</em></strong>（DataSource）和<strong><em>决定事务范围和控制方式的事务管理器</em></strong>（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：</p>
<pre><code>&lt;!-- mybatis-config.xml --&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
  &lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
      &lt;transactionManager type=&quot;JDBC&quot;/&gt;
      &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
      &lt;/dataSource&gt;
    &lt;/environment&gt;
  &lt;/environments&gt;
  &lt;mappers&gt;
    &lt;mapper resource=&quot;mapper.xml&quot;/&gt;
  &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><font color="red">注意：上述配置文件采用了Property文件注入的方式，这里为了方便，我们可以直接写死连接数据库的参数</font>

<p><img src="http://img.blog.csdn.net/20160802171100530" alt=""></p>
<p>当然，XML 配置文件中还有很多可以配置的，上面的示例指出的则是<strong><em>最关键的部分</em></strong>。要注意 XML 头部的声明，需要用来验证 XML 文档正确性。</p>
<ul>
<li>environment 元素体中包含了事务管理和连接池的环境配置</li>
<li>mappers 元素是包含一组 mapper 映射器（这些 mapper的 XML 文件包含了 SQL 代码和映射定义信息）</li>
</ul>
<h3 id="mapper-xml——映射文件"><a href="#mapper-xml——映射文件" class="headerlink" title="mapper.xml——映射文件"></a>mapper.xml——映射文件</h3><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心</p>
<pre><code>&lt;!-- mapper.xml --&gt;    
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可--&gt;
&lt;mapper namespace=&quot;cn.apeius.User&quot;&gt;
    &lt;!--sql语句映射，也称作mapperedStatement
        resultType：结果集对应的java类型，需要书写类的全路径
        #{id}：相当于？，表示参数的占位--&gt;
    &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt;
        select * from tb_user where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><h3 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h3><p>SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</p>
<pre><code>//获取sqlsession
SqlSession session = sqlSessionFactory.openSession();
try {
    //sqlSession.selectOne(&quot;sql的id&quot;,&quot;sql中需要的参数&quot;)
    User user = (User) session.selectOne(&quot;cn.apeius.User.selectUser&quot;, 1);
    System.out.println(user);
} finally {
    //关闭session
    session.close();
}
</code></pre><h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><p><img src="http://i.imgur.com/X0igqa5.png" alt=""></p>
<p>问题原因：mybatis没有引入 mapper ，需要在 mybatis-config.xml 中使用mapper引入外部的mapper.xml</p>
<h3 id="mybatis使用步骤总结"><a href="#mybatis使用步骤总结" class="headerlink" title="mybatis使用步骤总结"></a>mybatis使用步骤总结</h3><p><img src="http://i.imgur.com/9XiuQMK.png" alt=""></p>
<p><strong><em>java代码</em></strong><br><img src="http://i.imgur.com/hURwgDx.png" alt=""></p>
<h2 id="添加日志支持"><a href="#添加日志支持" class="headerlink" title="添加日志支持"></a>添加日志支持</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><p><strong><em>log4j.properties</em></strong></p>
<pre><code>log4j.rootLogger=DEBUG,A1
log4j.logger.org.mybatis=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
</code></pre><h2 id="完整的CRUD操作-未使用动态代理类-★★★★★"><a href="#完整的CRUD操作-未使用动态代理类-★★★★★" class="headerlink" title="完整的CRUD操作(未使用动态代理类)★★★★★"></a>完整的CRUD操作(未使用动态代理类)★★★★★</h2><h3 id="创建UserDao接口"><a href="#创建UserDao接口" class="headerlink" title="创建UserDao接口"></a>创建UserDao接口</h3><pre><code>public interface UserDao {
    /**
     * 根据id查询用户信息
     * @param id
     * @return
     */
    public User queryUserById(Long id);
    /**
     * 查询所有用户
     * @return
     */
    public List&lt;User&gt; queryAllUser();
    /**
     * 添加用户信息
     * @param user
     */
    public void addUser(User user);
    /**
     * 修改用户信息
     * @param user
     */
    public void updateUser(User user);
    /**
     * 根据id删除用户信息
     * @param id
     */
    public void deleteUserById(Long id);
}
</code></pre><h3 id="创建UserDao的实现类"><a href="#创建UserDao的实现类" class="headerlink" title="创建UserDao的实现类"></a>创建UserDao的实现类</h3><pre><code>public class UserDaoImpl implements UserDao {
    private SqlSession sqlSession;
    public UserDaoImpl(SqlSession sqlSession){
        this.sqlSession = sqlSession;
    }
    public User queryUserById(Long id) {
        return sqlSession.selectOne(&quot;user.queryUserById&quot;, id);
    }

    public List&lt;User&gt; queryAllUser() {
        return sqlSession.selectList(&quot;user.queryAllUser&quot;);
    }

    public void addUser(User user) {
        sqlSession.insert(&quot;user.addUser&quot;, user);
    }

    public void updateUser(User user) {
        sqlSession.update(&quot;user.updateUser&quot;, user);
    }

    public void deleteUserById(Long id) {
        sqlSession.delete(&quot;user.deleteUserById&quot;, id);
    }
}
</code></pre><h3 id="编写User对应的Mapper-xml"><a href="#编写User对应的Mapper-xml" class="headerlink" title="编写User对应的Mapper.xml"></a>编写User对应的Mapper.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--
    1、namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可
    2、但为了与Mapper接口进行映射，一般为Mapper接口的完全限定名
    --&gt;
&lt;mapper namespace=&quot;cn.apeius.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryUserById&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt;
        select * from tb_user where id = #{id}
    &lt;/select&gt;

    &lt;!-- resultType为结果集映射的java的类型 --&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt;
        select * from tb_user
    &lt;/select&gt;

    &lt;!-- #{}中的值为domain类中的属性名 --&gt;
    &lt;insert id=&quot;addUser&quot;&gt;
        INSERT INTO tb_user VALUES (NULL,#{user_name},#{password},#{name},#{age},#{sex},#{birthday},NOW(),NOW())
    &lt;/insert&gt;

    &lt;update id=&quot;updateUser&quot;&gt;
        UPDATE tb_user SET user_name = #{user_name},password = #{password},name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday}, updated = NOW() WHERE id=#{id}
    &lt;/update&gt;

    &lt;delete id=&quot;deleteUserById&quot;&gt;
        delete from tb_user where id = #{id}
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre><h3 id="全部配置文件mybatis-config-xml加入UserMapper-xml"><a href="#全部配置文件mybatis-config-xml加入UserMapper-xml" class="headerlink" title="全部配置文件mybatis-config.xml加入UserMapper.xml"></a>全部配置文件mybatis-config.xml加入UserMapper.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><h3 id="编写测试用例JUNIT★★★★★★★"><a href="#编写测试用例JUNIT★★★★★★★" class="headerlink" title="编写测试用例JUNIT★★★★★★★"></a>编写测试用例JUNIT★★★★★★★</h3><ul>
<li>在UserDao接口中按快捷键Ctrl + Shift + T，快速创建UserDaoTest测试类</li>
<li>add/update/delete需要commit</li>
</ul>
<pre><code>public class UserDaoTest {
    UserDao userDao;
    SqlSession sqlSession;

    //初始操作        
    @Before
    public void setUp() throws Exception {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream is = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        sqlSession = sqlSessionFactory.openSession();
        this.userDao = new UserDaoImpl(sqlSession);
    }

    @After
    public void tearDown() throws Exception{
        sqlSession.close();
    }

    @Test
    public void testQueryUserById() throws Exception {
        User user = userDao.queryUserById(1l);
        System.out.println(user);
    }

    @Test
    public void testQueryAllUser() throws Exception {
        List&lt;User&gt; users = userDao.queryAllUser();
        for(User user : users){
            System.out.println(user);
        }
    }

    @Test
    public void testAddUser() throws Exception {
        User user = new User();
        user.setName(&quot;xxx&quot;);
        user.setAge(18);
        user.setSex(1);
        user.setPassword(&quot;123456&quot;);
        user.setUser_name(&quot;xxxx&quot;);
        user.setBirthday(new Date());
        userDao.addUser(user);
        //需要事务进行提交
        sqlSession.commit();
    }

    @Test
    public void testUpdateUser() throws Exception {
        //先查询再更新
        User user = userDao.queryUserById(15l);
        user.setUser_name(&quot;二舅&quot;);
        userDao.updateUser(user);
        sqlSession.commit();
    }

    @Test
    public void testDeleteUserById() throws Exception {
        userDao.deleteUserById(17l);
        sqlSession.commit();
    }
}
</code></pre><h3 id="解决数据库字段名和实体类属性名不一致的问题"><a href="#解决数据库字段名和实体类属性名不一致的问题" class="headerlink" title="解决数据库字段名和实体类属性名不一致的问题"></a>解决数据库字段名和实体类属性名不一致的问题</h3><p>查询数据的时候，查不到userName的信息，原因：数据库的字段名是<strong><em>user_name</em></strong>，POJO中的属性名字是<strong><em>username</em></strong>，两端不一致，造成mybatis无法填充对应的字段信息</p>
<ul>
<li>解决方案1：在sql语句中使用别名</li>
</ul>
<p><img src="http://i.imgur.com/lGbkLOR.png" alt=""></p>
<p><img src="http://i.imgur.com/Ch9AR6z.png" alt=""></p>
<ul>
<li>解决方案2： 参考后面的resultMap –mapper具体的配置的时候</li>
<li>解决方案3：参考驼峰匹配 — mybatis-config.xml 的时候</li>
</ul>
<h2 id="动态代理mapper实现类★★★★★★★"><a href="#动态代理mapper实现类★★★★★★★" class="headerlink" title="动态代理mapper实现类★★★★★★★"></a>动态代理mapper实现类★★★★★★★</h2><h3 id="思考CURD的dao中的问题"><a href="#思考CURD的dao中的问题" class="headerlink" title="思考CURD的dao中的问题"></a>思考CURD的dao中的问题</h3><p><img src="http://i.imgur.com/dokD9Lz.png" alt=""></p>
<p>1、上述开发过程为：接口-&gt;实现类-&gt;mapper.xml<br>2、可以发现在实现类中，使用mybatis的方式非常类似<br>　　●  查询 —— selectOne/selectList<br>　　●  查询 —— insert<br>　　●  修改 —— update<br>　　●  删除 —— delete<br>3、sql statement 硬编码到java代码中（举例，函数参数user.queryUserById与mapper.xml中id=”queryUserById对应”）</p>
<p><strong>思考：能否只写接口，不书写实现类，只编写Mapper.xml即可</strong></p>
<p>答：因为在dao（mapper）的实现类中对sqlsession的使用方式很类似，mybatis提供了接口的动态代理</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><ul>
<li>mapper.xml 根标签的 namespace 属性 称为名称空间。namespace的定义本身是没有限制的，只要不重复就行</li>
<li>如果希望使用mybatis通过的动态代理的接口，就需要namespace中的值，和需要对应的Mapper(dao)接口的全路径一致</li>
</ul>
<p><img src="http://i.imgur.com/1CDRzor.png" alt=""></p>
<h3 id="通过sqlSession-getMapper-Class"><a href="#通过sqlSession-getMapper-Class" class="headerlink" title="通过sqlSession.getMapper(Class)"></a>通过sqlSession.getMapper(Class)</h3><ul>
<li><p>在mybatis中，dao层的命名规则，以后都修改成*mapper<br><img src="http://i.imgur.com/vUHzBKf.png" alt=""></p>
</li>
<li><p>要求mapper中的statement,sql中的id 和方法中的名字一模一样才可以去调用<br><img src="http://i.imgur.com/StHBgCi.png" alt=""></p>
</li>
</ul>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><pre><code>package cn.apeius.mybatis.mapper;

public interface UserMapper {
    /**
     * 根据id查询用户信息
     * @param id
     * @return
     */
    public User queryUserById(Long id);
}
</code></pre><h4 id="编写mapper-xml文件"><a href="#编写mapper-xml文件" class="headerlink" title="编写mapper.xml文件"></a>编写mapper.xml文件</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace：名字空间，唯一标识，不需要特别的起名称，只要保证所有的mapper中唯一即可--&gt;
&lt;mapper namespace=&quot;cn.apeius.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryUserById&quot; resultType=&quot;cn.apeius.mybatis.domain.User&quot;&gt;
        select * from tb_user where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><pre><code>public class UserMapperTest {
    UserMapper userMapper;
    SqlSession sqlSession;

    @Before
    public void setUp() throws Exception {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream is = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        this.sqlSession = sqlSessionFactory.openSession();
        //this.userMapper = new UserDaoImpl(sqlSession);
        this.userMapper = sqlSession.getMapper(UserMapper.class);
    }

    @Test
    public void testQueryUserById() throws Exception {
        User user = userMapper.queryUserById(1l);
        System.out.println(user);
    }
}
</code></pre><h3 id="使用动态代理总结★★★★★★★★★"><a href="#使用动态代理总结★★★★★★★★★" class="headerlink" title="使用动态代理总结★★★★★★★★★"></a>使用动态代理总结★★★★★★★★★</h3><p><img src="http://i.imgur.com/k8rtmcd.png" alt=""></p>
<ul>
<li><p>在名字空间”cn.apeius.mybatis.mapper.UserMapper”定义了一个名为”queryUserById”的映射语句，这样它就允许使用指定的完全限定名”cn.apeius.mybatis.mapper.UserMapper.queryUserById”来调用映射语句</p>
<pre><code>User user = sqlSession.selectOne(&quot;cn.apeius.mybatis.mapper.UserMapper.queryUserById&quot;,1L);
System.out.println(user);
</code></pre></li>
<li><p>这和使用完全限定名调用Java对象的方法是相似的，这样命名可以直接映射到命名空间同名的Mapper类，并将select语句中的名字、参数和返回类型映射成Mapper类的方法，这样可以调用对应Mapper接口的方法</p>
<pre><code>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User user = userMapper.queryUserById(1L);
System.out.println(user);
</code></pre></li>
<li><p><strong><em>综上所述：namespace与Mapper接口映射，sql语句与mapper接口中的方法映射</em></strong></p>
</li>
<li><strong><em>一张表对应一个Doamin对象，一个Mapper接口（DAO），一个mapper.xml</em></strong>。例如user表对应User.java、UserMapper.java、UserMapper.xml</li>
</ul>
<h2 id="mybatis-config-xml-配置"><a href="#mybatis-config-xml-配置" class="headerlink" title="mybatis-config.xml 配置"></a>mybatis-config.xml 配置</h2><p>子标签出现的顺序不能改变</p>
<p><img src="http://i.imgur.com/q6iBImX.png" alt=""></p>
<h3 id="properties-读取外部的资源文件"><a href="#properties-读取外部的资源文件" class="headerlink" title="properties(读取外部的资源文件)"></a>properties(读取外部的资源文件)</h3><p><img src="http://i.imgur.com/So9Ptdk.png" alt=""></p>
<p><strong><em>编写jdbc.properties文件</em></strong></p>
<pre><code>driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis
username=root
password=root
</code></pre><p><strong><em>mybatis-config.xml属性值注入</em></strong></p>
<pre><code>&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre><h3 id="settings（设置）"><a href="#settings（设置）" class="headerlink" title="settings（设置）"></a>settings（设置）</h3><p><strong><em>mapUnderscoreToCamelCase用法：</em></strong></p>
<ul>
<li>开启驼峰匹配：从经典数据库的命名规则，到经典java命名规则的映射</li>
<li>经典数据库的命名规则： 多个单词之间使用下划线分割，例如：user_name</li>
<li>java经典命名规则：驼峰样式，多个单词，后续的单词首字母大写 例如：userName</li>
<li>开启驼峰匹配：相当于去掉数据库名字中的下划线，然后在与java中的属性名进行对应</li>
</ul>
<p><img src="http://i.imgur.com/GKLEVn7.png" alt=""></p>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><p>类型别名是为 Java 类型命名的一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余</p>
<p><strong><em>typeAliases的使用1</em></strong></p>
<ul>
<li>使用这个配置，”User”可以用在任何使用”cn.apeius.mybatis.domain.User”的地方</li>
<li><strong><em>大小写不敏感</em></strong></li>
<li>缺点：每个一个类都去书写别名，麻烦</li>
</ul>
<p><img src="http://i.imgur.com/PLq7JS8.png" alt=""></p>
<p><strong><em>typeAliases的使用2——扫描包的方式</em></strong></p>
<p>每一个在包 cn.apeius.mybatis.domain 中的 Java Bean，在没有注解的情况下，会使用 Bean 的<strong><em>首字母小写的非限定类名</em></strong> 来作为它的别名。比如<br>cn.apeius.mybatis.domain.User 的别名为 User，且<strong><em>大小写不敏感</em></strong></p>
<p><img src="http://i.imgur.com/CTiAuKz.png" alt=""></p>
<p>若有注解，则别名为其注解值。</p>
<pre><code>@Alias(&quot;xxx&quot;)
public class User {
    ...
}
</code></pre><h3 id="plugins（插件，又名拦截器）"><a href="#plugins（插件，又名拦截器）" class="headerlink" title="plugins（插件，又名拦截器）"></a>plugins（插件，又名拦截器）</h3><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>图：利用拦截器进行分页<br><img src="http://i.imgur.com/DlB41sl.png" alt=""></p>
<h3 id="environments（环境）"><a href="#environments（环境）" class="headerlink" title="environments（环境）"></a>environments（环境）</h3><h4 id="为什么要适应多种环境"><a href="#为什么要适应多种环境" class="headerlink" title="为什么要适应多种环境"></a>为什么要适应多种环境</h4><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，现实情况下有多种理由需要这么做</p>
<ul>
<li>开发环境：开发人员日常开发的时候使用的环境</li>
<li>测试环境：测试人员测试的时候使用环境</li>
<li>预发布环境：几乎和线上环境一模一样，在上线之前在进行一次测试</li>
<li>生成环境：线上环境。 正式的java程序运行的环境</li>
</ul>
<p>不过要记住：尽管可以配置多个环境，<strong><em>每个 SqlSessionFactory 实例只能选择其一</em></strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p>
<ul>
<li><strong><em>每个数据库对应一个 SqlSessionFactory 实例</em></strong></li>
</ul>
<h4 id="指定创建哪种环境"><a href="#指定创建哪种环境" class="headerlink" title="指定创建哪种环境"></a>指定创建哪种环境</h4><p><strong><em>配置多个环境</em></strong></p>
<pre>
&lt;environments <font color="red"> default="development"</font>>
    &lt;environment <font color="blue">id="development"</font>>
        &lt;transactionManager type="JDBC"/>
        &lt;dataSource type="POOLED">
            &lt;property name="driver" value="${driver}"/>
            &lt;property name="url" value="${url}"/>
            &lt;property name="username" value="${username}"/>
            &lt;property name="password" value="${password}"/>
        &lt;/dataSource>
    &lt;/environment>
    &lt;environment <font color="blue">id="online"</font>>
        &lt;transactionManager type="JDBC"/>
        &lt;dataSource type="POOLED">
            &lt;property name="driver" value="${driver}"/>
            &lt;property name="url" value="${url}"/>
            &lt;property name="username" value="${username}"/>
            &lt;property name="password" value="${password}"/>
        &lt;/dataSource>
    &lt;/environment>
&lt;/environments>
</pre>

<p><strong><em>代码指定创建那种环境</em></strong></p>
<pre><code>SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment);
</code></pre><h3 id="mappers映射器"><a href="#mappers映射器" class="headerlink" title="mappers映射器"></a>mappers映射器</h3><p>mappers映射器将 mapper.xml 文件配置到 mybatis 的环境中</p>
<h4 id="相对于类路径的资源引用"><a href="#相对于类路径的资源引用" class="headerlink" title="相对于类路径的资源引用"></a>相对于类路径的资源引用</h4><pre>
&lt;!-- Using classpath relative resources -->
&lt;mappers>
    &lt;mapper resource="UserMapper.xml"/>
&lt;/mappers>
</pre>

<h4 id="使用mapper接口路径"><a href="#使用mapper接口路径" class="headerlink" title="使用mapper接口路径"></a>使用mapper接口路径</h4><ul>
<li>这里所谓的 <strong><em>mapper接口路径</em></strong>，实际上就是 <strong><em>dao的接口路径</em></strong></li>
<li>在mybatis中，<strong><em>通常把dao的包叫做mapper类名，也叫做mapper</em></strong></li>
<li><p>使用 class 方式去加载的时候，要求</p>
<ul>
<li>要求 mapper.xml 文件的名字和 mapper 接口的名字一致</li>
<li>要求 mapper.xml 文件和 mapper 接口类在一个目录</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/T8Ghcku.png" alt=""></p>
<pre><code>&lt;mapper class=&apos;cn.itcast.mybatis.mapper.UserMapper&apos;/&gt;
</code></pre><p><strong>问题:</strong><br>1、mapper.xml 和 java文件没有分离,明天和 spring 整合之后解决<br>2、需要一个一个的去加载 mapper</p>
<h4 id="使用mapper接口扫描包-常用"><a href="#使用mapper接口扫描包-常用" class="headerlink" title="使用mapper接口扫描包(常用)"></a>使用mapper接口扫描包(常用)</h4><p>扫描指定包下的所有接口，要求mapper.xml和接口在<strong><em>同一个包下</em></strong>，并且<strong><em>名字相同</em></strong></p>
<pre>
&lt;!-- Register all interfaces in a package as mappers -->
&lt;mappers>
    &lt;package name="cn.itcast.mybatis.mapper"/>
&lt;/mappers>
</pre>


<font color="red"><strong><em>缺点:</em></strong></font>

<p>1、如果包的路径有很多？ 明天spring整合的时候解决<br>2、mapper.xml和mapper.java没有分离</p>
<h2 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h2><p><img src="http://i.imgur.com/MYBT4po.png" alt=""></p>
<h3 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a>CURD操作</h3><h4 id="select——书写select语句"><a href="#select——书写select语句" class="headerlink" title="select——书写select语句"></a>select——书写select语句</h4><p><img src="http://i.imgur.com/6fIzsFk.png" alt=""></p>
<ul>
<li>id属性（必须）：当前名称空间下的statement的<strong><em>唯一标识</em></strong>；要求id和mapper接口中的方法的<strong><em>名字一致</em></strong></li>
<li>resultType：将结果集映射为java的对象类型，和 resultMap 二选一（必须）</li>
<li><strong><em>parameterType：传入参数类型。可以省略</em></strong></li>
</ul>
<h4 id="insert——书写insert语句"><a href="#insert——书写insert语句" class="headerlink" title="insert——书写insert语句"></a>insert——书写insert语句</h4><p><img src="http://i.imgur.com/Vzy1hda.png" alt=""></p>
<ul>
<li>id属性：必须的，当前名称空间下的statement的唯一标识(必须属性)</li>
<li>parameterType：传入的参数类型，可以省略</li>
<li>标签内部：具体的sql语句</li>
<li>使用#{} 去替换一个变量</li>
<li>如果需要数据库影响的行数，可以<strong><em>直接在接口上定义返回值Integer</em></strong> 即可</li>
</ul>
<h4 id="获取自增的id的值"><a href="#获取自增的id的值" class="headerlink" title="获取自增的id的值"></a>获取自增的id的值</h4><p>插入数据后获得自增长的id号</p>
<p><img src="http://i.imgur.com/8URkb5u.png" alt=""></p>
<ul>
<li>useGenerateKeys：true</li>
<li>keyColumn:主键列的名字</li>
<li>keyProperty：实体类对应的属性</li>
</ul>
<p>测试</p>
<p><img src="http://i.imgur.com/i6Rwlo0.png" alt=""></p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p><img src="http://i.imgur.com/dh6mcwe.png" alt=""></p>
<ul>
<li>id属性：当前名称空间下的statement的唯一标识(必须属性)</li>
<li>parameterType：传入的参数类型，可以省略</li>
<li>标签内部：具体的sql语句</li>
<li>使用#{} 去替换一个变量</li>
</ul>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p><img src="http://i.imgur.com/bdcNIic.png" alt=""></p>
<ul>
<li>id属性：当前名称空间下的statement的唯一标识(必须属性)</li>
<li>parameterType：传入的参数类型，可以省略</li>
<li>标签内部：具体的sql语句</li>
<li>使用#{} 去替换一个变量</li>
</ul>
<h3 id="的用法及传入多个参数"><a href="#的用法及传入多个参数" class="headerlink" title="#{}的用法及传入多个参数"></a>#{}的用法及传入多个参数</h3><ul>
<li><code>#{}</code> 存在mapper.xml中的sql语句部分，标识该位置可以接受参数信息，<strong><em>相当于?占位符</em></strong></li>
<li>传入的参数和参数名无关，问题：如果有多个参数该怎么办？</li>
</ul>
<p><img src="http://i.imgur.com/T5wdiqe.png" alt=""></p>
<p>方法一：使用0，1……自然数取出对应的数据，0表示第一个参数</p>
<pre><code>select * from tb_user where user_name = #{0} and password = #{1}
</code></pre><p>方法二：使用param1，param2……param1表示第一个参数</p>
<pre><code>select * from tb_user where user_name = #{param1} and password = #{param2}
</code></pre><p><strong><em>方法三（常用）：在方法的定义上使用@param为传入的参数定义一个名字</em></strong></p>
<ul>
<li>在UserMapper接口中声明函数login，使用@param为每个参数定义一个名字</li>
</ul>
<pre><code>public User login(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);
</code></pre><ul>
<li>sql语句在#{}中填入定义的名字</li>
</ul>
<pre><code>select * from tb_user where user_name = #{username} and password = #{password}
</code></pre><ul>
<li>测试</li>
</ul>
<pre><code>@Test
public void testLogin(){
    User user = userMapper.login(&quot;zhangsan&quot;,&quot;123456&quot;);
    System.out.println(user);
}
</code></pre><h3 id="的用法及传入多个参数-1"><a href="#的用法及传入多个参数-1" class="headerlink" title="${}的用法及传入多个参数"></a>${}的用法及传入多个参数</h3><p>${}的用法：仍然是接受传递的参数，但是${}是sql语句的拼接</p>
<p><strong><em>需求</em></strong></p>
<p>查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据，希望使用1个方法来完成操作</p>
<ul>
<li><p>方法一：$在取值时，使用value表示传入的参数值，不建议写</p>
<ul>
<li>mapper接口<pre><code>public List&lt;User&gt; queryUserByTableName(String tableName);
</code></pre></li>
<li>mapper.xml<pre><code>select * from ${value}
</code></pre></li>
<li>测试<pre><code>@Test
public void testQueryUsersByTableName(){
    List&lt;User&gt; users = userMapper.queryUserByTableName(&quot;tb_user&quot;);
    for(User u : users){
        System.out.println(u);
    }
}
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>方法二（常用）：$在取值时，可以在mapper接口的参数之前使用@Param主键为当前参数指定一个名字</p>
<ul>
<li>mapper接口<pre><code>public List&lt;User&gt; queryUserByTableName(@Param(&quot;tableName&quot;) String tableName);
</code></pre></li>
<li>mapper.xml<pre><code>select * from ${tableName}
</code></pre></li>
<li>测试<pre><code>@Test
public void testQueryUsersByTableName(){
    List&lt;User&gt; users = userMapper.queryUserByTableName(&quot;tb_user&quot;);
    for(User u : users){
        System.out.println(u);
    }
}
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="面试题：-与-的区别"><a href="#面试题：-与-的区别" class="headerlink" title="面试题：#{}与${}的区别"></a>面试题：#{}与${}的区别</h3><p><img src="http://i.imgur.com/h9QffWS.png" alt=""></p>
<h3 id="resultMap与resultType用法★★★★★★★★"><a href="#resultMap与resultType用法★★★★★★★★" class="headerlink" title="resultMap与resultType用法★★★★★★★★"></a>resultMap与resultType用法★★★★★★★★</h3><h4 id="从SQL查询结果到领域模型实体"><a href="#从SQL查询结果到领域模型实体" class="headerlink" title="从SQL查询结果到领域模型实体　"></a>从SQL查询结果到领域模型实体　</h4><p><strong><em>从SQL查询结果集到JavaBean或POJO实体的过程：</em></strong></p>
<ol>
<li>通过JDBC查询得到ResultSet对象</li>
<li>遍历ResultSet对象并将每行数据暂存到HashMap实例中，以结果集的字段名或字段别名为键，以字段值为值</li>
<li>根据ResultMap标签的type属性<strong><em>通过反射实例化领域模型</em></strong></li>
<li>根据ResultMap标签的type属性和id、result等标签信息将HashMap中的键值对，填充到领域模型实例中并返回</li>
</ol>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><ul>
<li>在MyBatis进行查询映射的时候，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值</li>
<li>当提供的返回类型属性是resultType的时候，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性</li>
</ul>
<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>返回类型直接是一个ResultMap主要用在进行复杂联合查询上</p>
<p><strong><em>简单 resultMap 配置</em></strong></p>
<pre><code>&lt;resultMap id=&quot;BlogResult&quot; type=&quot;com.liulanghan.Blog&quot; &gt;    
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    
    &lt;result column=&quot;title&quot; property=&quot;title&quot;/&gt;    
    &lt;result column=&quot;content&quot; property=&quot;content&quot;/&gt;    
    &lt;result column=&quot;owner&quot; property=&quot;owner&quot;/&gt;    
&lt;/resultMap&gt;   

&lt;select id=&quot;selectBlog&quot; parameterType=&quot;int&quot; resultMap=&quot;BlogResult&quot;&gt;    
      select * from t_blog where id = #{id}    
&lt;/select&gt;  
</code></pre><ul>
<li>结果集的列比resultMap多会报错么？ —— 不会,只映射resultMap中有的列</li>
<li>结果集的列比resultMap少会报错么？ —— 不会,只映射结果集中有的列</li>
</ul>
<p><strong><em>高级结果映射</em></strong><br>见高级查询</p>
<h2 id="Mybatis学习路线总结★★★★★★★★★★"><a href="#Mybatis学习路线总结★★★★★★★★★★" class="headerlink" title="Mybatis学习路线总结★★★★★★★★★★"></a>Mybatis学习路线总结★★★★★★★★★★</h2><p><img src="http://i.imgur.com/EbzMZer.png" alt=""></p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>在mybatis中，一级缓存默认是开启的，并且无法关闭</p>
<p><img src="http://i.imgur.com/BQQ7iX7.png" alt=""></p>
<p><strong><em>一级缓存满足条件：</em></strong></p>
<ol>
<li>同一个session中</li>
<li>相同的SQL和参数</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1、测试代码</p>
<p><img src="http://i.imgur.com/ymQQ6nN.png" alt=""></p>
<p>2、日志输出</p>
<p><img src="http://i.imgur.com/o1OxJMa.png" alt=""></p>
<h3 id="使用session-clearCache-强制查询不缓存"><a href="#使用session-clearCache-强制查询不缓存" class="headerlink" title="使用session.clearCache()强制查询不缓存"></a>使用session.clearCache()强制查询不缓存</h3><p>1、代码</p>
<p><img src="http://i.imgur.com/2m1FkUi.png" alt=""></p>
<p>2、日志输出：</p>
<p><img src="http://i.imgur.com/IrbSbCH.png" alt=""></p>
<p>向数据库发送两次查询语句</p>
<h3 id="执行update-delete-insert-语句的时候，会刷新缓存"><a href="#执行update-delete-insert-语句的时候，会刷新缓存" class="headerlink" title="执行update,delete,insert 语句的时候，会刷新缓存"></a>执行update,delete,insert 语句的时候，会刷新缓存</h3><p>1、代码</p>
<p><img src="http://i.imgur.com/TxLA7bj.png" alt=""></p>
<p>2、日志</p>
<p><img src="http://i.imgur.com/CBcMlvg.png" alt=""></p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>mybatis 的二级缓存的 <strong><em>作用域</em></strong> 是一个mapper的<strong><em>namespace</em></strong> ，同一个namespace中查询sql可以从缓存中命中</p>
<h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>需要在mapper.xml 中加入如下：</p>
<pre><code>&lt;cache /&gt;
</code></pre><h3 id="测试二级缓存"><a href="#测试二级缓存" class="headerlink" title="测试二级缓存"></a>测试二级缓存</h3><ul>
<li>查询一次</li>
<li>关闭sqlSession</li>
<li>重新打开sqlSession</li>
<li>继续查询，观察是否发送sql语句</li>
</ul>
<p>1、代码</p>
<p><img src="http://i.imgur.com/Ny0NUin.png" alt=""></p>
<p>2、日志<br>　　<br><img src="http://i.imgur.com/e489uAs.png" alt=""></p>
<h3 id="二级缓存的高级配置"><a href="#二级缓存的高级配置" class="headerlink" title="二级缓存的高级配置"></a>二级缓存的高级配置</h3><p><img src="http://i.imgur.com/K1YSI2j.png" alt=""></p>
<h3 id="关闭二级缓存"><a href="#关闭二级缓存" class="headerlink" title="关闭二级缓存"></a>关闭二级缓存</h3><p>在全局的mybatis-config.xml 中去关闭二级缓存</p>
<p><img src="http://i.imgur.com/RW4Q6F3.png" alt=""></p>
<p><img src="http://i.imgur.com/UcpX9OF.png" alt=""></p>
<p><strong><em>测试</em></strong></p>
<p><img src="http://i.imgur.com/Ny0NUin.png" alt=""></p>
<ul>
<li>日志会有两次sql语句查询</li>
</ul>
<h2 id="高级查询★★★★★★"><a href="#高级查询★★★★★★" class="headerlink" title="高级查询★★★★★★"></a>高级查询★★★★★★</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="http://blog.csdn.net/tayanxunhua/article/details/19194607" target="_blank" rel="external">http://blog.csdn.net/tayanxunhua/article/details/19194607</a></p>
<p><img src="http://i.imgur.com/uvS6OXb.png" alt=""></p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>1、用户表<br>2、订单表<br>3、产品表</p>
<p>思路：</p>
<ul>
<li>一个用户可以有多个订单，某个订单只属于一个用户：需在订单表中设置指向用户表的外键</li>
<li>一个订单中有多个产品，一个产品可以属于多个订单，关系是多对多：建立中间表，指向订单表和产品表的外键</li>
</ul>
<h3 id="表之间的关系，以订单表作为出发点"><a href="#表之间的关系，以订单表作为出发点" class="headerlink" title="表之间的关系，以订单表作为出发点"></a>表之间的关系，以订单表作为出发点</h3><p><img src="http://i.imgur.com/rnuPgvZ.png" alt=""></p>
<p>订单表与用户表：1：1</p>
<ul>
<li>一个订单只能属于一个人 1：1</li>
<li>一个用户可以有多个订单 1：N</li>
</ul>
<p>订单表与商品表：N:N</p>
<ul>
<li>一个订单可以有多个商品 1：N</li>
<li>一个商品可以属于多个订单表 1：N</li>
</ul>
<p>订单表与订单详情：1：N</p>
<ul>
<li>一个订单有多个订单详情</li>
<li>一个订单详情只属于一个订单</li>
</ul>
<font color="red"><strong><em>总结，以订单的角度看，他们的关系是：</em></strong></font>

<ul>
<li>订单和人是一对一关系</li>
<li>订单和订单详情是一对多的关系</li>
<li>订单和商品是多对多的关系</li>
</ul>
<h3 id="autoMapping详解"><a href="#autoMapping详解" class="headerlink" title="autoMapping详解"></a>autoMapping详解</h3><p><a href="http://www.cnblogs.com/TheViper/p/4480765.html" target="_blank" rel="external">http://www.cnblogs.com/TheViper/p/4480765.html</a><br><a href="http://www.zhihu.com/question/41983738/answer/98829976" target="_blank" rel="external">http://www.zhihu.com/question/41983738/answer/98829976</a></p>
<h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><ul>
<li>查询订单，并且查询出下单人的信息</li>
<li>核心思想：面向对象的思想，在Order对象中添加User对象</li>
</ul>
<h4 id="association关联映射"><a href="#association关联映射" class="headerlink" title="association关联映射"></a>association关联映射</h4><p>association关联元素处理一对一关联，比如：一个博客只有一个作者，一张订单只属于一个用户</p>
<h4 id="关联的嵌套查询-（select联合查询，懒加载）"><a href="#关联的嵌套查询-（select联合查询，懒加载）" class="headerlink" title="关联的嵌套查询 （select联合查询，懒加载）"></a>关联的嵌套查询 （select联合查询，懒加载）</h4><p><strong>Domain</strong></p>
<pre><code>public class Order {
    private int id;
    private User user;//private int user_id;
    private String order_number;
}
</code></pre><p><strong>定义OrderMapper接口</strong></p>
<pre><code>public interface OrderMapper {
    public Order queryOrderAndUserLazy(String orderNumber);
}
</code></pre><p><strong>Ordermapper.xml</strong></p>
<pre><code>&lt;!--association：嵌套查询--&gt;
&lt;!--查询订单和用户--&gt;
&lt;select id=&quot;queryOrderAndUserLazy&quot; resultMap=&quot;lazyOrderUserResultMap&quot;&gt;
    SELECT * FROM tb_order WHERE order_number = #{order_number}
&lt;/select&gt;
&lt;!--指定Order中user成员变量的详细装配方式--&gt;
&lt;resultMap id=&quot;lazyOrderUserResultMap&quot; type=&quot;Order&quot;&gt;
    &lt;!-- 一个 ID 结果，标记结果作为 ID 可以帮助提高整体效能 --&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
    &lt;!--resultMap必须制定javaType，如果你映射到一个JavaBean，MyBatis通常可以断定类型--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; column=&quot;user_id&quot; select=&quot;queryUserById&quot;/&gt;
&lt;/resultMap&gt;
&lt;!--查询用户--&gt;
&lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM tb_user where id = #{id}
&lt;/select&gt;
</code></pre><p><strong>测试</strong></p>
<pre><code>@Test
public void testQueryOrderAndUserByOrderNumber() throws Exception {
    Order order = orderMapper.queryOrderAndUserLazy(&quot;20140921001&quot;);
    System.out.println(order);
    System.out.println(order.getUser());
}
</code></pre><p>有两个查询语句：一个来加载订单，另外一个来加载用户, 而且订单的结果映射描述了”queryUserById”语句应该被用来加载它的 User 属性。  </p>
<p><strong>其他所有的属性将会被自动加载，假设它们的列和属性名相匹配</strong>。这种方式很简单, 但是对于大型数据集合和列表将不会表现很好，就会出现”N+1”的问题。</p>
<p>“N+1”的问题可以是这样引起的：<br>你执行了一个单独的 SQL 语句来获取结果列表(就是”+1”)——查询Order语句<br>对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是”N”)——查询User语句<br>这个问题会导致成百上千的 SQL 语句被执行，这通常不是期望的</p>
<p>MyBatis 能<strong>延迟加载</strong>这样的查询就是一个好处,因此你可以分散这些语句同时运行的消耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加载,这样的行为可能是很糟糕的。所以还有另外一种方法</p>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>方式一：属性全部重命名，手动映射</p>
<ul>
<li>代替了执行一个分离的语句,我们联合订单表和用户表在一起</li>
<li>所有结果被唯一而且清晰的名字来重命名，这使得映射非常简单</li>
<li>缺点是所有字段都要手动映射，操作简单，但工作量较大，可以使用自动映射</li>
</ul>
<pre><code>&lt;!--联合查询订单和用户，一对一关系--&gt;
&lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt;
    SELECT
        o.id as order_id,
        o.user_id as order_user_id,
        o.order_number as order_order_number,
        u.id as user_id,
        u.user_name as user_user_name,
        u.password as user_password,
        u.name as user_name,
        u.age as user_age,
        u.sex as user_sex,
        u.birthday as user_birthday,
        u.created as user_created,
        u.updated as user_updated
    FROM
        tb_order o
    LEFT JOIN tb_user u ON u.id = o.user_id
    WHERE
      o.order_number = #{order_number}
&lt;/select&gt;
&lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
    &lt;result property=&quot;order_number&quot; column=&quot;order_order_number&quot;/&gt;&lt;!-- 有顺序要求，必须放在id后--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
        &lt;result property=&quot;user_name&quot; column=&quot;user_name&quot;/&gt;
        &lt;result property=&quot;password&quot; column=&quot;user_password&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;user_name&quot;/&gt;
        &lt;result property=&quot;age&quot; column=&quot;user_age&quot;/&gt;
        &lt;result property=&quot;sex&quot; column=&quot;user_sex&quot;/&gt;
        &lt;result property=&quot;birthday&quot; column=&quot;user_birthday&quot;/&gt;
        &lt;result property=&quot;created&quot; column=&quot;user_created&quot;/&gt;
        &lt;result property=&quot;updated&quot; column=&quot;user_updated&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre><p>方式二：自动映射，冲突字段自动命名，手动映射，其余元素自动匹配★★★★★</p>
<ul>
<li>当自动匹配结果的时候，Mybatis会获取列名，并且查找一个相同的属性（忽略大小写）。这意味着命名为ID的列和命名为id的属性被查找到的时候，Mybatis将会把列ID的值赋给属性id</li>
<li>通常数据库列名命名的时候使用大写和下划线并且Java属性常常依据驼峰命名法。为了保证在他们之间的自动匹配要设置属性 mapUnderscoreToCamelCase 为 true</li>
<li>对于每一个result map，所有的在ResultSet中有的并且<strong>没有被手动匹配的列将会被自动的匹配</strong>。默认不开启，<strong>设置 autoMapping=”true”开启</strong></li>
<li><font color="red"><strong><em>冲突字段重命名，自动赋值，其余元素自动匹配</em></strong></font>


</li>
</ul>
<pre><code>&lt;!--联合查询订单和用户，一对一关系--&gt;
&lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt;
    SELECT
      *,u.id as user_id,o.id as order_id
    FROM
      tb_order o
    LEFT JOIN tb_user u ON u.id = o.user_id
    WHERE
      o.order_number = #{order_number}
&lt;/select&gt;
&lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre><p>方式三：外部结果映射</p>
<p>使用外部的结果映射元素来映射关联，使得User结果映射可以重用。如果你不需要重用它的话，或者你仅仅引用你所有的结果映射合到一个单独描述的结果映射中，即方式二</p>
<pre><code>&lt;!--方式三--&gt;
&lt;!--联合查询订单和用户，一对一关系--&gt;
&lt;select id=&quot;queryOrderAndUserByOrderNumber&quot; resultMap=&quot;orderUserResultMap&quot;&gt;
    SELECT
    *,u.id as user_id,o.id as order_id
    FROM
    tb_order o
    LEFT JOIN tb_user u ON u.id = o.user_id
    WHERE
    o.order_number = #{order_number}
&lt;/select&gt;
&lt;resultMap id=&quot;orderUserResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; resultMap=&quot;user&quot;/&gt;
&lt;/resultMap&gt;
&lt;resultMap id=&quot;user&quot; type=&quot;User&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
&lt;/resultMap&gt;
</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><p>查询订单，查询出下单人信息并且查询出订单详情</p>
<ul>
<li>订单表、用户表、订单详情三表联合查询</li>
<li>映射结果为Order类，填充user和orderDetails属性对象</li>
</ul>
<p><strong>Domain</strong></p>
<pre><code>public class Order {
    private int id;
    private User user;//private int user_id;
    private String order_number;
    private List&lt;OrderDetail&gt; orderDetails;
}
</code></pre><p><strong>定义OrderMapper接口</strong></p>
<pre><code>public interface OrderMapper {
    public Order queryOrderAndUserAndDetailByOrderNumber(String orderNumber);
}
</code></pre><p><strong>OrderMapper.xml</strong></p>
<pre><code>&lt;!--collection：1：N--&gt;
&lt;select id=&quot;queryOrderAndUserAndDetailByOrderNumber&quot; resultMap=&quot;orderUserDetailResultMap&quot;&gt;
    SELECT
        *,o.id as order_id,d.id as detail_id
    FROM
        tb_order o
    LEFT JOIN tb_user u ON u.id = o.user_id
    LEFT JOIN tb_orderdetail d ON o.id = d.order_id
    WHERE o.order_number = #{order_number}
&lt;/select&gt;
&lt;resultMap id=&quot;orderUserDetailResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;/association&gt;
    &lt;!--collection 定义集合
        property：集合的属性名
        javaType：集合的类型
        ofType：集合中成员类型
        子标签内：填id和result
    --&gt;
    &lt;collection property=&quot;orderDetails&quot; javaType=&quot;List&quot; ofType=&quot;OrderDetail&quot; autoMapping=&quot;true&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre><p><strong>测试</strong></p>
<pre><code>Order order = orderMapper.queryOrderAndUserAndDetailByOrderNumber(&quot;20140921001&quot;);
System.out.println(order);
List&lt;OrderDetail&gt; orderDetails = order.getOrderDetails();
for(OrderDetail d : orderDetails)
    System.out.println(d);
</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><p>查询订单，查询出下单人信息并且查询出订单详情中的商品数据</p>
<p><strong>doamin</strong></p>
<pre><code>public class OrderDetail {
    private int id;
    private Order order;//private int order_id;
    private Item item;//private int item_id;
    private double total_price;
    private int status;
}
</code></pre><p><strong>定义OrderMapper</strong></p>
<pre><code>public interface OrderMapper {
    public Order queryOrdreAndUserAndDetailAndItemByOrderNumber(String orderNumber);
}
</code></pre><p><strong>OrderMapper.xml</strong></p>
<pre><code>&lt;!--查询订单，查询出下单人信息并且查询出订单详情中的商品数据 N:N--&gt;
&lt;select id=&quot;queryOrdreAndUserAndDetailAndItemByOrderNumber&quot; resultMap=&quot;orderUserDetailItemResultMap&quot;&gt;
    SELECT
        *
    FROM
        tb_order o
    LEFT JOIN tb_user u ON u.id = o.user_id
    LEFT JOIN tb_orderdetail d ON o.id = d.order_id
    LEFT JOIN tb_item i ON d.item_id = i.id
    WHERE o.order_number = #{order_number}
&lt;/select&gt;
&lt;resultMap id=&quot;orderUserDetailItemResultMap&quot; type=&quot;Order&quot; autoMapping=&quot;true&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;User&quot; autoMapping=&quot;true&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;/association&gt;
    &lt;collection property=&quot;orderDetails&quot; javaType=&quot;List&quot; ofType=&quot;OrderDetail&quot; autoMapping=&quot;true&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;/&gt;
        &lt;association property=&quot;item&quot; javaType=&quot;Item&quot; autoMapping=&quot;true&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;item_id&quot;&gt;&lt;/id&gt;
        &lt;/association&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre><p><strong>测试</strong></p>
<pre><code>@Test
public void testQueryOrdreAndUserAndDetailAndItemByOrderNumber(){
    Order order = orderMapper.queryOrdreAndUserAndDetailAndItemByOrderNumber(&quot;20140921001&quot;);
    System.out.println(order);
}
</code></pre><h3 id="resultMap的继承"><a href="#resultMap的继承" class="headerlink" title="resultMap的继承"></a>resultMap的继承</h3><p><img src="http://i.imgur.com/R9JdYy3.png" alt=""></p>
<h2 id="延迟加载-未成功"><a href="#延迟加载-未成功" class="headerlink" title="延迟加载(未成功)"></a>延迟加载(未成功)</h2><h3 id="开启延迟加载"><a href="#开启延迟加载" class="headerlink" title="开启延迟加载"></a>开启延迟加载</h3><pre><code>&lt;settings&gt;
    &lt;!-- 打开延迟加载的开关 --&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt;
    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;
</code></pre><ul>
<li>lazyLoadingEnabled：true使用延迟加载，false禁用延迟加载，默认为false</li>
<li>aggressiveLazyLoading：<ul>
<li>默认true，当有一个进行加载的时候，就会把所有没有加载的属性加载进来</li>
<li>false按需加载，只有调用对应的getter的才会去加载</li>
</ul>
</li>
</ul>
<h3 id="添加cglib"><a href="#添加cglib" class="headerlink" title="添加cglib"></a>添加cglib</h3><pre><code>&lt;dependency&gt;
        &lt;groupId&gt;cglib&lt;/groupId&gt;
        &lt;artifactId&gt;cglib&lt;/artifactId&gt;
        &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><pre><code>public interface OrderMapper {
    public Order queryOrderAndUserLazy(String orderNumber);
}
</code></pre><h3 id="OrderMapper-xml"><a href="#OrderMapper-xml" class="headerlink" title="OrderMapper.xml"></a>OrderMapper.xml</h3><pre>
&lt;mapper namespace="cn.apeius.mybatis.mapper.OrderMapper">
    &lt;select id="queryOrderAndUserLazy" resultMap="<font color=" red">lazyOrderUserResultMap</font>">
        SELECT * FROM tb_order WHERE order_number = #{order_number}
    &lt;/select>
    &lt;resultMap id="<font color="red">lazyOrderUserResultMap</font>" type="Order" autoMapping="true">
        &lt;id property="id" column="id">&lt;/id>
            &lt;-- columnw中的user_id作为参数传入queryUserById-->
        &lt;association property="user" javaType="User" column="user_id" select="<font color="blue">queryUserById</font>"/>
    &lt;/resultMap>
    &lt;select id="<font color="blue">queryUserById</font>" resultType="User">
        SELECT * FROM tb_user where id = #{id}
    &lt;/select>
&lt;/mapper>
</pre>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><pre><code>@Test
public void testQueryOrderAndUserLazy(){
    OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.class);
    Order order = orderMapper.queryOrderAndUserLazy(&quot;20140921001&quot;);
    System.out.println(order.getOrder_number());
    System.out.println(order.getUser());
}
</code></pre><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><ul>
<li>Mybatis提供了plugin机制，<strong><em>允许我们在mybatis的原有流程上加入自己的逻辑</em></strong>，加上分页逻辑可以方便实现分页</li>
<li>原理是利用了拦截器，mybatis支持的拦截接口有四个：Executor、ParameterHandler、ResultSetHandlet、StatementHandler</li>
</ul>
<h3 id="plugin实现原理"><a href="#plugin实现原理" class="headerlink" title="plugin实现原理"></a>plugin实现原理</h3><p><img src="http://i.imgur.com/qP9KCdP.png" alt=""></p>
<p>原来的sql语句:</p>
<pre><code>select * from tb_user
</code></pre><p>经过拦截器后，变为:</p>
<pre><code>selectd * from tb_user limit 1,10
</code></pre><p>从而实现分页</p>
<h3 id="使用PageHelper实现分页"><a href="#使用PageHelper实现分页" class="headerlink" title="使用PageHelper实现分页"></a>使用PageHelper实现分页</h3><p>PageHelper实现了通用的分页查询，其支持的数据库有Mysq、Oracle、DB2、PostgreSQL等主流数据库</p>
<h3 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;3.7.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;0.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><pre><code>&lt;plugins&gt;
    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;
        &lt;!--数据库方言--&gt;
        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;
        &lt;!--设置为true时，使用RowBounds分页会进行count查询，即会去查询出总数--&gt;
        &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre><h3 id="在执行查询时设置分页参数"><a href="#在执行查询时设置分页参数" class="headerlink" title="在执行查询时设置分页参数"></a>在执行查询时设置分页参数</h3><pre><code>@Test
public void testPage(){
    //开启分页，第一个参数：当前的页数；第二个参数：每页几条数据
    PageHelper.startPage(2,5);
    //紧接着的第一个查询会被执行分页
    List&lt;User&gt; users = userMapper.queryAllUser();
    for(User u : users){
        System.out.println(u);
    }

    //获取分页信息
    PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(users);
    pageInfo.getList();//与users为同一个引用
    System.out.println(&quot;总记录数：&quot; + pageInfo.getTotal());
    System.out.println(&quot;总页数 &quot; + pageInfo.getPages());
    System.out.println(&quot;当前页数 &quot; + pageInfo.getPageNum());
    System.out.println(&quot;每页多少数据 &quot; + pageInfo.getPageSize());
    System.out.println(&quot;当前页的数据条目数 &quot; + pageInfo.getSize());
}
</code></pre><h2 id="mybatis和spring整合"><a href="#mybatis和spring整合" class="headerlink" title="mybatis和spring整合"></a>mybatis和spring整合</h2><h3 id="官方文档-1"><a href="#官方文档-1" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://github.com/rhapsody1290/MybatisStudy/tree/master/doc/%E4%B8%AD%E6%96%87%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/Mybatis-Spring-1.2.2" target="_blank" rel="external">https://github.com/rhapsody1290/MybatisStudy/tree/master/doc/%E4%B8%AD%E6%96%87%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/Mybatis-Spring-1.2.2</a></p>
<h3 id="什么是MyBatis-Spring"><a href="#什么是MyBatis-Spring" class="headerlink" title="什么是MyBatis-Spring"></a>什么是MyBatis-Spring</h3><ul>
<li>MyBatis-Spring 会帮助你将 MyBatis 代码 <strong><em>无缝地整合</em></strong> 到 Spring 中，使用这个类库中的类, Spring 将会<strong><em>加载必要的 MyBatis 工厂类和 session 类</em></strong></li>
<li>这个类库也提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean 中</li>
<li>它也会处理事务, 翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常中</li>
<li>最终,它并不会依赖于 MyBatis,Spring 或 MyBatis-Spring 来构建应用程序代码</li>
</ul>
<h3 id="导入依赖-2"><a href="#导入依赖-2" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>mybatis-spring整合包</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
  &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>c3p0依赖，一个开源的JDBC连接池</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;c3p0&lt;/groupId&gt;
    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
    &lt;version&gt;0.9.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="c3p0-properties-数据源"><a href="#c3p0-properties-数据源" class="headerlink" title="c3p0.properties(数据源)"></a>c3p0.properties(数据源)</h3><pre><code>c3p0.driverClass=com.mysql.jdbc.Driver
c3p0.url=jdbc:mysql://localhost:3306/mybatis
c3p0.user=root
c3p0.password=root
</code></pre><h3 id="配置spring的配置文件applicationContext-xml"><a href="#配置spring的配置文件applicationContext-xml" class="headerlink" title="配置spring的配置文件applicationContext.xml"></a>配置spring的配置文件applicationContext.xml</h3><ul>
<li>引入配置文件c3p0.properties</li>
<li>配置连接池</li>
<li>配置sqlSessionFactory<ul>
<li>引入数据源</li>
<li>引入mybatis的全局配置</li>
<li>包扫描方式配置别名typeAliasesPackage</li>
<li>mapper.xml所在路径(Mapper.xml和java代码分离)</li>
</ul>
</li>
<li>mapper接口所在的包</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 引入配置文件 --&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;locations&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:c3p0.properties&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 配置连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${c3p0.driverClass}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${c3p0.url}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;user&quot; value=&quot;${c3p0.user}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;${c3p0.password}&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--配置sqlSessionFactory。SqlSessionFactoryBean 是用于创建 SqlSessionFactory 的--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--引入数据源--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--引入mybatis的全局配置--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;!--mybatis别名包--&gt;
        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.apeius.mybatis.domain&quot;/&gt;
        &lt;!--mapper.xml所在路径,可以使mapper接口与mapper.xml分离；可以使用通配符，**表示所有目录--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/**/*.xml&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--指定扫描包，mapper接口所在的包--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--多个扫描包可以通过逗号或分号进行分割--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;cn.apeius.mybatis.mapper&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!-- 打开延迟加载的开关 --&gt;
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
        &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt;
        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
    &lt;/settings&gt;
    &lt;plugins&gt;
        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;
            &lt;!--数据库方言--&gt;
            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;
            &lt;!--设置为true时，使用RowBounds分页会进行count查询，即会去查询出总数--&gt;
            &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/configuration&gt;
</code></pre><p><strong><em>问题：为什么配置SqlSessionFactory时，class为SqlSessionFactory</em></strong></p>
<ul>
<li>在基本的 MyBatis 中, SqlSessionFactory 可以使用 SqlSessionFactoryBuilder 来创建，而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代</li>
<li>SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口，这就说明了由 Spring 最终创建的 bean <strong><em>不是 SqlSessionFactoryBean 本身</em></strong> ,  而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储</li>
</ul>
<h3 id="mybatis和spring整合测试"><a href="#mybatis和spring整合测试" class="headerlink" title="mybatis和spring整合测试"></a>mybatis和spring整合测试</h3><pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserMapper userMapper = context.getBean(UserMapper.class);
List&lt;User&gt; users = userMapper.queryAllUser();
for(User user : users){
    System.out.println(user.getId() + &quot; &quot; + user.getUser_name());
}
</code></pre><h2 id="mapper整合servcie"><a href="#mapper整合servcie" class="headerlink" title="mapper整合servcie"></a>mapper整合servcie</h2><h3 id="servcie接口"><a href="#servcie接口" class="headerlink" title="servcie接口"></a>servcie接口</h3><pre><code>public interface UserServiceInter {

    public List&lt;User&gt; queryAll();
}
</code></pre><h3 id="service实现"><a href="#service实现" class="headerlink" title="service实现"></a>service实现</h3><pre><code>@Service
public class UserServiceImp implements UserServiceInter {

    @Autowired
    private UserMapper userMapper;

    @Override
    public List&lt;User&gt; queryAll() {
        return userMapper.queryAllUser();
    }
}
</code></pre><h3 id="applicationContext-xml配置"><a href="#applicationContext-xml配置" class="headerlink" title="applicationContext.xml配置"></a>applicationContext.xml配置</h3><p>使service属性自动注入</p>
<pre><code>&lt;context:component-scan base-package=&quot;cn.apeius.mybatis.service.imp&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserServiceInter userServiceInter = context.getBean(UserServiceImp.class);
List&lt;User&gt; users = userServiceInter.queryAll();
for(User user : users){
    System.out.println(user);
}
</code></pre><h2 id="mybatis整合事务管理（未成功）"><a href="#mybatis整合事务管理（未成功）" class="headerlink" title="mybatis整合事务管理（未成功）"></a>mybatis整合事务管理（未成功）</h2><h3 id="配置事务管理"><a href="#配置事务管理" class="headerlink" title="配置事务管理"></a>配置事务管理</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;

    &lt;!-- 定义事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot;
          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 定义事务策略 --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!--所有以query开头的方法都是只读的 --&gt;
            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt;
            &lt;!--其他方法使用默认事务策略 --&gt;
            &lt;tx:method name=&quot;*&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;aop:config&gt;
        &lt;!--pointcut元素定义一个切入点，execution中的第一个星号 用以匹配方法的返回类型，
            这里星号表明匹配所有返回类型。 com.abc.dao.*.*(..)表明匹配cn.itcast.mybatis.service包下的所有类的所有方法 --&gt;
        &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* cn.apeius.mybatis.service.*.*(..))&quot; /&gt;
        &lt;!--将定义好的事务处理策略应用到上述的切入点 --&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot; /&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>@Service
public class UserServiceImp implements UserServiceInter {

    @Autowired
    protected UserMapper userMapper;

    @Override
    public List&lt;User&gt; queryAll() {
        return userMapper.queryAllUser();
    }

    @Override
    public void saveUser(User user) {
        userMapper.addUser(user);
        //int a = 9 / 0;
    }
}
</code></pre><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><pre><code>@Before
public void setUp(){
    ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext-transaction.xml&quot;});
    userServiceInter = context.getBean(UserServiceImp.class);
}

@Test
public void testSaveUser(){
    User user = new User();
    user.setUser_name(&quot;陈冠希&quot;);
    user.setName(&quot;dsfa&quot;);
    userServiceInter.saveUser(user);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/11/[Struts2]Struts2笔记/" itemprop="url">
                  Struts2笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-11T00:00:00+08:00" content="2016-08-11">
              2016-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Struts2/" itemprop="url" rel="index">
                    <span itemprop="name">Struts2</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Struts2"><a href="#什么是Struts2" class="headerlink" title="什么是Struts2"></a>什么是Struts2</h2><ul>
<li>Struts2是一个MVC框架</li>
<li>Struts2起源于WebWork框架，Struts2就是WebWork2</li>
<li>Struts2是对Struts1的一个补充，而不是替代品</li>
</ul>
<h2 id="Struts2快速入门-Action、struts-xml、跳转结果"><a href="#Struts2快速入门-Action、struts-xml、跳转结果" class="headerlink" title="Struts2快速入门(Action、struts.xml、跳转结果)"></a>Struts2快速入门(Action、struts.xml、跳转结果)</h2><h3 id="登录功能Action"><a href="#登录功能Action" class="headerlink" title="登录功能Action"></a>登录功能Action</h3><pre><code>package cn.apeius.action;

import com.opensymphony.xwork2.ActionSupport;
import com.sun.net.httpserver.Authenticator;

/**
 * Created by Asus on 2016/8/11.
 */
public class LoginAction extends ActionSupport {
    private String account;
    private String password;

    public String execute(){
        if(&quot;admin&quot;.equals(account) &amp;&amp; &quot;admin&quot;.equals(password)){
            return SUCCESS;
        }else{
            return LOGIN;
        }
    }
    public String getAccount() {
        return account;
    }

    public void setAccount(String account) {
        this.account = account;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</code></pre><ul>
<li>新建LoginAction，Struts2的Action需要继承com.opensymphony.xwork2.ActionSupport</li>
<li>LoginAction中有两个属性account、password，代表JSP表单的两个输入框。Struts2会自动把输入框中的内容通过getter、setter方法设置进来</li>
<li>还有一个execute方法，提交数据后会自动调用该方法</li>
<li>返回值代表结果页面的跳转，具体文件见配置文件</li>
</ul>
<h3 id="Struts2配置文件"><a href="#Struts2配置文件" class="headerlink" title="Struts2配置文件"></a>Struts2配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE struts PUBLIC
        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;

&lt;struts&gt;
    &lt;!--定义一个package，所有的result和action等必须配置到package--&gt;
    &lt;package name=&quot;main&quot; extends=&quot;struts-default&quot;&gt;
        &lt;!--所有的全局result--&gt;
        &lt;global-results&gt;
            &lt;!--名为login的result--&gt;
            &lt;result name = &quot;login&quot;&gt;/login.jsp&lt;/result&gt;
        &lt;/global-results&gt;
        &lt;!--LoginAction--&gt;
        &lt;action name=&quot;LoginAction&quot; class=&quot;cn.apeius.action.LoginAction&quot;&gt;
            &lt;!--名为success的result--&gt;
            &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt;
        &lt;/action&gt;
    &lt;/package&gt;
&lt;/struts&gt;
</code></pre><ul>
<li>Struts2所有的result、action等必须配置到package中，自定义的package一般继承struts-default</li>
<li>JSP配置在result中。上述配置文件配置了两个result，一个是名为success，配置在action里面，当登录成功后跳转到success.jsp里面；另一个是全局的result，配置在global-results中，名为login，访问任何页面首页跳转到login.jsp</li>
</ul>
<h3 id="JSP登录页面"><a href="#JSP登录页面" class="headerlink" title="JSP登录页面"></a>JSP登录页面</h3><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;struts&quot;%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;struts:form action=&quot;LoginAction&quot;&gt;
        &lt;struts:label value=&quot;登录系统&quot;&gt;&lt;/struts:label&gt;
        &lt;struts:textfield name=&quot;account&quot; label=&quot;帐号&quot;/&gt;
        &lt;struts:password name=&quot;password&quot; label=&quot;密码&quot;/&gt;
        &lt;struts:submit value=&quot;登录&quot;&gt;&lt;/struts:submit&gt;
    &lt;/struts:form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--struts2的filter，所有请求都被映射到struts上--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;!--匹配所有URL--&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</code></pre><ul>
<li>Struts2使用Filter作为分发器，配置ur-pattern最好配置为/*</li>
</ul>
<h2 id="Struts2工作流程★★★★★"><a href="#Struts2工作流程★★★★★" class="headerlink" title="Struts2工作流程★★★★★"></a>Struts2工作流程★★★★★</h2><ul>
<li>用户访问JSP页面 login.jsp，跳出登录页面</li>
<li>提交表单后数据提交给LoginAction</li>
<li>Struts2<strong><em>拦截所有请求</em></strong>，包括*.action的请求</li>
<li><strong><em>查找struts.xml</em></strong>，LoginAction对应LoginAction类，生成LoginAction实例，并将提交的<strong><em>数据注入</em></strong> 该实例中（从request中获取参数），调用LoginAction实例的<strong><em>execute方法</em></strong></li>
<li>根据返回结果，决定<strong><em>跳转</em></strong> JSP页面</li>
</ul>
<h2 id="Struts2线程安全"><a href="#Struts2线程安全" class="headerlink" title="Struts2线程安全"></a>Struts2线程安全</h2><ul>
<li>Struts1所有Action都只有一个实例，不是线程安全</li>
<li>Struts2对每个请求生成一个实例，处理完成即销毁，是线程安全的（Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用，Struts2必须是多例的，如果是单例会导致不同用户数据的冲突）</li>
</ul>
<h2 id="Action详解"><a href="#Action详解" class="headerlink" title="Action详解"></a>Action详解</h2><h3 id="通配符配置Action"><a href="#通配符配置Action" class="headerlink" title="通配符配置Action"></a>通配符配置Action</h3><p>BookAction.java</p>
<pre><code>public class BookAction extends ActionSupport {

    public static List&lt;Book&gt; bookList = new ArrayList&lt;Book&gt;();
    private String title;
    private Book book;

    public String add() {
        bookList.add(book);
        title = &quot;&lt;br/&gt;&lt;br/&gt;添加书籍成功&lt;br/&gt;&lt;br/&gt;&quot;;
        return &quot;success&quot;;
    }

    // 书籍列表
    @SkipValidation
    public String list() {
        return &quot;list&quot;;
    }

    // 清空书籍列表
    @SkipValidation
    public String clear() {
        bookList.clear();
        title = &quot;&lt;br/&gt;&lt;br/&gt;清空书籍列表成功&lt;br/&gt;&lt;br/&gt;&quot;;
        return &quot;list&quot;;
    }

}
</code></pre><p>struts.xml</p>
<pre><code>&lt;action name=&quot;*Book&quot;
    class=&quot;com.helloweenvsfei.struts2.action.BookAction&quot; method=&quot;{1}&quot;&gt;
    &lt;result&gt;/successBook.jsp&lt;/result&gt;
    &lt;result name=&quot;{1}&quot;&gt;/{1}Book.jsp&lt;/result&gt;
    &lt;result name=&quot;input&quot;&gt;/initAddBook.jsp&lt;/result&gt;
    &lt;result name=&quot;list&quot;&gt;/listBook.jsp&lt;/result&gt;
&lt;/action&gt;
</code></pre><ul>
<li><code>*</code>代表的内容可以在本Action配置内部使用{1},{2}等引用</li>
<li>举个例子，访问listBook.action时，执行list()方法</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Struts2中关于”There-is-no-Action-mapped-for-namespace-and-action-name”的总结"><a href="#Struts2中关于”There-is-no-Action-mapped-for-namespace-and-action-name”的总结" class="headerlink" title="Struts2中关于”There is no Action mapped for namespace / and action name”的总结"></a>Struts2中关于”There is no Action mapped for namespace / and action name”的总结</h3><p><a href="http://www.cnblogs.com/gulvzhe/archive/2011/11/21/2256632.html" target="_blank" rel="external">http://www.cnblogs.com/gulvzhe/archive/2011/11/21/2256632.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/09/[Java]命令行编译Java程序/" itemprop="url">
                  命令行编译Java程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-09T00:00:00+08:00" content="2016-08-09">
              2016-08-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先说下.java和.class文件，.java文件可以放在任何位置，只要运行javac时，指定你要编译的源文件位置就好，然后javac还有另一个参数是指定.class文件输出到哪个目录。另外javac还有一个option叫 -d，表示编译出来的.class文件，按照包名放进相应层级的目录中去。<br>所以，假设你的.java文件在D:\code\src\com\company\Hello.java，（因为Java要求源文件中的public类与源文件名要相同，类名通常首字母大写，所以源文件通常是Hello.java这样的），并且假如你的Hello.java里写明package com.company;<br>假如你当前置身于D:\code\目录下，执行javac .\src\com\company\Hello.java -d .\bin\<br>表示编译.\src\com\company\Hello.java，将编译好的.class文件按包名层级结构放到.\bin\目录下。<br>于是在D:\code\bin\com\company\下会出现一个Hello.class文件。这时，运行Hello时，跟.java文件就没有关系了。<br>这时如果你置身于D:\code\bin\目录下，最好了，因为我们通常配置环境变量时，CLASSPATH会配置.，也就是当前路径，那你就在D:\code\bin\下执行java，那class也就在当前路径找了：<br>java com.company.Hello，这里java是启动虚拟机的命令，启动时运行哪个类呢？com.company.Hello，这是类名，带着包名，叫全限定名，也就是类的全名，这跟它在哪个目录下没关系，是类名，虚拟机会在CLASSPATH下，也就是当前目录下，去找com.company.Hello这个类，并加载运行。<br>至于它怎么找，你就不用管了。<br>如果你当前正置身于D:\code\下，那你执行java com.company.Hello就失败了，因为虚拟机在CLASSPATH下找不到这个类。那怎么办呢，就要告诉虚拟机，去哪找，也就是要指定CLASSPATH，可以执行：java -classpath .\bin com.company.Hello<br>不知道你能不能理解，你要运行的是com.company.Hello这个类，这是类名，不是目录名，去哪找这个类？用-classpath告诉虚拟机，所以，不能java .\bin\com.company.Hello，这就不伦不类了。</p>
<p>参考<br><a href="http://bbs.csdn.net/topics/390865848" target="_blank" rel="external">http://bbs.csdn.net/topics/390865848</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/08/[Java]Log4j笔记/" itemprop="url">
                  Log4j笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-08T00:00:00+08:00" content="2016-08-08">
              2016-08-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1、新建一个JAva工程，导入包log4j-1.2.17.jar，整个工程最终目录如下</p>
<p><img src="http://i.imgur.com/8ZkEHMI.png" alt=""></p>
<p>2、src同级创建并设置log4j.properties</p>
<pre><code>### 设置###
log4j.rootLogger = debug,stdout,D,E

### 输出信息到控制抬 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss,SSS} [%p] method:%l%n%m%n

### 输出DEBUG级别以上的日志到=E://logs/error.log ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = E://logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG 
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 输出ERROR级别以上的日志到=E://logs/error.log ###
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File =E://logs/error.log 
log4j.appender.E.Append = true
log4j.appender.E.Threshold = ERROR 
log4j.appender.E.layout = org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><p>3、设置日志内容</p>
<pre><code>package com.mucfc;
import org.apache.log4j.Logger;
/**
 *@author linbingwen
 *@2015年5月18日9:14:21
 */
public class Test {
    private static Logger logger = Logger.getLogger(Test.class);  

    /** 
     * @param args 
     */  
    public static void main(String[] args) {  
        // System.out.println(&quot;This is println message.&quot;);  

        // 记录debug级别的信息  
        logger.debug(&quot;This is debug message.&quot;);  
        // 记录info级别的信息  
        logger.info(&quot;This is info message.&quot;);  
        // 记录error级别的信息  
        logger.error(&quot;This is error message.&quot;);  
    }  

}
</code></pre><h2 id="Log4j的架构"><a href="#Log4j的架构" class="headerlink" title="Log4j的架构"></a>Log4j的架构</h2><p>Log4j由三个重要的组件构成：</p>
<ul>
<li>日志写入器：控制日志信息的优先级，日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG</li>
<li>日志输出终端：指定了日志将打印到控制台还是文件中</li>
<li>日志布局模式：控制日志信息的输出格式</li>
</ul>
<p><img src="http://i.imgur.com/5z0m4oX.png" alt=""></p>
<p>Logger类是日志包的核心，Logger的名称是大小写敏感的，并且名称之间有继承关系。子名由父名做前缀，用点号”.”分隔，如x.y是x.y.z的父亲Logger。</p>
<h2 id="Log4j基本使用方法"><a href="#Log4j基本使用方法" class="headerlink" title="Log4j基本使用方法"></a>Log4j基本使用方法</h2><h3 id="定义配置文件"><a href="#定义配置文件" class="headerlink" title="定义配置文件"></a>定义配置文件</h3><p><strong><em>1、配置根Logger，其语法为：</em></strong></p>
<pre><code>log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre><ul>
<li>level是日志记录的优先级，Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来</li>
<li>appenderName就是指日志信息输出到哪个地方。您可以同时指定多个输出目的地</li>
</ul>
<p><strong><em>2.配置日志信息输出目的地Appender，其语法为：</em></strong></p>
<pre><code>log4j.appender.appenderName = org.apache.log4j.DailyRollingFileAppender
</code></pre><p>其中，Log4j提供的appender有以下几种：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台），  </li>
<li>org.apache.log4j.FileAppender（文件），  </li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），  </li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  </li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<p><strong><em>3.配置日志信息的格式（布局），其语法为：</em></strong></p>
<pre><code>log4j.appender.appenderName.layout = org.apache.log4j.PatternLayout
</code></pre><p>其中，Log4j提供的layout有以e几种：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局），  </li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式），  </li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），  </li>
<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<h3 id="在代码中使用Log4j"><a href="#在代码中使用Log4j" class="headerlink" title="在代码中使用Log4j"></a>在代码中使用Log4j</h3><p><strong><em>1.得到记录器</em></strong></p>
<pre><code>static Logger logger = Logger.getLogger(Class clazz)；//在某对象中，用该对象所属的类作为参数
</code></pre><p><strong><em>2.读取配置文件()</em></strong></p>
<pre><code>PropertyConfigurator.configure ( String configFilename) ：读取使用Java的特性文件编写的配置文件
</code></pre><p>例如：</p>
<pre><code>PropertyConfigurator.configure(&quot;config/properties/log4j.properties&quot;);
</code></pre><p>在项目下面建立一个文件夹名为config即可，这是标准写法。注意log4j默认的相对路径是工程下面，非src或者bin</p>
<p><strong><em>3.插入记录信息（格式化日志信息）</em></strong></p>
<pre><code>Logger.debug ( Object message ) ;  
Logger.info ( Object message ) ;  
Logger.warn ( Object message ) ;  
Logger.error ( Object message ) ;
</code></pre><h3 id="配置文件相对路径"><a href="#配置文件相对路径" class="headerlink" title="配置文件相对路径"></a>配置文件相对路径</h3><pre><code>log4j.appender.R.File=${user.dir}/logs/log.log
</code></pre><h2 id="commons-logging-和-log4j-之间的关系"><a href="#commons-logging-和-log4j-之间的关系" class="headerlink" title="commons-logging 和 log4j 之间的关系"></a>commons-logging 和 log4j 之间的关系</h2><h3 id="Log4j与通用日志包commons-logging的结合使用"><a href="#Log4j与通用日志包commons-logging的结合使用" class="headerlink" title="Log4j与通用日志包commons-logging的结合使用"></a>Log4j与通用日志包commons-logging的结合使用</h3><p>其实commons-logging中<strong><em>默认都支持</em></strong> Log4j，因此只要同时加载commons-logging包和log4j包，可以不用配置即可用在应用中使用commons-logging的接口方法。    </p>
<p>当然，标准的应用的是需要的配置，如果你log4j则这个配置是可选的。下面我说明如何通过配置文件来组合commons-logging和log4j。</p>
<p>配置文件内容很简单，就指定一个日志实现类即可，下面是个示例文件commons-logging.properties：</p>
<pre><code>org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger
org.apache.commons.logging.LogFactory=org.apache.commons.logging.impl.LogFactoryImpl
</code></pre><h3 id="commons-logging-和-log4j-之间的关系-1"><a href="#commons-logging-和-log4j-之间的关系-1" class="headerlink" title="commons-logging 和 log4j 之间的关系"></a>commons-logging 和 log4j 之间的关系</h3><p>我们在做项目时，日志的记录是必不可少的一项任务，而我们通常是使用 apache 的 log4j 日志管理工具。然而，在项目中，我们经常会看到两个 jar 包：commons-logging.jar 和 log4j.jar。为什么我们在使用 log4j 的同时还要引入 commons-logging.jar 呢，或者说不用 commons-logging.jar 可不可以，这两者之间到底是怎么的一种关系呢？ </p>
<p>作为记录日志的工具，它至少应该包含如下几个组成部分(组件)： </p>
<ol>
<li>Logger<br> 记录器组件负责产生日志，并能够对日志信息进行分类筛选，控制什么样的日志应该被输出，什么样的日志应该被忽略。它还有一个重要的属性 － 日志级别。不管何种日志记录工具，大概包含了如下几种日志级别：DEBUG, INFO, WARN, ERROR 和 FATAL。 </li>
<li>Level<br> 日志级别组件。 </li>
<li>Appender<br> 日志记录工具基本上通过 Appender 组件来输出到目的地的，一个 Appender 实例就表示了一个输出的目的地。 </li>
<li>Layout<br> Layout 组件负责格式化输出的日志信息，一个 Appender 只能有一个 Layout。 </li>
</ol>
<p>我们再来看看 log4j.jar，打开 jar 包，我们可以看到 Logger.class(Logger)，Level.class(Level), FileAppender.class(Appender)， HTMLLayout.class(Layout)。其它的我们先忽略不看，这几个字节码文件正好是记录日志必不可少的几个组件。 </p>
<p>接下来看看 commons-logging 中的 org.apache.commons.logging.Log.java 源码： </p>
<pre><code>package org.apache.commons.logging;  
public interface Log {  
    public boolean isDebugEnabled();  
    public boolean isErrorEnabled();  
    public boolean isFatalEnabled();  
    public boolean isInfoEnabled();  
    public boolean isTraceEnabled();  
    public boolean isWarnEnabled();  
    public void trace(Object message);  
    public void trace(Object message, Throwable t);  
    public void debug(Object message);  
    public void debug(Object message, Throwable t);  
    public void info(Object message);  
    public void info(Object message, Throwable t);  
    public void warn(Object message);  
    public void warn(Object message, Throwable t);  
    public void error(Object message);  
    public void error(Object message, Throwable t);  
    public void fatal(Object message);  
    public void fatal(Object message, Throwable t);  
}  
</code></pre><p>很显然，只要实现了 Log 接口，它就是一个名副其实的 Logger 组件，也验证了 Logger 组件具有日志级别的属性。继续看 commons-logging org.apache.commons.logging.impl 包下的几个类的源码片段： </p>
<pre><code>package org.apache.commons.logging.impl;  

import org.apache.commons.logging.Log;  
import org.apache.log4j.Logger;  
import org.apache.log4j.Priority;  
import org.apache.log4j.Level;  
import ......  

public class Log4JLogger implements Log, Serializable {  
    // 对 org.apache.commons.logging.Log 的实现  
    ......  
}  

------------------------------------------------------------------  

package org.apache.commons.logging.impl;  

import org.apache.commons.logging.Log;  
import java.io.Serializable;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

public class Jdk14Logger implements Log, Serializable {  
     // 对 org.apache.commons.logging.Log 的实现  
    ......  
}  
</code></pre><p>好了，分析到这里，我们应该知道，<font color="red">真正的记录日志的工具是 log4j 和 sun 公司提供的日志工具。而 commons-logging 把这两个(实际上，在 org.apache.commons.logging.impl 包下，commons-logging 仅仅为我们封装了 log4j 和 sun logger)记录日志的工具重新封装了一遍(Log4JLogger.java 和 Jdk14Logger.java)，可以认为 org.apache.commons.logging.Log 是个傀儡，它只是提供了对外的统一接口。因此我们只要能拿到 org.apache.commons.logging.Log，而不用关注到底使用的是 log4j 还是 sun logger。</font>正如我们经常在项目中这样写： </p>
<pre><code>// Run 是我们自己写的类，LogFactory 是一个专为提供 Log 的工厂(abstract class)  
private static final Log logger = LogFactory.getLog(Run.class);  
</code></pre><p>既然如此，我们向构建路径加了 commons-logging.jar 和 log4j.jar 两个 jar 包，那我们的应用程序到底使用的 log4j 还是 sun logger 呢？我们能不能认为由于加了 log4j.jar 包，就认为系统使用的就是 log4j 呢？事实上当然不是这样的，那我还认为我正在使用 jdk 而认为系统使用的是 sun logger 呢。使用 Spring 的朋友可以在 web.xml 中看到如下 listener 片段： </p>
<pre><code>&lt;listener&gt;  
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;  
&lt;/listener&gt;  
</code></pre><p>这是由 Spring 为我们提供的实现了标准的 servlet api 中的 javax.servlet.ServletContextListener 接口，用于在 web 容器启动时做一些初始化操作。我们逐层进入 Spring 的源码，可以看到如下代码： </p>
<pre><code>Log4jConfigurer.initLogging(location, refreshInterval);  
</code></pre><p>终于找到了 org.springframework.util.Log4jConfigurer，这正是 log4j 提供给我们的初始化日志的类。至此，我们终于明白了我们系统的的确确使用的是 log4j 的日志工具。 </p>
<p>可是问题又来了，org.apache.commons.logging.Log 和 org.apache.log4j.Logger 这两个类，通过包名我们可以发现它们都是 apache 的项目，既然如下，为何要动如此大的动作搞两个东西(指的是 commons-logging 和 log4j)出来呢？事实上，在 sun 开发 logger 前，apache 项目已经开发了功能强大的 log4j 日志工具，并向 sun 推荐将其纳入到 jdk 的一部分，可是 sun 拒绝了 apache 的提议，sun 后来自己开发了一套记录日志的工具。可是现在的开源项目都使用的是 <font color="red"><strong><em>log4j</em></strong></font>，log4j 已经成了事实上的标准，但由于又有一部分开发者在使用 <font color="red"><strong><em>sun logger</em></strong></font>，因此 apache 才推出 commons-logging，<font color="red"><strong><em>使得我们不必关注我们正在使用何种日志工具</em></strong></font>。</p>
<h2 id="slf4j-api、slf4j-log4j12以及log4j之间的关系"><a href="#slf4j-api、slf4j-log4j12以及log4j之间的关系" class="headerlink" title="slf4j-api、slf4j-log4j12以及log4j之间的关系"></a>slf4j-api、slf4j-log4j12以及log4j之间的关系</h2><p>几乎在每个jar包里都可以看到log4j的身影，在多个子工程构成项目中，slf4j相关的冲突时不时就跳出来让你不爽，那么slf4j-api、slf4j-log4j12还有log4j是什么关系？ </p>
<p><strong><em>slf4j:Simple Logging Facade for Java，为java提供的简单日志Facade。</em></strong>Facade门面，更底层一点说就是<strong>接口</strong>。<font color="red"><strong><em>它允许用户以自己的喜好，在工程中通过slf4j接入不同的日志系统</em></strong></font>。更直观一点，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。</p>
<p>因此slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此slf4j-api本质就是一个接口定义。</p>
<p>下图比较清晰的描述了它们之间的关系，例子为当系统采用log4j作为日志框架实现的调用关系：</p>
<p><img src="http://i.imgur.com/0GvNDWm.png" alt=""></p>
<p>①首先系统包含slf4j-api作为日志接入的接口。<font color="red">compile时slf4j-api中public final class LoggerFactor类中private final static void bind()方法会寻找具体的日志实现类绑定，主要通过StaticLoggerBinder.getSingleton()的语句调用。</font></p>
<p>②slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法。</p>
<p>③log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codeceo.com/article/log4j-usage.html" target="_blank" rel="external">http://www.codeceo.com/article/log4j-usage.html</a><br><a href="http://blog.csdn.net/hpf911/article/details/5852127" target="_blank" rel="external">http://blog.csdn.net/hpf911/article/details/5852127</a><br><a href="http://www.tuicool.com/articles/U7ZjUni" target="_blank" rel="external">http://www.tuicool.com/articles/U7ZjUni</a><br><a href="http://zachary-guo.iteye.com/blog/361177" target="_blank" rel="external">http://zachary-guo.iteye.com/blog/361177</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/[网络安全]Dos攻击原理及防御/" itemprop="url">
                  Dos攻击原理及防御
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T00:00:00+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Dos攻击简介"><a href="#Dos攻击简介" class="headerlink" title="Dos攻击简介"></a>Dos攻击简介</h2><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，<strong><em>其目的是使计算机或网络无法提供正常的服务</em></strong>。最常见的DoS攻击有计算机网络 <strong><em>带宽攻击</em></strong>和 <strong><em>连通性攻击</em></strong>。</p>
<ul>
<li><strong><em>带宽攻击</em></strong> 指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。</li>
<li><strong><em>连通性攻击</em></strong> 指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。</li>
</ul>
<h2 id="DDos攻击简介"><a href="#DDos攻击简介" class="headerlink" title="DDos攻击简介"></a>DDos攻击简介</h2><p>传统上，攻击者所面临的主要问题是网络带宽，由于较小的网络规模和较慢的网络速度的限制，攻击者无法发出过多的请求。但大多数的DoS攻击还是需要相当大的带宽的，而以个人为单位的黑客们很难使用高带宽的资源。为了克服这个缺点，DoS攻击者开发了分布式的攻击。攻击者简单利用工具集合许多的网络带宽来同时对同一个目标发动大量的攻击请求，这就是DDoS(Distributed Denial of Service)攻击。</p>
<h2 id="攻击表现方式★★★"><a href="#攻击表现方式★★★" class="headerlink" title="攻击表现方式★★★"></a>攻击表现方式★★★</h2><p>无论是DoS攻击还是DDoS攻击，简单的看，都只是一种破坏网络服务的黑客方式，虽然具体的实现方式千变万化，但都有一个共同点，就是其根本目的是使受害主机或网络无法及时接收并处理外界请求，或无法及时回应外界请求。其具体表现方式有以下几种：</p>
<p>　1. 制造大流量<strong><em>无用数据</em></strong>，造成通往被攻击主机的网络拥塞，使被攻击主机无法正常和外界通信。<br>　2. 利用被攻击主机提供服务或传输协议上处理重复连接的缺陷，反复高频的发出攻击性的 <strong><em>重复服务请求</em></strong>，使被攻击主机无法及时处理其它正常的请求。<br>　3. 利用被攻击主机所提供服务程序或传输协议的本身实现缺陷，反复发送 <strong><em>畸形的攻击数据</em></strong> 引发系统错误的分配大量系统资源，使主机处于挂起状态甚至死机。</p>
<h2 id="TCP三次连接及重要概念"><a href="#TCP三次连接及重要概念" class="headerlink" title="TCP三次连接及重要概念"></a>TCP三次连接及重要概念</h2><h3 id="TCP连接三次握手"><a href="#TCP连接三次握手" class="headerlink" title="TCP连接三次握手"></a>TCP连接三次握手</h3><p>要理解dos攻击，首先要理解TCP连接的三次握手过程(Three-way handshake)。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<div align="center"><br><img src="http://i.imgur.com/sSu5DYG.jpg" alt=""><br></div>

<ul>
<li>第一次握手:建立连接时，客户端发送 <strong><em>SYN</em></strong> 包((SYN=i)到服务器，并进入 <strong><em>SYN_SEND</em></strong> 状态，等待服务器确认;</li>
<li>第二次握手:服务器收到SYN包，必须确认客户的SYN (ACK=i+1 )，同时自己也发送一个SYN包((SYN=j)}即 <strong><em>SYN+ACK</em></strong> 包，此时服务器进入 <strong><em>SYN_RECV</em></strong> 状态;</li>
<li>第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包 <strong><em>ACK</em></strong> (ACK=j+1)，此包发送完毕，客户端和服务器进入 <strong><em>ESTABLISHED</em></strong> 状态，完成三次握手，客户端与服务器开始传送数据。</li>
</ul>
<h3 id="一些重要概念"><a href="#一些重要概念" class="headerlink" title="一些重要概念"></a>一些重要概念</h3><ul>
<li>半连接：<strong><em>收到SYN包而还未收到ACK包时的连接状态</em></strong> 称为半连接，即尚未完全完成三次握手的TCP连接。</li>
<li>半连接队列：在三次握手协议中，服务器维护一个半连接队列，<strong><em>该队列为每个客户端的SYN包(SYN=i)开设一个条目</em></strong>，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</li>
<li>Backlog参数：表示半连接队列的<strong><em>最大容纳数目</em></strong>。</li>
<li>SYN-ACK重传次数：<strong><em>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传</em></strong>，等待一段时间仍未收到客户确认包，进行第二次重传，<strong><em>如果重传次数超过系统规定的最大重传次数，系统将该连接信息、从半连接队列中删除</em></strong>。注意，每次重传等待的时间不一定相同。</li>
<li>半连接存活时间：是指半连接队列的条目存活的最长时间，也即<strong><em>服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和</em></strong>。有时也称半连接存活时间为Timeout时间、SYN_RECV存活时间。</li>
<li>上面 <strong><em>三个参数</em></strong> 对系统的TCP连接状况有很大影响</li>
</ul>
<h2 id="常见攻击与防范参考"><a href="#常见攻击与防范参考" class="headerlink" title="常见攻击与防范参考"></a>常见攻击与防范参考</h2><h3 id="SYN-Flood攻击（SYN洪水攻击）"><a href="#SYN-Flood攻击（SYN洪水攻击）" class="headerlink" title="SYN Flood攻击（SYN洪水攻击）"></a>SYN Flood攻击（SYN洪水攻击）</h3><p><strong><em>大纲：</em></strong><br><img src="http://i.imgur.com/SKds3zZ.png" alt=""></p>
<div style="display:none;"><br>    <table cellspacing="0px"><br>        <tr><th>Dos攻击形式</th><th>解决方法</th></tr><br>        <tr><td>1、固定源地址发起攻击</td><td>检测到某个IP地址发起较多报文，加入黑名单</td></tr><br>        <tr><td>2、伪造IP地址进行攻击</td><td rowspan="2">方法1失效，原因：<br>    1、单个IP发送的SYN报文不会很多，达不到被拒绝的阈值<br>    2、伪装的IP若被拒绝到，正常用户使用该IP将会无法获得服务<br>    3、可以用三种解决方法方法，如下表</td></tr><br>        <tr><td>3、僵尸网络固定源地址发起攻击</td></tr><br>    </table><br><br>    <table cellspacing="0px"><br>        <tr><th>解决方法</th><th>问题</th></tr><br>        <tr><td>方法一：不断监视系统中连接队列，达到阈值就释放系统连接</td><td>入门级防御SYN Flood方法，正常连接也会淹没在其中而被释放</td></tr><br>        <tr><td>方法二：延缓TCB分配</td><td>1、SYS Cache：cache（哈希表）中保存半连接信息，收到正确回应ACK后再分配TCB<br>    2、SYN cookie：根据SYN包按照一定的规则计算SYN+ACK包的初始序列。客户端返回ACK再次校验，若正确才分配TCB</td></tr><br>        <tr><td>方法三：使用SYN Proxy防火墙</td><td>防火墙提供SYN代理，验证成功后才放行</td></tr><br>    </table><br></div>

<p><strong><em>原理：</em></strong></p>
<ul>
<li>问题就出在TCP连接的三次握手中，假设一个用户<strong><em>向服务器发送了SYN报文后突然死机或掉线</em></strong>，那么服务器在发出SYN+ACK应答报文后是<strong><em>无法收到客户端的ACK报文</em></strong>的(第三次握手无法完成)，这种情况下服务器端一般会重试(<strong><em>再次发送SYN+ACK给客户端</em></strong>)，并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为<strong><em>SYN Timeout</em></strong>，一般来说这个时间是分钟的数量级(<strong><em>大约为30秒 - 2分钟</em></strong>);</li>
<li>一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源<ul>
<li><strong><em>数以万计的半连接</em></strong>，即使是简单的<strong><em>保存并遍历也会消耗非常多的CPU时间和内存</em></strong>，何况还要不断对这个列表中的IP进行<strong><em>SYN+ACK的重试</em></strong>。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃</li>
<li>即使服务器端的<strong><em>系统足够强大</em></strong>，服务器端也将忙于处理攻击者伪造的TCP连接请求而<strong><em>无暇理睬客户的正常请求</em></strong>(毕竟客户端的正常请求比率非常之小)，此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击(SYN洪水攻击)。</li>
</ul>
</li>
</ul>
<p><strong><em>SYN Flood种类：</em></strong></p>
<p><img src="http://i.imgur.com/jLdacJD.jpg" alt=""></p>
<ol>
<li>Direct Attack 攻击方使用 <strong><em>固定的源地址</em></strong> 发起攻击，这种方法对攻击方的消耗最小</li>
<li>Spoofing Attack 攻击方使用变化的源地址发起攻击，这种方法需要攻击方 <strong><em>不停地修改源地址</em></strong>，实际上消耗也不大</li>
<li>Distributed Direct Attack 这种攻击主要是使用<strong><em>僵尸网络</em></strong>进行<strong><em>固定源地址</em></strong>的攻击</li>
</ol>
<p><strong><em>防范：</em></strong></p>
<p>对于第一种攻击的防范可以使用比较简单的方法，即对SYN包进行监视，如果发现某个IP发起了较多的攻击报文，直接将这个<strong><em>IP列入黑名单</em></strong>即可。当然下述的方法也可以对其进行防范。<br>对于源地址不停变化的攻击使用上述方法则不行，首先从某一个被伪装的IP过来的Syn报文可能不会太多，<strong><em>达不到被拒绝的阈值</em></strong>，其次从这个<strong><em>被伪装的IP（真实的）的请求会被拒绝掉</em></strong>，即导致正常用户使用该IP将会无法访问服务。因此必须使用其他的方法进行处理。</p>
<p><strong>1． 无效连接监视释放</strong><br>　　这种方法不停<strong><em>监视系统的半开连接和不活动连接</em></strong>，当<strong><em>达到一定阈值时拆除这些连接</em></strong>，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级防御SYN Flood方法。</p>
<p><strong>2． 延缓TCB分配方法</strong><br>　　从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，<font color="red">当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗</font>。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<p>　　<strong>Syn Cache技术：</strong><br>　　这种技术是在收到SYN数据报文时<strong><em>不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB</em></strong>。在FreeBSD系统中这种Cache每个半开连接只需使用160字节，远小于TCB所需的736个字节。在发送的SYN ACK中需要使用一个己方的Sequence Number，这个数字不能被对方猜到，否则对于某些稍微智能一点的Syn Flood攻击软件来说，它们在发送Syn报文后会发送一个ACK报文，如果己方的Sequence Number被对方猜测到，则会被其建立起真正的连接。因此一般采用一些加密算法生成难于预测的Sequence Number。</p>
<p>　　<strong>Syn Cookie技术：</strong><br>　　对于SYN攻击，Syn Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，<strong><em>还是需要使用一些空间去保存己方生成的Sequence Number等信息</em></strong>，也造成了一些资源的浪费。<br>　　<strong><em>Syn Cookie技术则完全不使用任何存储资源</em></strong>，这种方法比较巧妙，它<strong><em>使用一种特殊的算法生成Sequence Number</em></strong>，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，<strong><em>重新计算一遍</em></strong>，看其是否与<strong><em>对方回应报文中的（Sequence Number-1）相同</em></strong>，从而决定是否分配TCB资源。(<font color="red">在接收到syn包后不分配TCB资源，而是根据SYN包计算出一个cookie，这个cookie作为将要返回syn+ack包的序号列，服务器中不存储序列号。下次客户端返回ack包时，再根据包头信息计算cookie，与ack包的序号加一进行对比，如果相等，则说明是正常的连接，分配资源建立连接</font>)</p>
<p><strong>3． 使用SYN Proxy防火墙</strong><br>　　Syn Cache技术和Syn Cookie技术总的来说是一种<strong><em>主机保护技术</em></strong>，需要系统的<strong><em>TCP/IP协议栈的支持</em></strong>，而目前<strong><em>并非所有的操作系统支持这些技术</em></strong>。因此很多防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p>
<p><img src="http://i.imgur.com/dR07Uvz.jpg" alt=""></p>
<p>　　从上图（左图）中可以看出，防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，在右图中，所有的无效连接均无法到达内部的服务器。而<strong><em>防火墙采用的验证连接有效性的方法则可以是Syn Cookie或Syn Flood等其他技术</em></strong>。<br>　　采用这种方式进行防范需要注意的一点就是防火墙需要对整个有效连接的过程发生的数据包<strong><em>进行代理</em></strong>，如下图所示：</p>
<div align="center"><br><img src="http://i.imgur.com/pM1a1P3.gif" alt=""><br></div>

<p>　　因为防火墙代替发出的SYN ACK包中使用的序列号为c，而服务器真正的回应包中序列号为c’，这其中有一个差值<strong><em>|c-c’|</em></strong>，在每个相关数据报文经过防火墙的时候进行序列号的修改。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>什么是Dos攻击？<br><a href="http://blog.csdn.net/justdoitflyer/article/details/12870907" target="_blank" rel="external">http://blog.csdn.net/justdoitflyer/article/details/12870907</a><br>SYN Flood攻击及防御方法<br><a href="http://blog.csdn.net/bill_lee_sh_cn/article/details/6065704" target="_blank" rel="external">http://blog.csdn.net/bill_lee_sh_cn/article/details/6065704</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/[Linux]磁盘分区/" itemprop="url">
                  磁盘分区
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T00:00:00+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="磁盘连接方式与设备文件名的关系"><a href="#磁盘连接方式与设备文件名的关系" class="headerlink" title="磁盘连接方式与设备文件名的关系"></a>磁盘连接方式与设备文件名的关系</h2><ul>
<li>计算机常用的磁盘接口有两种，分别是IDE与SATA接口，目前主流是SATA接口</li>
<li>一个IDE电缆可以连接两个IDE设备，通常主机提供两个IDE接口，因此最多可以接四个IDE设备。IDE设备分为主设备（Master）与从设备（Slave），四个IDE设备的文件名分别是<strong>/dev/hda、/dev/hdb、/dev/hdc/、/dev/hdd</strong>，对应IDE1的主设备、IDE1的从设备、IDE2的主设备、IDE2的从设备</li>
<li>SATA/USB/SCSI接口的磁盘设备文件名都是<strong>/dev/sd[a-p]</strong>，与IDE接口不同的是，SATA/USB接口没有一定的顺序，根据<strong>Linux内核检测到的磁盘顺序决定</strong>，即设备文件名与插槽号无关，Linux内核根据SATA插槽顺序进行检测磁盘，USB在开机候才被系统识别<br><img src="http://i.imgur.com/WXsDx1n.jpg" alt=""></li>
</ul>
<h2 id="磁盘组成"><a href="#磁盘组成" class="headerlink" title="磁盘组成"></a>磁盘组成</h2><ul>
<li>磁盘由盘片、机械手臂、磁头与主轴马达组成，数据的写入是在盘片上</li>
<li>盘片上可以细分为扇区与柱面两种单位</li>
<li>磁道：盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道</li>
<li>柱面：硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面。磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用</li>
<li>扇区：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，每个扇区可以存放512个字节的信息，磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位</li>
</ul>
<p><img src="http://img.mydigit.net/Mon_1111/84_493179_8d87dfa7e9d372c.jpg?26" alt=""></p>
<p><strong><em>问题1：不同磁道的扇区数是否相同？</em></strong></p>
<ul>
<li><p><strong>在旧的记录方式</strong>，的确每个磁道所拥有的扇区数量都是一样的。因为每个扇区所能容纳的数据量是相同的，都是512字节，而数据量需要平均分配在扇区面积的每个角落，所以外面扇区的数据密度低，里面扇区的速度密度高<br><img src="http://i.imgur.com/zHHLPEj.png" alt=""></p>
</li>
<li><p><strong>新的解决方式</strong>认为，既然磁盘越往外面积越大，那就应该划分出更多的扇区，每个扇区的面积都是一样的，容纳的数据量也是一样的<br><img src="http://i.imgur.com/0kRy8Wz.png" alt=""></p>
</li>
</ul>
<p><strong><em>问题2：如果有一块空硬盘，写入一个文件，是不是先写满同一个磁道的所有扇区，然后再换一个磁道写入？</em></strong></p>
<p>　　是的，而且<strong>写入的方式是从外到内</strong>，先写满最外的磁道，接着再写里面的磁道。为什么硬盘用久了读写速度会变慢？因为外面的磁道使用完了，开始用里面的磁道，越是里面的磁道读写速度越慢，同样的时间，读写头在外面磁道可以扫过10个扇区的面积，读写10个扇区的数据，但在里面的磁道只能扫过1个扇区的面积，读写1个扇区的数据，所以这时该做磁盘整理或者格式化，这会使外面的磁道得到使用</p>
<h2 id="磁盘的第一扇区（主引导分区、分区表）"><a href="#磁盘的第一扇区（主引导分区、分区表）" class="headerlink" title="磁盘的第一扇区（主引导分区、分区表）"></a>磁盘的第一扇区（主引导分区、分区表）</h2><p>磁盘的第一个扇区记录了两个重要信息，分别是：</p>
<ul>
<li>主引导分区（MBR），可以安装引导加载程序的地方，有446bytes。MBR是很重要的，系统在<strong>开机的时候会主动去读取这个区块的内容，这样系统才知道你的程序放在哪里且如何进行开机。</strong>如果你要安装多重引导的系统，MBR这个区块的管理就非常重要了</li>
<li>分区表，记录整块硬盘分区的状态，有64bytes </li>
</ul>
<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p><img src="http://i.imgur.com/Y8b8nPX.png" alt=""></p>
<ul>
<li>柱面是分割磁盘的最小单位，以开始柱面与结束柱面来标识一个分区</li>
<li>假设上面硬盘的设备文件名为/dev/hda，四个分区的设备文件名会在文件名后再加上一个数字，分别是/dev/hda1，/dev/hda2，/dev/hda3，/dev/hda4</li>
<li>上述硬盘被分为四个分区，第四个分区为301~400柱面的范围，在windows系统中，四个分区分别是C、D、E、F。当你把数据写入F盘时，你的数据会被写入这块磁盘的301~400号柱面之间</li>
<li><p><strong>分区表总结</strong></p>
<ul>
<li><strong>所谓的分区就是对64bytes的分区表进行设置而已</strong></li>
<li>分区的最小单位是柱面</li>
<li><strong>分区表默认只能写入四组分区信息，即主分区与扩展分区不超过四个</strong></li>
<li>系统要写入磁盘时，必须参考分区表，才能对某个分区进行数据处理</li>
<li>分区的好处：数据安全，系统性能</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/U8YbelW.png" alt=""></p>
<ul>
<li><p>分区继续深入</p>
<ul>
<li>上图中四个分区记录区仅用到两个，P1为主分区，P2为扩展分区</li>
<li>图中这5个由扩展分区切出来的分区叫做逻辑分区</li>
<li>上述分区在Linux下的设备文件名分别是P1：hda1，P2：hda2，L1：hda5，L2：hda6，L3：hda7，L4：hda8，L5：hda9</li>
<li><strong>发现少了hda3，hda4，因为前面四个号码都是保留给主分区和扩展分区用的，所以逻辑分区的设备号从5开始</strong></li>
</ul>
</li>
<li><p><strong>分区总结</strong></p>
<ul>
<li>主分区和扩展分区最多有四个</li>
<li>扩展分区最多只有一个（操作系统的限制）</li>
<li>逻辑分区是由扩展分区切割出来的分区</li>
<li>能够被格式化的是主分区和逻辑分区，扩展分区无法格式化 </li>
</ul>
</li>
</ul>
<h2 id="MBR（Master-boot-Record）主引导分区"><a href="#MBR（Master-boot-Record）主引导分区" class="headerlink" title="MBR（Master boot Record）主引导分区"></a>MBR（Master boot Record）主引导分区</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ul>
<li>操作系统的作用是控制计算机硬件资源的合理分配，但操作系统也是一个软件，从开机到执行操作系统软件的过程如下：</li>
<li>CMOS是记录各项硬件参数且嵌在主板上的存储器，BIOS是写入到主板的一个软件程序，<strong>是计算机开机主动执行的第一个的程序</strong></li>
<li><strong><em>BIOS</em></strong> 会根据用户的设置取得能够开机的硬盘，并读取该硬盘第一个扇区的 <strong><em>MBR</em></strong> 位置，MBR中会放置 <font color="red"><strong><em>引导加载程序</em></strong></font>，引导加载程序的目的是加载内核文件，<strong><em>内核文件</em></strong> 开始操作系统的功能</li>
</ul>
<h3 id="多系统"><a href="#多系统" class="headerlink" title="多系统"></a>多系统</h3><ul>
<li>引导加载程序的主要功能是读取内核文件，开始操作系统。在多系统中，引导加载程序能提供用户不同的开机选项，并将加载功能转交给其他引导加载程序</li>
<li>引导加载程序不但可以放置在MBR中，还可以安装在每个分区的引导扇区</li>
<li>如下图是windows和Linux双系统，开机时MBR的引导加载程序提供两个菜单，菜单一（M1）可以直接加载Windows内核文件来开机，菜单二（M2）则将引导加载工作移交给第二个分区的引导加载程序，加载Linux的内核文件来开机<br><img src="http://i.imgur.com/XFSpuWG.png" alt=""></li>
</ul>
<p><strong><em>为什么装双系统，最好先装windows再装Linux？</em></strong></p>
<ul>
<li>因为Linux在安装时，可以选择将<font color="red"> <strong><em>引导加载加载程序</em></strong> </font>安装在MBR还是个别分区的引导扇区</li>
<li>Windows安装时，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/[Java]JAVA深复制(深克隆)与浅复制(浅克隆)/" itemprop="url">
                  JAVA深复制(深克隆)与浅复制(浅克隆)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:00:00+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html" target="_blank" rel="external">http://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html</a></p>
<h2 id="浅复制与深复制概念"><a href="#浅复制与深复制概念" class="headerlink" title="浅复制与深复制概念"></a>浅复制与深复制概念</h2><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a><em>浅复制</em></h3><p>　　被复制的对象的成员变量与原来的对象都有相同的值，但引用其他对象的成员变量仍指向原来的对象，修改引用对象的值，会同时影响原对象与复制对象。换言之，<strong>浅复制仅仅复制所考虑的对象，不复制它引用的对象</strong>。</p>
<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a><em>深复制</em></h3><p>　　被复制的对象的所有成员变量与原来对象都有相同的值，而且引用其他对象的成员变量将指向被复制过的新对象。换言之，<strong>深复制把要复制的对象及所引用的对象都复制了一遍。</strong></p>
<h2 id="java-lang-Object类的clone-方法是浅复制"><a href="#java-lang-Object类的clone-方法是浅复制" class="headerlink" title="java.lang.Object类的clone()方法是浅复制"></a>java.lang.Object类的clone()方法是浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.clone();</div><div class="line">		</div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class student implements Cloneable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null;</div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>student 18
student 18
</code></pre><p>因为复制对象中成员变量引用的对象professor不变，当改变新复制对象的成员变量引用值，对原对象也会有影响。<br><img src="http://img.blog.csdn.net/20160504171513907" alt="这里写图片描述"></p>
<h2 id="实现深层次克隆方法1"><a href="#实现深层次克隆方法1" class="headerlink" title="实现深层次克隆方法1"></a>实现深层次克隆方法1</h2><p>　　在复制对象时，对引用的对象也进行复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.clone();</div><div class="line">		</div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class student implements Cloneable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null;</div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">			((student)o).p = (professor)this.p.clone();//核心</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor implements Cloneable&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null; </div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实现深层次克隆方法2"><a href="#实现深层次克隆方法2" class="headerlink" title="实现深层次克隆方法2"></a>实现深层次克隆方法2</h2><p>　　利用串行化来做深复制，在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args) throws Exception&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.deepClone();</div><div class="line"></div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class student implements Serializable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line">	public Object deepClone() throws Exception&#123;</div><div class="line">		//将对象写到流里</div><div class="line">		ByteArrayOutputStream bo = new ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream oo = new ObjectOutputStream(bo);</div><div class="line">		oo.writeObject(this);</div><div class="line">		//从流里读出来</div><div class="line">		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());</div><div class="line">		ObjectInputStream oi = new ObjectInputStream(bi);</div><div class="line">		return oi.readObject();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor implements Serializable&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<pre><code>student 40
student 18
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java面向对象编程的四大特征/" itemprop="url">
                  Java面向对象编程的四大特征
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:00:00+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>　　我们在前面去定义一个类时候，实际上就是把一类事物的共有的属性和行为提取出来，形成一个物理模型(模版)。这种研究问题的方法称为抽象。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>　　封装就是把抽象出来的数据和对数据的操作封装在一起。数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作。</p>
<p>###<em>访问控制修饰符</em><br><img src="http://img.blog.csdn.net/20160416152720709" alt="这里写图片描述"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>　　继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类(比如刚才的Student)，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要继承父类,这样子类就会自动拥有父类定义的某些属性和方法。
　　</p>
<h3 id="父类哪些属性、方法被子类继承"><a href="#父类哪些属性、方法被子类继承" class="headerlink" title="父类哪些属性、方法被子类继承"></a><em>父类哪些属性、方法被子类继承</em></h3><p>　　父类的public修饰符的属性和方法；protected修饰符的属性和方法；默认修饰符属性和方法被子类继承了，父类的private修饰符的属性和方法不能被子类继承。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><em>注意事项</em></h3><p>　　1. 子类最多只能继承一个父类(指直接继承)<br>　　2. java所有类都是Object类的子类 </p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a><em>方法重载（overload）</em></h3><p>　　简单的说：方法重载就是在类的同一种功能的多种实现方式，具有相同的方法名，但方法的参数类型、个数、顺序不同。<strong>到底采用哪种方式，取决于调用者给出的参数</strong>。<br>　　<br>注意事项</p>
<p>　　1. 方法返回类型可以不同(只是返回类型不一样，不能构成重载)<br>　　2. 方法的修饰符可以不同(只是控制访问修饰符不同，不能构成重载)</p>
<h3 id="方法覆盖（override）"><a href="#方法覆盖（override）" class="headerlink" title="方法覆盖（override）"></a><em>方法覆盖（override）</em></h3><p>　简单的说：方法覆盖就是<strong>子类</strong>有一个方法，和<strong>父类</strong>的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。</p>
<p>注意事项：</p>
<p>　　1、子类的方法的返回类型，参数，方法名称，要和父类的返回类型，参数，方法名称完全一样，否则编译出错。<br>　　2、子类方法不能缩小父类方法的访问权限，可以放大访问权限。★★★★</p>
<h3 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a><em>多态概念</em></h3><p>　　所谓多态，就是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的指针，来调用在不同子类中实现的方法。<br>　　实现多态有两种方式：1、继承；2、接口</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java类加载器深入讲解/" itemprop="url">
                  Java类加载器深入讲解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:00:00+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器?"></a>什么是类加载器?</h2><p>　　加载类的工具，把硬盘上.class文件加载到内存，并进行一些处理，得到字节码</p>
<h2 id="类加载器有什么作用"><a href="#类加载器有什么作用" class="headerlink" title="类加载器有什么作用?"></a>类加载器有什么作用?</h2><p>　　当程序需要的某个类，那么需要通过类加载器把类的二进制加载到内存中，类加载器也是Java类</p>
<h2 id="类加载器之间的父子关系和管辖范围。"><a href="#类加载器之间的父子关系和管辖范围。" class="headerlink" title="类加载器之间的父子关系和管辖范围。"></a>类加载器之间的父子关系和管辖范围。</h2><p><img src="http://my.csdn.net/uploads/201207/12/1342057661_9458.png" alt="类加载器之间的父子关系和管辖范围图"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#获得类加载器的名字</div><div class="line">ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</div><div class="line">while (classLoader != null) &#123;</div><div class="line">    System.out.println(classLoader.getClass().getName());</div><div class="line">    classLoader = classLoader.getParent();</div><div class="line">&#125;</div><div class="line">System.out.println(classLoader);</div></pre></td></tr></table></figure>
<p><img src="http://my.csdn.net/uploads/201207/12/1342057738_7123.png" alt="此处输入图片的描述"></p>
<p>##4. 类加载器的委托机制:</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a><strong>类的加载</strong></h3><ol>
<li>当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢?<br>　　①首先 <strong>当前线程的类加载器</strong> 去加载线程中的第一个类.<br>　　②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B<br>　　③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类.</li>
<li>每个类加载器加载类时，又<strong>先委托给其上级类加载器</strong><br>　　<strong>当所有祖宗类加载器没有加载到类，回到发起者类加载器</strong>，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。</li>
</ol>
<h3 id="委托机制有什么好处"><a href="#委托机制有什么好处" class="headerlink" title="委托机制有什么好处?"></a><strong>委托机制有什么好处?</strong></h3><ul>
<li>集中管理，如果我们写了几个类加载器，都去加载某个类，那么内存中就有多份这个类的字节码</li>
<li>安全。系统类由系统的类加载器加载</li>
</ul>
<h3 id="能不能自己写一个类叫java-lang-System"><a href="#能不能自己写一个类叫java-lang-System" class="headerlink" title="能不能自己写一个类叫java.lang.System?"></a><strong>能不能自己写一个类叫java.lang.System?</strong></h3><p>　　为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸优先，也就是使用的永远是爸爸的(系统的)System类，而不是我们写的System类.</p>
<h2 id="编写自己的类加载器"><a href="#编写自己的类加载器" class="headerlink" title="编写自己的类加载器"></a>编写自己的类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　然后在新建一个类，通过上面的方法将新建的类的字节码进行加密:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderAttachment</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123; <span class="comment">//为什么要继承Date待会再说?</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello，itcast"</span>;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　并在工程里新建一个文件夹，用来保存加密后的class文件.<br>　　<img src="http://my.csdn.net/uploads/201207/12/1342057789_4367.png" alt="此处输入图片的描述"><br>　　那么这就需要使用我们自己的类加载器来进行解密了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> String classDir;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        String classFileName = classDir + <span class="string">"\\"</span> + name.substring(name.lastIndexOf(<span class="string">'.'</span>)+<span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFileName);</div><div class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            cypher(fis，bos);</div><div class="line">            fis.close();</div><div class="line">            System.out.println(<span class="string">"aaa"</span>);</div><div class="line">            <span class="keyword">byte</span>[] bytes = bos.toByteArray();</div><div class="line">            <span class="keyword">return</span> defineClass(bytes， <span class="number">0</span>， bytes.length);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.classDir = classDir;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试运行代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class clazz = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClass"</span>).loadClass(<span class="string">"ClassLoaderAttachment"</span>);</div><div class="line"><span class="comment">//此处不能在使用ClassLoaderAttachment因为一旦用了之后，</span></div><div class="line"><span class="comment">//系统的类加载器就会去加载，导致失败，所以该类就继承了Date类了.</span></div><div class="line">Date date = (Date)clazz.newInstance();</div><div class="line">System.out.println(date);</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://my.csdn.net/uploads/201207/12/1342057844_5083.jpg" alt="此处输入图片的描述"></p>
<h2 id="一个类加载器的高级问题"><a href="#一个类加载器的高级问题" class="headerlink" title="一个类加载器的高级问题:"></a>一个类加载器的高级问题:</h2><p>　　我们知道tomcat服务器，是一个大大的java程序，那么它就必须在JVM上运行.这个大大的java程序内部也写了很多类加载器，它用这些类加载器去加载一些特定的类.注入servlet类.<br>下面我们新建一个javaweb工程，新建一个servlet程序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request， HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException， IOException &#123;</div><div class="line">    response.setContentType(<span class="string">"text/html"</span>);</div><div class="line">    PrintWriter out = response.getWriter();</div><div class="line">    ClassLoader classload = <span class="keyword">this</span>.getClass().getClassLoader();</div><div class="line">    <span class="keyword">while</span> (classload != <span class="keyword">null</span>) &#123;</div><div class="line">        out.println(classload.getClass().getName()+<span class="string">"&lt;br&gt;"</span>);</div><div class="line">        classload = classload.getParent();</div><div class="line">    &#125;</div><div class="line">    out.println();</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　然后配置服务器，部署应用程序，启动tomcat服务器.在页面访问我们这个servlet，在页面打印的<br>结果如下图所示:<br><img src="http://my.csdn.net/uploads/201207/12/1342057884_8748.png" alt="此处输入图片的描述"><br>这是从小到大排序的.<br>现在呢?我想把该servlet打成jar包，放在ExtClassLoad类加载器加载的路径.<br>通过Eclipse即可完成<br><img src="http://my.csdn.net/uploads/201207/12/1342057935_6368.png" alt="此处输入图片的描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/[Java]java中的事件监听是怎样实现随时监听的/" itemprop="url">
                  java中的事件监听是怎样实现随时监听的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:00:00+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/monitor" target="_blank" rel="external">https://github.com/rhapsody1290/monitor</a></p>
<h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p><img src="http://img.blog.csdn.net/20160420164724788" alt="这里写图片描述"><br>　　Java中的事件监听是整个Java消息传递的基础和关键。牵涉到三类对象：事件源（Event Source）、事件（Event）、事件监听器（Event Listener）。<br>　　● 事件源是事件发生的场所，通常就是各个组件，它可以是一个按钮，编辑框等。<br>　　● 事件监听者负责监听事件源所发生的事件，并对各种事件做出相应的响应。<br>　　● 事件是描述事件源状态改变的对象。<br>　　具体实现呢，可以看看Button的源码。可能不好看得懂。那好我们仿照侯捷先生的作法，来模拟一个这样的事件传递： </p>
<h3 id="定义一个自己的事件"><a href="#定义一个自己的事件" class="headerlink" title="定义一个自己的事件"></a>定义一个自己的事件</h3><p>将事件源中value的最新值告知监听器</p>
<pre><code>public class MyEvent {
    private int value;

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
}
</code></pre><h3 id="做一个监听器接口-Listener"><a href="#做一个监听器接口-Listener" class="headerlink" title="做一个监听器接口 Listener"></a>做一个监听器接口 Listener</h3><p>当外部响应触发事件源上的事件时，产生一个事件对象，该事件对象会作为参数传递给监听器的事件处理方法</p>
<pre><code>public interface Listener {
    public void valueChanged(MyEvent e);
}
</code></pre><h3 id="做一个事件发生者"><a href="#做一个事件发生者" class="headerlink" title="做一个事件发生者"></a>做一个事件发生者</h3><ul>
<li>当事件源中的value值发生改变时，会促发事件</li>
<li>监听器在事件源上注册，事件源会保存该监听器，在事件触发时调用监听器的事件处理方法</li>
</ul>
<pre><code>public class MySource {
    private int value;
    private Vector&lt;Listener&gt; listeners = new Vector&lt;Listener&gt;();
    /**
     * 添加监听器
     * @param listener
     */
    public void addListener(Listener listener){
        listeners.add(listener);
    }

    public void setValue(int value){
        this.value = value;
        //发送消息
        MyEvent e = new MyEvent();
        e.setValue(value);
        for(int i = 0; i &lt; listeners.size(); i++){
            listeners.get(i).valueChanged(e);
        }
    }

}
</code></pre><h3 id="注册监听器"><a href="#注册监听器" class="headerlink" title="注册监听器"></a>注册监听器</h3><ul>
<li>如果想监听事件源中value值改变，就在事件源那儿注册一下监听器，然后写消息处理代码就可以了，一般使用匿名内部类的方式定义监听器</li>
<li>这样，当MySource的value真的改变时，就会触发响应</li>
</ul>
<pre><code>public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        MySource mySource = new MySource();
        mySource.addListener(new Listener() {
            public void valueChange(MyEvent e) {
                System.out.println(&quot;值改变了：&quot; + e.getValue());
            }
        });
        mySource.setValue(1);
    }

}

#结果
value changed to:10
</code></pre><p>Java中AWT/Swing的事件传递的实现，现在版本于上述有所不同，但应该都是这个原理。</p>
<h3 id="总结-图解-★★★★★★"><a href="#总结-图解-★★★★★★" class="headerlink" title="总结[图解]★★★★★★"></a>总结[图解]★★★★★★</h3><p><img src="http://i.imgur.com/JU0I5Nn.png" alt=""></p>
<h4 id="建议开发顺序："><a href="#建议开发顺序：" class="headerlink" title="建议开发顺序："></a>建议开发顺序：</h4><ul>
<li>先编写事件源，事件源中有监听器集合Vector<listener> listeners和增加监听器方法addListener</listener></li>
<li>在触发事件源的方法上如setValue，产生事件、并调用监听器方法，将事件以参数传入监听器方法</li>
<li>创建事件类和监听器类</li>
<li>测试，创建事件源——添加监听器——触发事件</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><strong><em>监听器本质</em></strong></p>
<ul>
<li>当调用setValue时，使得value属性的值发生变化，产生事件并调用监听器中对应该属性值改变时做出的处理；而事件不触发时不会产生这个响应，这就起到<strong><em>对一个属性值监控</em></strong> 的作用</li>
<li>使用监听器有什么好处呢？我们可以直接在setValue这个函数中做出响应啊！但是如果直接在serValue中写，这个响应处理不能由程序员自己控制，这是写死的。而采用监听器方法时，通过重写Listener中的事件处理函数，<strong><em>程序员可以自己编写事件处理函数</em></strong></li>
<li><font color="red">函数调用顺序是：外界动作调用setValue方法，在这个而方法中去调用监听器中对应的事件处理函数</font>

</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]. <a href="http://www.jcodecraeer.com/a/chengxusheji/java/2012/0822/371.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/chengxusheji/java/2012/0822/371.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
