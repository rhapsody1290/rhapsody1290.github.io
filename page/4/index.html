<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/4/"/>


  <title> Mr.Qian's Home </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Qian's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java类加载器深入讲解/" itemprop="url">
                  Java类加载器深入讲解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T00:00:00+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器?"></a>什么是类加载器?</h2><p>　　加载类的工具，把硬盘上.class文件加载到内存，并进行一些处理，得到字节码</p>
<h2 id="类加载器有什么作用"><a href="#类加载器有什么作用" class="headerlink" title="类加载器有什么作用?"></a>类加载器有什么作用?</h2><p>　　当程序需要的某个类，那么需要通过类加载器把类的二进制加载到内存中，类加载器也是Java类</p>
<h2 id="类加载器之间的父子关系和管辖范围。"><a href="#类加载器之间的父子关系和管辖范围。" class="headerlink" title="类加载器之间的父子关系和管辖范围。"></a>类加载器之间的父子关系和管辖范围。</h2><p><img src="http://my.csdn.net/uploads/201207/12/1342057661_9458.png" alt="类加载器之间的父子关系和管辖范围图"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#获得类加载器的名字</div><div class="line">ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</div><div class="line">while (classLoader != null) &#123;</div><div class="line">    System.out.println(classLoader.getClass().getName());</div><div class="line">    classLoader = classLoader.getParent();</div><div class="line">&#125;</div><div class="line">System.out.println(classLoader);</div></pre></td></tr></table></figure>
<p><img src="http://my.csdn.net/uploads/201207/12/1342057738_7123.png" alt="此处输入图片的描述"></p>
<p>##4. 类加载器的委托机制:</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a><strong>类的加载</strong></h3><ol>
<li>当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢?<br>　　①首先 <strong>当前线程的类加载器</strong> 去加载线程中的第一个类.<br>　　②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B<br>　　③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类.</li>
<li>每个类加载器加载类时，又<strong>先委托给其上级类加载器</strong><br>　　<strong>当所有祖宗类加载器没有加载到类，回到发起者类加载器</strong>，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。</li>
</ol>
<h3 id="委托机制有什么好处"><a href="#委托机制有什么好处" class="headerlink" title="委托机制有什么好处?"></a><strong>委托机制有什么好处?</strong></h3><ul>
<li>集中管理，如果我们写了几个类加载器，都去加载某个类，那么内存中就有多份这个类的字节码</li>
<li>安全。系统类由系统的类加载器加载</li>
</ul>
<h3 id="能不能自己写一个类叫java-lang-System"><a href="#能不能自己写一个类叫java-lang-System" class="headerlink" title="能不能自己写一个类叫java.lang.System?"></a><strong>能不能自己写一个类叫java.lang.System?</strong></h3><p>　　为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸优先，也就是使用的永远是爸爸的(系统的)System类，而不是我们写的System类.</p>
<h2 id="编写自己的类加载器"><a href="#编写自己的类加载器" class="headerlink" title="编写自己的类加载器"></a>编写自己的类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　然后在新建一个类，通过上面的方法将新建的类的字节码进行加密:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderAttachment</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123; <span class="comment">//为什么要继承Date待会再说?</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello，itcast"</span>;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　并在工程里新建一个文件夹，用来保存加密后的class文件.<br>　　<img src="http://my.csdn.net/uploads/201207/12/1342057789_4367.png" alt="此处输入图片的描述"><br>　　那么这就需要使用我们自己的类加载器来进行解密了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> String classDir;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        String classFileName = classDir + <span class="string">"\\"</span> + name.substring(name.lastIndexOf(<span class="string">'.'</span>)+<span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFileName);</div><div class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            cypher(fis，bos);</div><div class="line">            fis.close();</div><div class="line">            System.out.println(<span class="string">"aaa"</span>);</div><div class="line">            <span class="keyword">byte</span>[] bytes = bos.toByteArray();</div><div class="line">            <span class="keyword">return</span> defineClass(bytes， <span class="number">0</span>， bytes.length);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.classDir = classDir;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试运行代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class clazz = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClass"</span>).loadClass(<span class="string">"ClassLoaderAttachment"</span>);</div><div class="line"><span class="comment">//此处不能在使用ClassLoaderAttachment因为一旦用了之后，</span></div><div class="line"><span class="comment">//系统的类加载器就会去加载，导致失败，所以该类就继承了Date类了.</span></div><div class="line">Date date = (Date)clazz.newInstance();</div><div class="line">System.out.println(date);</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://my.csdn.net/uploads/201207/12/1342057844_5083.jpg" alt="此处输入图片的描述"></p>
<h2 id="一个类加载器的高级问题"><a href="#一个类加载器的高级问题" class="headerlink" title="一个类加载器的高级问题:"></a>一个类加载器的高级问题:</h2><p>　　我们知道tomcat服务器，是一个大大的java程序，那么它就必须在JVM上运行.这个大大的java程序内部也写了很多类加载器，它用这些类加载器去加载一些特定的类.注入servlet类.<br>下面我们新建一个javaweb工程，新建一个servlet程序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request， HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException， IOException &#123;</div><div class="line">    response.setContentType(<span class="string">"text/html"</span>);</div><div class="line">    PrintWriter out = response.getWriter();</div><div class="line">    ClassLoader classload = <span class="keyword">this</span>.getClass().getClassLoader();</div><div class="line">    <span class="keyword">while</span> (classload != <span class="keyword">null</span>) &#123;</div><div class="line">        out.println(classload.getClass().getName()+<span class="string">"&lt;br&gt;"</span>);</div><div class="line">        classload = classload.getParent();</div><div class="line">    &#125;</div><div class="line">    out.println();</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　然后配置服务器，部署应用程序，启动tomcat服务器.在页面访问我们这个servlet，在页面打印的<br>结果如下图所示:<br><img src="http://my.csdn.net/uploads/201207/12/1342057884_8748.png" alt="此处输入图片的描述"><br>这是从小到大排序的.<br>现在呢?我想把该servlet打成jar包，放在ExtClassLoad类加载器加载的路径.<br>通过Eclipse即可完成<br><img src="http://my.csdn.net/uploads/201207/12/1342057935_6368.png" alt="此处输入图片的描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/[Spring]Spring笔记/" itemprop="url">
                  Spring笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-15T08:51:00+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><ul>
<li>struts是web框架 (jsp/action/actionfrom)</li>
<li>hibernate是orm框架，处于持久层</li>
<li>spring是<strong><em>容器框架</em></strong>，用于配置各个层的bean（action/service/domain/dao），并维护bean之间关系的框架 </li>
</ul>
<h2 id="spring中重要概念★★★★★"><a href="#spring中重要概念★★★★★" class="headerlink" title="spring中重要概念★★★★★"></a>spring中重要概念★★★★★</h2><h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><ul>
<li>Spring管理的对象为bean</li>
<li>bean是java中的任何一种对象（javabean/service/action/数据源/dao），spring作用是配置各个层中的组件（bean），并维持组件（bean）之间的关系</li>
<li>JavaBean必须拥有一个无参的构造器，通过get/set方法访问参数，同时支持持久化</li>
</ul>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul>
<li>ioc(inverse of control，控制反转)，控制反转就是把<font color="red">创建对象（bean）和维护对象（bean）的关系的权利</font>从程序中转移到spring容器中（applicationContext.xml），只需配置一下就能完成</li>
<li>使用Spring，程序中几乎所有重要的组件的创建工作和维护组件之间的依赖关系都移交给Spring</li>
</ul>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul>
<li>di(dependency injection，依赖注入)，<strong><em>实际上di和ioc是同一概念</em></strong>，spring设计者认为di更准确表示spring核心技术</li>
<li>依赖注入接管对象的创建工作，并将该对象的引用注入需要该对象的组件</li>
</ul>
<pre>
/*
<font color="red">有两个组件A和B，A依赖于B，且A中的importantMethod方法调用了B的方法，
使用B前，类A必须先获得组件B的实例（具体类可以new一个B实例，但如果B是接口，使用B的一个实现类，会降低A的可重用性）
使用依赖注入，框架会接管对象B的创建工作，并将B对象的引用注入到A中，具体是类A中的setB方法会被框架调用，注入一个B的实例，
这样类A的importantMethod方法在使用B的userfulMethod方法前不再需要创建一个B的实例</font>
*/
public class A {
    private B b;

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    public void importantMethod(){
        b.userfulMethod();
    }
}
</pre>

<h2 id="Spring在程序中的位置"><a href="#Spring在程序中的位置" class="headerlink" title="Spring在程序中的位置"></a>Spring在程序中的位置</h2><p>　　Spring层次图如下图所示</p>
<p><img src="http://i.imgur.com/xPyY3mN.png" alt=""></p>
<ul>
<li>Login.jsp与用户交互，将数据传递给Action.java处理器，Action.java一般与表单ActionForm关联，验证成功跳转到ok.jsp。这一层是web层，Struts位于web层</li>
<li>验证过程中，会调用UserService.java，这是业务层。业务层会有一个domain对象，Users.java[或者叫javabean，pojo]</li>
<li>业务层下是DAO层，它是对数据的操作</li>
<li>下面就是数据持久层，hibernate就位于持久层，它是一个orm框架</li>
<li>最底层的就是数据库</li>
<li>model层分为业务层（Service），DAO层和数据持久层，在开发过程中，可以根据实际情况进行选择组合，并不是必须把model层分得这么细</li>
<li>Spring横跨web层、业务层、DAO层、持久层，可以配置各个层的组件（JavaBean），并且维护各个bean之间的关系</li>
<li>具体的来说，spring可以配置web层的action[解决actin单例问题]，业务层的domain/service/dao以及数据持久层配置数据源</li>
<li>在配置文件中，体现出Spring创建各种组件及维持组件之间的关系<pre>
&lt;bean id = "bean1" class = "">配置bean
  &lt;property name = "" value = "">&lt;/property>
&lt;/bean>
&lt;bean id = "bean2" class = "">维护bean之间的关系(bean2依赖bean1)
  &lt;property name = "" ref="">&lt;/property>
&lt;/bean>
</pre>

</li>
</ul>
<h2 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/Spring_Study" target="_blank" rel="external">https://github.com/rhapsody1290/Spring_Study</a></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>&lt;properties&gt;
    &lt;!-- spring版本号 --&gt;
    &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;
    &lt;!-- log4j日志文件管理包版本 --&gt;
    &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;
    &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- 导入Mysql数据库链接jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- spring核心包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--spring事务--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 格式化对象，方便输出日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.1.41&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>创建组件A、B，其中A组件依赖B</p>
<p>类A</p>
<pre><code>public class A {
    private B b;

    public void importantMethod(){
        System.out.println(&quot;A:importantMethod&quot;);
        b.usefulMethod();
    }
    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }
}
</code></pre><p>类B </p>
<pre><code>public class B {

    public void usefulMethod() {
        System.out.println(&quot;B:usefulMethod&quot;);
    }
}
</code></pre><h3 id="applicationContext-xml中配置bean"><a href="#applicationContext-xml中配置bean" class="headerlink" title="applicationContext.xml中配置bean"></a>applicationContext.xml中配置bean</h3><p>applicationContext.xml是spring的一个核心配置文件, [hibernate有核心文件hibernate.cfg.xml struts核心文件 struts-config.xml]</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 在容器文件中配置bean(service/dao/domain/action/数据源) --&gt;
    &lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象,并放入内存--&gt;
    &lt;bean id = &quot;A&quot; class=&quot;hello.A&quot;&gt;
        &lt;!-- 这里就体现出注入的概念，将B对象的引用注入到A中的b属性--&gt;
        &lt;property name=&quot;b&quot; ref=&quot;B&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt;

&lt;/beans&gt;
</code></pre><h3 id="获得bean并调用方法"><a href="#获得bean并调用方法" class="headerlink" title="获得bean并调用方法"></a>获得bean并调用方法</h3><pre><code>public class testSpringAPI {

    private ApplicationContext context;

    @Before
    public void setUp() throws Exception {
        //1.得到spring 的applicationContext对象(容器对象)
        context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    }

    @Test
    public void testName() throws Exception {
        //2、利用java反射机制获取bean对象
        A a  = (A) context.getBean(&quot;A&quot;);
        a.importantMethod();
    }
}
</code></pre><h2 id="Spring运行原理图"><a href="#Spring运行原理图" class="headerlink" title="Spring运行原理图"></a>Spring运行原理图</h2><p><img src="http://i.imgur.com/IYAnjQ8.png" alt=""></p>
<ul>
<li>当ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);执行的时候，Spring容器对象将被创建，同时applicationContext.xml中配置的bean就会被创建</li>
<li>UserService us = (UserService)ac.getBean(‘UserService’);调用后取出bean，取出的bean对象是单例</li>
<li>bean的存储结构类似HashMap/HashTable，分为id和bean对象。id对应配置文件中bean元素的id，对象在Spring容器对象创建时创建并存放。若有引用关系，则指向引用对象的id</li>
<li>Spring框架扫描XML文件，利用Java反射机制，创建一个个bean对象</li>
<li><p>可以利用dom4j+java反射机制模拟Spring运行流程。扫描xml文件，检测到bean元素，利用Java反射机制创建对象，并设置属性值，存入HashMap</p>
  <pre>
  userService = Class.forName("com.service.UserService");
  userService.setName("韩顺平");

  applicationContext = new HashMap();
  applicationContext.put("userService",userService);
  </pre>

</li>
</ul>
<h2 id="Spring接口编程"><a href="#Spring接口编程" class="headerlink" title="Spring接口编程"></a>Spring接口编程</h2><p>spring开发提倡接口编程,配合di技术可以层与层的解耦</p>
<p>举例说明:<br>现在我们体验一下spring的di配合接口编程的，完成一个字母大小写转换的案例:<br>思路:</p>
<ol>
<li>创建一个接口 ChangeLetter<pre>
public interface ChangeLetter {
　　public String change();
}
</pre></li>
<li><p>两个类实现接口</p>
<pre>
public class LowerLetter implements ChangeLetter {
      private String str;

      public String getStr() {
          return str;
      }

      public void setStr(String str) {
          this.str = str;
      }

      @Override
      public String change() {
          return str.toLowerCase();
      }
}</pre><pre>
public class UpperLeter implements ChangeLetter {
      private String str;

      public String getStr() {
          return str;
      }

      public void setStr(String str) {
          this.str = str;
      }
      @Override
      public String change() {
          return str.toUpperCase();
      }
}
</pre></li>
<li>把对象配置到spring容器中<pre>
&lt;bean id="changeLetter" class="cn.apeius.inter.UpperLeter">
  &lt;property name="str" value="abc">&lt;/property>
&lt;/bean>
&lt;!--    &lt;bean id="changeLetter" class="cn.apeius.inter.LowerLetter">
  &lt;property name="str" value="ABC">&lt;/property>
&lt;/bean>-->
</pre></li>
<li>使用<pre>
ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
ChangeLetter us= (ChangeLetter) ac.getBean("changeLetter");
System.out.println(us.change());
</pre>

</li>
</ol>
<p>通过上面的案例，我们可以初步体会到di配合接口编程，的确可以减少层(web层) 和 业务层的耦合度.</p>
<h2 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h2><ul>
<li><p>配置文件的根元素通常为</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre></li>
<li>如果需要更强的Spring配置能力，可以在<strong><em>schemaLocation</em></strong>属性中添加相应地schema</li>
<li><p><strong><em>配置文件可以是一份，也可以是多份</em></strong>，ApplicationContext的实现类支持读取多份配置文件</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(new  String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;});
</code></pre></li>
</ul>
<h2 id="三种获取ApplicationContext对象引用的方法"><a href="#三种获取ApplicationContext对象引用的方法" class="headerlink" title="三种获取ApplicationContext对象引用的方法"></a>三种获取ApplicationContext对象引用的方法</h2><p>ApplicationContext对象代表一个<strong><em>Spring控制反转容器</em></strong>，org.springframework.context.ApplicationContext接口有多个实现，包括：</p>
<p>1、ClassPathXmlApplicationContext -&gt; 通过类路径加载配置文件</p>
<pre><code>ApplicationContext context  = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre><p>2、FileSystemXmlApplicationContext -&gt; 通过文件路径加载配置文件</p>
<pre>
ApplicationContext context = new FileSystemXmlApplicationContext("配置文件绝对路径");
</pre>

<p>3、XmlWebApplicationContext 从web系统中加载</p>
<h2 id="两个获取bean的方式★★★"><a href="#两个获取bean的方式★★★" class="headerlink" title="两个获取bean的方式★★★"></a>两个获取bean的方式★★★</h2><h3 id="从ApplicationContex应用上下文容器中获取bean"><a href="#从ApplicationContex应用上下文容器中获取bean" class="headerlink" title="从ApplicationContex应用上下文容器中获取bean"></a>从ApplicationContex应用上下文容器中获取bean</h3><h4 id="基本模式创建一个bean实例★★★★★"><a href="#基本模式创建一个bean实例★★★★★" class="headerlink" title="基本模式创建一个bean实例★★★★★"></a>基本模式创建一个bean实例★★★★★</h4><p>Spring通过<strong><em>默认无参的构造器</em></strong>来创建一个bean实例</p>
<p>配置文件</p>
<pre><code>&lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt;
</code></pre><p>获取bean</p>
<pre><code>//1.得到spring 的applicationContext对象(容器对象)
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
//从容器中取出一个bean的实例
B b = ac.getBean(&quot;B&quot;, B.class);
b.usefulMethod();
</code></pre><h4 id="工厂模式创建一个bean实例"><a href="#工厂模式创建一个bean实例" class="headerlink" title="工厂模式创建一个bean实例"></a>工厂模式创建一个bean实例</h4><p>1、定义一个接口</p>
<pre><code>public interface Animal {
    public void sayHello();
}
</code></pre><p>2、接口的两个实现类</p>
<p>Cat</p>
<pre><code>public class Cat implements Animal {
    public void sayHello() {
        System.out.println(&quot;Cat&quot;);
    }
}
</code></pre><p>Dog </p>
<pre><code>public class Dog implements Animal {    
    public void sayHello() {
        System.out.println(&quot;Dog&quot;);
    }
}
</code></pre><p>3、AnimalFactory工厂中包含了一个getAnimal的<strong><em>静态方法</em></strong>，该方法将根据传入的参数决定创建哪个对象。这是典型的静态工厂设计模式</p>
<pre><code>public class AnimalFactory {
    public static Animal getAnimal(String type){
        if(&quot;Cat&quot;.equals(type)){
            return new Cat();
        }else if(&quot;Dog&quot;.equals(type)){
            return new Dog();
        }
        return null;
    }
}
</code></pre><p>4、Spring配置文件中作如下配置</p>
<pre><code>&lt;bean id=&quot;cat&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt;
    &lt;constructor-arg value=&quot;Cat&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;dog&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt;
    &lt;constructor-arg value=&quot;Dog&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时<strong><em>class属性并不是指定Bean实例的实现类，而是静态工厂类</em></strong></li>
<li>需要使用factory-method来指定静态工厂方法名，Spring将调用静态工厂方法来返回一个Bean实例，使用<constructor-arg>元素来为静态工厂方法指定参数</constructor-arg></li>
<li>当使用静态工厂方法来创建Bean时，这个factory-method必须要是<strong><em>静态的</em></strong></li>
</ul>
<h3 id="从bean工厂容器中获取bean"><a href="#从bean工厂容器中获取bean" class="headerlink" title="从bean工厂容器中获取bean"></a>从bean工厂容器中获取bean</h3><pre><code>//如果我们使用beanfactory去获取bean，当你创建Spring容器时bean不被实例化,只有当你去使用getBean某个bean时，才会实时的创建    
BeanFactory factory = new XmlBeanFactory(
        new ClassPathResource(&quot;applicationContext.xml&quot;));
factory.getBean(&quot;A&quot;);
</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>如果使用ApplicationContext ，则配置的bean如果是singlton不管你用不用，都被实例化.(好处就是可以预先加载,缺点就是耗内存)</li>
<li>如果是 BeanFactory ,则当你获取beanfacotry时候，配置的bean不会被马上实例化，当你使用的时候，才被实例(好处节约内存,缺点就是速度)</li>
<li><strong>规定: 一般没有特殊要求，应当使用ApplicatioContext完成</strong>(实际项目中90%都采用这种方式)</li>
</ol>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p><strong><em>为什么总是一个生命周期当做一个重点?</em></strong></p>
<p>　　例如我们经常需要知道Servlet的生命周期，初始化init和销毁destroy，还有讨论java对象生命周期<br>　　不懂servlet的生命周期，你一样可以做开发。但是只有把一个新的技术对应的对象的生命周期弄清楚时，你才能真正的驾驭他。你知道Servlet创建的时候会调用init，才会把初始化工作放在init中，你知道Servlet销毁时会调用destroy，才会把文件备份的工作放在destroy中</p>
<p><strong><em>bean的生命周期</em></strong></p>
<p>bean被载入到容器中时，它的生命周期就开始了</p>
<p><img src="http://i.imgur.com/n6bHb14.png" alt=""></p>
<p>①    实例化★</p>
<ul>
<li>当我们的程序加载<code>beans.xml</code>文件，把我们的bean实例化到内存</li>
<li>默认调用无参的构造方法</li>
<li>以上我们考虑的是<code>scope=singleton</code>，单例模式最复杂</li>
</ul>
<p>②    调用set方法设置属性★<br>③    如果你实现了bean名字关注接口<code>BeanNameAware</code>则，可以通过<code>setBeanName</code>获取id号<br>④    如果你实现了bean工厂关注接口<code>BeanFactoryAware</code>,则可以获取<code>BeanFactory</code><br>⑤    如果你实现了<code>ApplicationContextAware</code>接口，则可以获得应用程序上下文</p>
<pre><code>//该方法传递ApplicationContext
public void setApplicationContext(ApplicationContext arg0)
        throws BeansException {
    // TODO Auto-generated method stub
    System.out.println(&quot;setApplicationContext&quot;+arg0);
}
</code></pre><p>⑥    如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。体现AOP（面向切片编程），放置一些公共方法，例如过滤ip，给对象添加属性等★</p>
<p><strong><em>自定义一个类myBeanPostProcessor，实现BeanPostProcessor接口，重写before和after两个方法</em></strong></p>
<pre>
# myBeanPostProcessor.java
public class myBeanPostProcessor <font color="red">implements BeanPostProcessor</font> {
    @Override
    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
        <font color="red">//对象o对实例化的bean对象，s为bean的id</font>
        System.out.println("postProcessBeforeInitialization");
        return o;
    }

    @Override
    public Object postProcessAfterInitialization(Object o, String s) throws BeansException {
        System.out.println("postProcessAfterInitialization");
        return o;
    }
}
</pre>

<p><strong><em>xml文件中配置</em></strong></p>
<pre><code>&lt;bean id = &quot;myBeanPostProcessor&quot; class=&quot;cn.apeius.beanlift.myBeanPostProcessor&quot;&gt;&lt;/bean&gt;
</code></pre><p><strong><em>运行</em></strong></p>
<pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
PersonService personService = (PersonService) ac.getBean(&quot;PersonService&quot;);
personService.sayHi();
</code></pre><p><strong><em>结果：bean对象创建后会自动调用before和after方法。类似JavaWeb中的过滤器</em></strong></p>
<pre><code>构造函数被调用
调用set方法
postProcessBeforeInitialization
postProcessAfterInitialization
你好啊 钱钱
</code></pre><p>⑦    如果你实现InitializingBean接口，则会调用afterPropertiesSet<br>⑧    如果自己配置<code>&lt;bean init-method=&quot;init&quot; /&gt;</code>，则可以在bean定义自己的初始化方法init。也可以通过注解的方式@PostConstruct<br>⑨    如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法<br>⑩    使用我们的bean<br>⑪ 容器关闭<br>⑫ 可以通过实现<code>DisposableBean</code>接口来调用方法<code>destory</code><br>⑬ 可以在<code>&lt;bean destory-method=&quot;fun1&quot;/&gt;</code>调用定制的销毁方法。可以通过注解的方式@PreDestroy</p>
<p><strong><em>小结: 我们实际开发中往往，没有用的这么的过程,常见的是:1-&gt;2-&gt;6-&gt;10-&gt;9-&gt;11 </em></strong></p>
<p>问题:通过BeanFactory来获取bean对象，bean的生命周期是否和 Applicationcontext 是一样吗?</p>
<pre><code>不是一样的，bean是工厂中创建的生命周期会简单一些:
比起ApplicationContext创建bean，通过BeanFactory少了一下步骤
⑤ 如果你实现了ApplicationContextAware接口，则可以获得应用程序上下文
⑥ 如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。
⑨ 如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法
</code></pre><p><img src="http://i.imgur.com/1KHveOv.png" alt=""></p>
<h2 id="bean装配的细节"><a href="#bean装配的细节" class="headerlink" title="bean装配的细节"></a>bean装配的细节</h2><h3 id="注入的写法★"><a href="#注入的写法★" class="headerlink" title="注入的写法★"></a>注入的写法★</h3><p>基础数据类型注入</p>
<pre>
一个标签
&lt;property name="name" <font color="red">value="财务部"</font>/>
两个标签
&lt;property name="name">
    <font color="red">&lt;value>财务部&lt;/value></font>
&lt;/property>
</pre>

<p>对象注入</p>
<pre>
# 方法一：利用property的ref属性，这是一种简写方式
&lt;bean id="Department"  class="cn.apeius.collections.Department">
    <font color="red">&lt;property name="emp" ref="Emp"/></font>
&lt;/bean>
&lt;bean id="Emp" class="cn.apeius.collections.Emp">
    &lt;property name="id" value="1"/>
    &lt;property name="name" value="qm"/>
&lt;/bean>

# 方法二：ref标签
&lt;bean id="Department"  class="cn.apeius.collections.Department">
    &lt;property name="emp">
        <font color="red">&lt;ref bean="Emp"/></font>
    &lt;/property>
&lt;/bean>
&lt;bean id="Emp" class="cn.apeius.collections.Emp">
    &lt;property name="id" value="1"/>
    &lt;property name="name" value="qm"/>
&lt;/bean>

# 方法三：内部配置

&lt;bean id="Department"  class="cn.apeius.collections.Department">
    &lt;property name="emp">
        <font color="red">&lt;bean class="cn.apeius.collections.Emp">
            &lt;property name="id" value="1"/>
            &lt;property name="name" value="qm"/>
        &lt;/bean></font>
    &lt;/property>
&lt;/bean>

</pre>

<h3 id="bean的作用域scope"><a href="#bean的作用域scope" class="headerlink" title="bean的作用域scope"></a>bean的作用域scope</h3><p><img src="http://i.imgur.com/1Dzlr62.png" alt=""></p>
<ul>
<li>singleton(默认)，单态，尽量使用scope=”singleton”,不要使用prototype,因为这样对我们的性能影响较大，除非有必要.<pre>
//获取两个student
Student s1=(Student) ac.getBean("student");
Student s2=(Student) ac.getBean("student");
System.out.println(s1 == s2);//一样
</pre></li>
<li>prototype<pre>
//获取两个student
Student s1=(Student) ac.getBean("student");
Student s2=(Student) ac.getBean("student");
System.out.println(s1 == s2);//不一样
</pre></li>
<li>request</li>
<li>session</li>
<li>global-session 是在web开发中才有意义</li>
</ul>
<h3 id="如何给集合类型注入值"><a href="#如何给集合类型注入值" class="headerlink" title="如何给集合类型注入值"></a>如何给集合类型注入值</h3><p>java中主要的集合有几种: map set list / 数组 </p>
<p><strong><em>给数组注入值</em></strong></p>
<pre><code>&lt;property name=&quot;empName&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;小明&lt;/value&gt;
        &lt;value&gt;小明小明&lt;/value&gt;
        &lt;value&gt;小明小明小明小明&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给list注入值 list 中可以有相同的对象</em></strong></p>
<pre><code>&lt;property name=&quot;empList&quot;&gt;
    &lt;list&gt;
        &lt;ref bean=&quot;emp2&quot; /&gt;
        &lt;ref bean=&quot;emp1&quot;/&gt;
        &lt;ref bean=&quot;emp1&quot;/&gt;
    &lt;/list&gt;
&lt;/property&gt;

&lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong><em>给set注入值set不能有相同的对象</em></strong></p>
<pre><code>&lt;property name=&quot;empsets&quot;&gt;
    &lt;set&gt;
        &lt;ref bean=&quot;emp1&quot; /&gt;
        &lt;ref bean=&quot;emp2&quot;/&gt;
        &lt;ref bean=&quot;emp2&quot;/&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给map注入值，key为索引，value指定值，如果为Java对象，则使用ref指定，或者使用bean定义。如果key为对象，使用key-ref属性</em></strong></p>
<pre><code>&lt;property name=&quot;empMaps&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; 
        &lt;entry key = &quot;12&quot; value = &quot;emp2&quot; /&gt;
        &lt;entry key-ref=&quot;13&quot; value=&quot;emp3&quot; /&gt;
        &lt;entry key-ref=&quot;14&quot; value-ref=&quot;emp4&quot; /&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给属性集合配置，即Property对象</em></strong></p>
<pre><code>&lt;property name=&quot;pp&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt;
        &lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre><h3 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h3><pre><code>&lt;bean id=&quot;foo&quot; class=&quot;....Foo&quot;&gt;
    &lt;property name=&quot;属性&quot;&gt;
        &lt;!—第一方法引用--&gt;
        &lt;ref bean=&quot;bean对象名&quot;/&gt;

        &lt;!—第二种方法，内部bean--&gt;
        &lt;bean&gt; 
            &lt;properyt name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="继承配置"><a href="#继承配置" class="headerlink" title="继承配置"></a>继承配置</h3><pre><code>public class Student 
public class Gradate extends Student

在beans.xml文件中体现配置 
&lt;!-- 配置一个学生对象 --&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.hsp.inherit.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;顺平&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;30&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 配置Grdate对象 --&gt;
&lt;bean id=&quot;grdate&quot; parent=&quot;student&quot; class=&quot;com.hsp.inherit.Gradate&quot;&gt;
    &lt;!-- 如果自己配置属性name,age,则会替换从父对象继承的数据  --&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;degree&quot; value=&quot;学士&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="通过构造函数注入值★★★"><a href="#通过构造函数注入值★★★" class="headerlink" title="通过构造函数注入值★★★"></a>通过构造函数注入值★★★</h3><ul>
<li>目前我们都是通过set方式给bean注入值，spring还提供其它的方式注入值，比如通过构造函数注入值!</li>
<li>set注入的缺点是无法清晰表达哪些属性是必须的，哪些是可选的；构造注入的优势是通过构造器<strong><em>强制依赖关系</em></strong></li>
<li>每个constructor-arg配置一个参数，参数有先后顺序，顺序要与构造函数相同</li>
</ul>
<h4 id="通过参数名传递参数"><a href="#通过参数名传递参数" class="headerlink" title="通过参数名传递参数"></a>通过参数名传递参数</h4><pre><code>&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;洗衣机&quot;/&gt;
    &lt;constructor-arg name=&quot;description&quot; value=&quot;家用洗衣服的工具&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="通过指数方式传递参数"><a href="#通过指数方式传递参数" class="headerlink" title="通过指数方式传递参数"></a>通过指数方式传递参数</h4><pre><code>&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;洗衣机&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;家用洗衣服的工具&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="初始化bean和销毁bean的时候执行某个方法"><a href="#初始化bean和销毁bean的时候执行某个方法" class="headerlink" title="初始化bean和销毁bean的时候执行某个方法"></a>初始化bean和销毁bean的时候执行某个方法</h3><p>方法一：通过注解@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作</p>
<pre><code>public class DataInitializer{     
    @PostConstruct  
    public void initMethod() throws Exception {  
        System.out.println(&quot;initMethod 被执行&quot;);  
    }  
    @PreDestroy  
    public void destroyMethod() throws Exception {  
        System.out.println(&quot;destroyMethod 被执行&quot;);  
    }  
}  
</code></pre><p>方法二：通过 在xml中定义 init-method 和  destory-method 方法★★★★★</p>
<p>DataInitializer</p>
<pre><code>public class DataInitializer{  
    public void initMethod() throws Exception {  
        System.out.println(&quot;initMethod 被执行&quot;);  
    }  
    public void destroyMethod() throws Exception {  
        System.out.println(&quot;destroyMethod 被执行&quot;);  
    }  
}  
</code></pre><p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;dataInitializer&quot; class=&quot;com.somnus.demo.DataInitializer&quot; init-method=&quot;initMethod&quot; destory-method=&quot;destroyMethod&quot;/&gt;  
</code></pre><p>方法三：通过bean实现InitializingBean和 DisposableBean接口</p>
<pre>
public class DataInitializer <font color="red">implements InitializingBean，DisposableBean</font>{  

    @Override  
    public void afterPropertiesSet() throws Exception {  
        System.out.println("afterPropertiesSet 被执行");  
    }  

    @Override  
    public void destroy() throws Exception {  
        System.out.println("destroy 被执行");  
    }  

}  
</pre>

<p>原理</p>
<pre>
<font color="red">//判断该bean是否实现了实现了InitializingBean接口，如果实现了InitializingBean接口，则只掉调用bean的afterPropertiesSet方法</font>  
<font color="blue">boolean isInitializingBean = (bean instanceof InitializingBean);  </font>
if(isInitializingBean)
    ((InitializingBean) bean).afterPropertiesSet();  
</pre>

<h2 id="注解装配Bean"><a href="#注解装配Bean" class="headerlink" title="注解装配Bean"></a>注解装配Bean</h2><h3 id="引入context名称空间，并配置扫描包"><a href="#引入context名称空间，并配置扫描包" class="headerlink" title="引入context名称空间，并配置扫描包"></a>引入context名称空间，并配置扫描包</h3><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;annotation&quot;/&gt;

&lt;/beans&gt;
</code></pre><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><pre><code>@Component(value = &quot;a&quot;)等价于&lt;bean id = &quot;a&quot; class = &quot;A&quot;&gt;

@Component(value = &quot;a&quot;)
public class A {

    public void say(){
        System.out.println(&quot;A&quot;);
    }

}
</code></pre><h3 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="简单类型数据注入"><a href="#简单类型数据注入" class="headerlink" title="简单类型数据注入"></a>简单类型数据注入</h4><p>spring3.0 提供 @Value 注解，可以注入简单数据类型</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Value(value = &quot;qm&quot;)
    private String name;

    public void say(){
        System.out.println(&quot;A&quot; + name);
    }

}
</code></pre><h4 id="复杂对象类型数据注入"><a href="#复杂对象类型数据注入" class="headerlink" title="复杂对象类型数据注入"></a>复杂对象类型数据注入</h4><p><strong>第一种：按类型注入，@Autowired</strong></p>
<p>A</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Autowired
    B b;

    public void say(){
        b.say();
    }

}
</code></pre><p>B</p>
<pre><code>@Component(value = &quot;b&quot;)
public class B {

    public void say(){
        System.out.println(&quot;B&quot;);
    }

}
</code></pre><p><strong>第二种：按名称注入，使用@Autowired 结合 @Qualifier 注解 (Spring 2.0 )</strong></p>
<p>A：</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Autowired
    @Qualifier(value = &quot;c_qualifier&quot;)
    B b;

    public void say(){
        b.say();
    }

}
</code></pre><p>B：</p>
<pre><code>@Component(value = &quot;c_qualifier&quot;)
public class B {

    public void say(){
        System.out.println(&quot;B&quot;);
    }

}
</code></pre><p><strong>第三种： 使用@Resouce注解 （JSR-250标准 ）</strong></p>
<pre><code>按照名称注入
</code></pre><p><strong>第四种： 使用 @Inject 注解 （JSR-330标准 ）</strong></p>
<pre><code>导入 javax.inject-1.jar 
</code></pre><h2 id="自动装配bean的属性值"><a href="#自动装配bean的属性值" class="headerlink" title="自动装配bean的属性值"></a>自动装配bean的属性值</h2><p>自动装配只有在属性没有设置时，才会进行</p>
<p><img src="http://i.imgur.com/wL8acDX.png" alt=""></p>
<h3 id="byName的用法"><a href="#byName的用法" class="headerlink" title="byName的用法:"></a>byName的用法:</h3><pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>原理图:</p>
<p>property中没有注入dog值，master中的dog为null。但当设置属性autowire=”byName”后，通过检测发现内存中有一个名字为dog的对象，则自动进行引用连接</p>
<p><img src="http://i.imgur.com/aYY9TE0.png" alt=""></p>
<h3 id="byType的用法"><a href="#byType的用法" class="headerlink" title="byType的用法"></a>byType的用法</h3><p>寻找和属性类型相同的bean，此时id为dog11也能够找到并进行装配；找不到、装不上、找到多个抛异常</p>
<pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog11&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="constructor的用法"><a href="#constructor的用法" class="headerlink" title="constructor的用法"></a>constructor的用法</h3><p>与byType类似， 查找和bean的构造参数一致的一个或多个bean，若找不到或找到多个，抛异常。按照参数的类型装配  </p>
<p><em>master写构造函数</em></p>
<pre><code>public master(Dog dog){
    this.dog = dog;
}
</code></pre><p><em>配置</em></p>
<pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;constructor&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="autodetect的用法"><a href="#autodetect的用法" class="headerlink" title="autodetect的用法"></a>autodetect的用法</h3><p><code>autowire=&quot;autodetect&quot;</code>(3)和(2)之间选一个方式。不确定性的处理与(3)和(2)一致</p>
<h3 id="defualt"><a href="#defualt" class="headerlink" title="defualt"></a>defualt</h3><p>这个需要在<code>&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;</code><br>当你在<code>&lt;beans&gt;</code>指定了default-atuowrite后，所有的bean的默认的autowire就是指定的装配方法;<br>如果没有在<code>&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;</code>没有defualt-autorwire=”指定”，则默认是defualt-autorwire=”no”</p>
<h3 id="no-不自动装配"><a href="#no-不自动装配" class="headerlink" title="no: 不自动装配"></a>no: 不自动装配</h3><p>这是autowire的默认值</p>
<h2 id="使用spring的特殊bean-完成分散配置"><a href="#使用spring的特殊bean-完成分散配置" class="headerlink" title="使用spring的特殊bean,完成分散配置"></a>使用spring的特殊bean,完成分散配置</h2><p>将配置文件分成几个分散的配置文件，如一个项目中连接多个数据库，每个数据库各对应一个db.properties文件</p>
<ul>
<li>引入我们的db.properties文件，并在要注入值的地方用$占位符</li>
</ul>
<pre><code>&lt;context:property-placeholder location=&quot;classpath:com/hsp/dispatch/db.properties,classpath:com/hsp/dispatch/db2.properties&quot;/&gt;
&lt;!-- 配置一DBUtil对象 $占位符号 --&gt;
&lt;bean id=&quot;dbutil&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;${name}&quot; /&gt;
    &lt;property name=&quot;drivername&quot; value=&quot;${drivername}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
    &lt;property name=&quot;pwd&quot; value=&quot;${pwd}&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>注意：当通过<code>context:property-placeholder</code>引入属性文件的时候，有多个需要使用<code>,</code>间隔.</p>
<ul>
<li>db.properties</li>
</ul>
<pre><code>name=scott
drivername=oracle:jdbc:driver:OracleDirver
url=jdbc:oracle:thin:@127.0.0.1:1521:hsp
pwd=tiger
</code></pre><ul>
<li>测试</li>
</ul>
<pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
DBUtil dBUtil = (DBUtil) ac.getBean(&quot;dbutil&quot;);
System.out.println(dbUtil.getDrivername());
</code></pre><h2 id="AOP编程"><a href="#AOP编程" class="headerlink" title="AOP编程"></a>AOP编程</h2><ul>
<li>AOP(Aspect Oriented Programming )，面向切面编程：AOP编程就是将共有的代码，如日志记录、权限控制、事务控制等全部抽取出来，放在某个地方集中管理，若需要使用这些功能，由容器动态织入这些共有代码，这样的好处：<br>1、程序员在编写业务逻辑时只需关心核心的业务逻辑处理方法，提高工作效率，使代码变得简洁<br>2、业务逻辑代码和共有代码分开存放，使维护工作变得轻松</li>
</ul>
<p><img src="http://i.imgur.com/CBjTgky.png" alt=""></p>
<ul>
<li><p>举个例子，在开发过程中，很多对象需要做同一类的操作，例如权限通知、日志记录、事务控制等，AOP编程就是把相同工作剥离出来，若对象需要使用其中的一个功能，则将其织入进去<br><img src="http://i.imgur.com/zNOHFYJ.png" alt=""></p>
</li>
<li><p>AOP编程，实际上在开发框架本身用的多，在实际项目中，用的不是很多，但是将来会越来越多，这是一个趋势</p>
</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/liujiahan629629/article/details/18864211" target="_blank" rel="external">http://blog.csdn.net/liujiahan629629/article/details/18864211</a></p>
<h3 id="AOP技术的实现原理"><a href="#AOP技术的实现原理" class="headerlink" title="AOP技术的实现原理"></a>AOP技术的实现原理</h3><ul>
<li>AOP技术是建立在 <strong>Java语言的反射机制</strong> 与 <strong>动态代理机制</strong> 之上的</li>
<li>业务逻辑组件在运行过程中，<strong>AOP容器</strong> 会动态创建一个 <strong>代理对象</strong> 供使用者调用，该代理对象已经按Java EE程序员的意图将 <strong>切面</strong> 成功切入到 <strong>目标方法</strong> 的 <strong>连接点</strong> 上，从而使 <strong>切面的功能</strong> 与 <strong>业务逻辑的功能</strong> 同时得以执行</li>
<li>从原理上讲，调用者直接调用的其实是AOP容器动态生成的代理对象，再由<strong>代理对象调用目标对象完成原始的业务逻辑处理</strong>，而代理对象则已经将切面与业务逻辑方法进行了合成</li>
</ul>
<p><img src="http://i.imgur.com/OJoBkfk.jpg" alt=""></p>
<p>现将图6-6中涉及到的一些概念解释如下：</p>
<p><strong>切面（Aspect）：</strong>其实就是<strong>共有功能的实现，包括通知和切入点</strong>,如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。<br><strong>通知（Advice）：</strong> <strong><em>是切面的具体实现</em></strong>。以目标方法为参照点，根据 <strong><em>放置的地方不同</em></strong>，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。<br><strong>连接点（Joinpoint）</strong>：就是程序在运行过程中能够<strong><em>插入切面的地点</em></strong>。例如，方法调用、异常抛出或字段修改等<br><strong>切入点（Pointcut）：<em>*</em></strong>用于定义通知应该切入到哪些连接点上<strong><em>。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的 </em></strong>正则表达式<em>*</em> 来定义的。</p>
<p><strong>目标对象（Target）</strong>：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。<br><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。<br><strong>织入（Weaving）：</strong> <strong><em>将切面应用到目标对象从而创建一个新的代理对象的过程。</em></strong>这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。</p>
<p>举个例子解释术语：</p>
<p><img src="http://i.imgur.com/Snv0YKO.png" alt=""></p>
<p>AOP编程可以在不增加原来业务逻辑方法代码的情况下，<strong>扩展某个方法</strong>，传统的方法是采用 <strong>继承</strong> 的方式，现在可以采用<strong>动态代理技术</strong></p>
<p>连接点表示哪些方法 <strong>可以被扩展</strong>（拦截）；切入点表示哪些方法 <strong>需要被扩展</strong>（拦截）；织入是把通知应用到目标上，生成动态代理类的过程；切面表示公用的业务逻辑，包括多个切入点和多个通知</p>
<h3 id="AOP底层实现"><a href="#AOP底层实现" class="headerlink" title="AOP底层实现"></a>AOP底层实现</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>详见Java——设计模式版块~</p>
<p>1、必须针对接口进行代理<br>2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类<br>3、自己实现InvocationHandler 接口 </p>
<p><img src="http://i.imgur.com/fzfob6x.png" alt=""></p>
<h4 id="Cglib动态代理机制"><a href="#Cglib动态代理机制" class="headerlink" title="Cglib动态代理机制"></a>Cglib动态代理机制</h4><p>JDK只能对接口进行代理，如果目标对象没有接口，无法使用JDK动态代理，则可以使用cglib </p>
<p><strong>什么是CGLIB？</strong></p>
<p>CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。Cglib可以对接口或者类进行代理 ！</p>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>Spring AOP 就是基于JDKProxy 和 CglibProxy </p>
<p>1、如果目标对象有接口，优先使用JDK Proxy<br>2、如果目标对象没有接口， 使用CglibProxy </p>
<p>面试题：spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？<br>答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术.</p>
<h3 id="Spring-AOP三种配置详细介绍"><a href="#Spring-AOP三种配置详细介绍" class="headerlink" title="Spring AOP三种配置详细介绍"></a>Spring AOP三种配置详细介绍</h3><p><strong>AOP框架三足鼎立：</strong></p>
<ol>
<li>AspectJ</li>
<li>Jboss AOP</li>
<li>Spring  AOP</li>
</ol>
<p><strong>Spring提供4种AOP支持</strong></p>
<ol>
<li>基于代理的经典AOP</li>
<li>纯POJO切面（使用XML）</li>
<li>@AspcetJ注解驱动的切面</li>
<li>注入式AspcetJ切面</li>
</ol>
<h4 id="基于代理的经典AOP"><a href="#基于代理的经典AOP" class="headerlink" title="基于代理的经典AOP"></a>基于代理的经典AOP</h4><p><img src="http://i.imgur.com/eK3KdQ1.png" alt=""></p>
<p>现在有个需求，在调用sayHello()方法前写日志，思路如下：</p>
<p>1、面向接口编程，定义一个TestServiceInter接口，声明函数sayHello()<br>2、两个类Test1Service和Test2Service实现这两个接口<br>3、传统的方式很简单，在sayHello()方法前加入日志操作的代码，但如果有多个业务逻辑方法都需要写日志操作，是会有很多冗余代码。<strong>可以引入一个类，它的功能是写日志</strong>，</p>
<pre><code>Test1Service t1 = new Test1Service();
//采用传统方法，此处写日志操作
t1.sayHello();

Test2Service t2 = new Test2Service();
//采用传统方法，此处写日志操作
t2.sayHello();
</code></pre><p>4、Service类与日志类如何关联起来呢，需引入一个代理类，Spring提供一个代理对象类ProxyFactoryBean</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1、定义接口</p>
<pre><code>TestServiceInter.java
public interface TestServiceInter {
    public void sayHello();
}
</code></pre><p>2、编写对象(也称作被代理对象或目标对象)，实现接口</p>
<pre><code>Test1Service.java
public class Test1Service implements TestServiceInter {
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void sayHello() {
        System.out.println(&quot;Hi &quot; + name);
    }
}
</code></pre><p>3、编写通知（以前置通知为例，前置通知在目标方法调用前调用）</p>
<pre><code># MyMethodBeforeAdvice.java
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(&quot;记录日志：&quot; + method.getName());
    }
}
</code></pre><p>4、在beans.xml文件配置（分三部分：通知、被代理对象、代理对象）<br>　　4.1    配置目标对象<br>　　4.2    配置通知<br>　　4.3    配置代理对象 是 ProxyFactoryBean的对象实例<br>　　　　4.3.1 代理接口集<br>　　　　4.3.2 织入通知<br>　　　　4.3.3 配置目标对象</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--配置前置通知，比如日志--&gt;
    &lt;bean id=&quot;MyMethodBeforeAdvice&quot; class=&quot;cn.apeius.AOP.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;

    &lt;!--配置目标对象--&gt;
    &lt;bean id=&quot;Test1Service&quot; class=&quot;cn.apeius.AOP.Test1Service&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;钱明&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置代理对象,spring提供--&gt;
    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;!--配置代理接口集--&gt;
        &lt;property name=&quot;proxyInterfaces&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;cn.apeius.AOP.TestServiceInter&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--通知--&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;!--相当于包MyMethodBeforeAdvice前置通知和代理对象关联，我们也可以把通知看成拦截器--&gt;
            &lt;value&gt;MyMethodBeforeAdvice&lt;/value&gt;
        &lt;/property&gt;
        &lt;!--配置被代理对象--&gt;
        &lt;property name=&quot;target&quot; ref=&quot;Test1Service&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p><img src="http://i.imgur.com/DR0KqCg.png" alt=""><br>除了四种基本通知外，还有引入通知</p>
<p>前置通知</p>
<pre><code>public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(&quot;记录日志：&quot; + method.getName());
    }
}
</code></pre><p>后置通知</p>
<pre><code>public class MyAfterReturningAdvice implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable {
        System.out.println(&quot;关闭资源&quot;);
    }
}
</code></pre><p>环绕通知</p>
<pre><code>public class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;环绕前&quot;);
        Object o = methodInvocation.proceed();
        System.out.println(&quot;环绕后&quot;);
        return o;
    }
}
</code></pre><p>异常通知<br>　　ThrowsAdvice为标记接口，在接口中没有任何方法，因为方法被反射机制调用，实现类必须实现以下形式，见文档</p>
<pre><code>public class MyThrowsAdvice implements ThrowsAdvice {
    public void afterThrowing(Exception e){
        System.out.println(&quot;出大事了&quot; + e.getMessage());
    }
}
</code></pre><p>引入通知<br>　　引入通知不需要编写相应的类，只需要进行配置，目的是用来指定哪些方法需要执行相应的通知，如，我们想指定只有sayHello（）方法执行前置通知，</p>
<pre><code>&lt;bean id=&quot;myMethodBeforeAdviceFilter&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;  
    &lt;property name=&quot;advice&quot; ref=&quot;myMethodBeforeAdvice&quot;&gt;&lt;/property&gt;  
    &lt;property name=&quot;mappedNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;sayHello&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;

拦截器名集中引入
 &lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt;
</code></pre><h4 id="传统AOP切面编程"><a href="#传统AOP切面编程" class="headerlink" title="传统AOP切面编程"></a>传统AOP切面编程</h4><p>极大简化了spring切面的配置工作，同时也让程序透明化，隐藏了切面的很多细节。上面所有内容都可以作为理解 <strong>spring配置AOP的基础</strong>，是最原始的配置方式，也体现了spring处理的过程。</p>
<p>使用ProxyFactoryBean配置有些欠优雅，在spring2.0里新的xml配置元素体现了改进。Spring2.0在aop命名空间里提供了一些配置元素，简化了把类转化为切面的操作。</p>
<p><strong>本质的使用同上，只是简化配置，隐藏细节</strong></p>
<h5 id="AspectJ切入点"><a href="#AspectJ切入点" class="headerlink" title="AspectJ切入点"></a>AspectJ切入点</h5><p>传统AOP切入点，使用正则表达式语法，不推荐使用。AspectJ切入点，是通过函数进行配置</p>
<p>常用语法说明简介:<br>execution 执行，语法：execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p>
<pre><code>execution(* *(..))  第一个* 任意返回类型 ， 第二个* 任意方法名 , .. 任意参数 

execution(* cn.itcast.service.UserService.*(..)) 匹配UserService所有方法 第一个星 任意返回类型

execution(* cn.itcast.service.UserService+.*(..)) 匹配UserService子类所有方法 + 子类

execution(* cn.itcast.service..*.*(..)) 第一个.. 任意子包 *.*任何类的任何方法 
</code></pre><p>within 根据包匹配</p>
<pre><code>语法：within(包名..*) 
within(cn.itcast.service..*) 拦截service下所有类的方法 
</code></pre><p>this根据目标类型匹配</p>
<pre><code>语法：this(类名) 
this(cn.itcast.service.UserService) 拦截 UserService所有方法 (包括代理对象)
</code></pre><p>target 根据目标类型匹配</p>
<pre><code>语法 ：target(类名)
target(cn.itcast.service.UserService) 拦截UserService所有方法 （不包括代理对象 ）
</code></pre><p>args 根据参数匹配</p>
<pre><code>args(java.lang.String) 拦截所有参数为String类的方法 
</code></pre><p>bean 根据bean name匹配 </p>
<pre><code>bean(userService) 拦截bean id/name为userService对象所有方法 
</code></pre><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><p>接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>实现</p>
<pre><code>public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>通知</p>
<pre><code>public class MyMethodInterceptor implements MethodInterceptor{
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;环绕前&quot;);
        Object o = methodInvocation.proceed();
        System.out.println(&quot;环绕后&quot;);
        return o;
    }
}
</code></pre><p>配置文件</p>
<pre><code>&lt;beans
        xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--1、目标--&gt;
    &lt;bean id=&quot;aopServiceImpl&quot; class=&quot;AOP.AopServiceImpl&quot;/&gt;
    &lt;!--2、通知--&gt;
    &lt;bean id=&quot;myMethodInterceptor&quot; class=&quot;AOP.MyMethodInterceptor&quot;/&gt;
    &lt;!--&lt;aop:config&gt; 配置切面=通知+切入点--&gt;
    &lt;aop:config&gt;
        &lt;!--aop:pointcut配置切入点--&gt;
        &lt;aop:pointcut id=&quot;service&quot; expression=&quot;execution(* AOP.*.*(..))&quot;/&gt;
        &lt;!--aop:advisor配置传统Spring AOP切面，只能有一个切入点和一个通知--&gt;
        &lt;aop:advisor advice-ref=&quot;myMethodInterceptor&quot; pointcut-ref=&quot;service&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre><p>测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService hello = (IAopService) context.getBean(&quot;aopServiceImpl&quot;);
        hello.withAop();
    }

}
</code></pre><h4 id="AspectJ-AOP切面编程"><a href="#AspectJ-AOP切面编程" class="headerlink" title="AspectJ AOP切面编程"></a>AspectJ AOP切面编程</h4><p>接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>实现</p>
<pre><code>public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>通知</p>
<pre><code>public class MyAspect {
    public void before1(JoinPoint jointPoint){
        System.out.println(&quot;before1&quot;);
    }
    public void before2(JoinPoint jointPoint){
        System.out.println(&quot;before2&quot;);
    }
}
</code></pre><p>配置</p>
<pre><code>&lt;!--1、目标--&gt;
&lt;bean id=&quot;aopServiceImplAspectJ&quot; class=&quot;AOP.AspectJ.AopServiceImpl&quot;/&gt;
&lt;!--2、通知--&gt;
&lt;bean id=&quot;myMethodInterceptorAspectJ&quot; class=&quot;AOP.AspectJ.MyAspect&quot;/&gt;
&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;aop:aspect ref=&quot;myMethodInterceptorAspectJ&quot;&gt;
        &lt;!--标签before决定前置通知--&gt;
        &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt;
        &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt;
        &lt;!--切入点--&gt;
        &lt;aop:pointcut id=&quot;serviceAspectJ&quot; expression=&quot;execution(* AOP.AspectJ.*.*(..))&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService hello = (IAopService) context.getBean(&quot;aopServiceImplAspectJ&quot;);
        hello.withAop();
    }

}
</code></pre><h4 id="AspcetJ注解驱动的切面"><a href="#AspcetJ注解驱动的切面" class="headerlink" title="@AspcetJ注解驱动的切面"></a>@AspcetJ注解驱动的切面</h4><p>1、接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>2、实现</p>
<pre><code>@Service(&quot;aopServiceImpl&quot;)
public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>3、通知</p>
<pre><code>@Component
@Aspect
//表示当前类是一个通知
public class MyAspect {

    @Before(value = &quot;bean(aopServiceImpl)&quot;)
    public void before1(JoinPoint jointPoint){
        System.out.println(&quot;before1&quot;);
    }

    public void before2(JoinPoint jointPoint){
        System.out.println(&quot;before2&quot;);
    }
}
</code></pre><p>4、配置</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
        xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;AOP.AspectJAnnotation&quot;/&gt;
    &lt;!--开启AspectJ注解开发的配置--&gt;
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre><p>5、测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService hello = (IAopService) context.getBean(&quot;aopServiceImpl&quot;);
        hello.withAop();
    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/[JSP]JSP笔记/" itemprop="url">
                  JSP笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T11:09:00+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JSP/" itemprop="url" rel="index">
                    <span itemprop="name">JSP</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p><strong><em>Java片段</em></strong>  </p>
<pre><code>&lt;%!  %&gt; jsp声明，在这里面声明的变量是全局变量，也可以函数定义
&lt;%  %&gt; Java片段，在这里面声明的变量是局部变量，
注释 &lt;%-- --%&gt;，&lt;%// % &gt;，&lt;%/* */% &gt;
&lt;%=  %&gt; 表达式
</code></pre><h2 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h2><ul>
<li>在web开发过程中，发现servlet做界面比较麻烦（out.println），于是又有一个新的技术JSP</li>
<li>JSP（Java Servlet Page）运行在服务器的语言，响应客户端请求，动态生成网页的技术</li>
</ul>
<h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h2><p><img src="http://i.imgur.com/WeHcjuc.png" alt=""></p>
<ul>
<li>如果是第一次访问jsp文件，web服务器就会把showTime.jsp <strong><em>翻译</em></strong> 成一个showTime_jsp.java（IDEA中showTIme_jsp.java的目录：<pre>C:\Users\Asus\.IntelliJIdea15\system\tomcat\Unnamed_JSP_Study\work\Catalina\localhost\JSP_Study\org\apache\jsp\showTime_jsp.java）</pre></li>
<li><font color="red">再将其编译成一个showTime_jsp.class，并把class加载到内存</font></li>
<li>然后创建一个该Servlet的实例，调用其jspInit方法，该方法在Servlet生命周期中只被执行一次，并调用实例的jspService()方法</li>
<li>如果是第二次或者以后，就直接访问内存中的实例的jspService()方法。JSP也是单例，所以第一次访问JSP网站速度比较慢，后面访问JSP的速度就变快了</li>
<li>如果某个JSP文件被修改了，就相当于重新访问JSP（相当于第一次访问）</li>
</ul>
<h2 id="JSP显示页面"><a href="#JSP显示页面" class="headerlink" title="JSP显示页面"></a>JSP显示页面</h2><p>Jsp页面中的html排版标签是如何被发送到客户端的？答：JSP中被翻译成Servlet时，HTML标签会<font color="red"><strong><em>以out.write()的形式打印出来</em></strong>，</font>例如：</p>
<pre><code>out.write(&quot;&lt;table border=1&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;/table&gt;\r\n&quot;);
</code></pre><h2 id="JSP中的Java片段"><a href="#JSP中的Java片段" class="headerlink" title="JSP中的Java片段"></a>JSP中的Java片段</h2><p>Jsp页面中的java代码，服务器是如何执行的？比如JSP中的Java代码:</p>
<pre><code>&lt;%
    int i=90;
    int j=i+90;
%&gt;
&lt;h1&gt;测试.&lt;/h1&gt;
&lt;%
    out.println(&quot;j=&quot;+j);
%&gt;
</code></pre><p>  当被翻译成Servlet后，格式如下</p>
<pre><code>public void _jspService(HttpServletRequest request, HttpServletResponse response)
    throws java.io.IOException, ServletException {
    int i=90;
    int j=i+90;
    out.println(&quot;j=&quot;+j);
}
</code></pre><ol>
<li>就是有多个&lt;% %&gt; 其实相当于是一个大的 &lt;% %&gt;，所有代码会<strong><em>放在一个_jspService函数中</em></strong></li>
<li>在&lt;% %&gt; 中定义的变量，会成为service函数的局部变量.</li>
</ol>
<h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><p>Web服务器在调用jsp时，会给jsp提供一些内置对象，<strong><em>这些内置对象无需创建可直接使用</em></strong>。前五个较常用，分别与Servlet中的几个对象对应</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>request：请求对象</td>
<td>javax.servlet.ServletRequest的子类</td>
<td>Request</td>
</tr>
<tr>
<td>response：响应对象</td>
<td>javax.servlet.ServletResponse的子类</td>
<td>Page</td>
</tr>
<tr>
<td>pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面</td>
<td>javax.servlet.jsp.PageContext</td>
<td>Page</td>
</tr>
<tr>
<td>session：会话对象，用于保存用户信息，跟踪用户行为</td>
<td>javax.servlet.http.HttpSession</td>
<td>Session</td>
</tr>
<tr>
<td>application：应用程序对象，多个用户共享该对象，可以做计数器</td>
<td>javax.servlet.ServletContext</td>
<td>Application</td>
</tr>
<tr>
<td>out：输出对象</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>Page</td>
</tr>
<tr>
<td>config：配置对象</td>
<td>javax.servlet.ServletConfig</td>
<td>Page</td>
</tr>
<tr>
<td>page：页面对象，代表JSP实例本身，使用较少</td>
<td>java.lang.Object</td>
<td>Page</td>
</tr>
<tr>
<td>exception：异常对象</td>
<td>java.lang.Throwable</td>
<td>Page</td>
</tr>
</tbody>
</table>
<h2 id="JSP的语法"><a href="#JSP的语法" class="headerlink" title="JSP的语法"></a>JSP的语法</h2><h3 id="指令元素"><a href="#指令元素" class="headerlink" title="指令元素"></a>指令元素</h3><p>　　概念: 用于从jsp发送一个信息到容器，比如设置全局变量,文字编码,引入包</p>
<h4 id="①page指令"><a href="#①page指令" class="headerlink" title="①page指令"></a>①page指令</h4><pre><code>&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;    
</code></pre><p><strong><em>常用的属性</em></strong>  </p>
<pre><code>language = &quot;xx&quot;，jsp中嵌入代码语言，通常是java
import = &quot;包.类名&quot;，在jsp页面引入类
errorPage=&quot;err.jsp&quot;，当JSP页面出现错误时，自动跳转到指定页面

contentType 和 pageEncoding的区别：
    contentType = &quot;text/html;charset=utf-8&quot; 指定网页以什么方式显示页面
    pageEncoding=&quot;utf-8&quot; 指定Servlet引擎以什么方法翻译jsp-&gt;servlet并指定网页以什么方式显示页面
</code></pre><h4 id="②include指令"><a href="#②include指令" class="headerlink" title="②include指令"></a>②include指令</h4><pre>
&lt;%@ include file="文件路径" %&gt;
</pre>

<ul>
<li>该指令用于引入一个文件（通常是JSP文件），JSP引擎会把两个JSP文件翻译成一个Servlet文件，因此也称为静态引入</li>
<li>被引入的JSP文件，只需保留page指令即可，html，body等均可省略★★★</li>
</ul>
<h4 id="③taglib指令"><a href="#③taglib指令" class="headerlink" title="③taglib指令"></a>③taglib指令</h4><p>　　允许在JSP页面使用自定义的标签</p>
<pre><code>&lt;mytag:yourTag num1 = &quot;123&quot; /&gt; 
</code></pre><h3 id="脚本元素-理解为脚本片段"><a href="#脚本元素-理解为脚本片段" class="headerlink" title="脚本元素(理解为脚本片段)"></a>脚本元素(理解为脚本片段)</h3><h4 id="java片段"><a href="#java片段" class="headerlink" title="java片段"></a>java片段</h4><pre><code>&lt;% java 代码 %&gt;
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>&lt;%=表达式 %&gt;，例如&lt;%=i*78-23%&gt;
</code></pre><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>全局变量</p>
<pre><code>&lt;%! int i=90; %&gt;
</code></pre><p>局部变量</p>
<pre><code>&lt;% int i=90;%&gt;
</code></pre><h4 id="定义函数★★★★★"><a href="#定义函数★★★★★" class="headerlink" title="定义函数★★★★★"></a>定义函数★★★★★</h4><pre><code>&lt;%!
    public int getResult(int a,int b){
        return a+b;
    }
%&gt;
注意：函数不能在&lt;% %&gt; 定义.
</code></pre><h3 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h3><p><strong><em>jsp:forward</em></strong></p>
<pre><code>&lt;jsp:forword file=&quot;xxx&quot;&gt;&lt;/jsp:forword&gt;页面跳转
</code></pre><p>　　在开发JSP的过程中，我们通常把JSP放入WEB-INF目录，目的是为了防止用户直接访问这些jsp文件.<br>　　在WebRoot下我们有一个入口页面,它的主要转发</p>
<pre><code>&lt;jsp:forword file=&quot;/WEB-INF/xx.jsp&quot;&gt;&lt;/jsp:forword&gt;
</code></pre><p><strong><em>jsp:incluce</em></strong>  </p>
<pre><code>&lt;%@ include file=&quot;&quot;%&gt; 静态引入
&lt;jsp:incluce  file=&quot;&quot;&gt;&lt;/jsp:incule&gt; 动态引入
相同点： 把一个文件引入到另外一个文件
区别：
    静态引入，把两个jsp翻译成一个Servlet,所以被引入的文件不要包含&lt;body&gt;&lt;html&gt;
    动态引入，把两个jsp分别翻译,所以被引入的jsp包含有&lt;html&gt;&lt;body&gt;也可以
</code></pre><h2 id="EL表达式语言"><a href="#EL表达式语言" class="headerlink" title="EL表达式语言"></a>EL表达式语言</h2><ul>
<li>EL表达式语言可以<strong><em>方便读取应用程序中的数据</em></strong>，JSP2.0以上版本即使没有JSTL（JSP标准标签库）也能使用EL</li>
<li>EL表达式以 <code>${</code> 开头，并以 <code>}</code> 结束，如${x + y}，从左向右取值，返回结果类型为String</li>
<li>EL表达式写在JSP的HTML代码中，而不能写在”&lt;%%&gt;”引起的JSP脚本中</li>
<li><font color="red"><strong>使用 <code>[]</code> 和 <code>.</code> 运算符来访问对象的属性，形式可以是${object.peopertyName}或${object[“peopertyName”]}</strong></font>


</li>
</ul>
<h3 id="EL内置对象"><a href="#EL内置对象" class="headerlink" title="EL内置对象"></a>EL内置对象</h3><p>我们知道jsp有九个内置对象，而EL表达式有11个对象，这些内置对象无需创建可直接使用</p>
<h4 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h4><p>pageContext对象表示当前JSP页面的javax.servlet.jsp.PageContext，包含了9大JSP内置对象</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>request：请求对象</td>
<td>javax.servlet.ServletRequest的子类</td>
<td>Request</td>
</tr>
<tr>
<td>response：响应对象</td>
<td>javax.servlet.ServletResponse的子类</td>
<td>Page</td>
</tr>
<tr>
<td>pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面</td>
<td>javax.servlet.jsp.PageContext</td>
<td>Page</td>
</tr>
<tr>
<td>session：会话对象，用于保存用户信息，跟踪用户行为</td>
<td>javax.servlet.http.HttpSession</td>
<td>Session</td>
</tr>
<tr>
<td>application：应用程序对象，多个用户共享该对象，可以做计数器</td>
<td>javax.servlet.ServletContext</td>
<td>Application</td>
</tr>
<tr>
<td>out：输出对象</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>Page</td>
</tr>
<tr>
<td>config：配置对象</td>
<td>javax.servlet.ServletConfig</td>
<td>Page</td>
</tr>
<tr>
<td>page：页面对象，代表JSP实例本身，使用较少</td>
<td>java.lang.Object</td>
<td>Page</td>
</tr>
<tr>
<td>exception：异常对象</td>
<td>java.lang.Throwable</td>
<td>Page</td>
</tr>
</tbody>
</table>
<p>例：获得客户端IP</p>
<pre><code>${pageContext.request.remoteAddr}
</code></pre><h4 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h4><p>包含所有初始化参数的Map，可以获取初始化参数</p>
<p>例，设置初始化参数</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>获得初始化参数</p>
<pre><code>${initParam.encoding}
</code></pre><h4 id="param"><a href="#param" class="headerlink" title="param"></a>param</h4><p>包含所有参数的Map，可以获取参数，返回String</p>
<p>例：url</p>
<pre><code>http://localhost:8080/SpringMVC_study/?name=xxx
</code></pre><p>获得参数</p>
<pre><code>${param.name}    
</code></pre><h4 id="paramValues"><a href="#paramValues" class="headerlink" title="paramValues"></a>paramValues</h4><p>包含所有参数的Map，可获取参数数组，返回String[]</p>
<p>例：请求url</p>
<pre><code>http://localhost:8080/SpringMVC_study/?name=aaa&amp;name=bbb
</code></pre><p>提交的参数name有多个值{“aaa”,”bbb”}，使用param只能获取第一个值，二使用paramValues能够获得其他的值</p>
<pre><code>${paramValues.name[0]}
${paramValues.name[1]}
</code></pre><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>包含所有头信息的Map，可以获取头信息</p>
<p>例：获得请求主机</p>
<pre><code>${header.host}
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>包含所有Cookie的Map，key为Cookie的name</p>
<pre><code>${cookie.JSESSIONID.value}
</code></pre><h4 id="applicationScope，sessionScope，requestScope，pageScope"><a href="#applicationScope，sessionScope，requestScope，pageScope" class="headerlink" title="applicationScope，sessionScope，requestScope，pageScope"></a>applicationScope，sessionScope，requestScope，pageScope</h4><p>分别是包含application，session，request，page作用域变量的Map</p>
<p>以requestScope为例：</p>
<p>使用<jsp:usebean id="person" class="com.jsp.bean.Person">声明person对象后，${pageScope.person.age}将输出person的age属性，useBean域默认的作用域为request</jsp:usebean></p>
<p>若输出session域中的变量，声明使<jsp:usebean id="person" class="com.jsp.bean.Person" scope="session"></jsp:usebean></p>
<h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>JSP标准标签库，用来解决遍历map或集合，格式化数字和日期等常见问题</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><p>JSTL 核心标签库标签共有13个，功能上分为4类：</p>
<ol>
<li>表达式控制标签：out、set、remove、catch</li>
<li>流程控制标签：if、choose、when、otherwise</li>
<li>循环标签：forEach、forTokens</li>
<li>URL操作标签：import、url、redirect</li>
</ol>
<h3 id="JSTL核心库"><a href="#JSTL核心库" class="headerlink" title="JSTL核心库"></a>JSTL核心库</h3><p><font color="red"><strong><em>使用标签时，一定要在jsp文件头加入以下代码：</em></strong></font></p>

<pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
</code></pre><h3 id="完整JSTL标签使用"><a href="#完整JSTL标签使用" class="headerlink" title="完整JSTL标签使用"></a>完整JSTL标签使用</h3><p><a href="http://www.cnblogs.com/lihuiyy/archive/2012/02/24/2366806.html" target="_blank" rel="external">http://www.cnblogs.com/lihuiyy/archive/2012/02/24/2366806.html</a></p>
<h3 id="遍历行为：-lt-c-forEach-gt"><a href="#遍历行为：-lt-c-forEach-gt" class="headerlink" title="遍历行为：&lt;c:forEach&gt;"></a>遍历行为：&lt;c:forEach&gt;</h3><p>语法：<br>&lt;c:forEach var=”name” items=”Collection” varStatus=”statusName” begin=”begin” end=”end” step=”step”&gt;&lt;/c:forEach&gt;</p>
<p>该标签根据循环条件遍历集合 Collection 中的元素。 var 用于存储从集合中取出的元素；items 指定要遍历的集合；</p>
<p><strong><em>遍历list</em></strong></p>
<pre>
&lt;%
    List a=new ArrayList();
    a.add("贝贝");
    a.add("晶晶");
    a.add("欢欢");
    a.add("莹莹");
    a.add("妮妮");
    request.setAttribute("a",a);
%>

<font color="red">&lt;c:forEach var="fuwa" items="${a}">
    &nbsp;&lt;c:out value="${fuwa}"/>&lt;br>
&lt;/c:forEach></font>
</pre>

<p><strong><em>遍历Map</em></strong></p>
<pre><code>&lt;%
    Map&lt;String, String&gt; capitals = new HashMap&lt;String,String&gt;();
    capitals.put(&quot;Indonesia&quot;,&quot;Jakarta&quot;);
    capitals.put(&quot;Malaysia&quot;,&quot;Kuala Lumpur&quot;);
    capitals.put(&quot;Thailand&quot;,&quot;Bangkok&quot;);
    request.setAttribute(&quot;capitals&quot;,capitals);
%&gt;

&lt;c:forEach var=&quot;capital&quot; items=&quot;${capitals}&quot;&gt;
    ${capital.key} ${capital.value} &lt;br/&gt;
&lt;/c:forEach&gt;
</code></pre><p><strong><em>forEach嵌套</em></strong></p>
<pre><code>&lt;%
    Map&lt;String, String[]&gt; bigCities = new HashMap&lt;String,String[]&gt;();
    bigCities.put(&quot;Australia&quot;,new String[]{&quot;Sydney&quot;,&quot;Melbourne&quot;,&quot;Perth&quot;});
    bigCities.put(&quot;New Zealand&quot;,new String[]{&quot;Auckland&quot;,&quot;Christchurch&quot;,&quot;Wellington&quot;});
    bigCities.put(&quot;Indonesia&quot;,new String[]{&quot;Jakarta&quot;,&quot;Surabaya&quot;,&quot;Medan&quot;});
    request.setAttribute(&quot;bigCities&quot;,bigCities);
%&gt;

&lt;c:forEach var=&quot;mapItem&quot; items=&quot;${bigCities}&quot;&gt;
    ${mapItem.key} :
        &lt;c:forEach var=&quot;city&quot; items=&quot;${mapItem.value}&quot;&gt;
            ${city}
        &lt;/c:forEach&gt;
    &lt;br/&gt;
&lt;/c:forEach&gt;
</code></pre><h3 id="格式化日期和时间"><a href="#格式化日期和时间" class="headerlink" title="格式化日期和时间"></a>格式化日期和时间</h3><pre><code>&lt;b&gt;格式化日期&lt;/b&gt;&lt;br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;格式化时间&lt;/b&gt;&lt;/br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;格式化日期和时间&lt;/b&gt;&lt;/br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;定制格式化日期和时间&lt;/b&gt;&lt;/br/&gt;
&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;br/&gt;
&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yy/MM/dd HH:mm:ss&quot;/&gt; &lt;br/&gt;
</code></pre><p>浏览器显示：</p>
<p><img src="http://i.imgur.com/4NLTcOv.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/13/[Java]Java中配置文件放在哪里/" itemprop="url">
                  Java中配置文件放在哪里
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-13T22:04:00+08:00" content="2016-07-13">
              2016-07-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><p>　　Java中路径可分为相对路径和绝对路径两种方式。<font color="red">相对路径</font>是相对当前工作目录，例如当使用命令</p>
<pre><code>C:\Users\Asus&gt;java MyClass xxx.properties  
</code></pre><p>要求在<code>C:\Users\Asus</code>目录下有xxx.properties文件，而在使用</p>
<pre><code>C:\&gt;java MyClass xxx.properties
</code></pre><p>时则要求在C盘根目录下有xxx.properties文件，所以使用相对路径是<strong>飘忽不定</strong>的，不建议使用。<br>　　但如果给出<font color="red">绝对路径</font>，<code>D:\xxx.properties</code>,当工程给用户时，若用户没有D盘，就会出现问题。<br>　　<strong>综上所述</strong>，仍旧采用绝对路径的方式来确定资源文件的地址，但是需要通过函数方法得到项目路径,在通过字符串连接的方式拼接得到绝对路径。</p>
<pre><code>//此时config.properties文件放在工程文件根目录下，即选择工程右键后，新建config.properties文件
InputStream ips = new FileInputStream(&quot;config.properties&quot;);
Properties properties = new Properties();
properties.load(ips);
System.out.println(properties.getProperty(&quot;name&quot;));  
</code></pre><h2 id="Java中比较常用的加载资源的方式"><a href="#Java中比较常用的加载资源的方式" class="headerlink" title="Java中比较常用的加载资源的方式"></a>Java中比较常用的加载资源的方式</h2><p>　　类加载器把字节码加载到内存中，即它可以加载.class文件，也可以加载普通文件。<br>　　当工程完成后，不会将工程目录下中的Src目录给用户（怎么可能会把源代码给用户），而是将bin目录下的文件，一些字节码等文件在用户电脑上运行。<br>　　eclipse会自动将Java文件编译，并存放字节码在 <code>工程目录/bin/包名</code>目录下，Java文件对应编译后的字节码，普通文件(如config.properties文件)仍原封不动拷贝过去。<br>　　类加载器会在<code>classPath</code>中搜索。<br>　　<font color="red">使用类加载器时，默认的主目录是src</font></p>
<pre><code>public class ReflectTest {
    public static void main(String[] args) throws Exception{
        /*InputStream ips = new FileInputStream(&quot;config.properties&quot;);
        Properties properties = new Properties();
        properties.load(ips);
        System.out.println(properties.getProperty(&quot;name&quot;));   */ 
        InputStream ipsInputStream = ReflectTest.class.getClassLoader().getResourceAsStream(&quot;com/qianming/config.properties&quot;);

        //在class类中直接有一个getResourceAsStream方法，路径名相对当前包名的相对路径，所以这里可以直接写config.properties
        //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;config.properties&quot;);
        //如果路径中写上&apos;/&apos;，则此时需相对根目录写路径
        //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;/com/qianming/config.properties&quot;);

        Properties properties = new Properties();
        properties.load(ipsInputStream);
        System.out.println(properties.getProperty(&quot;name&quot;));
    }
}
</code></pre><p><strong><em>注意:</em></strong><br>　　这里使用的路径是<code>com/qianming/config.properties</code>，即在<code>包/资源文件</code>的形式不能在com前加 <strong>“/“</strong>,记忆就行，否则会报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/08/[Java]JAVA分层思想/" itemprop="url">
                  JAVA分层思想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-08T14:49:00+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用户管理系统系统框架【需改造】"><a href="#用户管理系统系统框架【需改造】" class="headerlink" title="用户管理系统系统框架【需改造】"></a>用户管理系统系统框架【需改造】</h2><p><strong><em>存在的问题</em></strong>  </p>
<p>　　LoginClServlet中太过臃肿，既有业务逻辑，又有对数据库的操作，后期难以进行维护</p>
<p><img src="http://img.blog.csdn.net/20160611213134633" alt="这里写图片描述"></p>
<h2 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h2><p>① 业务逻辑代码和界面分离<br>② 把常用的代码(对数据库的连接和操作)封装到工具类SqlHelper【有时也称为DAO，数据访问对象，是对数据库进行操作】</p>
<h2 id="具体的方法"><a href="#具体的方法" class="headerlink" title="具体的方法"></a>具体的方法</h2><p>①    每一张表对应一个<font color="red">domain类</font>(表示数据)，还要对应一个<font color="red">Service类</font>（表示操作）<br>比如 users 表 对应 Users 类(domain 类)，UserService类(该类会封装对users表的各种操作)</p>
<p>每个表对应一个domain对象和Service类，将关系模型转化为对象模型（如下图），实际上这里体现出数据和操作分离的思想<br>② view负责与用户进行交互，并将数据传递给controller<br>③ controller接收view中传递的数据，进行数据校验，并调用service方法，根据返回结果的不同跳转到不同的显示页面</p>
<p><img src="http://img.blog.csdn.net/20160611212436607" alt="这里写图片描述"></p>
<h2 id="改造后系统框架"><a href="#改造后系统框架" class="headerlink" title="改造后系统框架"></a>改造后系统框架</h2><p><img src="http://i.imgur.com/DDiJspS.png" alt=""></p>
<ul>
<li>web层，structs位于web层，体现MVC的数据输入、数据处理、数据显示分离，当然web层需要调用service层中的方法完成数据处理。显示页面为MVC中的V，控制器为MVC中的C</li>
<li>model层可以划分为业务层（service）、DAO层、数据持久层，这里强调一下，在一个项目中不一定全部有，可以根据实际情况选择</li>
<li>hiberate（orm框架），处于数据持久层，主要解决关系模型和对象模型之间的阻抗，体现oop</li>
</ul>
<p><strong><em>详细文档</em></strong>  </p>
<p><a href="https://github.com/rhapsody1290/servlet_study_usersmanager_MVC_change/blob/master/doc/%E5%88%86%E5%B1%82.xls" target="_blank" rel="external">https://github.com/rhapsody1290/servlet_study_usersmanager_MVC_change/blob/master/doc/%E5%88%86%E5%B1%82.xls</a></p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p><strong><em>完成分页的mvc模式改写</em></strong><br>　　首先在UsersService类中添加方法getUsersByPage,然后再<br><strong><em>为什么要返回ArrayList ,而不是我们想到 ResultSet?</em></strong><br>　　1. ArrayList 中封装 User对象，更加符合面向对象的编程方式  OOP<br>　　2. 我们通过Resulst-&gt;User对象-&gt;ArrayList这样ArrayList和 Resultset没有关系，就可以及时关闭数据库资源</p>
<hr>
<pre><code>//按照分页来获取用户列表
public ArrayList&lt;Users&gt; getUsersByPage(int pageNow, int pageSize){
    ArrayList&lt;Users&gt; al = new ArrayList&lt;Users&gt;();

    ResultSet rs = SqlHelper.executeQuery(&quot;select * from users limit &quot; +
            (pageNow - 1) * pageSize + &quot;,&quot; + pageSize, null);
    try {
        while(rs.next()){
            Users user = new Users();
            user.setId(rs.getInt(&quot;id&quot;));
            user.setUsername(rs.getString(&quot;username&quot;));
            user.setEmail(rs.getString(&quot;email&quot;));
            user.setGrade(rs.getInt(&quot;grade&quot;));
            user.setPasswd(rs.getString(&quot;passwd&quot;));
            al.add(user);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        SqlHelper.close(rs,SqlHelper.getPs(),SqlHelper.getCt());
    }
    return al;
}
</code></pre><h2 id="Web-Service-DAO（数据访问层）大讨论"><a href="#Web-Service-DAO（数据访问层）大讨论" class="headerlink" title="Web-Service-DAO（数据访问层）大讨论"></a>Web-Service-DAO（数据访问层）大讨论</h2><p>　　mvc规定我们应该怎样去开发软件（把数据输入，数据处理，数据显示分离）<br>　　web(jsp V/Servlet C)-servie(M)-dao(M)这是一种mvc的具体实现<br>　　web(jsp V/Servlet C)-service(M)开发方式也是一种具体的实现</p>
<p><img src="http://i.imgur.com/j26engw.png" alt=""></p>
<ul>
<li>举个例子，UserService.java中只包含业务逻辑，UserBean.java为数据对象，而对数据库的操作放在UserDao.java中</li>
<li>这种分层的好处是使数据和操作分离</li>
<li>将整个model层分为service层和dao层（数据访问层）</li>
<li>若UserService中业务需要对多张表进行操作，可以通过多个DAO的组合操作来实现</li>
<li>但在实际项目中，很多持久化逻辑本身就是业务逻辑（比如增加一个用户，增加用户信息到数据库时持久化逻辑，增加用户是业务逻辑），省略DAO层有时候更方便，更实用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/08/[Java]Java基础常用/" itemprop="url">
                  Java基础常用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-08T14:49:00+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读取文件根目录"><a href="#读取文件根目录" class="headerlink" title="读取文件根目录"></a>读取文件根目录</h2><pre><code>根目录在工程目录
InputStream ips = new FileInputStream(&quot;src/xx.properties&quot;);
类加载器根目录在src下
InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;);
maven项目根目录为resources
InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;);
</code></pre><h2 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h2><pre><code>//读取文件
String realPath = this.getServletContext().getRealPath(&quot;record.txt&quot;);
FileReader fileReader = new FileReader(realPath);
BufferedReader br = new BufferedReader(fileReader);
String nums = br.readLine();
//一定要关闭流
br.close();
fileReader.close();
out.println(nums);
//写入文件
FileWriter fileWriter = new FileWriter(realPath);
BufferedWriter bw = new BufferedWriter(fileWriter);
bw.write(String.valueOf(Integer.parseInt(nums) + 1));
bw.close();
fileWriter.close();
</code></pre><h2 id="从控制台读取数据"><a href="#从控制台读取数据" class="headerlink" title="从控制台读取数据"></a>从控制台读取数据</h2><pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(br.readLine());
</code></pre><h2 id="Java读取资源文件"><a href="#Java读取资源文件" class="headerlink" title="Java读取资源文件"></a>Java读取资源文件</h2><pre><code>/**
 * 文件类型是UTF-8，在String生成字符时需指定解码方式为utf-8；
 */
InputStream ips = null;
try {
    ips = MyServer.class.getClassLoader().getResourceAsStream(&quot;com/main/戏曲.txt&quot;);
    int hasRead = 0;
    byte[] buffer = new byte[1024];
    StringBuffer content = new StringBuffer();
    while((hasRead = ips.read(buffer)) &gt; 0){
        content.append(new String(buffer, 0, hasRead, &quot;utf-8&quot;));
    }
    System.out.println(content);
} catch (Exception e) {
    e.printStackTrace();
}finally{
    if (ips != null) {
        try {
            ips.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>四舍五入
float totalMoney = 123.124f;
BigDecimal b = new BigDecimal(totalMoney);  
totalMoney  = b.setScale(2,BigDecimal.ROUND_HALF_UP).floatValue();  
保留两位小数
String.format(&quot;%.2f&quot;, totalMoney)
</code></pre><h2 id="生成指定长度的随机字符串"><a href="#生成指定长度的随机字符串" class="headerlink" title="生成指定长度的随机字符串"></a>生成指定长度的随机字符串</h2><pre><code>//生成指定长度的随机字符串    
public static String GenRandomString(int length){
    Random random = new Random();    
    char[] charArray = &quot;abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
    char[] randomChar = new char [length];
    for(int i = 0; i &lt; randomChar.length; i++){
        randomChar[i] = charArray[random.nextInt(charArray.length)];
    }        
    return new String(randomChar);    
}
</code></pre><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>MAVEN依赖：http://blog.csdn.net/earbao/article/details/44900083
连接步骤：http://www.cnblogs.com/hongten/archive/2011/03/29/1998311.html
</code></pre><p><strong><em>JDBC查询</em></strong></p>
<pre><code>//到数据库中验证
/*
* 1.加载驱动
* 2.得到连接
* 3.创建PrepareStatment
* 4.执行操作
* 5.根据结果做处理
* */
Connection connection = null;
PreparedStatement ps = null;
ResultSet rs = null;

try {
    //1.加载驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    //2.获得连接
    connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/servlet_users_manager&quot;,&quot;root&quot;,&quot;root&quot;);
    //3.创建prepareStatement
    ps = connection.prepareStatement(&quot;select * from users where username = ? and passwd = ?&quot;);
    ps.setObject(1,username);
    ps.setObject(2,password);
    //4.执行操作
    rs = ps.executeQuery();
    //5.根据结果做处理
    if(rs.next()){
        //说明用户合法
        System.out.println(rs.getString(&quot;username&quot;) + &quot; &quot; + rs.getString(&quot;passwd&quot;));
        request.getRequestDispatcher(&quot;/MainFrame&quot;).forward(request,response);
    }else{
        request.getRequestDispatcher(&quot;/Login&quot;).forward(request,response);
    }
} catch (Exception e) {
    e.printStackTrace();
}finally {
    //关闭资源
    if(rs != null){   // 关闭记录集
        try{
            rs.close();
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
    if(ps != null){   // 关闭声明
        try{
            ps.close() ;
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
    if(connection != null){  // 关闭连接对象
        try{
            connection.close() ;
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
}
</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><strong><em>定义四个分页变量</em></strong></p>
<pre><code>pageNow   表示第几页,该变量是由用户来决定,因此变化
pageSize  每页显示几条记录,由程序指定,也可以由用户定制
pageCount 表示共有多少页, 该变量是计算出来-&gt;思考 怎样确定
rowCount  共有多少条记录,该变量是查询数据库得到
</code></pre><p><strong><em>如何确定pageCount</em></strong>    </p>
<pre><code>(1)
if(rowCount% pageSize==0){
    pageCount=rowCount/pageSize;
}else{
    pageCount= rowCount/pageSize+1;
}
试试: 比如 users表 9 条记录 pageSize=3  =&gt;pageCount=3
       比如 users表 10 条记录 pageSize=3  =&gt;pageCount=4
(2)
上面的算法等价于
pageCount=rowCount% pageSize==0 ? rowCount/pageSize: rowCount/pageSize+1;

该运算称为三目运算
(3)
更简单的算法是:★★★★★
pageCount=(rowCount-1)/pageSize+1;
试试: 比如 users表 9 条记录 pageSize=3  =&gt;pageCount=3
       比如 users表 11 条记录 pageSize=3  =&gt;pageCount=4
为什么？
    如果pageSize整除rowCount，值不需要加一；
    如果pageSize不整除rowCount，值需要加一。
    我们可以使rowCount-1，保证每次都不能整除，这样可以得到统一公式:
        pageCount = （rowCount-1）/pageSize + 1
</code></pre><h3 id="项目中传递参数"><a href="#项目中传递参数" class="headerlink" title="项目中传递参数"></a>项目中传递参数</h3><p>客户端传递：pageNow、pageSize（为保证程序健壮性，服务器中设置pageNow和pageSize的默认值）<br>服务器传递：数据和rowCount</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>利用Java自带的MD5加密</p>
<pre><code>class MD5Util {
    public final static String MD5(String s) {
        char hexDigits[] = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,
                &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; };
        try {
            byte[] strTemp = s.getBytes();
            MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;);
            mdTemp.update(strTemp);
            byte[] md = mdTemp.digest();
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i &lt; j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];
                str[k++] = hexDigits[byte0 &amp; 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            return null;
        }
    }

    public static void main(String[] args) {
        // MD5_Test aa = new MD5_Test();
        System.out.print(MD5Util.MD5(&quot;qm&quot;));
    }
}
</code></pre><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><pre><code>public class check_code extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 7.禁止浏览器缓存随机图片
        response.setDateHeader(&quot;Expires&quot;, -1);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        // 6.通知客户机以图片方式打开发送过去的数据
        response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);
        // 1.在内存中创建一副图片
        BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB);
        // 2.向图片上写数据
        Graphics g = image.getGraphics();
        // 设背景色
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 60, 30);
        // 3.设置写入数据的颜色和字体
        g.setColor(Color.RED);
        g.setFont(new Font(null, Font.BOLD, 20));
        // 4.向图片上写数据
        String num = makeNum();
        //这句话就是把随机生成的数值，保存到session
        request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了
        g.drawString(num, 5, 22);
        // 5.把写好数据的图片输出给浏览器
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }
    //该函数时随机生成4位数字
    public String makeNum() {
        Random r = new Random();
        //9999999 可以生成7位
        String num = r.nextInt(9999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        //如果不够4位，前面补零
        for (int i = 0; i &lt; 4 - num.length(); i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
</code></pre><h2 id="list转string"><a href="#list转string" class="headerlink" title="list转string[]"></a>list转string[]</h2><p>方法一：单个元素转换</p>
<pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);
//转化成Object数组
Object[] objs = array.toArray();
//新建数组
String[] strings = new String[array.size()];
//每个元素类型转换
int i = 0;
for(Object obj : objs){
    if(obj instanceof String){
        strings[i++] = (String)obj;
    }
}
for(String s : strings){
    System.out.println(s);
}
</code></pre><p>方法二：整个转</p>
<pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);

String[] strings = new String[array.size()];
array.toArray(strings);
for(String s : strings){
    System.out.println(s);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/08/[IDEA]IDEA快捷键/" itemprop="url">
                  IDEA快捷键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-08T00:00:00+08:00" content="2016-07-08">
              2016-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index">
                    <span itemprop="name">IDEA</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://blog.csdn.net/dc_726/article/details/42784275" target="_blank" rel="external">http://blog.csdn.net/dc_726/article/details/42784275</a></p>
<h2 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h2><ul>
<li>Alt + /基本代码提示 <font color="gray">CTRL+空格(和系统输入法冲突，请在Settings-&gt;Keymap-&gt;mainmenu -&gt; code -Completion-&gt;basic，右键添加自己的快捷键)，可以设置为Alt + /</font></li>
<li>Ctrl + Alt + /更智能地按类型信息提示 <font color="gray">默认为Ctrl+Shift+Space</font></li>
<li><strong>ALT + Enter 快速修复，类似Eclipse中的Quick Fix功能</strong></li>
<li>Ctrl+Shift+Enter 自动补全末尾的字符，例如敲完if/for时也可以自动补上{}花括号</li>
<li><strong>F2/ Shift+F2 移动到有错误的代码</strong></li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul>
<li>Ctrl+Shift+Alt+T 重构功能大汇总快捷键，叫做Refactor This</li>
<li>Shift+F6 直接就是改名</li>
<li>Ctrl+Alt+V 提取变量</li>
</ul>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><ul>
<li>Ctrl+J 可以查看所有模板</li>
<li>Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等</li>
</ul>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul>
<li><strong>Ctrl + Shift + 上下 ： 上下移动当前行</strong></li>
<li>Ctrl + Shift + 左右 ：代替鼠标选中代码</li>
<li>Ctrl + Alt + 上下 ： 复制一行</li>
<li>Alt + 上下 ： 光标函数间跳转</li>
<li><strong>Alt + 左右 ： tab切换</strong></li>
<li><strong>Ctrl + D ： 删除一行</strong></li>
<li>Ctrl + / ： 注释</li>
<li>Ctrl + / Ctrl + Shift + / ： 折叠代码</li>
<li>Ctrl + ‘+’ Ctrl + Shift + ‘+’： 展开代码</li>
<li><strong><em>Ctrl+N / Ctrl+Shift+N 可以打开类或资源</em></strong></li>
<li>Shift+Shift 在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等</li>
<li>Ctrl+F/Ctrl+Shift+F 在当前窗口或全工程中查找</li>
<li>F3/Shift+F3前后移动到下一匹配处</li>
<li><strong>格式化代码  </strong><br>　　格式化import列表：Ctrl+Alt+O<br>　　格式化代码：Ctrl+Alt+L</li>
</ul>
<h2 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h2><ul>
<li><strong><em>CTRL+ALT+L  格式化代码</em></strong>    </li>
<li>CTRL+E或者ALT+SHIFT+C 最近更改的代码  </li>
<li>CTRL+SHIFT+SPACE 自动补全代码  </li>
<li>CTRL+ALT+SPACE  类名或接口名提示  </li>
<li><strong><em>CTRL+P   方法参数提示</em></strong>  </li>
<li><strong><em>CTRL+ALT+T  代码模版</em></strong></li>
<li><strong>Ctrl+Shift+T 自动生成测试类</strong></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>CIRL+U   大小写切换</li>
<li>CTRL+Z   倒退</li>
<li>CTRL+SHIFT+Z  向前</li>
<li><strong><em>CTRL+ALT+F12  资源管理器打开文件夹在WINDOW窗口快速定位到文件或者文件夹的位置</em></strong></li>
<li>ALT+F1   查找文件所在目录位置</li>
<li>SHIFT+ALT+INSERT 竖编辑模式</li>
<li>CTRL+/   注释//  </li>
<li>CTRL+SHIFT+/  注释</li>
<li>CTRL+B   快速打开光标处的类或方法</li>
<li><strong><em>page up 和 page down</em></strong></li>
<li><strong><em>ALT+ ←/→  切换代码视图</em></strong></li>
<li><strong><em>ALT+ ↑/↓  在方法间快速移动定位</em></strong></li>
<li>CTRL+ALT ←/→  返回上次编辑的位置</li>
<li><strong><em>SHIFT+F6  重构-重命名</em></strong></li>
<li>CTRL+H   显示类结构图</li>
<li><strong><em>CTRL+Q   显示注释文档</em></strong></li>
<li><strong><em>ALT+1   快速打开或隐藏工程面板</em></strong></li>
<li><strong><em>ALT + 4 Run Console</em></strong></li>
<li><strong><em>ALT + 5 Debug Console</em></strong></li>
<li><strong><em>在任何工具窗口里使用Escape键都可以把焦点移到编辑器上,Shift-Escape不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口</em></strong></li>
<li>CTRL+W   选中代码，连续按会有其他效果（我去掉了）</li>
<li><strong><em>CTRL+F4   关闭当前打开文件（我修改为CTRL + W）</em></strong></li>
<li><strong>Ctrl + Shift + F12 关闭所有工具栏</strong></li>
<li><strong><em>Ctrl+H 查看类的继承关系，打开类层次窗口</em></strong></li>
<li><strong><em>Ctrl+F12 查看当前类的所有方法</em></strong></li>
<li><strong><em>Ctrl+B/Ctrl+Alt+B 在继承层次上跳转，分别对应父类或父方法定义和子类或子方法实现</em></strong></li>
<li><strong><em>Ctrl + tab 切来切去</em></strong></li>
<li><strong><em>Ctrl + Shift + A 发号施令</em></strong></li>
<li><strong><em>CTRL+G 定位行</em></strong></li>
</ul>
<h2 id="JDK-doc绑定"><a href="#JDK-doc绑定" class="headerlink" title="JDK doc绑定"></a>JDK doc绑定</h2><p>CTRL + Q 查看注释文档</p>
<p><img src="http://i.imgur.com/vHEExEB.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/[Servlet]Intellij IDEA创建Maven管理的Java Web项目/" itemprop="url">
                  Intellij IDEA15创建Maven管理的Java Web项目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T10:13:00+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文的思路是先创建Maven项目，再加上Java Web模块支持</p>
<h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p><strong><em>File - New - Project，创建Maven项目</em></strong></p>
<p><img src="http://i.imgur.com/yCSg2OK.png" alt=""></p>
<p><strong><em>Next，填写GroupId，ArtifactId和Version</em></strong></p>
<p><img src="http://i.imgur.com/VlBtIOA.png" alt=""></p>
<p><strong><em>Next，这里在Properties中添加一个参数<code>archetypeCatalog=internal</code>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。</em></strong></p>
<pre><code>来自网上的解释：      
archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。
</code></pre><p><img src="http://i.imgur.com/YePrI2x.png" alt=""></p>
<p><strong><em>Next，填写项目名和module名称，项目名和模块名可以不一样（还不是很清楚两者的区别）</em></strong></p>
<p><img src="http://i.imgur.com/yrmOBcr.png" alt=""></p>
<p><strong><em>点击Finsh，项目的目录结构如下：</em></strong>  </p>
<p><img src="http://i.imgur.com/mppsHHu.png" alt=""></p>
<p>Maven规定，src文件下有<code>main</code>和<code>test</code>两个文件夹。其中：  </p>
<ul>
<li>main文件为项目主体目录，main下的java文件夹为源代码目录，resource为所需资源目录</li>
<li>test为项目测试目录，test下的java文件夹为测试代码目录，resources为测试所需资源目录</li>
</ul>
<p><strong><em>发现生成的Maven项目，没有Web目录！在项目名称右击，选择Add Framework Support</em></strong></p>
<p><img src="http://i.imgur.com/p5NAWmy.png" alt=""></p>
<p><strong><em>在Add Framework Support对话框中勾选Web Application，版本选择3.0并勾选Create web.xml</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248954_3896.png" alt=""></p>
<p><strong><em>点击OK后，看到如下界面，项目中出现了web文件夹，是不是很熟悉了，和MyEclipse中的项目结构类似</em></strong></p>
<p><img src="http://i.imgur.com/L5LXM7A.png" alt=""></p>
<h2 id="配置Tomcat服务器"><a href="#配置Tomcat服务器" class="headerlink" title="配置Tomcat服务器"></a>配置Tomcat服务器</h2><p><strong><em>点击右上角的倒三角，选择<code>Edit Configurations</code>，弹出服务器配置页面</em></strong></p>
<p><img src="http://i.imgur.com/77V6dHo.png" alt=""></p>
<p><strong><em>如下图，选择Local，然后点击Configure，在弹出的对话框中选择Tomcat安装目录</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248975_9849.png" alt=""></p>
<p><strong><em>选择Tomcat Server，然后点击绿色的“+”号</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248979_4524.png" alt=""></p>
<p><strong><em>点击“+”后选择Local，刚刚已经配置好了Local的Tomcat服务器</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248982_3705.png" alt=""></p>
<p><strong><em>这里会新建一个Tomcat服务，输入任意名字即可。Update的快捷键是Ctrl+F10</em></strong></p>
<p><img src="http://i.imgur.com/zVA6RYW.png" alt=""></p>
<p><strong><em>点击Deployment，然后点击右边的“+”，添加Artifact部署</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248993_1308.png" alt=""></p>
<p><strong><em>输入应用程序Context，输入路径:<code>/工程名</code></em></strong></p>
<p><img src="http://i.imgur.com/xsZHFqP.png" alt=""></p>
<p><strong><em>点击界面上方的启动按钮就可以启动Tomcat服务器，启动后服务器自动打开浏览器</em></strong></p>
<p><img src="http://i.imgur.com/fmJjfqg.png" alt=""></p>
<p><strong><em>回到主界面，如图，点击Run打开服务器视图，能看到项目的部署情况了，而且可以完成服务器重启/关闭，项目部署等操作</em></strong></p>
<p><img src="http://i.imgur.com/LMFpfTI.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/[Servlet]Servlet笔记/" itemprop="url">
                  Servlet笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T11:17:00+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><pre><code>#网页输出
PrintWriter out = response.getWriter();
out.println(&quot;Hello World&quot;);
#请求头
request.getHeader(&quot;host&quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&lt;String&gt; names = request.getHeaderNames();
while(names.hasMoreElements()){
    String name = names.nextElement();
    System.out.println(name + &quot;：&quot; + request.getHeader(name));
}
#浏览器返回
response.setContentType(&quot;text/html;charset=utf-8&quot;);
response.setCharacterEncoding(&quot;utf-8&quot;);
#获得请求参数
String username = request.getParameter(&quot;username&quot;);
Enumeration&lt;String&gt; e = request.getParameterNames()
#跳转
1、request.getRequestDispatcher(&quot;/资源URI&quot;).forward(request,response)
2、response.sendRedirect(&quot;/web应用/资源URI&quot;);
#获得web应用根路径
String path = this.getServletContext().getRealPath(&quot;/&quot;);
#获得资源路径
String path = this.getServletContext().getRealPath(&quot;/image/无标题.png&quot;);
#session，可以存字符串和对象
request.getSession().setAttribute(&quot;username&quot;,username);
request.getSession().getAttribute(&quot;username&quot;)
</code></pre><h2 id="为什么需要Servlet技术？"><a href="#为什么需要Servlet技术？" class="headerlink" title="为什么需要Servlet技术？"></a>为什么需要Servlet技术？</h2><p>　　普通的java技术很难完成网站开发，sun 就开发了servlet技术供程序员使用</p>
<h2 id="servlet的介绍"><a href="#servlet的介绍" class="headerlink" title="servlet的介绍"></a>servlet的介绍</h2><ul>
<li>servlet 其实就是java程序(java类)</li>
<li>该 java程序(java 类)要遵循servlet开发规范，继承servlet类</li>
<li>serlvet是运行在服务端</li>
<li>serlvet功能强大,几乎可以完成网站的所有功能</li>
<li>是学习jsp基础</li>
</ul>
<h2 id="Tomcat-和-servlet-在网络中的位置"><a href="#Tomcat-和-servlet-在网络中的位置" class="headerlink" title="Tomcat 和 servlet 在网络中的位置"></a>Tomcat 和 servlet 在网络中的位置</h2><p><img src="http://i.imgur.com/jvuMyhS.png" alt=""></p>
<h3 id="Tomcat三大功能"><a href="#Tomcat三大功能" class="headerlink" title="Tomcat三大功能"></a>Tomcat三大功能</h3><ul>
<li>Web服务器，与浏览器通信，解析和处理HTTP请求，处理静态页面</li>
<li>Servlet容器（Catalina），处理Servlet</li>
<li>JSP容器，把JSP页面翻译成一般的Servlet</li>
</ul>
<h3 id="Servlet容器与Servlet关系★★★★★"><a href="#Servlet容器与Servlet关系★★★★★" class="headerlink" title="Servlet容器与Servlet关系★★★★★"></a>Servlet容器与Servlet关系★★★★★</h3><ul>
<li>Servlet技术的核心是Servlet，所有的Servlet类必须直接或间接实现Servlet接口</li>
<li><strong><em>Servlet接口定义了Servlet与Servlet容器之间的契约</em></strong>，即Servlet容器将Servlet类载入内存，并在Servlet实例是调用具体的方法，如用户请求时Servlet调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例</li>
</ul>
<h2 id="Web程序目录结构"><a href="#Web程序目录结构" class="headerlink" title="Web程序目录结构"></a>Web程序目录结构</h2><p><img src="http://i.imgur.com/0HhKiSj.png" alt=""></p>
<ul>
<li>静态页面、jsp直接放在web目录下</li>
<li>Servlet是Java程序，必须放在WEB-INF/classes目录下</li>
</ul>
<h2 id="Servlet工作流程★★★"><a href="#Servlet工作流程★★★" class="headerlink" title="Servlet工作流程★★★"></a>Servlet工作流程★★★</h2><p><img src="http://i.imgur.com/6yEbnhC.png" alt=""></p>
<pre><code>用户输入的URL为http://localhost:8088/hspWeb1/MyFirstServlet
浏览器解析主机名（host文件，dns）
浏览器尝试连接web服务器（三次握手）
浏览器发送http请求
web服务器开始工作，首先解析主机名，选择使用哪个主机（引擎下有多个主机，有默认主机）
web服务器解析web应用，确定使用主机下的context
web服务器解析资源名，一个web应用下有多个资源，这里是MyFirstServlet
查询web.xml文件，确定MyFirstServlet在哪个包下
Web服务器利用反射机制，创建实例，并调用init方法（该方法只调用一次）
web服务器把接收到的http请求封装成Request对象，作为service的参数传入。service会被调用多次，没访问一次Servlet，它的service就会被调用一次
Servlet获得response对象，返回结果
web服务器把request的信息拆除，形成http响应格式
当在某些情况下（tomcat重启、reload该webapp、重启电脑）web服务器会调用Servlet的destroy方法，将该servlet销毁
</code></pre><h2 id="面试题-请简述servlet的生命周期-工作流程"><a href="#面试题-请简述servlet的生命周期-工作流程" class="headerlink" title="面试题: 请简述servlet的生命周期(工作流程)"></a>面试题: 请简述servlet的生命周期(工作流程)</h2><p>答:<br>　　当第一次访问某个servlet，web服务器将会创建一个该servlet的实例，并且调用 servlet的init()方法，init函数只会被调用一次；如果当服务器已经存在了一个servlet实例，那么，将直接使用此实例；每次请求都会调用service()方法，service()方法将根据客户端的请求方式来决定调用对应的doXXX()方法；当 web应用 reload 或者 关闭 tomcat 或者 关机，web服务器将调用destroy()方法，将该servlet从服务器内存中删除。</p>
<h2 id="开发Servlet程序"><a href="#开发Servlet程序" class="headerlink" title="开发Servlet程序"></a>开发Servlet程序</h2><p><strong><em>开发servlet有三种方法★★★</em></strong></p>
<ul>
<li>(1)    实现 Servlet接口(对Servlet的工作过程有清晰的认识)</li>
<li>(2)    通过继承 GenericServlet</li>
<li>(3)    通过继承 HttpServlet</li>
</ul>
<h3 id="①实现servlet接口的方式"><a href="#①实现servlet接口的方式" class="headerlink" title="①实现servlet接口的方式"></a>①实现servlet接口的方式</h3><p>需求如下: 请使用实现接口的方式，来开发一个Servlet，要求该Servlet可以显示Hello，world，同时显示当前时间</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、在webapps下建立一个web应用my<br>2、在my下建立 WEB-INF-&gt;web.xml [web.xml可以从 ROOT/WEB-INF/web.xml拷贝]<br>3、在WEB-INF下建立 classes 目录(我们的Servlet 就要在该目录开发)，建立lib文件夹<br>4、开发MyServlet.java  </p>
<pre>
package com.apeius;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class MyServlet implements Servlet
{
    //该函数用于初始化servlet,就是把该servlet装载到内存中,该函数只会被调用一次
    <font color="red">/*调用这个方法，Servlet容器会传入一个ServletConfig，
    * 一般会将ServletConfig赋给一个类级对象，这样可以在Servlet类中其他点来使用，
    * 但Servlet实例会被一个应用程序的所有用户共享，使用类级变量须是只读的，或者是
    * java.util.concurrent.atomic包的成员
    * /</font>
    public void init(ServletConfig config)
          throws ServletException{
    }

    //得到ServletConfig对象
    public ServletConfig getServletConfig(){
        return null;
    }

    //该函数是服务函数,我们的业务逻辑代码就是写在这里
    //该函数每次都会被调用
    public void service(ServletRequest req,
                    ServletResponse res)
             throws ServletException,
                    java.io.IOException{
        //在控制台输出时间
        System.out.println(new java.util.Date());
    }
    //该函数时得到servlet配置信息
    public java.lang.String getServletInfo(){
        return null;
    }
    //销毁该servlet,从内存中清除,该函数被调用一次
    public void destroy(){

    }
}
</pre>

<p>5、编译</p>
<p>如果使用javac去编译一个带package的java文件，则需要带命令参数<code>javac –d . java文件</code></p>
<p>6、根据Servlet规范，我们还需要部署Servlet</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
   version=&quot;2.5&quot;&gt;

    &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/ABC&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

服务器调用流程：http://localhost:8088/my/ABC---&gt;①---&gt;②---&gt;③---&gt;④
</code></pre><p>7、在浏览器中测试</p>
<p>　　在浏览器中输入<a href="http://localhost:8080/my/ABC" target="_blank" rel="external">http://localhost:8080/my/ABC</a></p>
<h3 id="②使用GenericServlet开发servlet（了解即可）"><a href="#②使用GenericServlet开发servlet（了解即可）" class="headerlink" title="②使用GenericServlet开发servlet（了解即可）"></a>②使用GenericServlet开发servlet（了解即可）</h3><h4 id="为什么使用GenericServlet"><a href="#为什么使用GenericServlet" class="headerlink" title="为什么使用GenericServlet"></a>为什么使用GenericServlet</h4><p>1、实现Servlet接口<strong><em>必须实现接口中的所有方法</em></strong>，即使有一些方法根本没有包含任何代码<br>2、此外还<strong><em>需要将ServletConfig对象保存到类级变量中</em></strong></p>
<h4 id="GenericServlet完成的任务"><a href="#GenericServlet完成的任务" class="headerlink" title="GenericServlet完成的任务"></a>GenericServlet完成的任务</h4><ul>
<li>将init方法中个ServletConfig赋给一个类级变量，以便可以通过getServletConfig获取</li>
<li>为Servlet接口中的所有方法提供默认的实现</li>
<li>提供方法，包围ServletConfig中的方法</li>
</ul>
<h4 id="GenericServlet原理"><a href="#GenericServlet原理" class="headerlink" title="GenericServlet原理"></a>GenericServlet原理</h4><p>GenericServlet通过将ServletConfig赋给init方法中的类级变量private transient ServletConfig config；来保存ServletConfig</p>
<pre><code>public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
</code></pre><p>但是，如果在子类中覆盖了这个方法，就会调用Servlet中的init方法，并且还必须调用super.init(servletConfig)来保存ServletConfig，为了避免上述麻烦，<strong><em>GenericServlet提供了第二个init方法，它不带参数。</em></strong>这个方法是在ServletConfig被赋给servletConfig后，由第一个init方法调用，子类改写后调用的是子类的无参数init方法</p>
<p><strong>总结：</strong><br>Tomcat调用Servlet接口的init(ServletConfig config)方法，其实现类是用户继承的子类，该子类重写了无参数的init方法进行初始化工作。首先调用父类中的init(ServletConfig config)方法，将config对象保存为类级变量，然后调用this.init()方法，this指针指向子类实例，init方法被重写，所以调用子类的init方法，若需要访问GenericServlet中的无参数init方法，则需要在子类中使用super.init()；</p>
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>继承GenericServlet</em></strong></p>
<pre><code>package com.hsp;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
public class MyGenericServlet extends GenericServlet
{
    public  void service(ServletRequest req,
                             ServletResponse res)
                      throws ServletException,
                             java.io.IOException{
        res.getWriter().println(&quot;hello,world,i am geneirc servlet&quot;);
    }
}
</code></pre><p><strong><em>将该Servlet部署到web.xml文件中:</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
 &lt;servlet&gt;
    &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
  &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
  &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
  &lt;servlet-class&gt;com.hsp.MyGenericServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    &lt;!--Servlet的映射--&gt;
 &lt;servlet-mapping&gt;
    &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
    &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
    &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分,默认命名规范:
    就是该Servlet的名字--&gt;
    &lt;url-pattern&gt;/MyGenericServlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><h3 id="③使用继承-HttpServlet-的方法来开发Serlvet"><a href="#③使用继承-HttpServlet-的方法来开发Serlvet" class="headerlink" title="③使用继承 HttpServlet 的方法来开发Serlvet"></a>③使用继承 HttpServlet 的方法来开发Serlvet</h3><ul>
<li>在软件公司 90%都是通过该方法开发.</li>
<li>举例说明，还是显示 hello,world 当前日期</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>HttpServlet类继承了GenericServlet类，并重写了service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，Tomcat调用Servlet接口的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，实际调用的是HttpServlet类中的的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，方法体内将ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse，并调用新添加的service方法</li>
</ul>
<pre><code>public void service(ServletRequest req, ServletResponse res)
    throws ServletException, IOException
    {
        HttpServletRequest    request;
        HttpServletResponse    response;

    try {
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
    } catch (ClassCastException e) {
        throw new ServletException(&quot;non-HTTP request or response&quot;);
    }

    service(request, response);
}
</code></pre><ul>
<li>HttpServlet中扩展了一个protected void service(HttpServletRequest req, HttpServletResponse resp)方法，根据不同的请求方法，调用不同的doXXX方法</li>
</ul>
<pre><code>protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
    {
    String method = req.getMethod();

    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
        // servlet doesn&apos;t support if-modified-since, no reason
        // to go through further expensive logic
        doGet(req, resp);
        } else {
        long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
        if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) {
            // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
            maybeSetLastModified(resp, lastModified);
            doGet(req, resp);
        } else {
            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        }
        }

    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);

    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);    

    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);

    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);

    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);

    } else {
        //
        // Note that this means NO servlet supports whatever
        // method was requested, anywhere on this server.
        //

        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);

        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}
</code></pre><ul>
<li>子类继承后，通过改写doGet和doPost方法，实现方法的调用</li>
</ul>
<h4 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>代码</em></strong></p>
<pre><code>package com.apeius;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class MyHttpServlet extends HttpServlet
{
    //在HttpServlet 中，设计者对post 提交和 get提交分别处理
    //回忆 &lt;form action=&quot;提交给?&quot; method=&quot;post|get&quot;/&gt;,默认是get

    protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
              throws ServletException,
                     java.io.IOException{
        resp.getWriter().println(&quot;i am httpServet doGet()&quot;);

    }
    protected void doPost(HttpServletRequest req,
                      HttpServletResponse resp)
               throws ServletException,
                      java.io.IOException{ 
        resp.getWriter().println(&quot;i am httpServet doPost() post name=&quot;+req.getParameter(&quot;username&quot;));
    }
}
</code></pre><p><strong><em>还有一个login.html</em></strong></p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;/my/MyHttpServlet&quot; method=&quot;post&quot;&gt;
    u:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong><em>部署</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyHttpServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/MyHttpServlet&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
</code></pre><h2 id="使用myeclipse来开发servlet，IDEA类似"><a href="#使用myeclipse来开发servlet，IDEA类似" class="headerlink" title="使用myeclipse来开发servlet，IDEA类似"></a>使用myeclipse来开发servlet，IDEA类似</h2><p><strong><em>(1)    建立web工程</em></strong></p>
<p><img src="http://i.imgur.com/6IcaPJQ.gif" alt=""></p>
<p><strong><em>(2)    在Src 目录下创建了一个包 com.hsp.servlet</em></strong></p>
<p><img src="http://i.imgur.com/VYwK3wL.png" alt=""></p>
<p><strong><em>添加Package，方法一般只需创建doGet()和doPost()方法，修改Servlet/JSP Mapping URL</em></strong></p>
<p><img src="http://i.imgur.com/ogGRxkN.png" alt=""></p>
<p><strong><em>(3)    开发一个Servlet</em></strong></p>
<pre><code>MySerlvet 的代码:
public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        response.setContentType(&quot;text/html&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;hello &quot;+new java.util.Date().toString() );
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        this.doGet(request, response);
    }
}
</code></pre><h2 id="使用IDEA来开发Servlet程序"><a href="#使用IDEA来开发Servlet程序" class="headerlink" title="使用IDEA来开发Servlet程序"></a>使用IDEA来开发Servlet程序</h2><p>　　见另一篇博文:<a href="https://rhapsody1290.github.io/2016/07/07/[Servlet]Intellij%20IDEA%E5%88%9B%E5%BB%BAMaven%E7%AE%A1%E7%90%86%E7%9A%84Java%20Web%E9%A1%B9%E7%9B%AE/" target="_blank" rel="external">Intellij IDEA15创建Maven管理的Java Web项目</a></p>
<h2 id="Servlet的细节问题-映射、单例、通配符、自启动"><a href="#Servlet的细节问题-映射、单例、通配符、自启动" class="headerlink" title="Servlet的细节问题[映射、单例、通配符、自启动]"></a>Servlet的细节问题[映射、单例、通配符、自启动]</h2><h3 id="①-一个已经注册的Servlet可以被多次映射即"><a href="#①-一个已经注册的Servlet可以被多次映射即" class="headerlink" title="① 一个已经注册的Servlet可以被多次映射即:"></a>① 一个已经注册的Servlet可以被多次映射即:</h3><pre><code>&lt;servlet&gt;
&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;
&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;
&lt;!-- servlet的注册名 --&gt;
&lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
&lt;!-- servlet类的全路径(包名+类名) --&gt;
&lt;servlet-class&gt;com.hsp.servlet.MyServlet1&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!-- 对一个已经注册的servlet的映射 --&gt;
&lt;!-- 映射1 --&gt;
&lt;servlet-mapping&gt;
    &lt;!-- servelt的注册名 --&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;!-- servlet的访问路径 --&gt;
    &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- 映射2 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hsp&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h3 id="②-映射一个servlet时候，可以多层，比如"><a href="#②-映射一个servlet时候，可以多层，比如" class="headerlink" title="② 映射一个servlet时候，可以多层，比如"></a>② 映射一个servlet时候，可以多层，比如</h3><pre><code>&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt;
</code></pre><p>　　从这里还可以看出，后缀名是 html 不一定就是 html,可能是假象.</p>
<h3 id="③-用通配符在servlet映射到URL中"><a href="#③-用通配符在servlet映射到URL中" class="headerlink" title="③ 用通配符在servlet映射到URL中"></a>③ 用通配符在servlet映射到URL中</h3><p><strong><em>有两种格式:</em></strong></p>
<ul>
<li>第一种格式  <code>*.扩展名</code>，比如 <code>*.do</code>，<code>*.ss</code></li>
<li>第二种格式  以 <code>/</code> 开头，同时以 <code>/*</code> 结尾。比如  <code>/*</code>,<code>/news/*</code> </li>
</ul>
<p><strong><em>在匹配的时候，要参考的标准:</em></strong></p>
<ul>
<li>看谁的匹配度高，谁就被选择</li>
<li><code>*.do</code>的优先级最低</li>
</ul>
<p><strong><em>通配符练习题：</em></strong></p>
<pre><code>● Servlet1 映射到 /abc/* 
● Servlet2 映射到 /* 
● Servlet3 映射到 /abc 
● Servlet4 映射到 *.do 
问题(面试题)：
当请求URL为&apos;/abc/a.html&apos;，&apos;/abc/*&apos;和&apos;/*&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为&apos;/abc&apos;时，&apos;/abc/*&apos;和&apos;/abc&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
</code></pre><h3 id="④Servlet单例问题"><a href="#④Servlet单例问题" class="headerlink" title="④Servlet单例问题"></a>④Servlet单例问题</h3><ul>
<li>当Servlet被第一次访问后，就被加载到内存，以后该实例对各个请求服务，即在使用中是单例</li>
<li><strong><em>Servlet实例会在一个应用程序中被所有用户共享，因此不建议使用类级变量</em></strong> ，除非它们是只读的，或者是java.util.concurrent.atomic包的成员</li>
</ul>
<p><strong><em>证明：</em></strong></p>
<p>　　在Servlet中定义一个变量i，当浏览器访问时i++，并输出i；如果Servlet是单例，则每次输出i都会增加</p>
<p><strong><em>问题：</em></strong></p>
<p>　　因为 Servlet是单例，因此会出现线程安全问题: 比如:售票系统. 如果不加同步机制，则会出现问题:</p>
<p><strong><em>原则:</em></strong></p>
<ul>
<li>（1）如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制  </li>
</ul>
<pre>
synchronized (对象){
  //同步代码
}
</pre>

<ul>
<li>（2）如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题  </li>
</ul>
<h3 id="⑤servlet中的-lt-load-on-startup-gt-配置"><a href="#⑤servlet中的-lt-load-on-startup-gt-配置" class="headerlink" title="⑤servlet中的&lt;load-on-startup&gt;配置"></a>⑤servlet中的&lt;load-on-startup&gt;配置</h3><p><strong><em>需求</em></strong></p>
<p>　　当我们的网站启动的时候，可能会要求初始化一些数据，(比如创建临时表), 在比如：我们的网站有一些要求定时完成的任务[ 定时写日志，定时备份数据.. 定时发送邮件..]</p>
<p><strong><em>解决方法</em></strong></p>
<p>　　可以通过 &lt; load-on-startup &gt; 配合线程知识搞定.<br>　　一般在有用户访问该Servlet时才会被加载进内存，现在需要在网站启动的时候自动启动Servlet。首先在web.xml下，该Servlet下进行配置<br><code>&lt;load-on-startup &gt;1（数字Servlet启动优先级）&lt;/load-on-startup&gt;</code><br>　　这样该Servlet在网站启动时将会被自动创建.</p>
<h2 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h2><ul>
<li>调用Servlet的init方法时，Servlet容器会传入一个ServletConfig实例，该对象主要用于读取 servlet的配置信息</li>
</ul>
<p><strong><em>案例</em></strong></p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.hsp.servlet.ServletConfigTest&lt;/servlet-class&gt;
    &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

获得配置参数
String encoding=this.getServletConfig().getInitParameter(&quot;encoding&quot;);
</code></pre><p><strong><em>补充说明</em></strong></p>
<p>　　这种配置参数的方式，只能被某个Servlet独立使用.如希望让所有的Servlet都去读取某个参数,这样配置:</p>
<pre><code>&lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;

获得配置参数
String encoding = this.getServletContext().getInitParameter(&quot;encoding&quot;)
</code></pre><p><strong><em>如果要把所有的参数都读取，则使用 如下方法 ：</em></strong></p>
<pre><code>Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames();
while(names.hasMoreElements()){
    String name=names.nextElement();
    System.out.println(name);
    System.out.println(this.getServletConfig().getInitParameter(name));
}
</code></pre><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>在访问某个网站时，首页会显示您是第几个浏览者，这个怎么实现的？除了数据库，文件等方式，最方便的是使用ServletContext。  </p>
<font color="red">ServletContext是一个公共的空间，可以被所有客户访问</font>

<p><img src="http://i.imgur.com/ZyoAE8n.png" alt=""></p>
<ul>
<li>Web容器在启动时，它会为每个Web应用程序创建一个对应的ServletContext对象，它代表当前Web应用。当web应用关闭/tomcat关闭/对web应用reload会造成servletContext销毁.</li>
<li>ServletContext对象通过ServletConfig.getServletContext方法获得对ServletContext对象的引用，也可以通过this.getServletContext()来获得其对象的引用</li>
<li><strong><em>每个Web应用程序只有一个上下文，一个Web应用中所有的Servlet共享同一个ServletContext对象</em></strong>，因此Servlet对象之间可以通过ServletContext对象实现通讯。ServletContext对象通常也被称为context域对象，公共聊天室就会用到它</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>获取:
this.getServletContext();  #在HttpServlet中直接获取
this.getServletConfig().getServletContext(); # 在ServletConfig中获取
request.getSession().getServletContext(); #通过HttpRequest获得 
添加属性:
servletcontext.setAttribute(string,object);
取出属性
servletcontext.getAttribute(“属性名”)
删除
setvletContext.removeAttribute(“属性名”);
</code></pre><h3 id="ServletContext的应用"><a href="#ServletContext的应用" class="headerlink" title="ServletContext的应用"></a>ServletContext的应用</h3><h4 id="获取WEB应用的初始化参数"><a href="#获取WEB应用的初始化参数" class="headerlink" title="获取WEB应用的初始化参数"></a>获取WEB应用的初始化参数</h4><pre><code>&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;name&lt;/param-name&gt;
    &lt;param-value&gt;scott&lt;/param-value&gt;
&lt;/context-param&gt;
如何获取
String val= this.getServletContext().getInitParameter(&quot;name&quot;);
</code></pre><h4 id="使用ServletContext实现跳转"><a href="#使用ServletContext实现跳转" class="headerlink" title="使用ServletContext实现跳转"></a>使用ServletContext实现跳转</h4><pre><code>//目前我们跳转到下一个页面的方法
//1 response.sendRedirect(&quot;/web应用名/资源名&quot;);
//2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);
/*
 * 区别1. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器
 *     2. 如果request.setAttribute(&quot;name&quot;,&quot;顺平&quot;) 希望下一个页面可以使用 属性值，则使用 getRequestDispatcher
 *       3. 如果session.setAttribute(&quot;name2&quot;,&quot;顺平3&quot;), 希望下一个页面可以使用 属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher
 *     4. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect
 */
//3.这种方法和2一样
this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response);
</code></pre><h4 id="读取文件，和获取文件全路径"><a href="#读取文件，和获取文件全路径" class="headerlink" title="读取文件，和获取文件全路径"></a>读取文件，和获取文件全路径</h4><p>　　读Web目录下和WEB-INF目录下的文件</p>
<pre><code>//首先读取到文件dbinfo.properties放在web根目录下
InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;);

//创建Properties
Properties pp=new Properties();
pp.load(inputStream);

out.println(&quot;name=&quot;+pp.getProperty(&quot;username&quot;));
</code></pre><p>　　如果文件放在src目录下(如果是maven项目，则resources目录下为根目录)，则使用类加载器</p>
<pre><code>//如果文件放在上述目录下，我们应该使用类加载器来读取
InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;)
//如果放在包下，则带上包名，例如cn/apeius/xx.properties
</code></pre><p>　　获取文件全路径（以WEB目录为根目录）</p>
<pre><code>//如果读取到一个文件的全路径（dbinfo.properties在web目录下）
String path=this.getServletContext().getRealPath(&quot;dbinfo.properties&quot;);
out.println(&quot;paht = &quot;+path);
</code></pre><h4 id="网站计数器"><a href="#网站计数器" class="headerlink" title="网站计数器"></a>网站计数器</h4><ul>
<li>我们建立一个文件recoder.txt文件，用于保存访问量,可以可以保证稳定增长.</li>
<li>建立InitServlet,Web项目启动时自动加载该Servlet，读取record.txt，初始化Servletcontext中的访问量，和在关闭tomcat时保存访问量如record.txt</li>
<li>如果我们的tomcat异常退出，使用线程定时把ServletContext的值，刷新到recorder.txt</li>
</ul>
<h2 id="http请求消息头"><a href="#http请求消息头" class="headerlink" title="http请求消息头"></a>http请求消息头</h2><pre><code>1.    Accept: text/html,image/*   [告诉服务器，我可以接受 文本，网页，图片]
2.    Accept-Charset: ISO-8859-1 [接受字符编码 iso-8859-1]
3.    Accept-Encoding: gzip,compress [可以接受 gzip,compress压缩后数据.]
4.    Accept-Language: en-us,zh-cn [浏览器支持中，英文]
5.    Host: www.sohu.com:80 [我要找主机是 www.sohu.com:80]
6.    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT [ 告诉服务器，我的缓冲中有这个资源文件，该文件的时间是 。。。，文件有更新才发送]
7.    Referer: http://www.sohu.com/index.jsp  [告诉服务器，我来自哪里,该消息头，常用于防止盗链]
8.    User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)[告诉服务器，浏览器内核]
9.    Cookie [cookie后面介绍]
10.    Connection: close/Keep-Alive   [保持连接，发完数据后，我不关闭连接]
11.    Date: Tue, 11 Jul 2000 18:23:51 GMT [浏览器发送该http请求的时间]
</code></pre><h2 id="http响应消息头"><a href="#http响应消息头" class="headerlink" title="http响应消息头"></a>http响应消息头</h2><pre><code>Location: http://www.baidu.org/index.jsp  【让浏览器重新定位到url】
Server:apache tomcat 【告诉浏览器我是tomcat】
Content-Encoding: gzip 【告诉浏览器我使用 gzip】
Content-Length: 80  【告诉浏览器会送的数据大小80节】
Content-Language: zh-cn 【支持中文】
Content-Type: text/html; charset=GB2312 [内容格式text/html; 编码gab2312]
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 【告诉浏览器，该资源上次更新时间】
Refresh: 1;url=http://www.baidu.com 【过多久去，刷新到 http://www.baidu.com】
Content-Disposition: attachment; filename=aaa.zip 【告诉浏览器，有文件下载】
Transfer-Encoding: chunked  [传输的编码]
Set-Cookie:SS=Q0=5Lb_nQ; path=/search[后面详讲]
Expires: -1[告诉浏览器如何缓存页面IE]
Cache-Control: no-cache  [告诉浏览器如何缓存页面火狐]
Pragma: no-cache   [告诉浏览器如何缓存页面]
Connection: close/Keep-Alive   [保持连接 1.1是Keep-Alive]
Date: Tue, 11 Jul 2000 18:23:51 GMT
</code></pre><h2 id="http响应的状态行"><a href="#http响应的状态行" class="headerlink" title="http响应的状态行"></a>http响应的状态行</h2><pre><code>200 就是整个请求和响应过程没有发生错误，这个最常见.
302: 表示当你请求一个资源的时候，服务器返回302 表示，让浏览器转向到另外一个资源，比如: response.sendRedirect(“/web应用/资源名”)

案例:
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/servletPro/Servlet2&quot;);
    // 上面两句话等价 response.sendRedirect(&quot;/servletPro/Servlet2&quot;);

404： 找不到资源
500: 服务器端错误
</code></pre><h2 id="http响应头应用★★★-防盗链、定时、文件下载、缓存"><a href="#http响应头应用★★★-防盗链、定时、文件下载、缓存" class="headerlink" title="http响应头应用★★★[防盗链、定时、文件下载、缓存]"></a>http响应头应用★★★[防盗链、定时、文件下载、缓存]</h2><h3 id="防盗链-Referer"><a href="#防盗链-Referer" class="headerlink" title="防盗链 - Referer"></a>防盗链 - Referer</h3><pre><code>//获取用户浏览器Referer
String referer=request.getHeader(&quot;Referer&quot;);
if(referer==null||!referer.startsWith(&quot;http://localhost:8088/servletPro&quot;)){
    response.sendRedirect(&quot;/servletPro/Error&quot;);
    return;
}
</code></pre><h3 id="定时刷新Refresh使用"><a href="#定时刷新Refresh使用" class="headerlink" title="定时刷新Refresh使用"></a>定时刷新Refresh使用</h3><pre><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=/servletPro/Servlet2&quot;);
</code></pre><h3 id="文件下载-Content-Disposition"><a href="#文件下载-Content-Disposition" class="headerlink" title="文件下载 Content-Disposition"></a>文件下载 Content-Disposition</h3><pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

    response.setContentType(&quot;text/html&quot;);
    //★★★需要注释
    //PrintWriter out = response.getWriter();

    //演示下载文件
    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=winter.jpg&quot;);

    //打开文件.说明一下web 站点下载文件的原理
    //1.获取到要下载文件的全路径
    String path=this.getServletContext().getRealPath(&quot;/images/Winter.jpg&quot;);
    //System.out.println(&quot;path=&quot;+path);
    //2创建文件输入流
    FileInputStream fis=new FileInputStream(path);
    //做一个缓冲字节数组
    byte buff[]=new byte[1024];
    int len=0;//表示实际每次读取了多个个字节
    OutputStream os=response.getOutputStream();
    while((len=fis.read(buff))&gt;0){
        os.write(buff, 0, len);
    }
    //关闭
    os.close();
    fis.close();
}
</code></pre><h3 id="缓存讲解"><a href="#缓存讲解" class="headerlink" title="缓存讲解"></a>缓存讲解</h3><p>　　提出问题：浏览器默认情况下，会缓存我们的页面，这样出现一个问题：如果我们的用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用cache中取数据（刷新还是会重新向服务器请求数据）。</p>
<p><strong><em>（1）有些网站要求及时性很高，因此要求我们不缓存页面</em></strong></p>
<pre><code>//指定该页面不缓存 Ie
response.setDateHeader(&quot;Expires&quot;, -1);//【针对IE浏览器设置不缓存】
//为了保证兼容性.
response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//【针对火狐浏览器等】
response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//【其他浏览器】
</code></pre><p><strong><em>（2）有些网站要求网页缓存一定时间,比如缓存一个小时</em></strong></p>
<pre><code>response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+3600*1000*24);后面一个参数表示设置的缓存保持时间，-1表示永远缓存
</code></pre><h2 id="HttpServletResponse的再说明"><a href="#HttpServletResponse的再说明" class="headerlink" title="HttpServletResponse的再说明"></a>HttpServletResponse的再说明</h2><p>HttpServletResponse中输出流两个方法：</p>
<ul>
<li>getWriter()</li>
<li>getOutputStream()</li>
</ul>
<p><strong><em>区别</em></strong></p>
<p>1、    getWriter() 用于向客户机回送字符数据</p>
<pre><code>PrintWriter out = response.getWriter();
out.println(&quot;hello,world&quot;);
</code></pre><p>2、    getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据(二进制数据)，但也可以输出文本内容</p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
</code></pre><p><strong><em>如何选择:</em></strong></p>
<ul>
<li>如果我们是回送字符数据，则使用PrintWriter对象,效率高</li>
<li>如果我们是回送字节数据(binary date),则只能使用OutputStream</li>
<li>这两个流不能同时使用.</li>
</ul>
<p><strong><em>比如：</em></strong></p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
PrintWriter out=response.getWriter();
out.println(&quot;abc&quot;);
就会报错:
java.lang.IllegalStateException: getOutputStream() has already been called for this response
</code></pre><p><strong><em>注意：</em></strong><br>　　Web服务器会自动检查并关闭流，为什么我们没有主动关闭流，程序也没有问题的原因.当然：你主动关闭流，更好.
　　</p>
<h2 id="参数的传递方式sendRedirect-和session"><a href="#参数的传递方式sendRedirect-和session" class="headerlink" title="参数的传递方式sendRedirect()和session()"></a>参数的传递方式sendRedirect()和session()</h2><p><img src="http://img.blog.csdn.net/20160607204306776" alt="这里写代码片"></p>
<p><strong><em>需求:</em></strong><br>　　当用户登录成功后，把该用户名字显示在登录成功页面;  </p>
<p><strong><em>解决方法</em></strong></p>
<ul>
<li><p>使用 java 基础 static，专门用一个类来存储静态数据</p>
</li>
<li><p>使用 sendRedirect()，在url上加上需要传递的参数</p>
</li>
</ul>
<pre>
response.sendRedirect("/UsersManager/MainFrame?uname="+username+"&pwd="+password);

说明:
基本格式:
response.sendRedirect("/Context/servlet的?参数名=参数值&参数名=参数值...");
</pre>

<ul>
<li>使用session传递</li>
</ul>
<p>　　session既可以传递字符串，也可以传递对象</p>
<pre><code>A.传递字符串
放入session   
    request.getSession.setAttribute(&quot;loginUser&quot;,username); 
取出session     
    在JSP中通过session取出 request.getSession.getAttribute(&quot;loginUser&quot;);

B．传递对象
User user= new User();
user.setName(&quot;xiaoli&quot;);
user.setPassWord(“123”);

放入session   
    request.getSession.setAttribute(&quot;userObj&quot;,userObj); 
取出session     
    User user=(User)request.getSession.getAttribute(&quot;userObj&quot;);
</code></pre><h2 id="中文乱码处理"><a href="#中文乱码处理" class="headerlink" title="中文乱码处理"></a>中文乱码处理</h2><p>　　发生中文乱码有三种情况，我们应当尽量使用post方式提交</p>
<h3 id="①表单form"><a href="#①表单form" class="headerlink" title="①表单form"></a>①表单form</h3><ul>
<li>(1)表单以post方式提交<br><br>　　浏览器把请求发送给web服务器[utf-8]，web服务器以ISO-8859-1编码方式进行接收，产生乱码，之后进行传递也都是乱码。<br>　　在接收参数时，采用正确的编码，即可解决问题，在服务器端设置成浏览器端的编码方式。</li>
</ul>
<pre>request.setCharacterEncoding("utf-8"); //gbk gb2312 big5</pre>

<ul>
<li>(2)表单以get方式提交<br><br>　　请求内容是以请求行URL进行提交，而不是用请求体，所以使用setCharacterEncoding无效</li>
</ul>
<p>写一个工具类:</p>
<pre><code>package com.hsp.utils;
public class MyTools {
    public static String getNewString(String str) {
        String newString=&quot;&quot;;
        try {
            newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;);
        } catch (Exception e) {
            e.printStackTrace();
            // 把iso-8859-1 转换成 utf-8
        } 
        return newString;
    }
}
</code></pre><h3 id="②超链接"><a href="#②超链接" class="headerlink" title="②超链接"></a>②超链接</h3><p>　　数据以get方式进行传递，该方法和get处理方法一样.</p>
<pre><code>&lt;a href=”http://www.sohu.com?name=函数后”&gt;测试&lt;/a&gt;
</code></pre><h3 id="③sendRedirect-发生乱码"><a href="#③sendRedirect-发生乱码" class="headerlink" title="③sendRedirect() 发生乱码"></a>③sendRedirect() 发生乱码</h3><p>　　客户端会重新发送一个http请求，该方法和get处理方法一样</p>
<pre><code>response.sendRedirect(&quot;servlet地址?username=顺平&quot;); 
</code></pre><h3 id="版本低导致的乱码"><a href="#版本低导致的乱码" class="headerlink" title="版本低导致的乱码"></a>版本低导致的乱码</h3><p>　　特别说明，如果你的浏览器是 ie6 或以下版本，则我们的 ② 和 ③中情况会出现乱码(当中文是奇数的时候)<br>解决方法是 ：</p>
<pre><code>String info=java.net.URLEncoder.encode(&quot;你好吗.jpg&quot;, &quot;utf-8&quot;);
&lt;a href=&quot;http://www.sohu.com?name=&quot;+ info &gt;测试&lt;/a&gt;
response.sendRedirect(&quot;servlet地址?username=&quot; + info);
</code></pre><h3 id="返回浏览器显示乱码"><a href="#返回浏览器显示乱码" class="headerlink" title="返回浏览器显示乱码"></a>返回浏览器显示乱码</h3><p>　　在服务端是中文，在response的时候，也要考虑浏览器显示是否正确,一般我们通过</p>
<pre><code>　response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre><h3 id="下载提示框中文乱码"><a href="#下载提示框中文乱码" class="headerlink" title="下载提示框中文乱码"></a>下载提示框中文乱码</h3><p>　　补充一个知识点: 当我们下载文件的时候，可能提示框是中文乱码 </p>
<pre><code>String temp=java.net.URLEncoder.encode(&quot;传奇.mp3&quot;,&quot;utf-8&quot;);
response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename=&quot;+temp);
</code></pre><h2 id="HttpServletRequest对象的详解"><a href="#HttpServletRequest对象的详解" class="headerlink" title="HttpServletRequest对象的详解"></a>HttpServletRequest对象的详解</h2><p>　　该对象表示浏览器的请求(http请求), 当web服务器得到该请求后，会把请求信息封装成一个HttpServletRequest 对象</p>
<ul>
<li>getRequestURL方法返回客户端发出请求时的完整URL。</li>
<li>getRequestURI方法返回请求行中的资源名部分。</li>
<li>getQueryString方法返回请求行中的参数部分(参数名+值)。该函数可以获取请求部分的数据，比如<br><code>http://localhost/web名?username=abc&amp;pwd=123request.getQueryString();</code><br>就会得到  username=abc&amp;pwd=123</li>
<li>getRemoteAddr方法返回发出请求的客户机的IP地址</li>
<li>getRemoteHost方法返回发出请求的客户机的完整主机名，如果该客户机没有在dns注册，则返回ip地址</li>
<li>getRemotePort方法返回客户机所使用的网络端口号，客户机的端口号是随机选择的，web服务器的端口号是一定的</li>
<li>getLocalPort方法返回web服务器所使用的网络端口号</li>
<li>getLocalAddr方法返回WEB服务器的IP地址。</li>
<li>getLocalName方法返回WEB服务器的主机名</li>
</ul>
<h2 id="url-和-uri-的区别"><a href="#url-和-uri-的区别" class="headerlink" title="url 和 uri 的区别"></a>url 和 uri 的区别</h2><pre><code>比如：
    Url=http://localhost:8088/servletPort3/GetinfoServlet 完整的请求
    Uri=/servletPort3/GetinfoServlet web应用的名称+资源的名称
</code></pre><h2 id="请求转发getRequestDispatcher"><a href="#请求转发getRequestDispatcher" class="headerlink" title="请求转发getRequestDispatcher"></a>请求转发getRequestDispatcher</h2><pre><code>#请求转发
requeset.getRequestDispatcher(资源地址).forward(request,response);
#可以在request的域对象中存储数据，request中的attribute在一次请求中有效
request.setAttribute(&quot;username&quot;,username);
</code></pre><p>　　资源地址：不需要项目名。因为它只是在WEB服务器内部转发。<br>　　<br><img src="http://img.blog.csdn.net/20160608153021012" alt="这里写图片描述"></p>
<p>　　Servlet接收到数据后，可以把数据放入到request域对象，Request中的Attribute在一次请求有效。<br>　　一次请求：浏览器发送一次http请求到接收到响应成为一次http请求，只要没有停止，也没有回到浏览器重定向，就算一次  </p>
<p><strong><em>请求转发的的(uml)图</em></strong></p>
<p><img src="http://img.blog.csdn.net/20160608154011510" alt="这里写图片描述"></p>
<ol>
<li>使用forward不能转发到该web应用外的url</li>
<li>因为 forward 是发生在web服务器，所以 Servlet1 和 Servlet 2使用的是用一个request 和response.</li>
<li>使用sendRedirect() 方法不能通过request.setAttribute() 把 属性传递给下一个Servlet</li>
</ol>
<p><strong><em>面试题：请问sendRedirect和 forward的区别是什么？</em></strong><br>答:  </p>
<pre><code>1. 叫法sendRedirect()请求重定向，转发forward()叫请求转发  
2. 实际发生的位置不一样    
　　sendRedirect发生在浏览器，由浏览器重新发出http请求  
　　forward发生web服务器，请求在web服务器转发  
3. 用法不一样    
　　request.getRequestDispatcher(“/资源URI”).forward(request,response)
　　response.sendRedirect(“/web应用/资源URI”);  
4. 能够去URL范围不一样  
　　sendRedirect可以去外边URL  
　　forward只能去当前的WEB应用的资源
</code></pre><h2 id="会话技术cookie"><a href="#会话技术cookie" class="headerlink" title="会话技术cookie"></a>会话技术cookie</h2><h3 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话"></a>什么是会话</h3><p>　　基本概念: 指用户开一个浏览器，访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话。比如打电话</p>
<p><strong><em>为什么需要cookie技术(会话技术)</em></strong>  </p>
<ul>
<li>如何保存用户上次登录时间</li>
<li>如何显示用户浏览历史</li>
<li>如何把登录的用户名和密码电脑，下次登录，不需要重新输入</li>
</ul>
<h3 id="cookie的原理图"><a href="#cookie的原理图" class="headerlink" title="cookie的原理图"></a>cookie的原理图</h3><p><img src="http://i.imgur.com/ihpk6OJ.png" alt=""></p>
<h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><pre><code>//创建cookie
Cookie cookie = new Cookie(&quot;name&quot;,&quot;qm&quot;);
//设置cookie的生命周期
cookie.setMaxAge(3600);
//把cookie会写给浏览器
response.addCookie(cookie);
</code></pre><h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><pre><code>Cookie[] cookies = request.getCookies();
System.out.println(cookies.length);
for(Cookie c : cookies){
    out.println(c.getName() + &quot; &quot; + c.getValue() + &quot;&lt;br/&gt;&quot;);
}
</code></pre><h3 id="cookie的小结★★★"><a href="#cookie的小结★★★" class="headerlink" title="cookie的小结★★★"></a>cookie的小结★★★</h3><ul>
<li>cookie 是在服务端创建</li>
<li>cookie 是保存在浏览器这端</li>
<li>cookie 的生命周期可以通过cookie.setMaxAge(2000);如果不设置setMaxAge则该cookie的生命周期当浏览器关闭时，就消亡</li>
<li><font color="red">同一个浏览器<strong><em>多个实例</em></strong>共享cookie，若cookie没到期，关闭浏览器后还能共享该cookie。当然不同浏览器之间是不能共享cookie的，因为每个浏览器存放cookie的路径不一样(与session的区别，session在关闭浏览器后，不采取任何方式，无法访问到session)</font></li>
<li>我们可以把cookie想成一张表<br><img src="http://i.imgur.com/jnEcC7g.png" alt=""></li>
<li>如果cookie重名就会替换存在的cookie值</li>
<li>一个web应用可以保存多个cookie,但保存在客户端浏览器下同一个cookie文本中</li>
<li>浏览器访问web应用时，会携带该web应用相关的cookie</li>
<li>cookie存放的时候是以明文方式存放，因此安全较低，我们可以通过加密后保存[MD5算法见Java基础常用-MD5]</li>
</ul>
<h3 id="举例-保存上次登录时间★★★"><a href="#举例-保存上次登录时间★★★" class="headerlink" title="举例 - 保存上次登录时间★★★"></a>举例 - 保存上次登录时间★★★</h3><pre><code>//先获取cookie
// 假设我们 保存上次登录时间的cookie &quot;lasttime&quot; &quot;2011-11-11 12:12:12&quot;;
// 这里我们要考虑一个情况: 用户第一次登录 &apos;您是第一次登录..&apos;
Cookie[] cookies = request.getCookies();
boolean b = false;//假设没有lasttime cookie
if (cookies != null) { //保证有cookie,取遍历
    for (Cookie cookie : cookies) {
        //取出名
        String name = cookie.getName();
        if (&quot;lasttime&quot;.equals(name)) {
            //显示
            out.println(&quot;您上次登录时间是 &quot; + cookie.getValue());
            //更新时间
            //把当前日期保存cookie
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String nowTime = simpleDateFormat.format(new java.util.Date());
            cookie.setValue(nowTime);
            cookie.setMaxAge(7 * 3600 * 24);//保存一周
            response.addCookie(cookie);
            b = true;
            break;
        }
    }
}

if (!b) {
    //没有找到
    out.println(&quot;您是第一次登录..&quot;);
    //把当前日期保存cookie
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String nowTime = simpleDateFormat.format(new java.util.Date());
    Cookie cookie = new Cookie(&quot;lasttime&quot;, nowTime);
    cookie.setMaxAge(7 * 3600 * 24);//保存一周
    response.addCookie(cookie);
}
</code></pre><h3 id="cookie的细节★★★"><a href="#cookie的细节★★★" class="headerlink" title="cookie的细节★★★"></a>cookie的细节★★★</h3><p>① 一个浏览器最多放入300cookie，一个web站点，最多20cookie，而且一个cookie大小限制子4k<br>② cookie生命周期的再说明:</p>
<ul>
<li><font color="red">cookie默认生命周期是会话级别，即浏览器关闭，cookie生命周期结束</font></li>
<li>通过setMaxAge() 可以设置生命周期<ul>
<li>setMaxAge(正数)，即多少秒后该cookie失效</li>
<li>setMaxAge(0)，删除该cookie</li>
<li>setMaxAge(负数)，相当于该cookie生命周期是会话级别</li>
</ul>
</li>
<li>cookie的生命周期，指的是累计时间，例如设置生命周期为30s，那么在30s之后cookie消亡（与session区别，session是发呆时间，即在一段时间内没有访问session就会消亡）</li>
</ul>
<p><strong><em>案例 ：</em></strong></p>
<pre><code>//先得到该cookie
Cookie cookies[]=request.getCookies();
for(Cookie cookie: cookies){
    if(cookie.getName().equals(&quot;id&quot;)){
        System.out.println(&quot;id&quot;);
        //删除
        cookie.setMaxAge(0);
        response.addCookie(cookie);//一定带上这句话，否则不能删除
    }
}
</code></pre><p>特别说明: 如果该web应用只有一个cookie ，则删除该cookie后，在浏览器的临时文件夹下没有该cookie文件，如果该web应用有多个cookie,则删除一个cookie后，文件还在，只是该cookie没有</p>
<p>③    cookie存放中文，怎么处理</p>
<p>进行URLEncoder</p>
<pre><code>存放:
String val=java.net.URLEncoder.encode(&quot;顺平&quot;,&quot;utf-8&quot;);
Cookie cookie=new Cookie(&quot;name&quot;,val);
取出:
String val=java.net.URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;);
out.println(&quot;name =&quot;+val);
</code></pre><h2 id="会话技术session（生成验证码）"><a href="#会话技术session（生成验证码）" class="headerlink" title="会话技术session（生成验证码）"></a>会话技术session（生成验证码）</h2><h3 id="session有什么用"><a href="#session有什么用" class="headerlink" title="session有什么用?"></a>session有什么用?</h3><p>　　问题1: 如何实现在不同的页面，可以去查看信息(比如说购物车)，同时还要实现不同的用户看到的信息是自己.<br>　　Session是服务端技术，可以为每一个用户的浏览器创建一个独享的session对象</p>
<h3 id="session工作原理图"><a href="#session工作原理图" class="headerlink" title="session工作原理图"></a>session工作原理图</h3><p> <img src="http://i.imgur.com/FlOMxdb.png" alt=""></p>
<ul>
<li>session对象一行就代表一个属性，键值对  </li>
<li>request.getSession()获得session，若第一次访问session会自动被创建，该浏览器第二次访问时将字节返回之前创建的session，不会创建新的。</li>
<li><font color="red">一个浏览器关联一个session。</font>如果此时有新的浏览器2访问Servlet1，那么就会创建一个新的sesssion与浏览器2对应</li>
<li>session默认的生命周期是30分钟</li>
<li>session中使用setAttribute时使用相同的属性名，属性值会被替换</li>
</ul>
<h3 id="session基本使用"><a href="#session基本使用" class="headerlink" title="session基本使用"></a>session基本使用</h3><pre><code>//访问session[当发现没有session时候，就会自动创建session]
HttpSession session = request.getSession();
//向session中添加属性
session.setAttribute(&quot;name&quot;,&quot;姓名&quot;);
//从session中得到某个属性
String name = (String) session.getAttribute(&quot;name&quot;);
out.println(name + &quot;&lt;br/&gt;&quot;);
//从session中删除某个属性
session.removeAttribute(&quot;name&quot;);
out.println((String) session.getAttribute(&quot;name&quot;) + &quot;&lt;br/&gt;&quot;);
</code></pre><h3 id="session小结"><a href="#session小结" class="headerlink" title="session小结"></a>session小结</h3><p>① session是存在服务器的内存中<br>② 一个用户浏览器，独享一个session域对象（不能浏览器会创建新的session）<br>③ session中的属性的默认生命周期是30min，你可以通过web.xml来修改<br>④ 3种session生命周期的设置</p>
<pre><code>（1）一个地方是 tomcat/conf/web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;//表示30分钟的意思
    &lt;/session-config&gt;
    对所有的web应用生效
（2）另外一个地方，就是在单个web应用的下去修改 web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;session精确到分钟,cookie精确到秒
    &lt;/session-config&gt;
    如果发生冲突，则以自己的web应用优先级高
（3）session.setMaxInactiveinterval(60) 六十秒为发呆时间，即在这六十秒内没有访问过session，则session中所有属性失效
</code></pre><p><img src="http://i.imgur.com/LarH0Wk.png" alt=""></p>
<ul>
<li>session周期是发呆时间，如果我们设置session是10s，是指在10s内，没有访问过session，session属性失效，如果在9s时候，你访问session，session就会重新计时</li>
<li>如果重启tomcat，或者reload web应用，或者关机了，session失效</li>
<li>我们也可以通过函数，让session失效。invalidate()方法让所有属性失效，通常用于用户安全退出</li>
<li>如果你希望某个session属性失效，可以使用方法removeAttribute</li>
</ul>
<p>⑤ session中可以存放多个属性<br>⑥ session可以存放对象<br>⑦ 如果session.setAttribute(“name”,val)，如果名字重复，则会替换该属性.</p>
<h3 id="session的更深入理解"><a href="#session的更深入理解" class="headerlink" title="session的更深入理解"></a>session的更深入理解</h3><p><strong><em>为什么服务器能够为不同的浏览器提供不同session？</em></strong>  </p>
<p>　　图中浏览器A第一次访问Servlet1的时候，没有携带JSESSIONID，调用getSession()就会自动给你创建一个session，id为110，并创建cookie：JSESSIONID=110.<br>　　第二次浏览器访问Servlet2时，携带cookie：JSESSIONID=110，说明session已经创建，getSession（）方法返回id=110的session，能够获得session中的数据<br>　　同理，浏览器B访问servlet1时会新建一个新的session，id=119<br>　　每个浏览器独享一个session对象<br>　　<font color="red">session自动返回的cookie不会被写入文件，所以不同浏览器访问servlet会获取不同的session</font></p>
<p><img src="http://i.imgur.com/Klh1fzm.png" alt=""></p>
<h3 id="生成验证码案例"><a href="#生成验证码案例" class="headerlink" title="生成验证码案例"></a>生成验证码案例</h3><pre><code>public class check_code extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 7.禁止浏览器缓存随机图片
        response.setDateHeader(&quot;Expires&quot;, -1);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        // 6.通知客户机以图片方式打开发送过去的数据
        response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);
        // 1.在内存中创建一副图片
        BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB);
        // 2.向图片上写数据
        Graphics g = image.getGraphics();
        // 设背景色
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 60, 30);
        // 3.设置写入数据的颜色和字体
        g.setColor(Color.RED);
        g.setFont(new Font(null, Font.BOLD, 20));
        // 4.向图片上写数据
        String num = makeNum();
        //这句话就是把随机生成的数值，保存到session
        request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了
        g.drawString(num, 5, 22);
        // 5.把写好数据的图片输出给浏览器
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }
    //该函数时随机生成4位数字
    public String makeNum() {
        Random r = new Random();
        //9999999 可以生成7位
        String num = r.nextInt(9999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        //如果不够4位，前面补零
        for (int i = 0; i &lt; 4 - num.length(); i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
</code></pre><h3 id="IE上购买商品后关闭，再打开IE，要求上次的商品还在"><a href="#IE上购买商品后关闭，再打开IE，要求上次的商品还在" class="headerlink" title="IE上购买商品后关闭，再打开IE，要求上次的商品还在"></a>IE上购买商品后关闭，再打开IE，要求上次的商品还在</h3><p><strong><em>分析</em></strong></p>
<ul>
<li>设session生命周期为30min,该session不会随浏览器的关闭而自动销毁。而会到30min后，才会被服务器销毁</li>
<li>关闭浏览器后，再打开。由于服务器端传回来的cookie：JSESSIONID没有设置生命周期，那么在浏览器关闭后cookie的生命周期结束。下次打开浏览器时，没有携带cookie：JSESSIONID，访问Servlet又会创建一个新的session</li>
<li>我们使用代码来实现该功能(session + cookie结合使用)</li>
</ul>
<p><strong><em>分析实现的思路:</em></strong></p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
    //创建一个session，并放入一个属性
    HttpSession session = request.getSession();
    session.setAttribute(&quot;name&quot;, &quot;xxx&quot;);
    out.println(&quot;创一个session并放入姓名属性&quot;);
    //把session_id保存在cookie，cookie名字必须按照规范命名，必须大写JSESSIONID
    Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());
    ////如果不设置时间生命周期，cookie在浏览器关闭后就消亡
    cookie.setMaxAge(60*30);
    response.addCookie(cookie);
}
</code></pre><h3 id="ie禁用cookie后使用session的方法"><a href="#ie禁用cookie后使用session的方法" class="headerlink" title="ie禁用cookie后使用session的方法"></a>ie禁用cookie后使用session的方法</h3><p><strong><em>简易购物车的实例</em></strong></p>
<p><img src="http://i.imgur.com/mqreaNv.png" alt=""></p>
<p><strong><em>思路</em></strong></p>
<pre><code>当用户点击购买商品时，我们把该商品保存到session中，该session的结构是:
name             val
mybookds    hashMap对象
而hashmap的结构是    
key     val
书号   书对象.
</code></pre><p>若禁用cookie后，每次访问Servlet不携带cookie数据，创建一个新的session，购物车商品不能保存</p>
<p><strong><em>解决方法</em></strong></p>
<p>URL重写</p>
<ul>
<li>response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写</li>
<li>response.encodeRedirectURL(java.lang.String url)用于对sendRedirect方法后的url地址进行重写</li>
</ul>
<p>Servlet.java</p>
<pre><code>request.getSession();//必须访问一下sesion
String url = response.encodeURL(&quot;/ServletStudy/cl&quot;);
out.println(&quot;&lt;form method = &apos;post&apos; action = &apos;&quot;+url+&quot;&apos;&gt;&quot;);
out.println(&quot;&lt;input type = &apos;submit&apos;/&gt;&quot;);
out.println(&quot;&lt;/form&gt;&quot;);
</code></pre><p>cl.java</p>
<pre><code>HttpSession session = request.getSession();
ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;) session.getAttribute(&quot;array&quot;);
if(null == array){
    array = new ArrayList&lt;String&gt;();
    session.setAttribute(&quot;array&quot;,array);
}
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String time = simpleDateFormat.format(new java.util.Date());
array.add(time);

for(String s : array){
    out.println(s + &quot;&lt;br/&gt;&quot;);
}
String url = response.encodeURL(&quot;/ServletStudy/Servlet&quot;);
out.println(&quot;&lt;a href = &apos;&quot;+url+&quot;&apos;&gt;返回&lt;/a&gt;&quot;);
</code></pre><h2 id="cookie-vs-session"><a href="#cookie-vs-session" class="headerlink" title="cookie vs session"></a>cookie vs session</h2><h3 id="存在的位置"><a href="#存在的位置" class="headerlink" title="存在的位置"></a>存在的位置</h3><ul>
<li>cookie存在客户端的临时文件夹</li>
<li>session存在服务器的内存中，一个sessio与对象为一个用户浏览器服务</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>cookie是以明文方式存放在客户端，安全性弱，可以通过加密md5再存放</li>
<li>session是存放在服务端的内存中，安全性好</li>
</ul>
<h3 id="网络传输量"><a href="#网络传输量" class="headerlink" title="网络传输量"></a>网络传输量</h3><ul>
<li>cookie会传递信息，给服务端</li>
<li>session的属性值不会给客户端</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>cookie的生命周期是累计时间，即如果我们给cookie设置setMaxAge（30），则cookie在30s后失效</li>
<li>session额生命周期是间隔时间，如果我们设置session 20min，指在20min内，如果没有访问session，则session失效（指的是session属性失效），在关闭tomcat,reload web应用，时间到，invalidate也会让session失效</li>
</ul>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><p>　　因为session会占用服务器的内存，因此不要向session存放过多的对象，会影响性能</p>
<h2 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器 Filter"></a>过滤器 Filter</h2><ul>
<li>客户端请求request在<strong>抵达Servlet之前</strong>、服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>会经过过滤器，过滤器用于在Servlet之外<strong>对request或者response进行修改</strong></li>
<li>Filter体现的是设计模式中的Filter模式</li>
</ul>
<h3 id="过滤器链-FilterChain"><a href="#过滤器链-FilterChain" class="headerlink" title="过滤器链 FilterChain"></a>过滤器链 FilterChain</h3><p>一个过滤器链包括多个Filter，客户端请求request在<strong>抵达Servlet之前</strong>会经过FilterChain里的所有Filter，服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>之前也会经过FilterChain里的所有Filter</p>
<p><img src="http://i.imgur.com/5S0gzS0.png" alt=""></p>
<h3 id="防盗链Filter"><a href="#防盗链Filter" class="headerlink" title="防盗链Filter"></a>防盗链Filter</h3><pre><code>public class ImageRedirectFilter implements Filter {

    public void init(FilterConfig config) throws ServletException {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 禁止缓存
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);
        response.setHeader(&quot;Pragrma&quot;, &quot;no-cache&quot;);
        response.setDateHeader(&quot;Expires&quot;, 0);

        // 链接来源地址
        String referer = request.getHeader(&quot;referer&quot;);

        if (referer == null || !referer.contains(request.getServerName())) {

            /**
             * 如果 链接地址来自其他网站，则返回错误图片
             */
            request.getRequestDispatcher(&quot;/error.gif&quot;).forward(request,
                    response);

        } else {

            /**
             * 图片正常显示
             */
            chain.doFilter(request, response);
        }

    }

    public void destroy() {
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;
</code></pre><h3 id="字符编码-Filter"><a href="#字符编码-Filter" class="headerlink" title="字符编码 Filter"></a>字符编码 Filter</h3><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><pre><code>public class CharacterEncodingFilter implements Filter {

    private String characterEncoding;
    private boolean enabled;

    @Override
    public void init(FilterConfig config) throws ServletException {

        characterEncoding = config.getInitParameter(&quot;characterEncoding&quot;);

        enabled = &quot;true&quot;.equalsIgnoreCase(characterEncoding.trim())
                || &quot;1&quot;.equalsIgnoreCase(characterEncoding.trim());
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {

        if (enabled || characterEncoding != null) {
            request.setCharacterEncoding(characterEncoding);
            response.setCharacterEncoding(characterEncoding);
        }

        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        characterEncoding = null;
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.CharacterEncodingFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;characterEncoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;enable&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h4 id="Spring-mvc自带"><a href="#Spring-mvc自带" class="headerlink" title="Spring mvc自带"></a>Spring mvc自带</h4><pre><code>&lt;!-- 编码过滤器，UTF8编码，对POST有效 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="异常捕捉-Filter"><a href="#异常捕捉-Filter" class="headerlink" title="异常捕捉 Filter"></a>异常捕捉 Filter</h3><pre><code>public class ExceptionHandlerFilter implements Filter {

    public void destroy() {}

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } catch (Exception e) {
            Throwable rootCause = e;
            while (rootCause.getCause() != null) {
                rootCause = rootCause.getCause();
            }
            String message = rootCause.getMessage();
            message = message == null ? &quot;异常：&quot; + rootCause.getClass().getName()
                    : message;
            request.setAttribute(&quot;message&quot;, message);
            request.setAttribute(&quot;e&quot;, e);

            if (rootCause instanceof AccountException) {
                request.getRequestDispatcher(&quot;/accountException.jsp&quot;).forward(
                        request, response);
            } else if (rootCause instanceof BusinessException) {
                request.getRequestDispatcher(&quot;/businessException.jsp&quot;).forward(
                        request, response);
            } else {
                request.getRequestDispatcher(&quot;/exception.jsp&quot;).forward(request,
                        response);
            }
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</code></pre><h3 id="内容替换-Filter"><a href="#内容替换-Filter" class="headerlink" title="内容替换 Filter"></a>内容替换 Filter</h3><p>需求：有时候需要对网站的内容进行控制，防止输出非法内容或者敏感内容<br>解决方案：</p>
<ul>
<li>方案一：在Servlet里输出到客户端时进行内容替换，这种方案需要对每个Servlet<br>都进行替换，工作量大，业务耦合比较严重</li>
<li>方案二：在Servlet将内容输出到response时，response将内容缓存起来，<br>在Filter中进行替换，然后再输出到客户端浏览器。但是默认的response并不能严格的<br>缓存输出内容，因此需要<font color="red"><strong><em>自定义一个具有缓存功能的response</em></strong></font></li>
</ul>
<p>要点：自定义的一个response只是一个伪装的response。Servlet会通过它输出内容到客户端，但是它内部只是将内容缓存起来了（<font color="red"><strong><em>使用自己创建的PrintWriter</em></strong></font>），并没有真正输出到客户端。最终输出到客户端还是通过原来的resonse完成的</p>
<p>框图：</p>
<p><img src="http://i.imgur.com/OirpKFm.png" alt=""></p>
<p>具体操作：</p>
<p>1、通过扩展HttpServletResponseWrapper类来<font color="red"><strong><em>实现自定义的response</em></strong></font>，该类覆盖了getWriter()方法，当Servlet使用该response对象调用getWriter()莱输出内容时，内容将被输出到CharArrayWriter对象中，达到缓存的效果</p>
<pre>
public class HttpCharacterResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">private CharArrayWriter charArrayWriter = new CharArrayWriter();</font>

    public HttpCharacterResponseWrapper(HttpServletResponse response) {
        super(response);
    }

    <font color="red">@Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(charArrayWriter);
    }</font>

    public CharArrayWriter getCharArrayWriter() {
        return charArrayWriter;
    }
}
</pre>

<p>2、Filter将自定义的response传进Servlet中</p>
<pre>
public class OutputReplaceFilter implements Filter {

    private Properties pp = new Properties();

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("file");
        String realPath = config.getServletContext().getRealPath(file);
        try {
            pp.load(new FileInputStream(realPath));
        } catch (IOException e) {
        }
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        <font color="red">// 自定义的 response
        HttpCharacterResponseWrapper response = new HttpCharacterResponseWrapper(
                (HttpServletResponse) res);

        // 提交给 Servlet 或者下一个 Filter
        chain.doFilter(req, response);</font>

        // 得到缓存在自定义 response 中的输出内容
        String output = response.getCharArrayWriter().toString();

        // 修改，替换
        for (Object obj : pp.keySet()) {
            String key = (String) obj;
            output = output.replace(key, pp.getProperty(key));
        }

        <font color="red">// 输出
        PrintWriter out = res.getWriter();
        out.write(output);</font>
        out.println("<!-- Generated at " + new java.util.Date() + " -->");
    }

    public void destroy() {
    }
}
</pre>

<h3 id="GZIP-压缩-Filter"><a href="#GZIP-压缩-Filter" class="headerlink" title="GZIP 压缩 Filter"></a>GZIP 压缩 Filter</h3><p>Servlet中操作输入输出流：</p>
<pre>
String path = request.getSession().getServletContext().getRealPath("/error.jpg");
InputStream inputStream = new FileInputStream(path);
int len = -1;
byte[] buffer = new byte[1024];
<font color="red">OutputStream outputStream = response.getOutputStream();</font>
while((len = inputStream.read(buffer)) != -1){
    <font color="red">outputStream.write(buffer,0,len);</font>
}
<font color="red">outputStream.close();</font>
inputStream.close();
</pre>

<p>要点：<br>1、替换response，并且替换的response中重写response中的getOutputStream()方法[也需要重写getWrite()，因为除了压缩二进制文件，还要压缩文本文件]<br>2、重写ServletOutputStream，当调用write方法时，使用JDK自带的GZIPOutputStream类进行数据压缩★★★★★★★★（核心）</p>
<p>总体操作框图：</p>
<p><img src="http://i.imgur.com/V7Ec9aU.png" alt=""></p>
<pre>
①自定义的GZipResponseWrapper替换tomcat传入的respone
    <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);</font>
    chain.doFilter(request, gzipResponse);
②Servlet中调用response中的getOutputStream()获得输出流，数据写入缓存，调用close方法进行压缩
    OutputStream outputStream = response.<font color="red">getOutputStream();</font>
    while((len = inputStream.read(buffer)) != -1){
        outputStream.write(buffer,0,len);
    }
    <font color="red">outputStream.close();</font>
    inputStream.close();
③输出压缩数据
    gzipResponse.finishResponse();
</pre>

<p>GZIPOutputStream类API：</p>
<pre><code>void finish() 
      完成将压缩数据写入输出流的操作，无需关闭底层流。 
void write(byte[] buf, int off, int len) 
      将字节数组写入压缩输出流。 
</code></pre><p>1、GZipFilter，如果客户端支持GZip自动解压，则进行GZIP压缩，否则不压缩</p>
<pre>
public class GZipFilter implements Filter {

    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        String acceptEncoding = request.getHeader("Accept-Encoding");
        System.out.println("Accept-Encoding: " + acceptEncoding);

        if (acceptEncoding != null
                && acceptEncoding.toLowerCase().indexOf("gzip") != -1) {

            // 如果客户浏览器支持 GZIP 格式, 则使用 GZIP 压缩数据
            <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);
            chain.doFilter(request, gzipResponse);</font>

            <font color="red">/*
            * 输出压缩数据，一般由用户在调用outputStream.close()自己关闭输出流，
            * 此处调用是为了防止用户忘记
            */
            gzipResponse.finishResponse();</font>

        } else {
            // 否则, 不压缩
            chain.doFilter(request, response);
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</pre>

<p>2、GZipResponseWrapper伪装response，GZipOutputStream为它的成员变量，Servlet中的输出就是对GZipOutputStream的操作</p>
<ul>
<li>GZipResponseWrapper为自定义的response类，内部将对输出的内容进行GZIP压缩。它继承HttpServletResponseWrapper，也是一个伪装的response，不真正输出内容到客户端</li>
<li>由于该response要处理二进制内容，又要处理字符内容，因此需要覆盖getOutputStream和getWriter</li>
<li><strong>GZipResponseWrapper中的方法是实现对GZipOutputStream的操作</strong></li>
</ul>
<pre>
public class GZipResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">/*
    * 传入默认的response，保存起来作为成员变量
    */</font>
    private HttpServletResponse response;

    <font color="red">/*
    * 可以不保存，如果用户自己关闭输入流，则无需调用finishResponse方法来关闭文本或二进制输出流。
    * 但是为了增加可靠性，在response抵达客户端浏览器前进行关闭流操作
    */</font>
    // 自定义的 outputStream, 执行close()的时候对数据压缩，并输出
    private GZipOutputStream gzipOutputStream;
    // 自定义 printWriter，将内容输出到 GZipOutputStream 中
    private PrintWriter writer;

    public GZipResponseWrapper(HttpServletResponse response) throws IOException {
        super(response);
        this.response = response;
    }

    public ServletOutputStream getOutputStream() throws IOException {
        if (gzipOutputStream == null)
            <font color="red">gzipOutputStream = new GZipOutputStream(response);</font>
        return gzipOutputStream;
    }

    public PrintWriter getWriter() throws IOException {
        if (writer == null)
            <font color="red">writer = new PrintWriter(new OutputStreamWriter(
                    new GZipOutputStream(response), "UTF-8"));</font>
        return writer;
    }

    // 压缩后数据长度会发生变化 因此将该方法内容置空
    public void setContentLength(int contentLength) {
    }

    public void flushBuffer() throws IOException {
        gzipOutputStream.flush();
    }

    <font color="red">public void finishResponse() throws IOException {
        if (gzipOutputStream != null)
            gzipOutputStream.close();
        if (writer != null)
            writer.close();
    }</font>
}
</pre>

<p>3、自定义GZipOutputStream类，继承ServletOutputStream，使用JDK自带的GZIP压缩类将数据缓存起来，之后调用finish函数进行数据压缩，并输出到客户端浏览器</p>
<pre>
public class GZipOutputStream extends ServletOutputStream {

    private HttpServletResponse response;

    // JDK 自带的压缩数据的类
    private GZIPOutputStream gzipOutputStream;

    // 将压缩后的数据存放到 ByteArrayOutputStream 对象中
    private ByteArrayOutputStream byteArrayOutputStream;

    <font color="red">/*
    * GZipResponseWrapper中调用构造函数，创建实例，数据缓存在ByteArrayOutputStream
    */</font>
    public GZipOutputStream(HttpServletResponse response) throws IOException {
        this.response = response;
        byteArrayOutputStream = new ByteArrayOutputStream();
        gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);
    }

    <font color="red">/*
    * Servlet中调用write方法，将数据写入缓存
    */</font>
    public void write(int b) throws IOException {
        gzipOutputStream.write(b);
    }

    <font color="red">/*
    * Servlet中调用close方法，并不是直接关闭输入流，而是先执行压缩操作，然后调用浏览器本身的输出流，在写入到客户端浏览器
    */</font>
    public void close() throws IOException {

        // 压缩完毕 一定要调用该方法
        gzipOutputStream.finish();

        // 将压缩后的数据输出到客户端
        byte[] content = byteArrayOutputStream.toByteArray();

        // 设定压缩方式为 GZIP, 客户端浏览器会自动将数据解压
        response.addHeader("Content-Encoding", "gzip");
        response.addHeader("Content-Length", Integer.toString(content.length));

        // 输出
        ServletOutputStream out = response.getOutputStream();
        out.write(content);
        out.close();
    }

    public void flush() throws IOException {
        gzipOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        gzipOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        gzipOutputStream.write(b);
    }
}
</pre>

<h3 id="图像水印-Filter"><a href="#图像水印-Filter" class="headerlink" title="图像水印 Filter"></a>图像水印 Filter</h3><p>使用Filter在图像上动态打上一个水印LOGO，工作原理与GZIP压缩类似，先把图像数据缓存起来，然后对图像进行水印处理后输出到客户端浏览器</p>
<p>图像水印Filter需要自定义response与servletOutputStream</p>
<p>1、WaterMarkFilter，在Filter初始化参数里设置水印图片文件路径</p>
<pre>
public class WaterMarkFilter implements Filter {

    // 水印图片，配置在初始化参数中
    private String waterMarkFile;

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("waterMarkFile");
        waterMarkFile = config.getServletContext().getRealPath(file);
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 自定义的response
        WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

        chain.doFilter(request, waterMarkRes);

        // 打水印，输出到客户端浏览器
        waterMarkRes.finishResponse();
    }

    public void destroy() {
    }

}
</pre>

<p>2、WaterMarkResponseWrapper继承HttpServletResponseWrapper，改写了getOutputStream方法，finishResponse方法将缓存的数据进行水印处理，并输出到客户端浏览器。水印处理的代码被封装到ImageUtil类的静态方法waterMark()中</p>
<pre>
public class WaterMarkResponseWrapper extends HttpServletResponseWrapper {

    // 水印图片位置
    private String waterMarkFile;

    // 原response
    private HttpServletResponse response;

    // 自定义servletOutputStream，用于缓冲图像数据
    private WaterMarkOutputStream waterMarkOutputStream;

    public WaterMarkResponseWrapper(HttpServletResponse response,
            String waterMarkFile) throws IOException {
        super(response);
        this.response = response;
        this.waterMarkFile = waterMarkFile;
        this.waterMarkOutputStream = new WaterMarkOutputStream();
    }

    // 覆盖getOutputStream()，返回自定义的waterMarkOutputStream
    public ServletOutputStream getOutputStream() throws IOException {
        return waterMarkOutputStream;
    }

    public void flushBuffer() throws IOException {
        waterMarkOutputStream.flush();
    }

    // 将图像数据打水印，并输出到客户端浏览器
    public void finishResponse() throws IOException {

        // 原图片数据
        byte[] imageData = waterMarkOutputStream.getByteArrayOutputStream()
                .toByteArray();

        // 打水印后的图片数据
        byte[] image = ImageUtil.waterMark(imageData, waterMarkFile);

        // 将图像输出到浏览器
        response.setContentLength(image.length);
        response.getOutputStream().write(image);

        waterMarkOutputStream.close();
    }
}
</pre>

<p>3、WaterMarkOutputStream类将图像数据缓存起来</p>
<pre>
public class WaterMarkOutputStream extends ServletOutputStream {

    // 缓冲图片数据
    private ByteArrayOutputStream byteArrayOutputStream;

    public WaterMarkOutputStream() throws IOException {
        byteArrayOutputStream = new ByteArrayOutputStream();
    }

    public void write(int b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public void close() throws IOException {
        byteArrayOutputStream.close();
    }

    public void flush() throws IOException {
        byteArrayOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        byteArrayOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public ByteArrayOutputStream getByteArrayOutputStream() {
        return byteArrayOutputStream;
    }

}
</pre>

<p>4、ImageUtil类使用JDK的图像处理类完成添加水印的操作</p>
<pre>
public class ImageUtil {

    /**
     * 
     * @param imageData
     *            JPG 图像文件
     * @param waterMarkFile
     *            水印图片
     * @return 加水印后的图像数据
     * @throws IOException
     */
    public static byte[] waterMark(byte[] imageData, String waterMarkFile)
            throws IOException {

        // 水印图片的右边距 下边距
        int paddingRight = 10;
        int paddingBottom = 10;

        // 原始图像
        Image image = new ImageIcon(imageData).getImage();
        int imageWidth = image.getWidth(null);
        int imageHeight = image.getHeight(null);

        // 水印图片
        Image waterMark = ImageIO.read(new File(waterMarkFile));
        int waterMarkWidth = waterMark.getWidth(null);
        int waterMarkHeight = waterMark.getHeight(null);

        // 如果图片尺寸过小，则不打水印，直接返回
        if (imageWidth < waterMarkWidth + 2 * paddingRight
                || imageHeight < waterMarkHeight + 2 * paddingBottom) {
            return imageData;
        }
        BufferedImage bufferedImage = new BufferedImage(imageWidth,
                imageHeight, BufferedImage.TYPE_INT_RGB);

        Graphics g = bufferedImage.createGraphics();

        // 绘制原始图像
        g.drawImage(image, 0, 0, imageWidth, imageHeight, null);
        // 绘制水印图片
        g.drawImage(waterMark, imageWidth - waterMarkWidth - paddingRight,
                imageHeight - waterMarkHeight - paddingBottom, waterMarkWidth,
                waterMarkHeight, null);
        g.dispose();

        // 转成JPEG格式
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
        encoder.encode(bufferedImage);
        byte[] data = out.toByteArray();
        out.close();
        return data;
    }
}
</pre>

<p>5、配置文件</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter&gt;
    &lt;filter-name&gt;waterMarkFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.watermark.WaterMarkFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;waterMarkFile&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/logo.png&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h3 id="内容替换、GZIP、图像水印-Filter-总结★★★★★★"><a href="#内容替换、GZIP、图像水印-Filter-总结★★★★★★" class="headerlink" title="内容替换、GZIP、图像水印 Filter 总结★★★★★★"></a>内容替换、GZIP、图像水印 Filter 总结★★★★★★</h3><p>以图像水印 Filter 为例</p>
<p>1、过滤器中自定义response包裹类，将原生response作为参数传入。自定义的response替换原生response传入Servlet；response返回客户端之前，调用新定义的finishResponse方法，输出到客户端浏览器</p>
<pre><code>// 自定义的response
WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

chain.doFilter(request, waterMarkRes);

// 打水印，输出到客户端浏览器
waterMarkRes.finishResponse();
</code></pre><p>2、自定义response包裹类有一个存放原生response的成员变量，一个自定义的输出流，起到缓存数据的功能。重写getOutputStream()方法或getWriter()方法，返回自定义输出流，添加finishResponse方法，将缓存中的数据进行处理，输出到客户端浏览器</p>
<p>3、重写ServletOutputStream类对数据进行，对数据缓存</p>
<h3 id="缓存-Filter"><a href="#缓存-Filter" class="headerlink" title="缓存 Filter"></a>缓存 Filter</h3><p><strong><em>对于访问量比较大的网站（淘宝），反复地查询数据库要消耗很多时间</em></strong>。如果第一次访问某页面查询了数据库，那么就可以把页面的内容缓存起来，下一次访问的时候直接返回缓存结果就行。使用缓存能将数据库读写次数较少都最少，从而提高服务器的响应速度</p>
<p>缓存Filter的工作流程：<br>1、截获浏览器提交的request<br>2、如果request为POST方式，则不进行缓存<br>3、<strong>如果request为GET方式，且请求的页面有缓存并且缓存没有过期</strong>，则直接返回缓存结果，这样就避免读取数据库<br>4、如果没有缓存或者缓存已过期，则重新请求Servlet，将Servlet返回的内容缓存并输出到客户端浏览器</p>
<p>使用缓存注意点：</p>
<p>1、缓存Filter不易用于数据会实时变化的数据，如报表、股票等，它适用于数据变化不大，但是访问次数多的内容，如论坛、博客、新闻等<br>2、缓存Filter不能用于POST方式提交数据，如登录、发表文章等<br>3、<strong>当缓存更新后，要更新缓存，或者直接将缓存删掉</strong><br>4、被缓存的内容不能依赖于Session，而要依赖于Cookie。即要使用Cookie来记录客户身份而不要使用Session，并且<strong>无论客户身份是管理员还是普通浏览者，Servlet输出内容都是一样的，只能在浏览器使用js根据cookie来决定显示什么内容</strong>。但是注意：由于菜单的显示与否并没有在服务器端进行权限检查，<font color="red"><strong><em>因此当客户单击链接操作的时候，一定要做权限检查，否则会引发安全问题</em></strong></font></p>
<p>框图：</p>
<p><img src="http://i.imgur.com/S75GBO8.png" alt=""></p>
<p>①如果存在缓存文件，直接缓存文件中读取数据并输出到客户端浏览器，不进入Servlet<br>②没有缓存或缓存过期，在Servlet将输出的内容缓存起来<br>③缓存Filter将缓存内容写入到缓存文件，并读取缓存文件将数据输出</p>
<p>程序流程图：</p>
<p><img src="http://i.imgur.com/SSL3f5N.png" alt=""></p>
<p>1、缓存Filter</p>
<pre>
public class CacheFilter implements Filter {

    private ServletContext servletContext;

    // 缓存文件夹，使用Tomcat工作目录
    private File temporalDir;

    // 缓存时间，配置在Filter初始化参数中
    private long cacheTime = Long.MAX_VALUE;

    public void init(FilterConfig config) throws ServletException {
        temporalDir = (File) config.getServletContext().getAttribute(
                "javax.servlet.context.tempdir");
        servletContext = config.getServletContext();
        cacheTime = new Long(config.getInitParameter("cacheTime"));
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        <font color="red">// 如果为 POST, 则不经过缓存</font>
        if ("POST".equals(request.getMethod())) {
            chain.doFilter(request, response);
            return;
        }

        <font color="red">// 请求的 URI，忽略应用程序名称</font>
        String uri = request.getRequestURI();
        if (uri == null)
            uri = "";
        uri = uri.replace(request.getContextPath() + "/", "");
        uri = uri.trim().length() == 0 ? "index.jsp" : uri;
        uri = request.getQueryString() == null ? uri : (uri + "?" + request
                .getQueryString());

        // 对应的缓存文件
        File cacheFile = new File(temporalDir, URLEncoder.encode(uri, "UTF-8"));
        System.out.println(cacheFile);

        // 如果缓存文件不存在 或者已经超出缓存时间 则请求 Servlet
        if (!cacheFile.exists()
                || cacheFile.length() == 0
                || cacheFile.lastModified() < System.currentTimeMillis()
                        - cacheTime) {

            CacheResponseWrapper cacheResponse = new CacheResponseWrapper(
                    response);

            chain.doFilter(request, cacheResponse);

            // 将内容写入缓存文件
            char[] content = cacheResponse.getCacheWriter().toCharArray();

            temporalDir.mkdirs();<font color="red">//递归创建文件夹</font>
            cacheFile.createNewFile();<font color="red">//创建文件</font>

            Writer writer = new OutputStreamWriter(new FileOutputStream(
                    cacheFile), "UTF-8");
            writer.write(content);
            writer.close();
        }

        // 请求的ContentType
        String mimeType = servletContext.getMimeType(request.getRequestURI());
        response.setContentType(mimeType);

        // 读取缓存文件的内容，写入客户端浏览器
        Reader ins = new InputStreamReader(new FileInputStream(cacheFile),
                "UTF-8");
        StringBuffer buffer = new StringBuffer();
        char[] cbuf = new char[1024];
        int len;
        while ((len = ins.read(cbuf)) > -1) {
            buffer.append(cbuf, 0, len);
        }
        ins.close();
        // 输出到客户端
        response.getWriter().write(buffer.toString());
    }

    public void destroy() {
    }
}
</pre>

<p>2、CacheResponseWrapper强Servlet中输出的内容缓存起来，然后被缓存Filter写入到缓存文件中。本缓存Filter只缓存字符类网页，因此只覆盖了getWriter()方法</p>
<pre><code>public class CacheResponseWrapper extends HttpServletResponseWrapper {

    // 缓存字符类输出
    private CharArrayWriter cacheWriter = new CharArrayWriter();

    public CacheResponseWrapper(HttpServletResponse response)
            throws IOException {
        super(response);
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(cacheWriter);
    }

    @Override
    public void flushBuffer() throws IOException {
        cacheWriter.flush();
    }

    public void finishResponse() throws IOException {
        cacheWriter.close();
    }

    public CharArrayWriter getCacheWriter() {
        return cacheWriter;
    }

    public void setCacheWriter(CharArrayWriter cacheWriter) {
        this.cacheWriter = cacheWriter;
    }
}
</code></pre><p>3、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.cache.CacheFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cache&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cacheTime&lt;/param-name&gt;
        &lt;param-value&gt;1000000&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="XSLT-转换-Filter"><a href="#XSLT-转换-Filter" class="headerlink" title="XSLT 转换 Filter"></a>XSLT 转换 Filter</h3><p>XSLT转换时XML文件的功能之一，是利用XSLT样式文件将XML文件转换成其他格式，使用XSLT 转换 Filter，浏览器访问请求XML格式，返回浏览器时已经是转换后的HTML文件了</p>
<p>1、该Filter使用JDK自带的标准XML工具包进行XML格式转换。MSN的聊天记录是用XML形式保存的，浏览器访问XML格式，返回转换后的HTML文件</p>
<pre><code>public class XSLTFilter implements Filter {

    private ServletContext servletContext;

    public void init(FilterConfig config) throws ServletException {
        servletContext = config.getServletContext();
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 格式样本文件：/book.xsl
        Source styleSource = new StreamSource(servletContext
                .getRealPath(&quot;/MessageLog.xsl&quot;));

        // 请求的 xml 文件
        Source xmlSource = new StreamSource(servletContext.getRealPath(request
                .getRequestURI().replace(request.getContextPath() + &quot;&quot;, &quot;&quot;)));
        try {

            // 转换器工厂
            TransformerFactory transformerFactory = TransformerFactory
                    .newInstance();

            // 转换器
            Transformer transformer = transformerFactory
                    .newTransformer(styleSource);

            // 将转换的结果保存到该对象中
            CharArrayWriter charArrayWriter = new CharArrayWriter();
            StreamResult result = new StreamResult(charArrayWriter);

            // 转换
            transformer.transform(xmlSource, result);

            // 输出转换后的结果
            response.setContentType(&quot;text/html&quot;);
            response.setContentLength(charArrayWriter.toString().length());
            PrintWriter out = response.getWriter();
            out.write(charArrayWriter.toString());

        } catch (Exception ex) {
        }
    }

    public void destroy() {
    }
}
</code></pre><p>2、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.helloweenvsfei.xml.XSLTFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/msn/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器 Listener"></a>监听器 Listener</h2><p>Listener用于监听Java Web程序中的事件，例如创建、修改、删除Session、request、context等</p>
<h3 id="Listener使用"><a href="#Listener使用" class="headerlink" title="Listener使用"></a>Listener使用</h3><p>使用Listener需要实现相应的Listener接口，<strong><em>触发Listener事件时，Tomcat会自动调用Listener的方法</em></strong></p>
<h4 id="实现Listener接口"><a href="#实现Listener接口" class="headerlink" title="实现Listener接口"></a>实现Listener接口</h4><p>创建Session服务器会调用sessionCreated()方法，销毁Session（包括sesson超时自动销毁）服务器会调用sessionDestroyed()方法</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener {

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        //Session创建时被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;创建了一个session：&quot; + session);
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        //销毁Session前被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;销毁了一个Session：&quot; + session);
    }
}
</code></pre><h4 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h4><p>&lt;listener&gt;标签一般配置在&lt;servlet&gt;前面</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h3 id="Listener的分类★★★★★★"><a href="#Listener的分类★★★★★★" class="headerlink" title="Listener的分类★★★★★★"></a>Listener的分类★★★★★★</h3><h4 id="监听对象的创建与销毁"><a href="#监听对象的创建与销毁" class="headerlink" title="监听对象的创建与销毁"></a>监听对象的创建与销毁</h4><ul>
<li>HttpSessionListener：监听Session的创建与销毁。创建Session时执行sessionCreated方法，超时或执行session.invalidate()时执行sessionDestroyed方法。<font color="red"><strong><em>该Listener可以收集在线者信息</em></strong></font></li>
<li>ServletContextListener：监听context的创建与销毁。<strong>context代表当前的Web应用程序</strong>，服务器启动或者热部署war包时执行contextInitialized，服务器关闭或关闭该Web时会执行contextDestroyed方法。<font color="red"><strong><em>该Listener可用于启动时读取web.xml里配置的初始化参数</em></strong></font></li>
<li>ServletRequestListener：监听request的创建与销毁，用户每次请求都会执行requestInitialized方法，request处理完毕自动销毁前执行requestDestroyed。注意如果一个HTML页面包含多个图片，则一次请求可能会多次触发request事件</li>
</ul>
<h4 id="实例：监听Session、request、servletContext"><a href="#实例：监听Session、request、servletContext" class="headerlink" title="实例：监听Session、request、servletContext"></a>实例：监听Session、request、servletContext</h4><p>自定义监听器类同时实现HttpSessionListener、ServletContextListener、ServletRequestListener接口，使得多种监听器一块工作</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener,
        ServletContextListener, ServletRequestListener {


    //Log log = LogFactory.getLog(getClass());
    Logger log = Logger.getLogger(SessionListenerTest.class);

    // 创建 session
    public void sessionCreated(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;新创建一个session, ID为: &quot; + session.getId());
    }

    // 销毁 session
    public void sessionDestroyed(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;销毁一个session, ID为: &quot; + session.getId());
    }

    // 加载 context
    public void contextInitialized(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将启动&quot; + servletContext.getContextPath());
    }

    // 卸载 context
    public void contextDestroyed(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将关闭&quot; + servletContext.getContextPath());
    }

    // 创建 request
    public void requestInitialized(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        String uri = request.getRequestURI();
        uri = request.getQueryString() == null ? uri : (uri + &quot;?&quot; + request
                .getQueryString());

        request.setAttribute(&quot;dateCreated&quot;, System.currentTimeMillis());

        log.info(&quot;IP &quot; + request.getRemoteAddr() + &quot; 请求 &quot; + uri);
    }

    // 销毁 request
    public void requestDestroyed(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        long time = System.currentTimeMillis()
                - (Long) request.getAttribute(&quot;dateCreated&quot;);

        log.info(request.getRemoteAddr() + &quot;请求处理结束, 用时&quot; + time + &quot;毫秒. &quot;);
    }
}
</code></pre><p>配置到web.xml</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h4 id="监听对象的属性变化"><a href="#监听对象的属性变化" class="headerlink" title="监听对象的属性变化"></a>监听对象的属性变化</h4><ul>
<li>另一类Listener用于监听Session、context、request的属性变化，接口名称格式为xxxAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener</li>
<li>当想被监听对象中添加、更新、移除属性时，会分别执行xxxAdded()、xxxReplace()、xxxRemoved()方法，xxx分别代表Session、Context、request</li>
</ul>
<pre><code>public class SessionAttributeListenerTest implements
        HttpSessionAttributeListener {

    Log log = LogFactory.getLog(getClass());

    // 添加属性
    public void attributeAdded(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;新建session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 删除属性
    public void attributeRemoved(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;删除session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 修改属性
    public void attributeReplaced(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        Object oldValue = se.getValue();
        log.info(&quot;修改session属性：&quot; + name + &quot;, 原值：&quot; + oldValue + &quot;, 新值：&quot;
                + session.getAttribute(name));
    }
}
</code></pre><h4 id="监听Session内的对象"><a href="#监听Session内的对象" class="headerlink" title="监听Session内的对象"></a>监听Session内的对象</h4><p>除了上面的6中Listener，有两种Listener用于监听Session内的对象，分别是HttpSessionBindingListener、HttpSessionActivationListener，他们的触发时机是：</p>
<ul>
<li>HttpSessionBindingListener：当对象被放到Session里是执行valueBound方法，当对象从Session里移除时执行valueUnbound，<strong><em>对象必须实现该Listener接口</em></strong></li>
<li>HttpSessionActivationListener：服务器关闭时，会将Session里的内容保存到硬盘上，这个过程叫做钝化。服务器重启时，会将Session里的内容从硬盘上重新加载，钝化时会执行sessionWillPassivate方法，对象被重新加载时执行sessionDidActivate方法，<strong><em>对象必须实现该Listener接口</em></strong></li>
</ul>
<p>这两个Listener监听的是Session中的对象而非Session等，因此不需要再web.xml中声明</p>
<p>PersonInfo对象被放进、移出Session或者启动、关闭服务器都会触发PersonInfo内的Listener时间：</p>
<pre><code>public class PersonInfo implements HttpSessionActivationListener,
        HttpSessionBindingListener, Serializable {

    private static final long serialVersionUID = -4780592776386225973L;

    Log log = LogFactory.getLog(getClass());

    private String name;

    private Date dateCreated;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    // 从硬盘加载后
    public void sessionDidActivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;已经成功从硬盘中加载。sessionId: &quot; + session.getId());
    }

    // 即将被钝化到硬盘时
    public void sessionWillPassivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;即将保存到硬盘。sessionId: &quot; + session.getId());
    }

    // 被放进session前
    public void valueBound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被绑定到session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上&quot;);

        // 记录放到session中的时间
        this.setDateCreated(new Date());
    }

    // 从session中移除后
    public void valueUnbound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被从session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上移除&quot;);
    }

    @Override
    public String toString() {
        return &quot;PersonInfo(&quot; + name + &quot;)&quot;;
    }

}
</code></pre><h3 id="Listener使用案例"><a href="#Listener使用案例" class="headerlink" title="Listener使用案例"></a>Listener使用案例</h3><h4 id="单态登录"><a href="#单态登录" class="headerlink" title="单态登录"></a>单态登录</h4><ul>
<li><font color="red"><strong>单态登录就是一个账号只能在一台机器上登录，如果在其他机器上登录了，则原来的登录无效</strong></font></li>
<li>单态登录的目的是为了防止多台机器同时使用一个账号</li>
</ul>
<h5 id="Listener方式实现"><a href="#Listener方式实现" class="headerlink" title="Listener方式实现"></a>Listener方式实现</h5><ul>
<li>见JavaWeb王者归来205页</li>
<li>思路：当成功验证用户信息，准备往session中存放用户的信息时，被监听器监听到，调用attributeAdded或attributeReplaced方法，方法中需要判断用户是否在别的机器上登录过，如果登录了则使以前的登录失效</li>
<li>使用这种方式Listener与登录模块没有代码耦合，部署Listener后将实现单态登录，拆掉该Listener后登录模块照常工作，只是不再保证是单态登录</li>
</ul>
<pre>
public class LoginSessionListener implements HttpSessionAttributeListener {

    Log log = LogFactory.getLog(this.getClass());

    Map<string, httpsession=""> map = new HashMap<string, httpsession="">();

    public void attributeAdded(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 登录
        if (name.equals("personInfo")) {

            PersonInfo personInfo = (PersonInfo) event.getValue();

            if (map.get(personInfo.getAccount()) != null) {

                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                PersonInfo oldPersonInfo = (PersonInfo) session
                        .getAttribute("personInfo");

                log.info("帐号" + oldPersonInfo.getAccount() + "在"
                        + oldPersonInfo.getIp() + "已经登录，该登录将被迫下线。");

                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }

            // 将session以用户名为索引，放入map中
            map.put(personInfo.getAccount(), event.getSession());
            log.info("帐号" + personInfo.getAccount() + "在" + personInfo.getIp()
                    + "登录。");
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 注销
        if (name.equals("personInfo")) {
            // 将该session从map中移除
            PersonInfo personInfo = (PersonInfo) event.getValue();
            map.remove(personInfo.getAccount());
            log.info("帐号" + personInfo.getAccount() + "注销。");
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 没有注销的情况下，用另一个帐号登录
        if (name.equals("personInfo")) {

            // 移除旧的的登录信息
            PersonInfo oldPersonInfo = (PersonInfo) event.getValue();
            map.remove(oldPersonInfo.getAccount());

            // 新的登录信息
            PersonInfo personInfo = (PersonInfo) event.getSession()
                    .getAttribute("personInfo");

            // 也要检查新登录的帐号是否在别的机器上登录过
            if (map.get(personInfo.getAccount()) != null) {
                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }
            map.put("personInfo", event.getSession());
        }

    }

}
</string,></string,></pre>

<h5 id="自己的实现"><a href="#自己的实现" class="headerlink" title="自己的实现"></a>自己的实现</h5><ul>
<li>如果没有要求单态登录，成功验证用户信息后，返回客户端token，在服务器端创建session，并将用户信息存入到session，之后客户端再次访问，根据token恢复session，如果session中存放了用户信息，则用户合法，否则退回登录页面</li>
<li>实现单态登录，需要在验证用户信息后，<font color="red"><strong><em>判断账号是否在别的机器上登录</em></strong></font>。</li>
<li>具体实现：用一个HashMap存储在线用户信息，主键为用户名，键值为session。成功验证用户信息后，根据用户名获取session，如果session不为空，说明用户已经在别的机器上登录，则使sesson无效，在HashMap上移除该值，这样之前登录的用户操作前，会检查session中没有用户信息，则必须重新登录，做到强制退出的目的</li>
<li>图示：红框是单态登录加入的模块</li>
</ul>
<p><img src="http://i.imgur.com/4vvjT4z.png" alt=""></p>
<pre>
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.setCharacterEncoding("utf-8");
    response.setCharacterEncoding("utf-8");
    response.setContentType("text/html;charset=utf-8");
    PrintWriter out = response.getWriter();

    String action = request.getParameter("action");
    if("login".equalsIgnoreCase(action)){
        String name = request.getParameter("name");
        String password = request.getParameter("password");
        User user = new User();
        user.setName(name);
        user.setPassword(password);
        if("qm".equals(name) && "123".equals(password)){
            <font color="red">//判断帐号是否在别的机器登录
            HttpSession oldSession = map.get(name);
            if(oldSession != null){//1、别的机器登录 2、重复登录
                oldSession.removeAttribute("user");
                <font color="blue">//oldSession.invalidate();不要删除session除了用户信息的其他属性，下次用户在本机登录还能获得先前的数据</font>
                map.remove(name);
            }</font>

            HttpSession session = request.getSession();
            session.setAttribute("user",user);
            map.put(name,session);
            out.println("登录成功");
        }else{
            out.println("登录失败");
        }
    }else if("logout".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //session.invalidate();
        session.removeAttribute("user");
        map.remove(user.getName());
        out.println("注销成功");
    }else if("main".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //往session添加其他属性
        Integer count = (Integer) session.getAttribute("count");
        if(count == null){
            count = 0;
            session.setAttribute("count", count);
        }
        count ++;
        session.setAttribute("count",count);

        //在线用户
        out.println(session.getAttribute("count"));
    }
}
</pre>

<h4 id="显示在线用户"><a href="#显示在线用户" class="headerlink" title="显示在线用户"></a>显示在线用户</h4><p>存放服务器信息、用户信息的类：</p>
<pre><code>public class ApplicationConstants {

    // 所有的 Session，session_id与session组成键值对
    public static Map&lt;String, HttpSession&gt; SESSION_MAP = new HashMap&lt;String, HttpSession&gt;();

    // 当前登录的用户总数
    public static int CURRENT_LOGIN_COUNT = 0;

    // 历史访客总数
    public static int TOTAL_HISTORY_COUNT = 0;

    // 服务器启动时间
    public static Date START_DATE = new Date();

    // 最高在线时间
    public static Date MAX_ONLINE_COUNT_DATE = new Date();

    // 最高在线人数
    public static int MAX_ONLINE_COUNT = 0;
}
</code></pre><p>使用ServletContextListener来监听服务器的启动与关闭，记录服务器启动时间等</p>
<pre><code>public class MyContextListener implements ServletContextListener {

    public void contextInitialized(ServletContextEvent event) {
        // 启动时，记录服务器启动时间
        ApplicationConstants.START_DATE = new Date();
    }

    public void contextDestroyed(ServletContextEvent event) {
        // 关闭时，将结果清除。也可以将结果保存到硬盘上，下次启动时再加载到ApplicationConstants中
        ApplicationConstants.START_DATE = null;
        ApplicationConstants.MAX_ONLINE_COUNT_DATE = null;
    }
}
</code></pre><p>对Session的监听，维护在线用户列表、总访问人数：</p>
<ul>
<li>使用Map来索引所有的Session，Session创建的时候放到Map中，Session销毁时从Map中剔除</li>
<li>什么时候用户数改变？成功验证用户信息后往session中存入用户信息、用户注销、用户被强退，attributeAdded和attributeReplaced的区别就是用户人数是否需要增加</li>
</ul>
<pre>
public class MySessionListener implements HttpSessionListener,
        HttpSessionAttributeListener {

    public void sessionCreated(HttpSessionEvent sessionEvent) {

        HttpSession session = sessionEvent.getSession();

        <font color="red">// 将 session 放入 map
        ApplicationConstants.SESSION_MAP.put(session.getId(), session);</font>
        // 总访问人数++
        ApplicationConstants.TOTAL_HISTORY_COUNT++;

        // 如果当前在线人数超过历史记录，则更新最大在线人数，并记录时间
        if (ApplicationConstants.SESSION_MAP.size() > ApplicationConstants.MAX_ONLINE_COUNT) {
            ApplicationConstants.MAX_ONLINE_COUNT = ApplicationConstants.SESSION_MAP
                    .size();
            ApplicationConstants.MAX_ONLINE_COUNT_DATE = new Date();
        }
    }

    public void sessionDestroyed(HttpSessionEvent sessionEvent) {
        HttpSession session = sessionEvent.getSession();
        // 将session从map中移除
        ApplicationConstants.SESSION_MAP.remove(session.getId());
    }

    public void attributeAdded(HttpSessionBindingEvent event) {

        if (event.getName().equals("personInfo")) {

            // 当前登录用户数++
            ApplicationConstants.CURRENT_LOGIN_COUNT++;
            HttpSession session = event.getSession();

            // 查找该帐号有没有在其他机器上登录
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {

                // 如果该帐号已经在其他机器上登录，则以前的登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        // 注销 当前登录用户数--
        if (event.getName().equals("personInfo")) {
            ApplicationConstants.CURRENT_LOGIN_COUNT--;
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        // 重新登录，但人数不用增加
        if (event.getName().equals("personInfo")) {
            HttpSession session = event.getSession();
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {
                // 如果新帐号在其他机器上登录过，则以前登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

}
</pre>

<p>监听request主要是记录客户的IP地址、访问次数等，也可以记录用户访问的URI：</p>
<pre>
public class MyRequestListener implements ServletRequestListener {

    public void requestDestroyed(ServletRequestEvent event) {
    }

    public void requestInitialized(ServletRequestEvent event) {

        HttpServletRequest request = (HttpServletRequest) event
                .getServletRequest();

        <font color="red">/*
        * 如果session为空，则重新创建一个session，主要是之前session.invalidate()会销毁session        
        */</font>
        HttpSession session = request.getSession(true);

        // 记录IP地址
        session.setAttribute("ip", request.getRemoteAddr());

        // 记录访问次数，只记录访问 .html, .do, .jsp, .action 的累计次数
        String uri = request.getRequestURI();
        String[] suffix = { ".html", ".do", ".jsp", ".action" };
        for (int i=0; i&lt;suffix.length; i++) {
            if (uri.endsWith(suffix[i])) {
                break;
            }
            if(i == suffix.length-1)
                return;
        }

        Integer activeTimes = (Integer) session.getAttribute("activeTimes");

        if (activeTimes == null) {
            activeTimes = 0;
        }

        session.setAttribute("activeTimes", activeTimes + 1);
    }
}
</pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/[Tomcat]Tomcat笔记/" itemprop="url">
                  Tomcat笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T10:14:00+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tomcat的目录结构文件"><a href="#Tomcat的目录结构文件" class="headerlink" title="Tomcat的目录结构文件"></a>Tomcat的目录结构文件</h2><p><img src="http://i.imgur.com/Dp2gPgS.png" alt=""></p>
<pre><code>bin: 启动和关闭tomcat的bat文件
conf: 配置文件 
    --&gt;server.xml : 该文件用于配置和 server 相关的信息, 比如 tomcat启动端口后,配置Host,  配置Context 即web应用 
    --&gt;web.xml : 该文件配置与 web应用(web应用就相当于是一个 web站点)
    --&gt;tomcat-users.xml: 该文件用户配置tomcat 的用户密码 和 权限
lib目录: 该目录放置运行tomcat 运行需要的jar包
logs目录：存放日志, 当我们需要去查看日志的时候，很有用!,当我们启动tomcat错误时候，可以查询信息.
webapps目录: 该目录下，放置我们的web应用(web 站点)
work: 工作目录: 该目录用于存放jsp被访问后 生成的对应的 server文件 和.class文件
</code></pre><h2 id="首页面设置及目录规范结构"><a href="#首页面设置及目录规范结构" class="headerlink" title="首页面设置及目录规范结构"></a>首页面设置及目录规范结构</h2><p><img src="http://i.imgur.com/UJt4wAM.png" alt=""></p>
<p><em>配置访问首目录</em></p>
<pre><code>①在web文件夹下配置WEB-INF文件夹
②在 web.xml 文件中添加配置的代码:
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;hello1.html&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
③通过http://localhost:8088/web1来访问hello1.html
</code></pre><p><em>目录结构</em></p>
<pre><code>web-inf目录下的 classes目录将来是存放 class文件
lib 目录将来时存放 jar文件
web.xml 配置当前这个web应用的信息.
</code></pre><h2 id="Tomcat体系"><a href="#Tomcat体系" class="headerlink" title="Tomcat体系"></a>Tomcat体系</h2><p><img src="http://i.imgur.com/7cYZp67.png" alt=""></p>
<p><strong><em>理解服务、引擎、host（主机）、Web应用[Context]概念</em></strong></p>
<ul>
<li>查看Tomcat中的server.xml文件，最外面节点为Server，Service下一个节点服务<code>&lt;Service name = &quot;Catalina&quot;&gt;</code>，所以我们有时把Tomcat服务叫做Catalina服务。</li>
<li>服务下有引擎（engine）<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>，它可以管理多个主机host。</li>
<li>主机下有多个Web应用[Context]</li>
<li>与引擎并列的有连接器（connector），有支持不同类型协议（http、https等）的连接器。不同协议使用不同的连接器    </li>
</ul>
<h2 id="配置默认主机"><a href="#配置默认主机" class="headerlink" title="配置默认主机"></a>配置默认主机</h2><p>　　当我们在浏览器中输入<a href="http://127.0.0.1:8080/web应用，引擎是如何知道用户要访问那个`主机`下的web应用？答：配置一个默认主机" target="_blank" rel="external">http://127.0.0.1:8080/web应用，引擎是如何知道用户要访问那个`主机`下的web应用？答：配置一个默认主机</a></p>
<pre><code>在tomcat/conf/server.xml 文件
&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;主机名&quot;&gt;

默认是localhost，即在webapps目录下，查找web应用
&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;
            xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;
</code></pre><h2 id="配置域名-host"><a href="#配置域名-host" class="headerlink" title="配置域名[host]"></a>配置域名[host]</h2><p><em>步骤：</em></p>
<pre><code>(1) 在C:\WINDOWS\system32\drivers\etc 下的host文件 添加127.0.0.1 www.sina.com.cn[浏览器向Tomcat发送请求，但Tomcat认为自己不是www.sina.com，可以拒绝，所以需添加主机名]
(2) 在tomcat 的server.xml文件添加主机名 
&lt;Host name=&quot;www.sina.com&quot; appBase=&quot;d:\web3”&gt;
    &lt;Context path=&quot;/&quot; docBase=&quot;d:\web3&quot; /&gt;
&lt;/Host&gt;
(3) 在d:\web3 加入了一个 /WEB-INF/web.xml 把 hello2.html设为首页面
如果连端口都不希望带，则可以吧tomcat的启动端口设为80即可.
(4) 重启生效
</code></pre><h2 id="CATALINA-BASE与CATALINA-HOME的区别"><a href="#CATALINA-BASE与CATALINA-HOME的区别" class="headerlink" title="CATALINA_BASE与CATALINA_HOME的区别"></a>CATALINA_BASE与CATALINA_HOME的区别</h2><ul>
<li>CATALINA_HOME是Tomcat的<strong><em>安装目录</em></strong>，CATALINA_BASE是Tomcat的<strong><em>工作目录</em></strong></li>
<li>如果我们想要运行Tomcat的多个实例，但是不想安装多个Tomcat软件副本。那么我们可以配置多个工作目录，每个运行实例独占一个工作目录，但是共享同一个安装目录</li>
<li>Tomcat每个运行实例需要使用自己的conf、logs、temp、webapps、work和shared目录，因此CATALINA_BASE就指向这些目录。 而其他目录主要包括了Tomcat的二进制文件和脚本，CATALINA_HOME就指向这些目录</li>
</ul>
<h2 id="Tomcat管理虚拟目录-context"><a href="#Tomcat管理虚拟目录-context" class="headerlink" title="Tomcat管理虚拟目录[context]"></a>Tomcat管理虚拟目录[context]</h2><p><em>需求</em></p>
<p>当我们把 web 应用放到 webapps目录，tomcat会自动管理，如果我们希望tomcat可以管理其它目录下的web应用?　　-&gt; 虚拟目录配置</p>
<p>假设我在d盘有一个web应用文件夹web2</p>
<p><em>步骤</em></p>
<pre><code>1、找到server.xml文件
2、编辑host节点，在Host节点中添加Context
    在server.xml中添加：&lt;Context path=&quot;/myweb2&quot; docBase=&quot;d:\web2&quot;/&gt;
    myweb2：是访问时输入的web名,实际取出的是web2中的资源（★★★★url与文件夹有映射关系）
    &quot;d:\web2&quot;：web应用文件夹在计算机中绝对路径
实际访问时输入的地址：http://localhost:8088/myweb2/hello2.html
</code></pre><h2 id="定义上下文"><a href="#定义上下文" class="headerlink" title="定义上下文"></a>定义上下文</h2><h3 id="显式定义"><a href="#显式定义" class="headerlink" title="显式定义"></a>显式定义</h3><p>1、在Tomcat的conf/Catalina/localhost目录下创建一个XML文件。例如把一个commerce.xml文件放在conf/Catalina/localhost目录下，那么应用程序的上下文路径就是commerce，下面给出一个范例：</p>
<pre><code>&lt;Context docBase=&quot;C://apps/commerce&quot; reloadable=&quot;true&quot;/&gt;
</code></pre><p>docBase是必要的属性，用来定义应用程序的位置；reloadable属性是可选的，如果值为true，一旦应用程序中Java类文件或者其他资源有增加、减少或者更新，Tomcat都会侦测到，就会重新加载应用程序</p>
<p>2、在Tomcat的conf/server.xml文件中添加一个Context元素[同Tomcat管理虚拟目录]</p>
<pre><code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;
            xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;

    &lt;Context path = &quot;/commerce&quot; docBase=&quot;C:/apps/commerce&quot; reloadable=&quot;true&quot; /&gt; 

&lt;/Host&gt;
</code></pre><h3 id="隐式定义"><a href="#隐式定义" class="headerlink" title="隐式定义"></a>隐式定义</h3><p>通过将一个war文件或者整个应用程序复制到Tomcat的webapps目录下，就可以隐式地部署应用程序</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
