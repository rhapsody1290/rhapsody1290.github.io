<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> Mr.Qian's Home </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Qian's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            日程
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/30/[Java]list转string[]/" itemprop="url">
                  list转string[]
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-30T00:00:00+08:00" content="2016-09-30">
              2016-09-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法一：单个元素转换"><a href="#方法一：单个元素转换" class="headerlink" title="方法一：单个元素转换"></a>方法一：单个元素转换</h2><pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);
//转化成Object数组
Object[] objs = array.toArray();
//新建数组
String[] strings = new String[array.size()];
//每个元素类型转换
int i = 0;
for(Object obj : objs){
    if(obj instanceof String){
        strings[i++] = (String)obj;
    }
}
for(String s : strings){
    System.out.println(s);
}
</code></pre><h2 id="方法二：整个转"><a href="#方法二：整个转" class="headerlink" title="方法二：整个转"></a>方法二：整个转</h2><pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);

String[] strings = new String[array.size()];
array.toArray(strings);
for(String s : strings){
    System.out.println(s);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/07/[Spring MVC]Jave Web模型2和MVC模式/" itemprop="url">
                  Jave Web模型2和MVC模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-07T23:00:00+08:00" content="2016-09-07">
              2016-09-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模型1和模型2介绍"><a href="#模型1和模型2介绍" class="headerlink" title="模型1和模型2介绍"></a>模型1和模型2介绍</h2><ul>
<li>Java Web应用开发中有两种设计模型，为了方便，分别称为模型1和模型2</li>
<li>模型1是通过链接方式进行JSP页面之间的跳转<ul>
<li>方式<strong><em>直接</em></strong>，适合小型应用开发</li>
<li>但在中型和大型应用中，这种方式会带来<strong><em>维护</em></strong>上的问题</li>
</ul>
</li>
<li>模型2是基于MVC模式，是Java Web应用的推荐架构<ul>
<li>一个MVC模式的应用包括<strong><em>模型</em></strong>、<strong><em>视图</em></strong> 和<strong><em>控制器</em></strong> 3个模块</li>
<li><font color="red"><strong><em>视图负责应用的展示，模型封装了应用的数据和业务逻辑，控制器负责接收用户输入，改变模型，以及调整视图的显示</em></strong></font></li>
<li><font color="blue"><strong><em>Servlet</em></strong></font> 或者<font color="blue"><strong><em>Filter</em></strong></font> 都可以充当控制器、Spring MVC和Struts1使用一个Servlet作为控制器，而Struts2 则使用一个Filter作为控制器</li>
<li>大部分采用<font color="blue"><strong><em>JSP</em></strong></font> 页面作为应用的视图，当然也有别的技术</li>
<li>模型会采用一个<font color="blue"><strong><em>JavaBean</em></strong></font> 来持有模型状态，并将业务逻辑放到一个Action类中。<font color="red"><strong><em>一个JavaBean必须拥有一个无参的构造器，通过get/set方法来访问参数，同时支持持久化</em></strong></font></li>
</ul>
</li>
</ul>
<h2 id="模型2应用-——-产品信息保存"><a href="#模型2应用-——-产品信息保存" class="headerlink" title="模型2应用 —— 产品信息保存"></a>模型2应用 —— 产品信息保存</h2><p><img src="http://i.imgur.com/EarIrIZ.png" alt=""></p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/SpringMVC_study" target="_blank" rel="external">https://github.com/rhapsody1290/SpringMVC_study</a><br>包名为cn.apeius.product</p>
<h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h3><p><img src="http://i.imgur.com/XHZXorE.png" alt=""></p>
<p>其中红框内的为<code>产品信息保存应用</code>相关文件</p>
<h3 id="ProductForm-jsp-——-填写产品信息表单"><a href="#ProductForm-jsp-——-填写产品信息表单" class="headerlink" title="ProductForm.jsp —— 填写产品信息表单"></a>ProductForm.jsp —— 填写产品信息表单</h3><ul>
<li>ProductForm.jsp文件放在WEB-INF下，<strong><em>不能通过URL直接访问</em></strong></li>
<li><font color="blue"><strong><em>一个控制器可以对应多个action(url)</em></strong></font></li>
<li><strong><em>通过url：product_input.action</em></strong>指向控制器ControllerServlet，由控制器根据相应的action跳转到页面ProductForm.jsp</li>
</ul>
<p><strong><em>页面展示</em></strong></p>
<p><img src="http://i.imgur.com/he0IokR.png" alt=""></p>
<p><strong><em>JSP代码</em></strong></p>
<pre>
&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
&lt;title>Add Product Form&lt;/title>
&lt;style type="text/css">@import url(css/main.css);&lt;/style>
&lt;/head>
&lt;body>

&lt;div id="global">
&lt;form <font color="red">action="product_save.action"</font> method="post">
    &lt;fieldset>
        &lt;legend>Add a product&lt;/legend>
            <font color="red">&lt;p>
                &lt;label for="name">Product Name: &lt;/label>
                &lt;input type="text" id="name" name="name" 
                    tabindex="1">
            &lt;/p></font>
            &lt;p>
                &lt;label for="description">Description: &lt;/label>
                &lt;input type="text" id="description" 
                    name="description" tabindex="2">
            &lt;/p>
            &lt;p>
                &lt;label for="price">Price: &lt;/label>
                &lt;input type="text" id="price" name="price" 
                    tabindex="3">
            &lt;/p>
            <font color="red">&lt;p id="buttons">
                &lt;input id="reset" type="reset" tabindex="4">
                &lt;input id="submit" type="submit" tabindex="5" 
                    value="Add Product">
            &lt;/p></font>
    &lt;/fieldset>
&lt;/form>
&lt;/div>
&lt;/body>
&lt;/html>
</pre>

<ul>
<li>表单的action为product_save.action，这个url会匹配到控制器ControllerServlet，调用相应的service方法完成产品保存工作，并完成页面的跳转，显示产品的详细信息</li>
<li>fieldset可将表单内的元素进行分组</li>
<li>推荐使用标签 &lt;label for = ‘指向的标签name’&gt;标签内容&lt;/label&gt;，点击标签焦点就定位在指向的标签</li>
<li>@import url(css/main.css)：css在web根目录下</li>
</ul>
<h3 id="main-css-——-样式文件"><a href="#main-css-——-样式文件" class="headerlink" title="main.css —— 样式文件"></a>main.css —— 样式文件</h3><pre><code>#global {
    text-align: left;
    border: 1px solid #dedede;
    background: #efefef;
    width: 560px;
    padding: 20px;
    margin: 100px auto;
}

form {
  font:100% verdana;
  min-width: 500px;
  max-width: 600px;
  width: 560px;
}

form fieldset {
  border-color: #bdbebf;
  border-width: 3px;
  margin: 0;
}

legend {
    font-size: 1.3em;
}

form label {
    width: 250px;
    display: block;
    float: left;
    text-align: right;
    padding: 2px;
}

#buttons {
    text-align: right;
}
</code></pre><ul>
<li><strong><em>灰色背景为一块 DIV，设置宽度560px，marigin：100px auto使 DIV 居中显示，页面下移100px</em></strong>；高度不用设置，内部标签自动会撑开；另，设置padding为20px，DIV向外扩展，此时灰色面积尺寸为602（加上边框）</li>
<li><strong><em>字体verdana</em></strong>在小字上仍有结构清晰端整、阅读辨识容易等高品质的表现</li>
<li><p><font color="red"><strong><em>怎样使得冒号对齐？</em></strong></font><font color="blue">关键点是使设置标签长度一致，并使标签内容右对齐</font>；默认label是inline，长度设置无效，可采用如下两种办法：</p>
<pre><code>方法一：使用inline-block来设置长度
form label {
  width: 250px;
  display: inline-block;
  text-align: right;

}
方法二：使用block来设置长度
form label {
    width: 250px;
    display: block;
    float: left; /*使用block后label占用一行，使用float让输入框移上来*/
    text-align: right;
    padding: 2px; /*不是关键*/
}
</code></pre></li>
</ul>
<ul>
<li><strong><em>心得：</em></strong>DIV+CSS设计，外层DIV固定尺寸，内部元素相对外层进行设计，这个DIV为一个整体</li>
</ul>
<h3 id="Product类和ProductForm类"><a href="#Product类和ProductForm类" class="headerlink" title="Product类和ProductForm类"></a>Product类和ProductForm类</h3><p><strong><em>Product.java —— 产品信息JavaBean</em></strong></p>
<ul>
<li>Java规范中说要写入文件或是通过网络传输的对象必须是可序列化的，所以弄个标志接口Serializable 来标识一个类可以被序列化</li>
<li>Product类实现了java.io.Serializationi接口，其实例可以安全地将数据保存到HttpSession中</li>
</ul>
<pre>
package cn.apeius.product.domain;
import java.io.Serializable;

public class Product <font color="red">implements Serializable</font> {
    private static final long serialVersionUID = 748392348L;
    private String name;
    private String description;
    <font color="red">private float price;</font>

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public float getPrice() {
        return price;
    }
    public void setPrice(float price) {
        this.price = price;
    }
}
</pre>

<p><strong><em>ProductForm.java</em></strong></p>
<ul>
<li>表单类与HTML表单相映射，是后者在服务器端的代表</li>
<li><strong><em>Product和ProductForm类似，是否有必要存在？</em></strong>表单对象会传递ServletRequest给其他组件，类似Validator，而ServletRequest是一个Servlet层的对象，<font color="blue"><strong><em>不应当暴露给应用的其它层</em></strong></font></li>
<li>表单类不需要实现Serialization接口，因为表单对象很少存在HttpSession中</li>
</ul>
<pre>
package cn.apeius.product.form;

public class ProductForm {
    private String name;
    private String description;
    <font color="red">private String price;</font>

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public String getPrice() {
        return price;
    }
    public void setPrice(String price) {
        this.price = price;
    }
}
</pre>

<h3 id="ControllerServlet类★★★★★"><a href="#ControllerServlet类★★★★★" class="headerlink" title="ControllerServlet类★★★★★"></a>ControllerServlet类★★★★★</h3><p>控制器的操作：</p>
<pre><code>1、对URI处理获得action名
2、根据action，创建表单对象，数据校验，创建领域对象，并执行领域对象的业务逻辑，例如将其持久化到数据库
3、根据处理结果，跳转页面
</code></pre><font color="blue">url思考：</font>

<ul>
<li>product_input.action、product_save.acton对应一个Servlet</li>
<li>url的形式可以采用模块+操作的形式，举个例子：<ul>
<li>用户模块有login和logout操作，一个模块一个控制器</li>
<li>可以采用/user/login.action，/user/logout.action对应匹配规则为/user/*的Servlet</li>
</ul>
</li>
</ul>
<p><strong><em>代码</em></strong></p>
<pre>
package cn.apeius.product.servlet;
import cn.apeius.product.domain.Product;
import cn.apeius.product.form.ProductForm;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ControllerServlet extends HttpServlet {

    private static final long serialVersionUID = 1579L;

    @Override
    public void doGet(HttpServletRequest request, 
            HttpServletResponse response)
            throws IOException, ServletException {
        process(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, 
            HttpServletResponse response)
            throws IOException, ServletException {
        process(request, response);
    }

    private void process(HttpServletRequest request,
            HttpServletResponse response) 
            throws IOException, ServletException {
        /*
        1、URI的形式为：/应用名/资源名，例如/app10a/product_input
        2、一个Servlet可以对应多个action，本应用中访问/product_input.action和/product_save.action会进入ControllerServlet
        3、这个Servlet命名为ControllerServlet，是遵循了一个约定：所有Servlet类的名称都带有Servlet后缀
        */
        <font color="red">//1、对URI处理获得action名</font>
        String uri = request.getRequestURI();
        int lastIndex = uri.lastIndexOf("/");
        String action = uri.substring(lastIndex + 1); 
        <font color="red">//2、根据action，创建表单对象，数据校验，创建领域对象，并并执行领域对象的业务逻辑，例如将其持久化到数据库</font>
        if (action.equals("product_input.action")) {
            //不需要调用service类执行业务逻辑
        } else if (action.equals("product_save.action")) {
            //创建表单对象
            ProductForm productForm = new ProductForm();
            //填充对象属性
            productForm.setName(request.getParameter("name"));
            productForm.setDescription(
                    request.getParameter("description"));
            productForm.setPrice(request.getParameter("price"));

            //创建模型
            Product product = new Product();
            product.setName(productForm.getName());
            product.setDescription(productForm.getDescription());
            try {
                product.setPrice(Float.parseFloat(
                        productForm.getPrice()));
            } catch (NumberFormatException e) {
            }

            //调用service层的方法，保存产品，此处略

            //将产品模型保存在session，以便后续页面使用
            request.setAttribute("product", product);
        }

        <font color="red">//3、根据处理结果，跳转页面</font>
        String dispatchUrl = null;
        if (action.equals("product_input.action")) {
            dispatchUrl = "/WEB-INF/jsp/ProductForm.jsp";
        } else if (action.equals("product_save.action")) {
            dispatchUrl = "/WEB-INF/jsp/ProductDetails.jsp";
        }
        if (dispatchUrl != null) {
            RequestDispatcher rd = 
                    request.getRequestDispatcher(dispatchUrl);
            rd.forward(request, response);
        }
    }
}

</pre>

<h3 id="ProductDetails-jsp-——-显示产品详细信息"><a href="#ProductDetails-jsp-——-显示产品详细信息" class="headerlink" title="ProductDetails.jsp —— 显示产品详细信息"></a>ProductDetails.jsp —— 显示产品详细信息</h3><ul>
<li>ProductDetails.jsp 页面通过<strong><em>表达式语言（EL）</em></strong> 访问 <strong><em>HttpServletRequest</em></strong> 所包含的对象</li>
</ul>
<p><strong><em>代码</em></strong></p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Save Product&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;@import url(css/main.css);&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;global&quot;&gt;
    &lt;h4&gt;The product has been saved.&lt;/h4&gt;
    &lt;p&gt;
        &lt;h5&gt;Details:&lt;/h5&gt;
        Product Name: ${product.name}&lt;br/&gt;
        Description: ${product.description}&lt;br/&gt;
        Price: $${product.price}
    &lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>可以通过url：</p>
<pre><code>http://localhost:8080/SpringMVC_study/product_input.action
</code></pre><p>访问应用<br>注意，可以将servlet控制器作为默认主页，使得在浏览器地址中仅输入域名+应用名，就可以访问到该Servlet控制器</p>
<pre><code>&lt;jsp:forward page=&quot;/product_input.action&quot;/&gt;
</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong><em>业务逻辑代码</em></strong> 都写在了Servlet控制器中，随着应用复杂度增加而不断膨胀</li>
<li><font color="red"><strong><em>哪些是业务逻辑？</em></strong></font>图中红框所示，根据不同的action，创建表单对象，数据校验，创建领域对象，并执行领域对象的业务逻辑；如果action多了，controller将会变得非常臃肿<br><img src="http://i.imgur.com/VdCCYHr.png" alt=""></li>
</ul>
<h2 id="解耦控制器代码"><a href="#解耦控制器代码" class="headerlink" title="解耦控制器代码"></a>解耦控制器代码</h2><h3 id="github-1"><a href="#github-1" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/SpringMVC_study" target="_blank" rel="external">https://github.com/rhapsody1290/SpringMVC_study</a><br>包名为cn.apeius.product2</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>将原来ControllerServlet中的<strong><em>业务逻辑提取出来</em></strong></li>
<li>此时的Servlet变得更加专注，作用更像是一个<strong><em>dispatcher</em></strong>，<strong><em>即检查每个url，根据访问的action，调用具体的controller完成业务逻辑，并完成页面跳转</em></strong>，而非一个controller，因此改名为DispatcherServlet</li>
</ul>
<h3 id="工程目录-1"><a href="#工程目录-1" class="headerlink" title="工程目录"></a>工程目录</h3><p><img src="http://i.imgur.com/O4gRIs9.png" alt=""></p>
<h3 id="DispatcherServlet类"><a href="#DispatcherServlet类" class="headerlink" title="DispatcherServlet类"></a>DispatcherServlet类</h3><font color="red"><strong><em>一个DispatcherServlet必须能够做如下事情：</em></strong></font>

<ul>
<li>根据URI调用相应的action</li>
<li>实例化正确的控制器类</li>
<li>调用控制器对象的响应方法</li>
<li>转到一个视图（JSP页面）</li>
</ul>
<pre>
public class DispatcherServlet extends HttpServlet {

    private static final long serialVersionUID = 748495L;

    @Override
    public void doGet(HttpServletRequest request, 
            HttpServletResponse response)
            throws IOException, ServletException {
        process(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, 
            HttpServletResponse response)
            throws IOException, ServletException {
        process(request, response);
    }

    private void process(HttpServletRequest request,
            HttpServletResponse response) 
            throws IOException, ServletException {

        //1、对URI处理获得action名
        String uri = request.getRequestURI();
        int lastIndex = uri.lastIndexOf("/");
        String action = uri.substring(lastIndex + 1);

        //2、根据action，调用具体的controller处理，DispatcherServlet只起到分派功能
        String dispatchUrl = null;
        if (action.equals("product_input.action")) {
            <font color="red">InputProductController controller = new InputProductController();
            dispatchUrl = controller.handleRequest(request, response);</font>
        } else if (action.equals("product_save.action")) {
            SaveProductController controller = new SaveProductController();
            dispatchUrl = controller.handleRequest(request, response);
        }

        //3、根据处理结果，跳转页面
        if (dispatchUrl != null) {
            RequestDispatcher rd = 
                    request.getRequestDispatcher(dispatchUrl);
            rd.forward(request, response);
        }
    }
}
</pre>

<h3 id="Controller接口"><a href="#Controller接口" class="headerlink" title="Controller接口"></a>Controller接口</h3><ul>
<li>面向接口编程的方式，在DispatcherServlet中使用Controller来引用具体实现类，并调用其handleRequest方法完成具体业务逻辑操作</li>
</ul>
<pre>
public interface Controller {
    String handleRequest(HttpServletRequest request,
                         HttpServletResponse response);
}
</pre>

<h3 id="InputProductController类和SaveProductController类"><a href="#InputProductController类和SaveProductController类" class="headerlink" title="InputProductController类和SaveProductController类"></a>InputProductController类和SaveProductController类</h3><ul>
<li>两个Controller都实现了Controller接口，Controller接口只有handleRequest方法</li>
<li>Controller接口的实现类需要通过该方法访问到请求的HttpServletRequest和HttpServletResponse</li>
<li>handleRequest返回结果为跳转文件路径</li>
</ul>
<h4 id="InputProductController类"><a href="#InputProductController类" class="headerlink" title="InputProductController类"></a>InputProductController类</h4><ul>
<li>直接返回输入产品的表单页面</li>
</ul>
<pre><code>public class InputProductController implements Controller {

    public String handleRequest(HttpServletRequest request, 
            HttpServletResponse response) {
        return &quot;/WEB-INF/jsp/ProductForm.jsp&quot;;
    }
}
</code></pre><h4 id="SaveProductController类"><a href="#SaveProductController类" class="headerlink" title="SaveProductController类"></a>SaveProductController类</h4><ul>
<li>创建表单对象</li>
<li>创建模型</li>
<li>保存产品信息到数据库</li>
<li>返回跳转页面</li>
</ul>
<pre><code>public class SaveProductController implements Controller {

    public String handleRequest(HttpServletRequest request, 
            HttpServletResponse response) {
        ProductForm productForm = new ProductForm();
        //填充表单数据
        productForm.setName(
                request.getParameter(&quot;name&quot;));
        productForm.setDescription(
                request.getParameter(&quot;description&quot;));
        productForm.setPrice(request.getParameter(&quot;price&quot;));

        //创建模型
        Product product = new Product();
        product.setName(productForm.getName());
        product.setDescription(productForm.getDescription());
        try {
            product.setPrice(Float.parseFloat(
                    productForm.getPrice()));
        } catch (NumberFormatException e) {
        }

        //将产品信息加入数据的代码，此处省略

        request.setAttribute(&quot;product&quot;, product);
        return &quot;/WEB-INF/jsp/ProductDetails.jsp&quot;;
    }

}
</code></pre><h2 id="校验器"><a href="#校验器" class="headerlink" title="校验器"></a>校验器</h2><ul>
<li>Web应用执行action时，很重要的步骤是进行输入校验</li>
<li>因为校验工作很重要，Java社区专门发布了标准对Java世界的输入检验进行标准化</li>
</ul>
<h3 id="github-2"><a href="#github-2" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/SpringMVC_study" target="_blank" rel="external">https://github.com/rhapsody1290/SpringMVC_study</a><br>包名为cn.apeius.product2</p>
<h3 id="工程目录-2"><a href="#工程目录-2" class="headerlink" title="工程目录"></a>工程目录</h3><ul>
<li>红色部分有修改，增加了ProductValidator类</li>
<li>ProductForm.jsp展示输入校验的错误信息</li>
</ul>
<p><img src="http://i.imgur.com/zVKODsg.png" alt=""></p>
<h3 id="ProductValidator"><a href="#ProductValidator" class="headerlink" title="ProductValidator"></a>ProductValidator</h3><ul>
<li>ProductValidator类中有一个validate方法，保证产品的字符串非空，价格是一个合理的数字</li>
<li>validate返回一个包含错误信息的字符串列表，若返回一个空列表，则表示输入合法</li>
<li>在SaveProductController类中使用ProductValidator类</li>
</ul>
<pre><code>public class ProductValidator {

    public List&lt;String&gt; validate(ProductForm productForm) {
        List&lt;String&gt; errors = new ArrayList&lt;String&gt;();
        String name = productForm.getName();
        if (name == null || name.trim().isEmpty()) {
            errors.add(&quot;Product must have a name&quot;);
        }
        String price = productForm.getPrice();
        if (price == null || price.trim().isEmpty()) {
            errors.add(&quot;Product must have a price&quot;);
        } else {
            try {
                Float.parseFloat(price);
            } catch (NumberFormatException e) {
                errors.add(&quot;Invalid price value&quot;);
            }
        }
        return errors;
    }
}
</code></pre><h3 id="新版的SaveProductController"><a href="#新版的SaveProductController" class="headerlink" title="新版的SaveProductController"></a>新版的SaveProductController</h3><ul>
<li>首先对变淡类进行校验，如果校验发现有错误，则页面跳转到ProductForm.jsp；若没有错误，则创建一个Product对象</li>
</ul>
<pre>
public class SaveProductController implements Controller {

    public String handleRequest(HttpServletRequest request,
            HttpServletResponse response) {
        ProductForm productForm = new ProductForm();
        //填充表单属性
        productForm.setName(request.getParameter("name"));
        productForm.setDescription(request.getParameter("description"));
        productForm.setPrice(request.getParameter("price"));

        //校验表单
        ProductValidator productValidator = new ProductValidator();
        List<string> errors = productValidator.validate(productForm);
        if (errors.isEmpty()) {
            //创建领域对象Product
            Product product = new Product();
            product.setName(productForm.getName());
            product.setDescription(productForm.getDescription());
            product.setPrice(Float.parseFloat(productForm.getPrice()));

            //没有校验错误，执行action方法
            //保存产品信息到数据库的代码

            //将product存入request域中，便于后面页面显示
            request.setAttribute("product", product);
            return "/WEB-INF/jsp/ProductDetails.jsp";
        } else {
            //保存错误信息，在后续页面显示
            request.setAttribute("errors", errors);
            //保留表单信息，在后续页面显示
            request.setAttribute("form", productForm);
            return "/WEB-INF/jsp/ProductForm.jsp";
        }
    }

}
</string></pre>

<h3 id="新的ProductForm-jsp"><a href="#新的ProductForm-jsp" class="headerlink" title="新的ProductForm.jsp"></a>新的ProductForm.jsp</h3><ul>
<li>用户提交了非法数据，页面将显示相应地错误信息</li>
</ul>
<pre>
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
    &lt;title>Add Product Form&lt;/title>
    &lt;style type="text/css">@import url(css/main.css);&lt;/style>
&lt;/head>
&lt;body>

&lt;div id="global">
    <font color="red">&lt;c:if test="${requestScope.errors != null}">
        &lt;p id="errors">
            Error(s)!
        &lt;ul>
            &lt;c:forEach var="error" items="${requestScope.errors}">
                &lt;li>${error}&lt;/li>
            &lt;/c:forEach>
        &lt;/ul>
        &lt;/p>
    &lt;/c:if></font>
    &lt;form action="product_save.action" method="post">
        &lt;fieldset>
            &lt;legend>Add a product&lt;/legend>
            &lt;p>
                &lt;label for="name">Product Name: &lt;/label>
                &lt;input type="text" id="name" name="name"
                       tabindex="1">
            &lt;/p>
            &lt;p>
                &lt;label for="description">Description: &lt;/label>
                &lt;input type="text" id="description"
                       name="description" tabindex="2">
            &lt;/p>
            &lt;p>
                &lt;label for="price">Price: &lt;/label>
                &lt;input type="text" id="price" name="price"
                       tabindex="3">
            &lt;/p>
            &lt;p id="buttons">
                &lt;input id="reset" type="reset" tabindex="4">
                &lt;input id="submit" type="submit" tabindex="5"
                       value="Add Product">
            &lt;/p>
        &lt;/fieldset>
    &lt;/form>
&lt;/div>
&lt;/body>
&lt;/html>
</pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/06/[Java]自动装箱与拆箱/" itemprop="url">
                  自动装箱与拆箱（张孝祥补充）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-06T17:07:00+08:00" content="2016-09-06">
              2016-09-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Integer与int比较"><a href="#Integer与int比较" class="headerlink" title="Integer与int比较"></a>Integer与int比较</h2><ul>
<li>Integer.valueof() 返回的是Integer的对象</li>
<li>Integer.parseInt() 返回的是一个int的值</li>
<li>new Integer.valueof().intValue();返回的也是一个int的值</li>
</ul>
<h3 id="不同类型比较"><a href="#不同类型比较" class="headerlink" title="不同类型比较"></a>不同类型比较</h3><pre><code>public static void main(String[] args) {        
    String a = &quot;400&quot;;  
    String b = &quot;400&quot;;  
    //int和Integer比较，Integer自动拆箱，结果true
    System.out.println(Integer.parseInt(a) == Integer.valueOf(b));
}  
</code></pre><h3 id="相同类型比较"><a href="#相同类型比较" class="headerlink" title="相同类型比较"></a>相同类型比较</h3><p><strong><em>单字节（-128-127）的Integer</em></strong> 比较是直接作为基本类型比较，否则是对象比较</p>
<pre><code>Integer c = 100; 
Integer d = 100; 
Integer c1 = 200; 
Integer d1 = 200; 
System.out.println(c == d); //为true 
System.out.println(c1 == d1);//为false 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/06/[网络安全]IP地址与整数转换/" itemprop="url">
                  IP地址与整数转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-06T09:52:00+08:00" content="2016-09-06">
              2016-09-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java中byte-int的转换"><a href="#Java中byte-int的转换" class="headerlink" title="Java中byte, int的转换"></a>Java中byte, int的转换</h2><h3 id="int-gt-byte"><a href="#int-gt-byte" class="headerlink" title="int -&gt; byte"></a>int -&gt; byte</h3><ul>
<li>可以直接使用强制类型转换: byte b = (byte) aInt;</li>
<li>这个操作是直接截取int中最低一个字节，如果int大于255，则值就会变得面目全非了</li>
</ul>
<h3 id="byte-gt-int"><a href="#byte-gt-int" class="headerlink" title="byte -&gt; int"></a>byte -&gt; int</h3><ul>
<li>这里有两种情况，一种是要求<strong><em>保持值不变</em></strong>，例如进行<strong><em>数值计算</em></strong>，可采用强制类型转换：int i = (int) aByte; </li>
<li>另一种是要求<strong><em>保持最低字节中各个位不变</em></strong>，<strong><em>3个高字节全部用 0填充</em></strong>，例如<strong><em>进行编解码操作</em></strong> ，则需要采用位操作：int i = b &amp; 0xff; </li>
</ul>
<h3 id="理解★★★★★"><a href="#理解★★★★★" class="headerlink" title="理解★★★★★"></a>理解★★★★★</h3><ul>
<li><p>Java中使用System.out.println(int);因为println中形参为int类型，会将字符类型强行转化为整型</p>
<pre><code>byte b = (byte) 127;
System.out.println(b);
</code></pre></li>
<li><font color="red">字符类型转化为整型时有两种方式，一种是强转，高位用符号位填充；另一种是通过’与’的方式，高位用0填充</font></li>
<li>如果采用强转的方式，即int i = (int) aByte；Java默认byte是有符号的，int也是有符号的，强转后int的3个高字节全部用 <strong><em>符号位</em></strong> 填充，直接进行强转强转后数值不变，适合用于数值计算    </li>
<li><p>采用位操作int i = bByte &amp; 0xff 时，bByte和0xff<strong><em>先分别转换成整型，再进行 ‘与’ 操作</em></strong>，得到一个32位整数，此时高位用0填充，常用于编码中</p>
<pre><code>  11111111 11111111 11111111 11101010 (a=-22)
&amp;
  00000000 00000000 00000000 11111111 (0xff)
---------------------------------------------------------------------
= 00000000 00000000 00000000 11101010 (234)
</code></pre></li>
<li><font color="red">“字节变量 &amp; 0xff” 相当于将字节转换为无符号整型</font></li>
<li>Java中byte为<strong><em>有符号类型</em></strong>，占用一个字节，大小范围为-128~127，使用System.out.println(int)，首先会将byte强转为int类型，输出值保持不变；如果超过这个范围，会出现<font color="blue"><strong><em>溢出</em></strong></font>，正数变负数，负数变正数<ul>
<li>结果不变<pre><code>byte b = (byte) 127;//结果127，不变
因为127（0111 1111），首位为符号位，127为单字节正数最大，（-128）10000 0000为负数最小
</code></pre></li>
<li>正数变负数<pre><code>byte b = (byte) 128;//结果-128
1000 0000（128），在Java中byte为有符号数，一字节，首位为1，则这个数是负数，打印结果是-128
</code></pre></li>
<li>负数变正数<pre><code>byte b = (byte) -129;//结果127
-129（1 0111 1111），超出范围溢出，首先进行截断，结果为0111 1111，变为正数127
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="int-InputStream-read-读取字节流内部实现"><a href="#int-InputStream-read-读取字节流内部实现" class="headerlink" title="int InputStream.read() 读取字节流内部实现"></a>int InputStream.read() 读取字节流内部实现</h3><pre><code>该函数返回一个int类型，范围从0至255，如果到达流末尾，返回-1。通过ByteArrayInputStream的源码可以看到是如何从byte转到int
public synchronized int read() {
    return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;
}
</code></pre><h3 id="int-lt-gt-byte"><a href="#int-lt-gt-byte" class="headerlink" title="int &lt;-&gt; byte[]"></a>int &lt;-&gt; byte[]</h3><p>方法一：（推荐）</p>
<pre>
<font color="red">//将整数转为一个byte数组，字节数组的低位是整型的低字节位</font>
public static byte[] toByteArray(int iSource, int iArrayLen) {
    byte[] bLocalArr = new byte[iArrayLen];
    for (int i = 0; (i < 4) && (i < iArrayLen); i++) {
        bLocalArr[i] = (byte) ((iSource >> 8 * i) & 0xFF);
    }
    return bLocalArr;
}
</pre>

<ul>
<li>移位</li>
<li>转成整型，与操作，取低字节</li>
<li>截断，转成byte</li>
</ul>
<p>方法二：</p>
<pre><code>private static byte[] int2byte(int i) {
        byte[] bytes = new byte[4];
        bytes[0] = (byte) (0xff &amp; i);
        bytes[1] = (byte) ((0xff00 &amp; i) &gt;&gt; 8);
        bytes[2] = (byte) ((0xff0000 &amp; i) &gt;&gt; 16);
        bytes[3] = (byte) ((0xff000000 &amp; i) &gt;&gt; 24);
        return bytes;
    }
</code></pre><h3 id="byte-lt-gt-int"><a href="#byte-lt-gt-int" class="headerlink" title="byte[] &lt;-&gt; int"></a>byte[] &lt;-&gt; int</h3><p>方法一：（推荐）</p>
<pre>
<font color="red">// 将byte数组转为一个整数,字节数组的低位是整型的低字节位</font>
public static int toInt(byte[] bRefArr) {
    int iOutcome = 0;
    byte bLoop;

    for (int i = 0; i < bRefArr.length; i++) {
        bLoop = bRefArr[i];
        iOutcome += (bLoop & 0xFF) << (8 * i);//左移并加起来
    }
    return iOutcome;
}
</pre>

<ul>
<li>转成整型</li>
<li>移位</li>
<li>相加</li>
</ul>
<p>方法二：</p>
<pre><code>private static int byte2Int(byte[] bytes) {
        int n = bytes[0] &amp; 0xFF;
        n |= ((bytes[1] &lt;&lt; 8) &amp; 0xFF00);
        n |= ((bytes[2] &lt;&lt; 16) &amp; 0xFF0000);
        n |= ((bytes[3] &lt;&lt; 24) &amp; 0xFF000000);
        return n;
    }
</code></pre><h2 id="IpUtil（IP地址与整数转换工具）"><a href="#IpUtil（IP地址与整数转换工具）" class="headerlink" title="IpUtil（IP地址与整数转换工具）"></a>IpUtil（IP地址与整数转换工具）</h2><h3 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h3><p><img src="http://i.imgur.com/TWMLfKy.png" alt=""></p>
<h3 id="IP地址转换为整数"><a href="#IP地址转换为整数" class="headerlink" title="IP地址转换为整数"></a>IP地址转换为整数</h3><ul>
<li>Ip地址可以分成四段，每段可以是8位无符号整数即0~255</li>
<li>Ip地址转化为字节数组，数字出现的顺序不变，举个例子：<pre><code>192.168.1.1 -&gt; {192，168，1，1}
</code></pre></li>
<li><strong><em>字节数组的低位为整数的低位</em></strong>，把每段拆分成一个二进制形式，组合起来，然后把这个<strong><em>32位二进制数</em></strong> 变成一个<strong><em>32位无符号整数</em></strong><pre><code>1（0000 0001），1（0000 0001），168（1010 1000），192（1100 0000） -&gt;16885952(32位整数)
</code></pre></li>
</ul>
<h3 id="整数转换为IP地址"><a href="#整数转换为IP地址" class="headerlink" title="整数转换为IP地址"></a>整数转换为IP地址</h3><ul>
<li>把这个整数转换成一个无符号32位二进制数，举个例子：<pre><code>16885852（0000 0001，0000 0001，1010 1000，1100 0000）
</code></pre></li>
<li><strong><em>字节数组的低位为整数的低位</em></strong>，<pre><code>192（1100 0000），168（1010 10000），1（0000 0001），1（0000 0001）
</code></pre></li>
<li>从左到右，每八位进行一下分割，得到4段8位的二进制数，把这些二进制数转换成整数然后加上”.”就可以了<pre><code>切割，转成十进制：192.168.1.1
</code></pre></li>
</ul>
<h3 id="直接转换（不利用IpUtil，利于理解）★★★★★★"><a href="#直接转换（不利用IpUtil，利于理解）★★★★★★" class="headerlink" title="直接转换（不利用IpUtil，利于理解）★★★★★★"></a>直接转换（不利用IpUtil，利于理解）★★★★★★</h3><pre><code>String ip = &quot;192.168.1.1&quot;;
String[] ipSection = ip.split(&quot;\\.&quot;);
//ip-&gt;int
int result = 0;
for(int i = 0; i &lt; ipSection.length; i++){
    result += Integer.parseInt(ipSection[i]) &lt;&lt; 8*i;
}
System.out.println(result);//16885952
//int -&gt; ip
byte[] bytes = new byte[4];
for(int i = 0; i &lt; ipSection.length; i++){
    bytes[i] = (byte)((result &gt;&gt; 8*i) &amp; 0xff);
}
for(byte b : bytes){
    System.out.println(b &amp; 0xff);//192,168,1,1
}
</code></pre><h3 id="IpUtil（转换成字节数组）"><a href="#IpUtil（转换成字节数组）" class="headerlink" title="IpUtil（转换成字节数组）"></a>IpUtil（转换成字节数组）</h3><pre><code>public class IpUtil {

    /**
     * 将字符串型ip转成int型ip
     * @param strIp
     * @return
     */
    public static int Ip2Int(String strIp){
        String[] ss = strIp.split(&quot;\\.&quot;);
        if(ss.length != 4){
            return 0;
        }
        byte[] bytes = new byte[ss.length];
        for(int i = 0; i &lt; bytes.length; i++){
            bytes[i] = (byte) Integer.parseInt(ss[i]);
        }
        return byte2Int(bytes);
    }

    /**
     * 将int型ip转成String型ip
     * @param intIp
     * @return
     */
    public static String int2Ip(int intIp){
        byte[] bytes = int2byte(intIp);
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i &lt; 4; i++){
            sb.append(bytes[i] &amp; 0xFF);
            if(i &lt; 3){
                sb.append(&quot;.&quot;);
            }
        }
        return sb.toString();
    }

    private static byte[] int2byte(int i) {
        byte[] bytes = new byte[4];
        bytes[0] = (byte) (0xff &amp; i);
        bytes[1] = (byte) ((0xff00 &amp; i) &gt;&gt; 8);
        bytes[2] = (byte) ((0xff0000 &amp; i) &gt;&gt; 16);
        bytes[3] = (byte) ((0xff000000 &amp; i) &gt;&gt; 24);
        return bytes;
    }

    private static int byte2Int(byte[] bytes) {
        int n = bytes[0] &amp; 0xFF;
        n |= ((bytes[1] &lt;&lt; 8) &amp; 0xFF00);
        n |= ((bytes[2] &lt;&lt; 16) &amp; 0xFF0000);
        n |= ((bytes[3] &lt;&lt; 24) &amp; 0xFF000000);
        return n;
    }

    public static void main(String[] args) {
        String ip1 = &quot;192.168.0.1&quot;;
        int intIp = Ip2Int(ip1);
        String ip2 = int2Ip(intIp);
        System.out.println(ip2.equals(ip1));
    }
}
</code></pre><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p>java中byte, int的转换 - 小柯的日志 - 网易博客<br><a href="http://freewind886.blog.163.com/blog/static/661924642011810236100/" target="_blank" rel="external">http://freewind886.blog.163.com/blog/static/661924642011810236100/</a><br>Java将ip字符串转换成整数<br><a href="http://outofmemory.cn/code-snippet/4837/Java-jiang-ip-charaeter-chuan-turn-huancheng-integer" target="_blank" rel="external">http://outofmemory.cn/code-snippet/4837/Java-jiang-ip-charaeter-chuan-turn-huancheng-integer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/[Spring MVC]Spring MVC学习笔记/" itemprop="url">
                  Spring MVC学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T00:00:00+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-MVC简介"><a href="#Spring-MVC简介" class="headerlink" title="Spring MVC简介"></a>Spring MVC简介</h2><ul>
<li><strong><em>SpringMVC是一个基于MVC设计理念的web框架</em></strong></li>
<li>Spring MVC通过一套MVC注解，让POJO成为处理请求的控制器，无需实现任何接口，同时SpringMVC还支持REST风格的URL请求</li>
<li>Spring MVC在框架设计、扩展性、灵活性等方面全面超越Struts、WebWork等MVC框架，成为MVC的领跑者</li>
<li>Spring MVC框架围绕DispatcherServlet这个核心展开，DispatcherServlet是Spring MVC框架的总导演、总策划，他负责截获请求并将其分派给相应地处理器处理</li>
</ul>
<h2 id="Spring-MVC-整体架构"><a href="#Spring-MVC-整体架构" class="headerlink" title="Spring MVC 整体架构"></a>Spring MVC 整体架构</h2><p><img src="http://i.imgur.com/8Eb6auw.png" alt=""></p>
<p>1、用户发起请求到控制器 DispatcherServlet (请求分派)<br>2、DispatcherServlet 去 handlerMapping 查找 Handler 对应的 Handler（Handler可以理解成struts中的 action）<br>3、HandlerMapper 返回 HandlerExecutorChain 执行链（包含两部分内容：Handler,拦截器集合）<br>4、DispatcherServlet 调用 HandlerAdapter<br>5、HandlerAdapter 调用 Handler<br>6、Handler 处理具体的业务逻辑<br>7、Handler 处理完业务逻辑之后，返回 ModelAndView 给 HandlerAdapter，其中的 View 是视图名称，Modal 是数据模型<br>8、HandlerAdapter 将 ModelAndView 返回给 DispatcherServlet<br>9、DispatcherServlet 通过 ModelAndView 中的视图名称在视图解析器中查找视图<br>10、视图解析器返回真正的 View 视图对象<br>11、渲染视图<br>12、返回用户响应</p>
<h2 id="Spring-MVC快速入门★★★★★★"><a href="#Spring-MVC快速入门★★★★★★" class="headerlink" title="Spring MVC快速入门★★★★★★"></a>Spring MVC快速入门★★★★★★</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/SpringMVC_study" target="_blank" rel="external">https://github.com/rhapsody1290/SpringMVC_study</a></p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;cn.apeius&lt;/groupId&gt;
    &lt;artifactId&gt;Demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;!-- 全局属性配置,定义变量 --&gt;
    &lt;properties&gt;
        &lt;!--用来定义war包名称--&gt;
        &lt;project.build.name&gt;tools&lt;/project.build.name&gt;
        &lt;!--用来定义资源文件的编码格式  --&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;!-- spring版本号 --&gt;
        &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;
        &lt;!-- mybatis版本号 --&gt;
        &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt;
        &lt;!-- log4j日志文件管理包版本 --&gt;
        &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;
        &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--Spring MVC--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--日志依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- JSTL标签类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--JSP相关--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.0.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><ul>
<li>Spring MVC自带一个<font color="red"><strong><em>Dispatcher Servlet</em></strong></font>，要是用这个servlet，需要把它配置到<strong><em>部署描述符（web.xml文件）</em></strong></li>
<li>load-on-startup 元素是可选的，如果它存在，则在<strong><em>应用程序启动时</em></strong> 装载该servlet，并调用它的init方法；若它不存在，则在该servlet<strong><em>第一次请求</em></strong> 时进行加载</li>
<li>★ DispatcherServlet将使用Spring MVC的诸多默认组件，在初始化时它会寻找WEB-INF目录下的配置文件，其命名规则为<strong><em>servletName-servlet.xml</em></strong></li>
<li>url-pattern为/时，拦截所有请求，包括静态资源，此时需要设置annotation-driven和resources</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</code></pre><h3 id="spring-mvc的配置"><a href="#spring-mvc的配置" class="headerlink" title="spring-mvc的配置"></a>spring-mvc的配置</h3><h4 id="添加springmvc-servlet-xml"><a href="#添加springmvc-servlet-xml" class="headerlink" title="添加springmvc-servlet.xml"></a>添加springmvc-servlet.xml</h4><ul>
<li>spring-mvc 会默认去WEB-INF的目录下寻找${serlvet-name}-serlvet.xml的文件</li>
<li>所以我们把serlvetmvc的配置文件添加到web-inf的目录下，并且名字与 web.xml 中的servlet-name 相同</li>
<li>可以把配置文件放在应用程序的任意目录，用servlet定义的init-param元素，以便DispatcherServlet加载到该文件</li>
</ul>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/config/springmvc-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre><h4 id="自定义Handler（controller）★★★★★★"><a href="#自定义Handler（controller）★★★★★★" class="headerlink" title="自定义Handler（controller）★★★★★★"></a>自定义Handler（controller）★★★★★★</h4><ul>
<li>在Spring2.5版本前，开发一个控制器的唯一方法是<strong><em>实现org.springframework.web.servlet.mvc.Controller接口</em></strong>，这个接口公开了一个handleRequest方法</li>
<li>其实现类可以访问请求的HttpServletRequest和HttpServletResponse</li>
<li>还必须返回包含<font color="red"><strong><em>视图路径</em></strong> </font>或<font color="blue"><strong><em>视图路径和模的ModelAndView对象</em></strong></font></li>
<li>Controller接口的实现类只能处理一个单一动作（Action）（<strong><em>一个Action对应一个Controller的实现类。调用其handleRequest方法</em></strong>），而一个基于注解的控制器可以同时支持多个请求处理的动作，并且无需实现任何接口</li>
</ul>
<pre><code>public class Hello implements Controller{

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        ModelAndView mv = new ModelAndView();
        //设置试图名称
        mv.setViewName(&quot;hello&quot;);
        mv.addObject(&quot;msg&quot;,&quot;这是第一个springmvc程序&quot;);
        return mv;

        /*也可以直接
        return new ModelAndView(&quot;hello&quot;,&quot;msg&quot;,&quot;这是第一个springmvc程序&quot;);
        */
    }
}
</code></pre><h4 id="在springmvc-servlet-xml-中配置Handler"><a href="#在springmvc-servlet-xml-中配置Handler" class="headerlink" title="在springmvc-servlet.xml 中配置Handler"></a>在springmvc-servlet.xml 中配置Handler</h4><ul>
<li>当DispatcherServlet收到/hello.do的请求时，自动构建控制器Hello，并调用其handleRequest方法，返回ModelAndView</li>
</ul>
<pre><code>&lt;!--配置自定义Handler，name表示对应的访问路径--&gt;
&lt;bean name=&quot;/hello.do&quot; class=&quot;cn.apeius.springmvc.controller.Hello&quot;/&gt;
</code></pre><h4 id="配置HandlerMapping（非必须，需要注释）"><a href="#配置HandlerMapping（非必须，需要注释）" class="headerlink" title="配置HandlerMapping（非必须，需要注释）"></a>配置HandlerMapping（非必须，需要注释）</h4><pre><code>&lt;!--配置handlerMapping--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre><h4 id="配置handlerAdapter（非必须，需要注释）"><a href="#配置handlerAdapter（非必须，需要注释）" class="headerlink" title="配置handlerAdapter（非必须，需要注释）"></a>配置handlerAdapter（非必须，需要注释）</h4><pre><code>&lt;!--配置handlerAdapter--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre><h4 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h4><ul>
<li>视图解析器<font color="red"><strong><em>可以不设置</em></strong></font>，但需填入完整路径，如 /WEB-INF/views/hello.jsp</li>
<li>视图解析器负责解析视图</li>
<li>可以通过在配置文件中定义一个ViewResolver来配置视图解析器</li>
<li>视图解析器配置有<strong><em>前缀</em></strong> 和<strong><em>后缀</em></strong> 两个属性，这样一来<strong><em>view路径将缩短</em></strong>，如只需填hello</li>
</ul>
<pre><code>&lt;!--配置试图解析器
Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; &quot;/WEB-INF/jsp/test.jsp--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h4><p><strong><em> 文件路径在/WEB-INF/views/hello.jsp</em></strong></p>
<p><img src="http://i.imgur.com/1hiYmrm.png" alt=""></p>
<p><strong><em>hello.jsp中可以使用ModelAndView中的对象</em></strong></p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;hello&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
      &lt;font color=&quot;red&quot;&gt;${msg}&lt;/font&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="分析第一个案例的执行过程"><a href="#分析第一个案例的执行过程" class="headerlink" title="分析第一个案例的执行过程"></a>分析第一个案例的执行过程</h2><h3 id="方法一：看日志"><a href="#方法一：看日志" class="headerlink" title="方法一：看日志"></a>方法一：看日志</h3><p><strong><em>导入日志</em></strong></p>
<p>log4j.properties</p>
<pre><code>log4j.rootLogger=DEBUG,A1
log4j.logger.org.mybatis=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
</code></pre><p><strong><em>在web.xml中配置servlet 服务器开启的时候启动</em></strong></p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre><h3 id="方法二：看源码"><a href="#方法二：看源码" class="headerlink" title="方法二：看源码"></a>方法二：看源码</h3><p>在DispatcherServlet的doDispatch方法中打断点</p>
<h2 id="精简之后的配置"><a href="#精简之后的配置" class="headerlink" title="精简之后的配置"></a>精简之后的配置</h2><p>springmvc-servlet.xml</p>
<pre><code>&lt;!--配置自定义Handler，name表示对应的访问路径--&gt;
&lt;bean name=&quot;/hello.do&quot; class=&quot;cn.apeius.springmvc.controller.Hello&quot;/&gt;

&lt;!--配置试图解析器
Example: prefix=&quot;/WEB-INF/jsp/&quot;, suffix=&quot;.jsp&quot;, viewname=&quot;test&quot; -&gt; &quot;/WEB-INF/jsp/test.jsp--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre><h2 id="第一个注解程序★★★★★★"><a href="#第一个注解程序★★★★★★" class="headerlink" title="第一个注解程序★★★★★★"></a>第一个注解程序★★★★★★</h2><p>基于注解的控制器有以下几个优点：</p>
<ul>
<li><font color="red"><strong><em>一个控制器类可以处理多个动作</em></strong></font>，而一个实现了Controller接口的控制器<strong><em>只能处理一个动作</em></strong>。<strong><em>这就允许将相关的操作都写在同一个控制器内</em></strong>，从而减少应用程序中类的数量</li>
<li>基于注解的控制器的<font color="red"><strong><em>请求映射不需要存储在配置文件中</em></strong> </font>，使用RequestMapping注释类型，可以对一个方法进行请求处理</li>
</ul>
<h3 id="创建注解的步骤"><a href="#创建注解的步骤" class="headerlink" title="创建注解的步骤"></a>创建注解的步骤</h3><p><strong><em>1、书写一个类，需要在类上面加上@Controller</em></strong></p>
<ul>
<li>用于指示Spring类的实例是一个控制器</li>
<li>Spring使用<strong><em>扫描机制</em></strong> 来找到应用程序中所有<strong><em>基于注解的控制器类</em></strong></li>
</ul>
<p><strong><em>2、@RequestMapping映射一个请求与请求处理方法。一个采用@RequestMapping注释的方法将成为一个请求处理方法，访问相应的URL请求时调用。@RequestMapping使用后面有详解</em></strong></p>
<pre><code>@Controller
public class AnnotationHello {

    @RequestMapping(value = &quot;/show1&quot;)//可以省略后缀
    public ModelAndView test1(){
        ModelAndView mv = new ModelAndView();
        mv.setViewName(&quot;hello&quot;);
        mv.addObject(&quot;msg&quot;,&quot;这是第一个注解程序&quot;);
        return mv;
    }
}
</code></pre><p><strong><em>3、在springmvc的配置文件中，去配置扫描包，使@Controller生效，和spring配置扫描包的方式一样</em></strong></p>
<ul>
<li>为了保证Spring能找到你的控制器，需要在Spring MVC的配置文件中声明spring-context<pre><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
</code></pre></li>
<li>在<component-scan>元素中指定控制器类的基本包<pre><code>&lt;context:component-scan base-package=&quot;cn.apeius.springmvc.controller&quot;/&gt;
</code></pre></component-scan></li>
</ul>
<p><strong><em>4、测试</em></strong></p>
<pre><code>http://localhost:8080/SpringMVC_study/show1.do
</code></pre><h3 id="推荐使用的HandlerMapper和HandlerAdapter（什么意思？？）"><a href="#推荐使用的HandlerMapper和HandlerAdapter（什么意思？？）" class="headerlink" title="推荐使用的HandlerMapper和HandlerAdapter（什么意思？？）"></a>推荐使用的HandlerMapper和HandlerAdapter（什么意思？？）</h3><p><img src="http://i.imgur.com/GRSWFil.png" alt=""></p>
<h3 id="使用注解驱动替换推荐的配置（什么意思？？）"><a href="#使用注解驱动替换推荐的配置（什么意思？？）" class="headerlink" title="使用注解驱动替换推荐的配置（什么意思？？）"></a>使用注解驱动替换推荐的配置（什么意思？？）</h3><ul>
<li>url-pattern为/时，拦截所有请求，包括静态资源，此时需要在springmvc-config.xml中设置annotation-driven和resources元素</li>
<li>annotation-driven 相当于注册了DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter两个bean，配置一些messageconverter，即解决了@Controller注解的使用前提配置</li>
<li>resource 元素则指示Spring MVC哪些静态资源需要单独处理（不通过DispatcherServlet）；如果没有annotation-driven，resource元素会阻止任意控制器被调用；若不使用resources，则不需要annotation-driven</li>
</ul>
<pre><code>&lt;!--配置注解驱动，会默认加载HandlerMapping，HandlerAdapter--&gt;
&lt;mvc:annotation-driven/&gt;
&lt;!-- 确保/css目录下所有文件可见--&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;
&lt;!--允许显示所有的.html文件--&gt;
&lt;mvc:resources mapping=&quot;/*.html&quot; location=&quot;/&quot;/&gt;
</code></pre><ul>
<li>或者使用mvc:default-servlet-handler，过滤掉所有的静态资源</li>
</ul>
<pre><code>&lt;!--过滤掉所有的静态资源，把静态资直接交给tomcat去处理--&gt;
&lt;mvc:default-servlet-handler/&gt;
</code></pre><h2 id="使用RequestMapping映射请求★★★★★★"><a href="#使用RequestMapping映射请求★★★★★★" class="headerlink" title="使用RequestMapping映射请求★★★★★★"></a>使用RequestMapping映射请求★★★★★★</h2><ul>
<li>在SpringMVC中的众多Controller以及每个Controller的众多方法，请求是如何映射到具体的处理方法上？这个就是靠@RequestMapping完成的，<strong><em>他完成了一个请求与请求处理方法的映射</em></strong></li>
<li><font color="red">@RequestMapping既可以定义在类上也可以定义在方法上，请求映射的规则是：</font><pre><code>类上面的@RequestMapping.value + 方法上面的@RequestMapping.value
</code></pre></li>
</ul>
<p>举个例子：<br>—— 控制器：</p>
<pre><code>@Controller
@RequestMapping(&quot;test&quot;)
public class AnnotationHello {

    @RequestMapping(&quot;show1&quot;)//可以省略后缀
    public ModelAndView test1(){
        ModelAndView mv = new ModelAndView();
        mv.setViewName(&quot;hello&quot;);
        mv.addObject(&quot;msg&quot;,&quot;这是第一个注解程序&quot;);
        return mv;
    }
}
</code></pre><p>—— 访问URL：</p>
<pre><code>http://localhost:8080/SpringMVC_study/test/show1.do
</code></pre><h3 id="五种映射"><a href="#五种映射" class="headerlink" title="五种映射"></a>五种映射</h3><h4 id="标准URL映射"><a href="#标准URL映射" class="headerlink" title="标准URL映射"></a>标准URL映射</h4><ul>
<li><p>标准URL映射是最简单的一种映射，例如：</p>
<p>  @RequestMapping(“hello”)或<br>  @RequestMapping（”/hello”）或<br>  @RequestMapping(“value=”/hello””)</p>
</li>
<li><p>请求URL：</p>
<pre><code>http://localhost:8080/web应用名/hello.do
</code></pre></li>
<li><p>value是RequestMapping的注释的默认属性，因此若只有唯一的属性，则可以省略属性名字，即以下两个标注含义相同：</p>
<pre><code>@RequestMapping(&quot;show1&quot;)
@RequestMapping(value = &quot;show1&quot;)
</code></pre></li>
<li><p>但如果有超过一个属性时，就必须写入value属性名称</p>
</li>
</ul>
<h4 id="Ant风格的URL映射（通配符）"><a href="#Ant风格的URL映射（通配符）" class="headerlink" title="Ant风格的URL映射（通配符）"></a>Ant风格的URL映射（通配符）</h4><p><img src="http://i.imgur.com/APZ3QF7.png" alt=""></p>
<p>举例1：</p>
<pre><code>@RequestMapping(&quot;/test/*/show2&quot;)
public ModelAndView test2(){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;/test/*/show2&quot;);
    return mv;
}
</code></pre><p>能匹配：</p>
<pre><code>/test/a/show2.do
/test/abc/show2.do
/test/show2.do 匹配不到
</code></pre><p>举例2：</p>
<pre><code>@RequestMapping(&quot;/test/**/show3&quot;)
public ModelAndView test3(){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;/test/**/show3&quot;);
    return mv;
}
</code></pre><p>能匹配：</p>
<pre><code>http://localhost:8080/web应用名/test/a/show3.do
http://localhost:8080/web应用名/test/b/a/d/show3.do
</code></pre><h4 id="占位符映射"><a href="#占位符映射" class="headerlink" title="占位符映射"></a>占位符映射</h4><ul>
<li>Url中可以通过一个或多个{xxxx}占位符映射,通过@PathVariable(“xxx”)绑定到方法的入参中</li>
<li>占位符映射让传递参数多了一种方式</li>
</ul>
<p>例如： </p>
<pre><code>@RequestMapping(&quot;/test/{itemId}/{itemName}&quot;)
public ModelAndView test4(@PathVariable(&quot;itemId&quot;) String itemId, @PathVariable(&quot;itemName&quot;) String itemName){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;itemId:&quot; + itemId + &quot; &quot; + &quot;itemName:&quot; + itemName);
    return mv;
}
</code></pre><p>URL:</p>
<pre><code>http://localhost:8080/SpringMVC_study/test/2011/iphone6s.do
</code></pre><p>结果：</p>
<pre><code>itemId:2011 itemName:iphone6s
</code></pre><h4 id="限制请求方法映射"><a href="#限制请求方法映射" class="headerlink" title="限制请求方法映射"></a>限制请求方法映射</h4><p><strong><em>若无指定method属性，则请求处理方法可以处理任意HTTP方法</em></strong></p>
<p><strong><em>只允许get请求访问</em></strong></p>
<pre><code>@RequestMapping(value = &quot;test5&quot;, method = RequestMethod.GET)
public ModelAndView test5(){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;限制只有get请求才能进入&quot;);
    return mv;
}
</code></pre><p><strong><em>只允post和get方法</em></strong></p>
<pre><code>@RequestMapping(value = &quot;test5&quot;, method = {RequestMethod.GET,RequestMethod.POST})
public ModelAndView test5(){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;限制只有get、post请求才能进入&quot;);
    return mv;
}
</code></pre><h4 id="限制参数映射"><a href="#限制参数映射" class="headerlink" title="限制参数映射"></a>限制参数映射</h4><pre><code>@RequestMapping(value = &quot;/test6&quot;,params = &quot;userId&quot;)
public ModelAndView test6(@RequestParam(value=&quot;userId&quot;) String userId){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;限定请求参数，必须要有Userid这个信息；userid：&quot; + userId);
    return mv;
}
</code></pre><ul>
<li>请求中必须带userId参数</li>
<li>参数的规则如下<ul>
<li>params=”userId”请求参数中必须包含userId</li>
<li>params=”!userId”请求参数中不能包含userId</li>
<li>params=”userId!=1”请求参数必须包含userId，但其值不能为1</li>
<li>params=”{“userId”,”name”}”必须包含userId和name参数</li>
</ul>
</li>
</ul>
<p>请求URL</p>
<pre><code>http://localhost:8080/SpringMVC_study/test6.do?userId=2
</code></pre><h2 id="请求响应处理方法的数据绑定"><a href="#请求响应处理方法的数据绑定" class="headerlink" title="请求响应处理方法的数据绑定"></a>请求响应处理方法的数据绑定</h2><ul>
<li>一个请求URL与请求响应方法一一对应</li>
<li>数据绑定是将<strong><em>用户输入</em></strong> 与<strong><em>领域模型</em></strong> 相互绑定<ul>
<li>类型总为<strong><em>String</em></strong> 的HTTP请求参数，可用于填充<strong><em>不同类型</em></strong>的对象属性</li>
<li>数据绑定使得form bean变成多余</li>
</ul>
</li>
</ul>
<h3 id="绑定servlet内置对象"><a href="#绑定servlet内置对象" class="headerlink" title="绑定servlet内置对象"></a>绑定servlet内置对象</h3><p>非常简单，只需在参数中加入需要使用的内置对象，常用的有HttpServletRequest、HttpServletResponse、HttpSession</p>
<pre><code>@RequestMapping(value = &quot;/test7&quot;)
public ModelAndView test7(HttpServletRequest request, HttpServletResponse response, HttpSession session){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;Servlet中的对象&quot;);
    System.out.println(request);
    System.out.println(response);
    System.out.println(session);
    return mv;
}
</code></pre><h3 id="PathVariable获取占位符中的参数"><a href="#PathVariable获取占位符中的参数" class="headerlink" title="@PathVariable获取占位符中的参数"></a>@PathVariable获取占位符中的参数</h3><ul>
<li>通过@PathVariable可以绑定占位符参数到方法参数中</li>
<li>路径变量的类型可以不是字符串</li>
<li><strong><em>可以使用多个路径变量</em></strong></li>
</ul>
<pre><code>@RequestMapping(&quot;/test/{itemId}/{itemName}&quot;)
public ModelAndView test4(@PathVariable(&quot;itemId&quot;) String itemId, @PathVariable(&quot;itemName&quot;) String itemName){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;itemId:&quot; + itemId + &quot; &quot; + &quot;itemName:&quot; + itemName);
    return mv;
}
</code></pre><ul>
<li>特殊说明：不要省略@PathVariable中的参数</li>
</ul>
<p><img src="http://i.imgur.com/LDhruoO.png" alt=""></p>
<h3 id="RequestParam-★★★★★"><a href="#RequestParam-★★★★★" class="headerlink" title="@RequestParam ★★★★★"></a>@RequestParam ★★★★★</h3><ul>
<li>将请求参数传入到方法中，如<a href="http://localhost:8080/SpringMVC_study/test8?userId=qm" target="_blank" rel="external">http://localhost:8080/SpringMVC_study/test8?userId=qm</a></li>
<li>@RequestParam 注解的参数类型不一定是字符串，可以是整型等其他</li>
</ul>
<pre><font color="red">/**
 * required：必须要有这个参数
 * defautlValue：默认值，如果defaultValue设置了值，那么required失效
 * @param userId
 * @return
 */</font>
@RequestMapping(value = "/test8")
public ModelAndView test8(@RequestParam(value = "userId",required = true,defaultValue = "10") String userId){
    ModelAndView mv = new ModelAndView();
    mv.setViewName("hello");
    mv.addObject("msg","userId：" + userId);
    return mv;
}
</pre>

<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>在Spring MVC中通过@CookieValue可以轻松获取cookie的值</p>
<p><strong><em>Servlet中如何获取指定的cookie值</em></strong></p>
<pre><code>Cookie[] cookies = request.getCookies();
//对数组进行遍历，根据cookie中的name 来找到对应的cookie
for(Cookie cookie : cookies){
    if(&quot;abc&quot;.equals(cookie.getName()))
        cookie.getValue();//获取cookie中的值
}
</code></pre><p><strong><em>使用@CookieValue</em></strong></p>
<pre><code>@RequestMapping(value = &quot;/test9&quot;)
public ModelAndView test9(@CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,&quot;JESSIONID：&quot; + JSESSIONID);
    return mv;
}
</code></pre><h3 id="POJO对象绑定参数"><a href="#POJO对象绑定参数" class="headerlink" title="POJO对象绑定参数"></a>POJO对象绑定参数</h3><p>SpringMVC会将请求过来的 <strong><em>参数名</em></strong> 和POJO实体中的 <strong><em>属性名</em></strong> 进行匹配，如果名称一致，将把值填充到对象中</p>
<pre><code>@RequestMapping(value = &quot;/test10&quot;)
public ModelAndView test10(User user){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;hello&quot;);
    mv.addObject(&quot;msg&quot;,user);
    return mv;
}
</code></pre><p>User.java</p>
<pre><code>public class User {

    private String userName;
    private String password;

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    @Override
    public String toString(){
        return userName + &quot; &quot; + password;
    }
}
</code></pre><h3 id="自定义复合对象类型"><a href="#自定义复合对象类型" class="headerlink" title="自定义复合对象类型"></a>自定义复合对象类型</h3><p>User对象中有ContactInfo属性，Controller中的代码和第3点说的一致，但是，在表单代码中，需要使用<font color="red"><strong><em>“属性名(对象类型的属性).属性名”</em></strong></font>来命名input的name</p>
<p>Model代码：</p>
<pre><code>public class ContactInfo {
    private String tel;
    private String address;

    public String getTel() {
        return tel;
    }

    public void setTel(String tel) {
        this.tel = tel;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

}

public class User {
    private String firstName;
    private String lastName;
    private ContactInfo contactInfo;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public ContactInfo getContactInfo() {
        return contactInfo;
    }

    public void setContactInfo(ContactInfo contactInfo) {
        this.contactInfo = contactInfo;
    }

}
</code></pre><p>Controller代码：</p>
<pre>
@RequestMapping("saysth.do")
public void test(User user) {
    System.out.println(user.getFirstName());
    System.out.println(user.getLastName());
    System.out.println(<font color="red">user.getContactInfo().getTel()</font>);
    System.out.println(<font color="red">user.getContactInfo().getAddress()</font>);
}
</pre>

<p>表单代码：</p>
<pre>
&lt;form action="saysth.do" method="post">
&lt;input name="firstName" value="张" />&lt;br>
&lt;input name="lastName" value="三" />&lt;br>
&lt;input name=<font color="red">"contactInfo.tel"</font> value="13809908909" />&lt;br>
&lt;input name=<font color="red">"contactInfo.address"</font> value="北京海淀" />&lt;br>
&lt;input type="submit" value="Save" />
&lt;/form>
</pre>


<h3 id="Java的基本数据类型绑定"><a href="#Java的基本数据类型绑定" class="headerlink" title="Java的基本数据类型绑定"></a>Java的基本数据类型绑定</h3><ul>
<li>表单中input的name值和Controller的<font color="red"><strong><em>参数变量名保持一致</em></strong></font>，就能完成数据绑定，如果<strong><em>不一致可以使用@RequestParam注解</em></strong></li>
<li>如果Controller方法参数中定义的是基本数据类型，但是从页面提交过来的<strong><em>数据为null或者””的话，会出现数据转换的异常</em></strong>。也就是必须保证表单传递过来的数据不能为null或””，所以，在开发过程中，对可能为空的数据，最好将参数数据类型定义成<font color="red"><strong><em>包装类型</em></strong></font></li>
<li><font color="red"><strong><em>Java的基本数据类型数组可以自动转换</em></strong></font>，如String[] interests，但是用户自定义User[] users不行，需要将User[]包装到一个UserForm中，通List操作</li>
</ul>
<p>表单代码</p>
<pre><code>&lt;form action=&quot;/demos/demo1.action&quot; method=&quot;post&quot;&gt;
    &lt;div&gt;姓名:&lt;/div&gt;
    &lt;div&gt;&lt;input name=&quot;name&quot; value=&quot;张三&quot;/&gt;&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
    &lt;div&gt;年龄:&lt;/div&gt;
    &lt;div&gt;&lt;input name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
    &lt;div&gt;收入:&lt;/div&gt;
    &lt;div&gt;&lt;input name=&quot;income&quot; value=&quot;100000&quot;/&gt;&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
    &lt;div&gt;结婚:&lt;/div&gt;
    &lt;div&gt;
    &lt;input type=&quot;radio&quot; name=&quot;isMarried&quot; value=&quot;true&quot; checked=&quot;checked&quot;/&gt;是
    &lt;input type=&quot;radio&quot; name=&quot;isMarried&quot; value=&quot;false&quot;/&gt;否&lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
    &lt;div&gt;兴趣:&lt;/div&gt;
    &lt;div&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;听歌&quot; checked=&quot;checked&quot;/&gt;听歌
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;书法&quot; checked=&quot;checked&quot;/&gt;书法
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;看电影&quot; checked=&quot;checked&quot;/&gt;看电影
    &lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
    &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;提交表单&quot;/&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre><p>测试：</p>
<p><img src="http://i.imgur.com/u6Gq5bU.png" alt=""></p>
<h3 id="集合List绑定"><a href="#集合List绑定" class="headerlink" title="集合List绑定"></a>集合List绑定</h3><ul>
<li>如果方法需要接受的list集合，不能够直接在方法中书写List，List的绑定，需要 <strong><em>将List对象包装到一个类中</em></strong> 才能绑定<font color="red">（<strong><em>如果List中的类型是Java自带的，则可以自动转换</em></strong></font>，如List &lt;Object&gt;，List<string>，而List &lt;User&gt;不行）</string></li>
<li>与”自定义复合对象类型”数据绑定类似，但是UserForm对象的属性被定义成List，而不是普通自定义对象，所以在表单中需要指定List的下标</li>
<li>Spring会创建一个以最大下标值为size的List对象，List中的对象，只有在表单中对应有下标的那些才会有值，否则会为null</li>
</ul>
<p>表单</p>
<pre><code>&lt;form action=&quot;/SpringMVC_study/test11.do&quot;&gt;
        用户1：&lt;input type=&quot;text&quot; name=&quot;users[0].userName&quot;/&gt;&lt;br/&gt;
        用户2：&lt;input type=&quot;text&quot; name=&quot;users[1].userName&quot;/&gt;&lt;br/&gt;
        用户3：&lt;input type=&quot;text&quot; name=&quot;users[2].userName&quot;/&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;测试&quot;/&gt;
&lt;/form&gt;
</code></pre><p>将List对象包装到一个类中</p>
<pre>
public class UserForm {

    <font color="red">private List<user> users;</user></font>

    public List<user> getUsers() {
        return users;
    }

    public void setUsers(List<user> users) {
        this.users = users;
    }
}
</user></user></pre>

<p>Action</p>
<pre>
@RequestMapping(value = "/test11")
public ModelAndView test11(<font color="red">UserForm userForm</font>){
    ModelAndView mv = new ModelAndView();
    mv.setViewName("hello");
    mv.addObject("msg","List集合");

    for(User user : userForm.getUsers()){
        System.out.println(user);
    }

    return mv;
}
</pre>

<h3 id="集合Set绑定"><a href="#集合Set绑定" class="headerlink" title="集合Set绑定"></a>集合Set绑定</h3><p>Set和List类似，也需要绑定在对象上，而不能直接写在Controller方法的参数中。但是，绑定Set数据时，<strong><em>必须先在Set对象中add相应的数量的模型对象</em></strong></p>
<p>Model代码：</p>
<pre>
public class User {
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

}

public class UserSetForm {

    <font color="red">private Set<user> users = new HashSet<user>();</user></user></font>

    public UserSetForm() {
        <font color="red">users.add(new User());
        users.add(new User());
        users.add(new User());</font>
    }

    public Set<user> getUsers() {
        return users;
    }

    public void setUsers(Set<user> users) {
        this.users = users;
    }

}
</user></user></pre>

<p>Controller代码：</p>
<pre><code>@RequestMapping(&quot;saysth.do&quot;)
public void test(UserSetForm userForm) {
    for (User user : userForm.getUsers()) {
        System.out.println(user.getFirstName() + &quot; - &quot; + user.getLastName());
    }
}
</code></pre><p>表单代码：</p>
<pre>
&lt;form action="saysth.do" method="post">
    &lt;table>
        &lt;thead>
            &lt;tr>
            &lt;th>First Name&lt;/th>
            &lt;th>Last Name&lt;/th>
            &lt;/tr>
        &lt;/thead>
        &lt;tfoot>
            &lt;tr>
            &lt;td colspan="2">&lt;input type="submit" value="Save" />&lt;/td>
            &lt;/tr>
        &lt;/tfoot>
        &lt;tbody>
            &lt;tr>
            <font color="red">&lt;td>&lt;input name="users[0].firstName" value="aaa" />&lt;/td>
            &lt;td>&lt;input name="users[0].lastName" value="bbb" />&lt;/td></font>
            &lt;/tr>
            &lt;tr>
            <font color="red">&lt;td>&lt;input name="users[1].firstName" value="ccc" />&lt;/td>
            &lt;td>&lt;input name="users[1].lastName" value="ddd" />&lt;/td></font>
            &lt;/tr>
            &lt;tr>
            <font color="red">&lt;td>&lt;input name="users[2].firstName" value="eee" />&lt;/td>
            &lt;td>&lt;input name="users[2].lastName" value="fff" />&lt;/td></font>
            &lt;/tr>
        &lt;/tbody>
    &lt;/table>
&lt;/form>
</pre>

<h3 id="Map绑定"><a href="#Map绑定" class="headerlink" title="Map绑定"></a>Map绑定</h3><p>Map最为灵活，它也需要绑定在对象上，而不能直接写在Controller方法的参数中</p>
<p>Model代码：</p>
<pre>
public class User {
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

}

public class UserMapForm {
    <font color="red">private Map<string, user=""> users;</string,></font>

    public Map<string, user=""> getUsers() {
        return users;
    }

    public void setUsers(Map<string, user=""> users) {
        this.users = users;
    }

}
</string,></string,></pre>

<p>Controller代码：</p>
<pre><code>@RequestMapping(&quot;saysth.do&quot;)
public void test(UserMapForm userForm) {
    for (Map.Entry&lt;String, User&gt; entry : userForm.getUsers().entrySet()) {
        System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue().getFirstName() + &quot; - &quot; +
        entry.getValue().getLastName());
    }
}
</code></pre><p>表单代码：</p>
<pre>
&lt;form action="saysth.do" method="post">
    &lt;table>
    &lt;thead>
        &lt;tr>
            &lt;th>First Name&lt;/th>
            &lt;th>Last Name&lt;/th>
        &lt;/tr>
    &lt;/thead>
    &lt;tfoot>
        &lt;tr>
            &lt;td colspan="2">&lt;input type="submit" value="Save" />&lt;/td>
        &lt;/tr>
    &lt;/tfoot>
    &lt;tbody>
        &lt;tr><font color="red">
            &lt;td>&lt;input name="users['x'].firstName" value="aaa" />&lt;/td>
            &lt;td>&lt;input name="users['x'].lastName" value="bbb" />&lt;/td></font>
        &lt;/tr>
        &lt;tr><font color="red">
            &lt;td>&lt;input name="users['y'].firstName" value="ccc" />&lt;/td>
            &lt;td>&lt;input name="users['y'].lastName" value="ddd" />&lt;/td></font>
        &lt;/tr>
        &lt;tr><font color="red">
            &lt;td>&lt;input name="users['z'].firstName" value="eee" />&lt;/td>
            &lt;td>&lt;input name="users['z'].lastName" value="fff" />&lt;/td></font>
        &lt;/tr>
    &lt;/tbody>
    &lt;/table>
&lt;/form>
</pre>

<h2 id="数据绑定与表单标签库结合（表单不清空）★★★★★"><a href="#数据绑定与表单标签库结合（表单不清空）★★★★★" class="headerlink" title="数据绑定与表单标签库结合（表单不清空）★★★★★"></a>数据绑定与表单标签库结合（表单不清空）★★★★★</h2><ul>
<li>数据绑定可以将<strong><em>用户表单输入</em></strong> 绑定到一个<strong><em>领域模型</em></strong>，可以自动将HTTP请求参数默认的<strong><em>字符串</em></strong> 类型转化成<strong><em>不同类型</em></strong> 的对象属性，<font color="red"><strong><em>因此不再需要FORM类</em></strong></font></li>
<li>数据绑定还有另外一个好处：当输入验证失败时，它会重新生成一个HTML表单。手工编写HTML代码时，必须<strong><em>记着用户之前输入的值</em></strong>，重新填充输入字段。有了Spring的数据绑定和表单标签后，它们会替你完成这些工作</li>
</ul>
<p>第一步： 访问displayCustomerForm.do时创建一个领域对象并初始化属性，<strong><em>作为表单的默认显示</em></strong>，并添加到Model中，然后跳转到显示表单页面SignUpForm.jsp</p>
<pre>
@RequestMapping(value = "displayCustomerForm", method = RequestMethod.GET)
public String displayCustomerForm(ModelMap model) {
    Customer customer = new Customer();
    customer.setName("qm");
    customer.setAge(2333);
    <font color="red">model.addAttribute("customer", customer);</font>
    return "SignUpForm";
}
</pre>

<p>第二步：使用表单标签库</p>
<ul>
<li>commandName定义了模型的名称，其对象属性将用于填充所生成的表单</li>
<li>input标签中个path属性，将这个输入字段绑定到commandName指定对象的一个属性</li>
<li>errors标签可以显示一个特定的字段错误（path=”name”）或所有字段错误（path=”*”）</li>
</ul>
<pre>
&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
&lt;form:form <font color="red">commandName="product"</font> action="product_save" method="post">
    &lt;fieldset>
        &lt;legend>Add a product&lt;/legend>
        &lt;p class="errorLine">
            <font color="red">&lt;form:errors path="name" cssClass="error"/></font>
        &lt;/p>
        &lt;p>
            &lt;label for="name">*Product Name: &lt;/label>
            <font color="red">&lt;form:input id="name" path="name" tabindex="1"/></font>
        &lt;/p>
        &lt;p>
            &lt;label for="description">Description: &lt;/label>
            &lt;form:input id="description" path="description" tabindex="2"/>
        &lt;/p>
        &lt;p class="errorLine">
            &lt;form:errors path="price" cssClass="error"/>
        &lt;/p>
        &lt;p>
            &lt;label for="price">*Price: &lt;/label>
            &lt;form:input id="price" path="price" tabindex="3"/>
        &lt;/p>
        &lt;p class="errorLine">
            &lt;form:errors path="productionDate" cssClass="error"/>
        &lt;/p>
        &lt;p>
            &lt;label for="productionDate">*Production Date: &lt;/label>
            &lt;form:input id="productionDate" path="productionDate" tabindex="4"/>
        &lt;/p>
        &lt;p id="buttons">
            &lt;input id="reset" type="reset" tabindex="5">
            &lt;input id="submit" type="submit" tabindex="6" 
                value="Add Product">
        &lt;/p>
    &lt;/fieldset>
&lt;/form:form>
</pre>

<h2 id="转换器和格式化（麻烦，建议使用joda-time，参考ssm整合部分）"><a href="#转换器和格式化（麻烦，建议使用joda-time，参考ssm整合部分）" class="headerlink" title="转换器和格式化（麻烦，建议使用joda-time，参考ssm整合部分）"></a>转换器和格式化（麻烦，建议使用joda-time，参考ssm整合部分）</h2><p>1、实现一种对象类型转换成另一种对象类型<br>2、Converter是通用元件，可以在应用程序的任意层中使用<br>3、Formatter则是专门为Web层设计的</p>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><p>通过转换器，实现将输入的日期字符串转换成Date类型</p>
<ul>
<li>实现Converter接口，源数据类型和目标数据类型可以自由指定</li>
</ul>
<pre>
public class StringToDateConvert <font color="red">implements Converter<string,date> </string,date></font>{
    private String datePattern;

    public StringToDateConvert(String datePattern){
        this.datePattern = datePattern;
    }

    <font color="red">public Date convert(String s)</font> {
        SimpleDateFormat dateFormat = new SimpleDateFormat(datePattern);
        dateFormat.setLenient(false);
        try {
            return dateFormat.parse(s);
        } catch (ParseException e) {
            throw new RuntimeException("格式错误");
        }
    }
}
</pre>

<ul>
<li>Spring MVC配置文件中编写一个conversionService bean，Bean的类必须为org.springframework.context.support.ConversionServiceFactoryBean，同时配置converters属性，它将列出程序中所有订制的Converter</li>
</ul>
<pre><code>&lt;bean id = &quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;cn.apeius.convert.StringToDateConvert&quot;&gt;
                &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt;
            &lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService</li>
</ul>
<pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
</code></pre><ul>
<li>表单输入</li>
</ul>
<pre><code>&lt;form action=&quot;/SpringMVC_study/test22.do&quot;&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;用户登录&lt;/legend&gt;
        &lt;p&gt;
            &lt;label&gt;出生日期：&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;birthday&quot;/&gt;
        &lt;/p&gt;
        &lt;p id = &quot;buttons&quot;&gt;
            &lt;input type=&quot;submit&quot; value=&quot;测试&quot;/&gt;
        &lt;/p&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre><ul>
<li>字符串日期自动转换</li>
</ul>
<pre><code>@RequestMapping(value = &quot;/test22&quot;)
    public ModelAndView test22(@RequestParam(&quot;birthday&quot;) Date birthday){
        return new ModelAndView(&quot;hello&quot;,&quot;msg&quot;,birthday);
}
</code></pre><h3 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h3><p>1、Formatter的源类型必须是一个String，适合在Web层转换表单中用户的输入<br>2、Converter源类型可以是任意类型，可以在任意层中使用</p>
<p>以下案例为将一个表单输入的String日期转换成Date：</p>
<ul>
<li>编写一个实现org.springframework.format.Formatter接口的Java类</li>
</ul>
<pre>
public class DateFormatter <font color="red">implements Formatter<date></date></font>{
    private String datePattern;
    private SimpleDateFormat simpleDateFormat;

    public DateFormatter(String datePattern){
        this.datePattern = datePattern;
        simpleDateFormat = new SimpleDateFormat(datePattern);
        simpleDateFormat.setLenient(false);
    }

    /*利用Locale将String解析成目标类型（Date）*/
    public Date <font color="red">parse(String text, Locale locale)</font> throws ParseException {
        return simpleDateFormat.parse(text);
    }

    /*利用Locale将目标类型转换成String*/
    public String <font color="red">print(Date date, Locale locale)</font> {
        return simpleDateFormat.format(date);
    }

}
</pre>

<ul>
<li>配置conversionService bean，bean的类名必须为org.springframework.format.support.FormattingConversionServiceFactoryBean，注入属性formatters，它将列出程序中所有订制的Formatter</li>
</ul>
<pre><code>&lt;!--配置conversionService bean--&gt;
&lt;bean id = &quot;conversionService&quot;
      class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;formatters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;cn.apeius.formatter.Date，它将列出程序中所有订制的Converter&quot;&gt;
                &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt;
            &lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService</li>
</ul>
<pre><code>&lt;mvc:annotation-driven
    conversion-service=&quot;conversionService&quot;/&gt;
</code></pre><ul>
<li>测试同Converter</li>
</ul>
<h3 id="用Registrar注册Formatter"><a href="#用Registrar注册Formatter" class="headerlink" title="用Registrar注册Formatter"></a>用Registrar注册Formatter</h3><p>注册Formatter的另一种方法是使用Registrar：</p>
<ul>
<li>创建一个实现org.springframework.format.FormatterRegistrar接口的Java类</li>
</ul>
<pre><code>public class MyFormatterRegistrar implements FormatterRegistrar{

    private  String datePattern;

    public MyFormatterRegistrar(String datePattern){
        this.datePattern = datePattern;
    }
    public void registerFormatters(FormatterRegistry registry) {
        registry.addFormatter(new DateFormatter(datePattern));
        //注册更多的Formatter
    }
}
</code></pre><ul>
<li>在配置文件中注册Registrar</li>
</ul>
<pre><code>&lt;!--配置conversionService bean--&gt;
&lt;bean id = &quot;conversionService&quot;
      class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;formatterRegistrars&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;cn.apeius.formatter.MyFormatterRegistrar&quot;&gt;
                &lt;constructor-arg name=&quot;datePattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt;
            &lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>给annotation-driven元素的conversion-service赋值bean名称，本例中是conversionService</li>
</ul>
<h3 id="选择Convert还是Formatter"><a href="#选择Convert还是Formatter" class="headerlink" title="选择Convert还是Formatter"></a>选择Convert还是Formatter</h3><ul>
<li>Converter是一般工具，<strong><em>可以将一种类型转换成另一种类型</em></strong>，Converter既可用在Web层，也可用在其他层中</li>
<li>Formatter只能将String转换成另一种类型，Formatter适用于web层，将表单属性进行类型转换</li>
<li>因此在Spring MVC程序中，选择Formatter比选择Converter更合适</li>
</ul>
<h2 id="使用joda-time注解对日期格式转换"><a href="#使用joda-time注解对日期格式转换" class="headerlink" title="使用joda-time注解对日期格式转换"></a>使用joda-time注解对日期格式转换</h2><p>SpringMVC默认不支持字符串转换成Date格式，可以采用SpringMVC自带的转换器，还有一种简单的方法：</p>
<p>注解可以加载javaBean上:</p>
<pre><code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date birthday;
</code></pre><p>注解接在方法参数上：</p>
<pre><code>public void test(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) @RequestParam(&quot;date&quot;) Date date){
    System.out.println(date);
}
</code></pre><p>需要导入依赖：</p>
<pre><code>&lt;!--时间操作组件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;joda-time&lt;/groupId&gt;
    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
    &lt;version&gt;${joda-time.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="应用-Autowired和-Service进行依赖注入"><a href="#应用-Autowired和-Service进行依赖注入" class="headerlink" title="应用@Autowired和@Service进行依赖注入"></a>应用@Autowired和@Service进行依赖注入</h2><ul>
<li><p>将依赖注入到Spring MVC控制器的最简单方法是通过<strong><em>注解@Autowired到字段或方法</em></strong></p>
<pre><code>@Autowired
private ProductService productService;
</code></pre></li>
<li><p>能被作为依赖注入的类必须<strong><em>声明@Service</em></strong>，</p>
<pre><code>@Service
public class ProductServiceImpl implements ProductService {
</code></pre></li>
<li><p>在配置文件中还需添加一个<component-scan>元素来<strong><em>扫描依赖基本包</em></strong></component-scan></p>
<pre><code>&lt;context:component-scan base-package=&quot;cn.apeius.product5.service&quot;/&gt;
</code></pre></li>
</ul>
<h2 id="验证器Validator（JSR-spring5-0不通过）！！！"><a href="#验证器Validator（JSR-spring5-0不通过）！！！" class="headerlink" title="验证器Validator（JSR spring5.0不通过）！！！"></a>验证器Validator（JSR spring5.0不通过）！！！</h2><p>如果一个程序中既有Formatter，又有Validator（验证器），那么在调用Controller期间，将会有一个或者多个<font color="red"><strong><em>Formatter</em></strong> </font>试图将字符串转成domain对象中个属性值，一旦转换成功，<font color="red"><strong><em>验证器</em></strong> </font>就会介入</p>
<h3 id="Spring验证器"><a href="#Spring验证器" class="headerlink" title="Spring验证器"></a>Spring验证器</h3><h4 id="验证的Product对象"><a href="#验证的Product对象" class="headerlink" title="验证的Product对象"></a>验证的Product对象</h4><pre><code>public class Product implements Serializable {
    private static final long serialVersionUID = 748392348L;
    private String name;
    private String description;
    private Float price;
    private Date productionDate;

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public Float getPrice() {
        return price;
    }
    public void setPrice(Float price) {
        this.price = price;
    }
    public Date getProductionDate() {
        return productionDate;
    }
    public void setProductionDate(Date productionDate) {
        this.productionDate = productionDate;
    }

}
</code></pre><h4 id="实现Validator接口"><a href="#实现Validator接口" class="headerlink" title="实现Validator接口"></a>实现Validator接口</h4><pre>
<font color="red">/*需要实现接口中supports和validate两个方法*/</font>
public class ProductValidator implements Validator {

    <font color="red">/*如果验证器可以处理指定的Class，supports方法将返回true*/</font>
    public boolean supports(Class<?> klass) {
        return Product.class.isAssignableFrom(klass);
    }

    <font color="red">/*validate方法验证目标对象，并将错误填入Errors对象*/</font>
    public void validate(Object target, Errors errors) {
        Product product = (Product) target;
        <font color="blue">/*
        1、给Errors对象添加错误最容易的方法是调用Errors对象的一个reject或rejectValue方法，
        大多时候只传入一个错误码，Spring会在属性文件中查找错误码，获得相应的错误信息
            void reject(String errorcode)
            void rejectValue(String field, String errorCode)
        2、使用ValidationUtils类
            if(firstName == null || firstName.isEmpty()) errors.rejectValue("price","xxx")
            等效于 ValidationUtils.rejectIfEmpty("price");
        */</font>
        ValidationUtils.rejectIfEmpty(errors, "name", "productname.required");
        ValidationUtils.rejectIfEmpty(errors, "price", "price.required");
        ValidationUtils.rejectIfEmpty(errors, "productionDate", "productiondate.required");

        Float price = product.getPrice();
        if (price != null && price < 0) {
            errors.rejectValue("price", "price.negative");
        }

        Date productionDate = product.getProductionDate();
        if (productionDate != null) {
            // The hour,minute,second components of productionDate are 0
            if (productionDate.after(new Date())) {
                errors.rejectValue("productionDate", "productiondate.invalid");
            }
        }
    }
}
</pre>

<h4 id="错误信息属性文件"><a href="#错误信息属性文件" class="headerlink" title="错误信息属性文件"></a>错误信息属性文件</h4><p>若想要从某个属性文件获取错误消息，则要通过声明messageSource bean告诉spring去那里查找这个文件</p>
<p><strong><em>messageSource bean</em></strong></p>
<pre><code>&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;
    &lt;property name=&quot;basename&quot; value=&quot;/WEB-INF/resource/messages&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong><em>messages.properties</em></strong></p>
<pre><code>productname.required.product.name=Please enter a product name
price.required=Please enter a price
productiondate.required=Please enter a production date
productiondate.invalid=Invalid production date. Please ensure the production date is not later than today.
price.negative=price should be positive
</code></pre><h4 id="Controller类"><a href="#Controller类" class="headerlink" title="Controller类"></a>Controller类</h4><pre>
@Controller
public class ProductController {

    private static final Log logger = LogFactory
            .getLog(ProductController.class);

    @RequestMapping(value = "/product_input")
    public String inputProduct(Model model) {
        model.addAttribute("product", new Product());
        return "ProductForm";
    }

    @RequestMapping(value = "/product_save")
    public String saveProduct(@ModelAttribute Product product,
            <font color="red">BindingResult bindingResult</font>, Model model) {<font color="red">//BindingResult继承Errors接口</font>        
        logger.info("product_save");
        <font color="red">/*实例化Vaildator类，调用其validate方法*/</font>
        ProductValidator productValidator = new ProductValidator();
        productValidator.validate(product, bindingResult);

        <font color="red">/*检验该验证器是否生成错误消息，需在BindingResult中调用hasErrors方法*/</font>
        if (bindingResult.hasErrors()) {
            FieldError fieldError = bindingResult.getFieldError();
            logger.info("Code:" + fieldError.getCode() + ", field:"
                    + fieldError.getField());

            return "ProductForm";
        }

        // save product here

        model.addAttribute("product", product);
        return "ProductDetails";
    }
}
</pre>

<h3 id="JSR-303验证"><a href="#JSR-303验证" class="headerlink" title="JSR 303验证"></a>JSR 303验证</h3><p>Hibernate Validator 是 Bean Validation 的参考实现。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code>&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;5.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="Product类"><a href="#Product类" class="headerlink" title="Product类"></a>Product类</h4><p>Prodcut类中的name和productionDate字段用JSR 303标注类型进行标注</p>
<pre><code>public class Product implements Serializable {
    private static final long serialVersionUID = 78L;

    @Size(min=1, max=10)
    private String name;

    private String description;
    private Float price;

    @Past
    private Date productionDate;

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public Float getPrice() {
        return price;
    }
    public void setPrice(Float price) {
        this.price = price;
    }
    public Date getProductionDate() {
        return productionDate;
    }
    public void setProductionDate(Date productionDate) {
        this.productionDate = productionDate;
    }

} 
</code></pre><h2 id="Spring-MVC-和-Struts2的区别"><a href="#Spring-MVC-和-Struts2的区别" class="headerlink" title="Spring MVC 和 Struts2的区别"></a>Spring MVC 和 Struts2的区别</h2><ul>
<li>Struts2的入口是filter，Spring MVC的入口是Servlet，两者的实现机制不同</li>
<li>Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用；Spring MVC是基于方法设计的，参数绑定到方法的形参，并且只有一个方法可以使用</li>
<li>Struts2必须是多例的（Struts2传递到的参数绑定到类的属性，如果是单例会导致不同用户数据的冲突），Spring MVC默认是单例的，所以Spring MVC的性能比Struts2好</li>
</ul>
<h2 id="jsp-和-jstl-视图解析器"><a href="#jsp-和-jstl-视图解析器" class="headerlink" title="jsp 和 jstl 视图解析器"></a>jsp 和 jstl 视图解析器</h2><p>userList.jsp</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1px&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt; 用户名&lt;/td&gt;
        &lt;td&gt; 密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt;
        &lt;tr&gt;
            &lt;td&gt; ${user.userName} &lt;/td&gt;
            &lt;td&gt; ${user.password} &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/c:forEach&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>controller代码</p>
<pre><code>@RequestMapping(value=&quot;/test12&quot;)
public ModelAndView test12(){
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;userList&quot;);
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();
    for(int i = 0 ; i &lt; 3 ; i ++){
        User user = new User();
        user.setUserName(&quot;user_name&quot;+i);
        user.setPassword(&quot;123456&quot;);
        userList.add(user);
    }
    mv.addObject(&quot;userList&quot;, userList);
    return mv;
}
</code></pre><h2 id="使用ResponseBody输出JSON"><a href="#使用ResponseBody输出JSON" class="headerlink" title="使用ResponseBody输出JSON"></a>使用ResponseBody输出JSON</h2><ul>
<li>在实际开发过程中json是最为常用的一种方式，所以Spring MVC提供了一种更为简便的方式输出数据，即使用@ResponseBody注解</li>
<li>需引入Jackson:Json处理工具包</li>
</ul>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>导入依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.4.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>返回json数组</p>
<pre><code>@RequestMapping(value=&quot;/test13&quot;)
@ResponseBody
public List&lt;User&gt; test13(){
    List&lt;User&gt; userList = new ArrayList&lt;User&gt;();

    for(int i = 0 ; i &lt; 3 ; i ++){
        User user = new User();
        user.setUserName(&quot;user_name&quot;+i);
        user.setPassword(&quot;123456&quot;);
        userList.add(user);
    }

    return userList;
}
</code></pre><p>返回单个json对象</p>
<pre><code>@RequestMapping(value=&quot;/test14&quot;)
@ResponseBody
public User test14(){
    User user = new User();
    user.setUserName(&quot;user_name&quot;);
    user.setPassword(&quot;123456&quot;);
    return user;
}
</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="http://i.imgur.com/BFUifSh.png" alt=""></p>
<h3 id="忽略某个JaveBean的属性"><a href="#忽略某个JaveBean的属性" class="headerlink" title="忽略某个JaveBean的属性"></a>忽略某个JaveBean的属性</h3><pre><code>// 密码
@JsonIgnore
private String password;
</code></pre><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>使用@RequestBody可以将请求的json字符串转化POJO对象</p>
<p><strong><em>传递json对象</em></strong></p>
<pre><code>@RequestMapping(value=&quot;/test15&quot;)
@ResponseStatus(value= HttpStatus.OK)
public void test15(@RequestBody User user){
    System.out.println(user);
}
</code></pre><p><strong><em>传递json数组</em></strong></p>
<pre><code>@RequestMapping(value=&quot;/test16&quot;)
@ResponseStatus(value= HttpStatus.OK)
public void test16(@RequestBody List&lt;User&gt; users){
    for(User user : users){
        System.out.println(user);
    }
}
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="定义文件上传解析器"><a href="#定义文件上传解析器" class="headerlink" title="定义文件上传解析器"></a>定义文件上传解析器</h3><p>在springmvc的配置文件中，去定义文件上传的解析器</p>
<pre><code>&lt;!-- 定义文件上传解析器 --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 设定默认编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;
    &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h3><pre><code>&lt;form method=&quot;post&quot; action=&quot;/SpringMVC_study/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>如果想要上传多个文件，在input元素中加入multiple属性：</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;file&quot; multiple/&gt;
</code></pre><h3 id="MultipartFile接口"><a href="#MultipartFile接口" class="headerlink" title="MultipartFile接口"></a>MultipartFile接口</h3><p>上传到Spring MVC程序的文件会被包在一个MultipartFile对象中，具有以下方法：</p>
<pre><code>byte[] getBytes() #以字节数组形式返回文件的内容
String getContentType() # 返回文件的内容类型
InputStream getInputStream() # 返回一个InputStream，从中读取文件的内容
String getName() # 以多部分的形式返回参数的名称
String getOriginalFilename() # 返回客户端本地驱动器中个初始文件名
String getSize() # 以字为单位，返回文件的大小
boolean isEmpty() # 表示被上传的文件是否为空
void transferTo(File destination) # 将上传的文件保存到目标目录下
</code></pre><h3 id="利用注解上传单文件"><a href="#利用注解上传单文件" class="headerlink" title="利用注解上传单文件"></a>利用注解上传单文件</h3><pre><code>@RequestMapping(value=&quot;/upload&quot;)
public String upload(@RequestParam(&quot;file&quot;) MultipartFile multipartFile)
        throws Exception {
    if (multipartFile != null) {
        // multipartFile.getOriginalFilename() 获取文件的原始名称
        multipartFile.transferTo(new File(&quot;d:\\tmp\\&quot; + multipartFile.getOriginalFilename()));
    }
    return &quot;redirect:/success.html&quot;;

}
</code></pre><h3 id="利用注解上传多文件"><a href="#利用注解上传多文件" class="headerlink" title="利用注解上传多文件"></a>利用注解上传多文件</h3><pre><code>@RequestMapping(value=&quot;/uploadMultipartFile&quot;)
public String uploadMultipartFile(@RequestParam(&quot;files&quot;) MultipartFile[] multipartFiles)
        throws Exception {
    for(MultipartFile multipartFile : multipartFiles){
        if (multipartFile != null) {
            // multipartFile.getOriginalFilename() 获取文件的原始名称
            multipartFile.transferTo(new File(&quot;d:\\tmp\\&quot; + multipartFile.getOriginalFilename()));
        }
    }

    return &quot;redirect:/success.html&quot;;

}
</code></pre><h3 id="利用domain类上传文件★★★★★"><a href="#利用domain类上传文件★★★★★" class="headerlink" title="利用domain类上传文件★★★★★"></a>利用domain类上传文件★★★★★</h3><p>Product类中加入了新的属性 List<multipartfile> images：</multipartfile></p>
<pre>
public class Product implements Serializable {
    private static final long serialVersionUID = 74458L;

    @NotNull
    @Size(min=1, max=10)
    private String name;

    private String description;
    private Float price;
    <font color="red">private List&lt;MultipartFile> images;</font>

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public Float getPrice() {
        return price;
    }
    public void setPrice(Float price) {
        this.price = price;
    }
    public List&lt;MultipartFile> getImages() {
        return images;
    }
    public void setImages(List&lt;MultipartFile> images) {
        this.images = images;
    }
}
</pre>

<p>控制器：</p>
<pre><code>@RequestMapping(value = &quot;/product_save&quot;)
public String saveProduct(HttpServletRequest servletRequest,
        @ModelAttribute Product product, BindingResult bindingResult,
        Model model) {

    List&lt;MultipartFile&gt; files = product.getImages();

    List&lt;String&gt; fileNames = new ArrayList&lt;String&gt;();

    if (null != files &amp;&amp; files.size() &gt; 0) {
        for (MultipartFile multipartFile : files) {

            String fileName = multipartFile.getOriginalFilename();
            fileNames.add(fileName);

            File imageFile = new File(servletRequest.getServletContext()
                    .getRealPath(&quot;/image&quot;), fileName);
            try {
                multipartFile.transferTo(imageFile);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // save product here
    model.addAttribute(&quot;product&quot;, product);
    return &quot;ProductDetails&quot;;
}
</code></pre><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><ul>
<li>HTML5 input元素的change事件，当input元素的值发生改变时，就会被触发</li>
<li>HTML5 在XMLHttpRequest对象中添加的progress事件，当异步使用XMLHttpRequest对象上传文件时，就会持续地触发progress对象，直到上传进度完成或取消。通过监听progress事件，可以监控文件上传操作的进度</li>
</ul>
<h4 id="UploadFile的domain类"><a href="#UploadFile的domain类" class="headerlink" title="UploadFile的domain类"></a>UploadFile的domain类</h4><p>UploadFile类中包含一个MultipartFile属性，代表一个文件</p>
<pre><code>public class UploadedFile implements Serializable {

    private static final long serialVersionUID = 72348L;    
    private MultipartFile multipartFile;

    public MultipartFile getMultipartFile() {
        return multipartFile;
    }

    public void setMultipartFile(MultipartFile multipartFile) {
        this.multipartFile = multipartFile;
    }
}
</code></pre><h4 id="Html5FileUploadController类"><a href="#Html5FileUploadController类" class="headerlink" title="Html5FileUploadController类"></a>Html5FileUploadController类</h4><pre>
@Controller
public class Html5FileUploadController {

    private static final Log logger = LogFactory
            .getLog(Html5FileUploadController.class);

    @RequestMapping(value = "/html5")
    public String inputProduct() {
        return "Html5";
    }

    @RequestMapping(value = "/file_upload")
    public void saveFile(HttpServletRequest servletRequest,
            <font color="red">@ModelAttribute UploadedFile uploadedFile,</font>
            BindingResult bindingResult, Model model) {

        MultipartFile multipartFile = uploadedFile.getMultipartFile();
        String fileName = multipartFile.getOriginalFilename();
        try {
            File file = new File(servletRequest.getSession().getServletContext().getRealPath("/file"), fileName);
            multipartFile.transferTo(file);
            System.out.println(file.getAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</pre>

<h4 id="html5-jsp"><a href="#html5-jsp" class="headerlink" title="html5.jsp"></a>html5.jsp</h4><p>html5.jsp的用户界面主要包含了一个名为progressBar的div元素，一个表单和另一个名为debug的div元素。progressBar用于展示上传进度，debug用于展示调试信息，表单中有一个类型为file的input元素的一个按钮，有一些注意点：</p>
<ul>
<li>标识为files的input元素，它有一个multiple属性，用于支持多文件选择</li>
<li>这个按钮不是一个提交按钮，单击它不会提交表单，脚本是利用XMLHttpRequest对象来完成上传的</li>
</ul>
<pre>
&lt;!DOCTYPE HTML>
&lt;html>
&lt;head>
&lt;script>
    <font color="red">/*①
    * JavaScript代码执行的第一个件事是分配四个变量：
    * totalFileLength，totalUploaded，fileCount，filesUploaded。
    * totalFileLength表示要上传的文件总长度，totalUploaded表示目前已经上传的字节数，
    * fileCount表示上传的文件数量，filesUploaded表示已经上传的文件数量
    */</font>
    var totalFileLength, totalUploaded, fileCount, filesUploaded;

    function debug(s) {
        var debug = document.getElementById('debug');
        if (debug) {
            debug.innerHTML = debug.innerHTML + '&lt;br/>' + s;
        }
    }

    <font color="red">/*②
    * 启动时将files input元素的change事件映射到onFileSelect函数，
    * 从本地目录选择了不同的文件，就会触发change事件；
    * 将按钮的click事件映射到startUpload函数，点击就执行上传操作
    */</font>
    window.onload = function() {
        document.getElementById('files').addEventListener(
                'change', onFileSelect, false);
        document.getElementById('uploadButton').
                addEventListener('click', startUpload, false);
    }

    <font color="red">/*③
    * 每当用户选择本地目录不同文件时就会调用该函数，计算fileCount和totalFileLength    
    */</font>
    function onFileSelect(e) {
        var files = e.target.files; // FileList object
        var output = [];
        fileCount = files.length;
        totalFileLength = 0;
        for (var i=0; i&lt;fileCount; i++) {
            var file = files[i];
            output.push(file.name, ' (',
                  file.size, ' bytes, ',
                  file.lastModifiedDate.toLocaleDateString(), ')'
            );
            output.push('&lt;br/>');
            debug('add ' + file.size);
            totalFileLength += file.size;
        }
        document.getElementById('selectedFiles').innerHTML = 
            output.join('');
        debug('totalFileLength:' + totalFileLength);
    }

    <font color="red">/*④
    * 当用户调用Upload按钮时，就会调用startUpload函数，初始化totalUploaded和filesUploaded，
    * 随之调用uploadNext函数，上传下一个文件
    */</font>
    function startUpload() {
        totalUploaded = filesUploaded = 0;
        uploadNext();
    }

    <font color="red">/*⑤★★★★★
    * 首先创建一个XMLHttpRequest和FormData对象，并将接下来要上传的文件添加到它的后面，
    * 随后，uploadNext函数将XMLHttpRequest对象的progress事件添加到onUploadProgress函数，
    * 并将load事件和error事件分别添加到onUploadComplete和onUploadFailed
    * 接下来打开一个服务器连接，并发出FormData
    * 在上传期间，会重复得调用onUploadProgress函数，让它有机会更新进度条
    */</font>
    function uploadNext() {
        var xhr = new XMLHttpRequest();
        var fd = new FormData();
        var file = document.getElementById('files').
                files[filesUploaded];
        fd.append("multipartFile", file);
        xhr.upload.addEventListener(
                "progress", onUploadProgress, false);
        xhr.addEventListener("load", onUploadComplete, false);
        xhr.addEventListener("error", onUploadFailed, false);
        xhr.open("POST", "file_upload");
        debug('uploading ' + file.name);
        xhr.send(fd);
    }

    <font color="red">/*⑥
    * 在上传期间，会重复得调用onUploadProgress函数，让它有机会更新进度条
    * 更新包括计算已经上传的总字节数比率，与选择文件的总字节数，得到上传比率
    * 更新div元素的宽度
    */</font>
    function onUploadProgress(e) {
        if (e.lengthComputable) {
            var percentComplete = parseInt(
                    (e.loaded + totalUploaded) * 100 
                    / totalFileLength);
            var bar = document.getElementById('bar');
            bar.style.width = percentComplete + '%';
            bar.innerHTML = percentComplete + ' % complete';
        } else {
            debug('unable to compute');
        }
    }

    <font color="red">/*⑦
    * 上传完成时，调用onUploadComplete函数，这个事件处理函数会增加totalUploaded，
    * 即已经上传的文件容量，并添加filesUploaded
    * 如果所有文件已经上传完毕，弹出文件已经成功完成的提示
    * 否则再次调用uploadNext
    */</font>
    function onUploadComplete(e) {
        totalUploaded += document.getElementById('files').
                files[filesUploaded].size;
        filesUploaded++;
        debug('complete ' + filesUploaded + " of " + fileCount);
        debug('totalUploaded: ' + totalUploaded);        
        if (filesUploaded &lt; fileCount) {
            uploadNext();
        } else {
            var bar = document.getElementById('bar');
            bar.style.width = '100%';
            bar.innerHTML = '100% complete';
            alert('Finished uploading file(s)');
        }
    }

    function onUploadFailed(e) {
        alert("Error uploading file");
    }   

&lt;/script>
&lt;/head>
&lt;body>
&lt;h1>Multiple file uploads with progress bar&lt;/h1>
&lt;div id='progressBar' style='height:20px;border:2px solid green'>
    &lt;div id='bar' 
            style='height:100%;background:#33dd33;width:0%'>
    &lt;/div>
&lt;/div>
&lt;form>
    &lt;input type="file" id="files" multiple/>
    &lt;br/>
    &lt;output id="selectedFiles">&lt;/output>
    &lt;input id="uploadButton" type="button" value="Upload"/>
&lt;/form>
&lt;div id='debug' 
    style='height:100px;border:2px solid green;overflow:auto'>
&lt;/div>
&lt;/body>
&lt;/html>
</pre>

<p><img src="http://i.imgur.com/eJ5uWnl.png" alt=""></p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul>
<li>只要把图片或者HTML这样的静态资源放在<strong><em>应用程序的目录下，或者放在应用程序目录的子目录下，而不是放在WEB-INF下</em></strong>，Servlet、JSP容器就会将该资源发送到浏览器，在浏览器中打开正确的URL即可下载</li>
<li>有时候静态资源是<strong><em>保存在应用程序目录外</em></strong>，或者<strong><em>保存在某一个数据库</em></strong>，或者<strong><em>有时候需要控制它的访问权限，方式其他网站交叉引用它</em></strong>，必须通过编程发送资源到浏览器</li>
</ul>
<h3 id="文件下载概览"><a href="#文件下载概览" class="headerlink" title="文件下载概览"></a>文件下载概览</h3><ol>
<li>对请求处理方法使用void返回类型（如果不需要页面跳转的话），并在方法中添加HttpServletResponse参数</li>
<li>将响应的内容类型设为文件的内容类型，例如 response.setContentType(“application/pdf”)，如果不清楚内容类型，希望浏览器始终显示Save as对话框，则将它设为application/octet-stream</li>
<li>添加一个名为Content-Disposition的HTTP响应标题，并赋值attachment; filename=fileName，这里的fileName是默认文件名，应该出现在File Download对话框中</li>
<li>将文件发送到浏览器</li>
</ol>
<h3 id="范例1：隐藏资源"><a href="#范例1：隐藏资源" class="headerlink" title="范例1：隐藏资源"></a>范例1：隐藏资源</h3><pre>
@RequestMapping(value="/resource_download")
public String downloadResource(HttpSession session, HttpServletRequest request,
        <font color="red">HttpServletResponse response</font>) {

    <font color="red">/*
    * 判断用户是否登录
    */</font>
    if (session == null || 
            session.getAttribute("loggedIn") == null) {
        return "LoginForm";
    }

    <font color="red">/*
    * 判断文件是否存在，并将文件发送到浏览器
    */</font>
    String dataDirectory = request.getSession().
            getServletContext().getRealPath("/WEB-INF/data");
    File file = new File(dataDirectory, "secret.pdf");

    if (file.exists()) {
        <font color="red">response.setContentType("application/pdf");
        response.addHeader("Content-Disposition", 
                "attachment; filename=secret.pdf");</font>        
        <font color="blue">byte[] buffer = new byte[1024];
        int len = 0;
        FileInputStream fis = null;
        OutputStream os = null;
        // if using Java 7, use try-with-resources
        try {
            fis = new FileInputStream(file);
            os = response.getOutputStream();
            while((len = fis.read(buffer)) != -1){
                os.write(buffer, 0, len);
            }
        } catch (IOException ex) {
            // do something, 
            // probably forward to an Error page
        } finally {
            if (os != null) {
                try {
                    os.close();
                } catch (IOException e) {
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                }
            }
        }</font>
    }
    return null;
}
</pre>

<h3 id="范例2：防止交叉引用"><a href="#范例2：防止交叉引用" class="headerlink" title="范例2：防止交叉引用"></a>范例2：防止交叉引用</h3><ul>
<li>通过编程控制，是的只有当<strong><em>refer标题中包含你的域名时</em></strong> 才发出资源，这样可以防盗链</li>
<li>但还是有办法下载到这些资源，但是绝对不会像以前那么容易得到</li>
</ul>
<p>ImageController.java</p>
<ul>
<li>如果直接在浏览器访问<a href="http://localhost:8080/SpringMVC_study/image_get/1返回404" target="_blank" rel="external">http://localhost:8080/SpringMVC_study/image_get/1返回404</a> not found</li>
<li>若加入注解 @RequestHeader String referer，直接访问，会导致调用getImage函数失败，根本无法进入函数体，也不进行refer是否为空的判断</li>
<li>通过images.html的超链接跳转，能访问到图片</li>
</ul>
<pre>
@Controller
public class ImageController {

    private static final Log logger = LogFactory.getLog(ImageController.class);

    @RequestMapping(value="/image_get/{id}", method = RequestMethod.GET)
    public void getImage(@PathVariable String id,
            HttpServletRequest request, 
            HttpServletResponse response,
            <font color="red">@RequestHeader String referer</font>) {
        <font color="red">if (referer != null) {</font>
            String imageDirectory = request.getSession().getServletContext().
                    getRealPath("/WEB-INF/image");
            File file = new File(imageDirectory, 
                    id + ".jpg");
            if (file.exists()) {
                response.setContentType("image/jpg");
                byte[] buffer = new byte[1024];
                int len = -1;
                FileInputStream fis = null;
                OutputStream os = null;
                // if you're using Java 7, use try-with-resources
                try {
                    fis = new FileInputStream(file);
                    os = response.getOutputStream();
                    while ((len = fis.read(buffer)) != -1) {
                        os.write(buffer, 0, len);
                    }
                } catch (IOException ex) {
                    // do something here
                } finally {
                    if (os != null) {
                        try {
                            os.close();
                        } catch (IOException e) {

                        }
                    }
                    if (fis != null) {
                        try {
                            fis.close();
                        } catch (IOException e) {

                        }
                    }
                }
            }
        }
    }
}
</pre>

<p>images.html</p>
<pre><code>&lt;a href=&quot;image_get/1&quot;&gt;图片1&lt;/a&gt;
</code></pre><h2 id="重定向与转发的区别"><a href="#重定向与转发的区别" class="headerlink" title="重定向与转发的区别"></a>重定向与转发的区别</h2><ul>
<li>重定向发生在浏览器，由浏览器重新发出http请求，转发发生web服务器，请求在web服务器转发  </li>
<li>重定向可以到外部网站，重定向只能访问WEB应用个资源  </li>
</ul>
<h2 id="方法的返回值为string"><a href="#方法的返回值为string" class="headerlink" title="方法的返回值为string"></a>方法的返回值为string</h2><ul>
<li>如果方法的返回值是string类型，那么此时表示返回值是视图名称viewname</li>
<li>当进行转发时，没有数据的传递，不需要去书写ModelAndView，直接书写返回值是String</li>
</ul>
<h2 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h2><ul>
<li>在转发地址前加上redirect：完成重定向，<font color="red"><strong><em>不需要加应用名</em></strong></font>，直接写URI</li>
<li>转发到外部网站，例 <code>return &quot;redirect:http://www.baidu.com&quot;;</code></li>
</ul>
<p>不带参数传递：</p>
<pre><code>@RequestMapping(value = &quot;test19&quot;)
public String test19(){
    System.out.println(&quot;19&quot;);
    return &quot;redirect:/success.html&quot;;
}
</code></pre><p>参数传递：</p>
<pre>
<font color="red">/*
* 1、重定向发生在浏览器，不能直接访问WEB-INF中的文件，书写的URL以/开头
* 2、需要传递的参数会自动拼接在url，本例中http://localhost:8080/SpringMVC_study/login.html?name=zhangsan
*/</font>
@RequestMapping(value = "/test23")
public ModelAndView test23(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("redirect:/login.html");
    modelAndView.addObject("name","zhangsan");
    return modelAndView;
}
</pre>

<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><ul>
<li>使用重定向的一个不便是<strong><em>无法轻松传值给目标页面</em></strong>，而采用转发可以将属性添加到Model，使得目标视图可以轻松访问。重定向经过客户端，<strong><em>Model中的一切都会在重定向时丢失</em></strong></li>
<li>Spring 3.1版本以及更高版本可以通过Flash属性提供一种<strong><em>重定向传值的方法</em></strong></li>
<li>使用Flash属性，必须在Spring MVC配置中有一个<code>&lt;mvc:annotation-driven/&gt;</code>，并且在方法上添加一个参数类型org.springframework.web.servlet.mvc.support.RedirectAttributes</li>
<li>使用方法：redirectAttributes.addFlashAttribute(“message”, “The product was successfully added.”);可以在转发页面访问到这个属性</li>
</ul>
<h2 id="转发的实现★★★★★★"><a href="#转发的实现★★★★★★" class="headerlink" title="转发的实现★★★★★★"></a>转发的实现★★★★★★</h2><ul>
<li><strong><em>Spring MVC中默认是转发</em></strong>，但返回的值默认是试图名称</li>
<li><strong><em>如需要实现请求方法间跳转、页面跳转</em></strong>，在试图名称之前添加forward: 要访问的路径</li>
</ul>
<pre><code>@RequestMapping(value = &quot;/test24&quot;)
public ModelAndView test24(){
    System.out.println(24);
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;forward:/test25&quot;);
    return mv;
}

@RequestMapping(value = &quot;/test25&quot;)
public ModelAndView test25(){
    System.out.println(25);
    ModelAndView mv = new ModelAndView();
    mv.setViewName(&quot;forward:/login.html&quot;);
    return mv;
}
</code></pre><h3 id="数据传递-1"><a href="#数据传递-1" class="headerlink" title="数据传递"></a>数据传递</h3><ul>
<li>在每次调用请求方法时，都会创建Model类型的一个实例</li>
<li>若打算使用该实例，在请求方法参数中加入org.springframework.ui.Model参数，Spring MVC会在每一个请求方法被调用时创建一个<strong><em>Model</em></strong>实例，用于增加需要显示在视图中的属性</li>
<li>调用model.addAttribute来添加属性</li>
</ul>
<h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h3><p>每次调用请求响应方法时都会<strong><em>创建Model类的一个实例</em></strong>，可以<strong><em>在方法中添加一个Model类型的参数</em></strong>，也可以在方法中<strong><em>添加ModelAttribute注解类型</em></strong><font color="red"> <strong>来访问Model实例</strong></font></p>
<h4 id="不加ModelAttribute"><a href="#不加ModelAttribute" class="headerlink" title="不加ModelAttribute"></a>不加ModelAttribute</h4><p>先看一个没有使用@ModelAttribute的Controller方法：</p>
<pre><code>@RequestMapping(&quot;/save&quot;)  
public String save(User user) {  
    user.setUsername(&quot;U love me&quot;);  
    userService.save(user);  
    return &quot;result&quot;;  
}  
</code></pre><p>等价于：</p>
<pre><code>@RequestMapping(&quot;/save&quot;)  
public String save(Model model,int id,String username) {  
    User user=new User();  
    //这里是通过反射从request里面拿值再set到user  
    user.setId(id);  
    user.setUsername(username);  
    model.addAttribute(&quot;user&quot;,user);  

    user.setUsername(&quot;U love me&quot;);  
    userService.save(user);  
    return &quot;result&quot;;  
}  
</code></pre><ul>
<li>其中User包含id和username两个私有属性,含有公共setter和getter方法</li>
<li>执行此方法时会将key为”user”(注意:这里即使参数名称是user1，key一样还是”user”)，value为user的对象加入到model</li>
</ul>
<h4 id="用途一："><a href="#用途一：" class="headerlink" title="用途一："></a>用途一：</h4><ul>
<li>带ModelAttribute注解的参数会将对象添加到Model中</li>
<li><font color="red"><strong><em>与不加ModelAttribute的区别：</em></strong></font>带ModelAttribute注解会先从model去获取key为”user”的对象，如果获取不到会通过反射实例化一个User对象，再从request里面拿值set到这个对象，然后把这个User对象添加到model(其中key为”user”).<br>使用了@ModelAttribute可修改这个key，不一定是”user”，此情况下，<strong><em>用与不用@ModelAttribute没有区别</em></strong></li>
</ul>
<pre>
<font color="red">/*
本例中将用newOrder键值将Order实例添加到Model对象中；
如果为定义键值，则键值将使用对象类型的名字，即用键值order将Order实例添加到Model中*/</font>
public String summitOrder(@ModelAttribute("newOrder") Order order){

}
</pre>

<h4 id="用途二："><a href="#用途二：" class="headerlink" title="用途二："></a>用途二：</h4><ul>
<li>标注一个<font color="red"><strong><em>非请求的处理方法</em></strong></font>，Spring MVC会每次在调用<strong><em>请求处理方法之前</em></strong> 调用带@ModelAttribute注解的方法</li>
<li>@ModelAttribute注解的方法可以<strong><em>返回一个对象或一个void类型</em></strong>，如果返回一个对象，则返回对象会自动加到Model中，如未指定键值，键值为对象类型的名字</li>
<li>若返回类型为void，若需要将对象放入Model中，则必须添加一个Model类型的参数，并自行将实例添加到Model中</li>
</ul>
<pre><code>@ModelAttribute
public String test23(){
    return new String(&quot;qm&quot;);
}

@RequestMapping
public String test24(Model model){
    Map&lt;String, Object&gt; map = model.asMap();
    for(Map.Entry&lt;String,Object&gt; entry:map.entrySet()){
        System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());
    }
    return &quot;forward:/WEB-INF/views/hello.jsp&quot;;
}
</code></pre><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>在这个全球化的时代，编写能够支持<strong><em>不同语言的国家和地区的应用程序</em></strong> 越来越重要</p>
<h3 id="国际化应用程序的方式"><a href="#国际化应用程序的方式" class="headerlink" title="国际化应用程序的方式"></a>国际化应用程序的方式</h3><p>国际化应用程序的具体方式取决于有多少静态数据<strong><em>需要以不同的语言显示出来</em></strong>，这里有两种方式：</p>
<ol>
<li>如果大量数据是静态的，就要针对每一个语言区域单独创建一个资源版本</li>
<li>如果静态数据有限，可以将文本元素，<strong><em>如元件标签和错误消息隔离成为文本</em></strong>，每个文本文件保存着一个语言区域的译文，随后应用程序会自动获取每一个元素</li>
</ol>
<h3 id="语言区域-Locale"><a href="#语言区域-Locale" class="headerlink" title="语言区域 Locale"></a>语言区域 Locale</h3><p>java.util.Locale类表示一个语言区域，一个Locale对象包含3个主要原件：language、country、variant</p>
<ul>
<li>language是最主要的部分</li>
<li>语言本身不能区分一个语言区域，比如讲英语的国家很多，但不同国家讲的英语有区别</li>
<li>variant是一个特定于供应商或特定于浏览器的代号，例如用WIN代表Windows</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><pre><code>Locale(String language)
Locale(String language, String country)
Locale(String language, String country, String variant)
</code></pre><p>创建一个中国所用的中文Locale对象</p>
<pre><code>Locale locale = new Locale(&quot;zh&quot;,&quot;CN&quot;);
</code></pre><p>利用Locale类的静态方法来创建Local对象</p>
<pre><code>Locale locale = Locale.CHINA;
</code></pre><p>利用getDefault方法返回计算机的语言区域</p>
<pre><code>Locale locale = Locale.getDefault();
</code></pre><h4 id="ResourceBundle读取属性文件"><a href="#ResourceBundle读取属性文件" class="headerlink" title="ResourceBundle读取属性文件"></a>ResourceBundle读取属性文件</h4><p>区域属性文件值</p>
<p>国际化和本地化应用程序时，需要具备以下条件：</p>
<pre><code>1. 将文本文件隔离成属性文件
2. 选择和读取正确的属性文件
</code></pre><p>1、将文本文件隔离成属性文件，可以利用如下工具：<a href="http://javawind.net/tools/native2ascii.jsp?action=transform" target="_blank" rel="external">http://javawind.net/tools/native2ascii.jsp?action=transform</a> ，给出以下两个语言区域属性文件，文件的格式为：</p>
<pre><code>basename_languageCode_countryCode
</code></pre><p>MyResources_en_US.properties</p>
<pre><code>greetings=hello
</code></pre><p>MyResources_zh_CN.properties</p>
<pre><code>greetings=\u4f60\u597d
</code></pre><p>2、使用ResourceBundle类来读取属性文件中的值</p>
<pre><code>ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;MyResources&quot;, Locale.SIMPLIFIED_CHINESE);
System.out.println(resourceBundle.getString(&quot;greetings&quot;));//你好

resourceBundle = ResourceBundle.getBundle(&quot;MyResources&quot;, Locale.US);
System.out.println(resourceBundle.getString(&quot;greetings&quot;));//hello
</code></pre><p>3、在Spring MVC中，不直接使用ResourceBundle，而是利用messageSourceBean告诉Spring MVC要将属性文件保存在哪里</p>
<h3 id="国际化Spring-MVC应用程序"><a href="#国际化Spring-MVC应用程序" class="headerlink" title="国际化Spring MVC应用程序"></a>国际化Spring MVC应用程序</h3><p>在Spring MVC中，不直接使用ResourceBundle，而是利用messageSource bean告诉Spring MVC要将属性文件保存在哪里</p>
<h4 id="配置-messageSource-bean"><a href="#配置-messageSource-bean" class="headerlink" title="配置 messageSource bean"></a>配置 messageSource bean</h4><font color="red"><strong><em>利用messageSource bean告诉Spring MVC要将属性文件保存在哪里</em></strong></font>

<pre>
&lt;bean id="messageSource"
    class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
    <font color="red">//用两个基准名设置basenames的属性</font>
    &lt;property name="basenames" >
        &lt;list>
            &lt;value>/WEB-INF/resource/messages&lt;/value>
            &lt;value>/WEB-INF/resource/labels&lt;/value>
        &lt;/list>
    &lt;/property>
&lt;/bean>
</pre>

<p><img src="http://i.imgur.com/1T6Betq.png" alt=""></p>
<p>说明，上面定义的bean的类class有两种实现方式：</p>
<ul>
<li>一种是ReloadableResourceBundleMessageSource，提供了定时刷新功能，<strong><em>允许在不重启系统的情况下</em></strong>，更新资源的信息；<strong><em>它在应用程序目录下搜索这些属性文件</em></strong>，即WEB目录下搜索</li>
<li>另一种是ResourceBundleMessageSource，它是不能重新加载的，如果在任意属性文件中修改了某一个属性的key或者value，那么要使修改生效，<strong><em>就必须重启JVM</em></strong>；属性文件必须放在<strong><em>类路径</em></strong> 下，即src目录下</li>
</ul>
<p>还有一个说明，如果只有一组属性文件，则可以用basename属性代替basenames，像下面这样：</p>
<pre><code>&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;
    &lt;property name=&quot;basename&quot; value=&quot;resource/messages&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="配置-语言区域解析器bean"><a href="#配置-语言区域解析器bean" class="headerlink" title="配置 语言区域解析器bean"></a>配置 语言区域解析器bean</h4><p>在Spring MVC中选择语言区域，可以使用语言区域解析器bean，它有几个实现，其中AcceptHeaderLocaleResolver是其中最容易使用的一个</p>
<pre><code>&lt;bean id=&quot;localeResolver&quot;
      class=&quot;org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver&quot;&gt;
&lt;/bean&gt;
</code></pre><h4 id="使用message标签"><a href="#使用message标签" class="headerlink" title="使用message标签"></a>使用message标签</h4><p>使用message标签，要在使用该标签的JSP页面声明这个taglib指令：</p>
<pre><code>&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;
</code></pre><p>使用message标签：</p>
<pre><code>&lt;label for=&quot;description&quot;&gt;&lt;spring:message code=&quot;label.description&quot;/&gt;: &lt;/label&gt;
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul>
<li>HandlerExecutionChain是一个执行链，从HandlerMapping返回给DispatcherServlet</li>
<li>其中包含Handler对象和Interceptor（拦截器）对象</li>
<li>SpringMVC的拦截器定义了三个方法<ul>
<li>preHandler：调用handler之前执行</li>
<li>postHandler：调用handler之后执行</li>
<li>afterCompletion：视图渲染完之后执行</li>
</ul>
</li>
</ul>
<h3 id="拦截器执行过程"><a href="#拦截器执行过程" class="headerlink" title="拦截器执行过程"></a>拦截器执行过程</h3><p><img src="http://i.imgur.com/z7vVxv6.png" alt=""></p>
<ul>
<li>在执行Handler前会经过多个拦截器</li>
<li>每个拦截器的前置方法会按照拦截器的顺序依次执行</li>
<li>每个拦截器的后置方法会从后向前执行</li>
<li>每个拦截器的afterCompletion方法会从后往前执行</li>
</ul>
<h3 id="编写自定义拦截器"><a href="#编写自定义拦截器" class="headerlink" title="编写自定义拦截器"></a>编写自定义拦截器</h3><pre>
public class MyInterceptor implements HandlerInterceptor {

    <font color="red">//前置方法，如果返回值是false，后面的拦截器不会执行；如果返回true，执行后面的拦截器</font>
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("前置方法");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("后置方法");
    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("完成方法");
    }
}
</pre>

<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><pre><code>&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--拦截器的路径--&gt;
        &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor&quot;&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre><h3 id="配置多个拦截器"><a href="#配置多个拦截器" class="headerlink" title="配置多个拦截器"></a>配置多个拦截器</h3><pre><code>&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--拦截器的路径--&gt;
        &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor1&quot;&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--配置连接器的路径，/**表示表示拦截所有的请求--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--拦截器的路径--&gt;
        &lt;bean class=&quot;cn.apeius.springmvc.interceptor.MyInterceptor2&quot;&gt;&lt;/bean&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre><p>若配置1，2，3，4多个拦截器，如果3的前置方法返回false，则：</p>
<ul>
<li>拦截器4的所有方法都不会执行</li>
<li>拦截器1，2的完成方法仍会去执行</li>
<li>1，2，3的后置方法不会执行</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://i.imgur.com/6ge6LQ1.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/22/[Java]Java分层思想——Struts+Hibernate+接口编程的方式/" itemprop="url">
                  Java分层思想——Struts+Hibernate+接口编程的方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-22T00:00:00+08:00" content="2016-08-22">
              2016-08-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h2><ul>
<li>通过接口(使用动态代理)，就达到web层和业务层的解耦（业务层代码改动，web层不需要重写，达到解耦）</li>
<li>数据库有两张表，分别是users表和message表，对应的在业务层有Users对象、UsersService对象；Message对象、MessageService对象</li>
<li>在web层定义UsersServiceInter接口，业务层实现类UsersServiceImp；同理定义MessageServiceInter解耦，业务层实现类MessageServiceImp</li>
<li>定义一个基础接口BaseServiceInter，把一些通用的方法直接定义到该接口内，子接口继承</li>
<li>BaseService类实现BaseServiceInter接口，包含基础方法</li>
</ul>
<h2 id="留言板工程"><a href="#留言板工程" class="headerlink" title="留言板工程"></a>留言板工程</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/NoteBook" target="_blank" rel="external">https://github.com/rhapsody1290/NoteBook</a></p>
<h3 id="程序框架图"><a href="#程序框架图" class="headerlink" title="程序框架图"></a>程序框架图</h3><p><img src="http://i.imgur.com/DP9tp0e.png" alt=""></p>
<h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h3><p><img src="http://i.imgur.com/WCtAkwy.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/[Java]优雅代码解析/" itemprop="url">
                  优雅代码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T00:00:00+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="判断两个对象是否相等"><a href="#判断两个对象是否相等" class="headerlink" title="判断两个对象是否相等"></a>判断两个对象是否相等</h2><h3 id="判断两个对象是否相等代码"><a href="#判断两个对象是否相等代码" class="headerlink" title="判断两个对象是否相等代码"></a>判断两个对象是否相等代码</h3><pre><code>public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Employee employee = (Employee) o;

    if (id != null ? !id.equals(employee.id) : employee.id != null) return false;
    if (name != null ? !name.equals(employee.name) : employee.name != null) return false;
    if (email != null ? !email.equals(employee.email) : employee.email != null) return false;
    if (hiredate != null ? !hiredate.equals(employee.hiredate) : employee.hiredate != null) return false;

    return true;
}
</code></pre><p>其中Employee有如下属性：</p>
<pre><code>public class Employee {
    private Integer id;
    private String name;
    private String email;
    private Date hiredate;
}
</code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>判断两个对象是否相等的原则：<strong><em>对象类型相同</em></strong>，而且<strong><em>属性值全部相等</em></strong></p>
<p>1、如果两个对象地址相等，两个对象一定相等</p>
<pre><code>if( this == o ) return true;
</code></pre><p>2、两个对象类型不相等，两个一定不相等</p>
<pre><code>if( getClass() != o.getClass() ) return false;
养成一个好习惯，在使用对象前判断对象o是否为空
考虑到如果比较对象o为空null，但当前对象this必然不为null，不相等，可以结合起来：
if( o == null || getClass() != o.getClass() ) return false;
</code></pre><p>3、如果两个对象所有属性相等，两个对象才相等，否则判定为不相等</p>
<pre><code>类型强转:Employee employee = (Employee) o;
如果属性不相等，return false
if( !id.equals(employee.id) ) return false;
同样，需要判断id是否为空。如果id为空，不能使用equals作为判断方法，如下
if( id == null &amp;&amp; employee.id != null || id != null &amp;&amp; !id.equals(employee.id) ) return false;
使用三目运算符让代码更加优雅：
if( id != null ? !id.equals(employee.id) : employee.id != null) return false
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/[Maven]Maven安装及基础功能/" itemprop="url">
                  Maven安装及基础功能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T00:00:00+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index">
                    <span itemprop="name">Maven</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Maven作用★★★★★"><a href="#Maven作用★★★★★" class="headerlink" title="Maven作用★★★★★"></a>Maven作用★★★★★</h2><ul>
<li>统一开发规范与工具：项目目录结构，配置文件、单元测试代码位置；项目构建工具，自动完成那个编译、测试、打包等工作</li>
<li>统一管理 jar 包：Maven 中央仓库下载jar包</li>
</ul>
<h2 id="项目构建过程"><a href="#项目构建过程" class="headerlink" title="项目构建过程"></a>项目构建过程</h2><p>Maven是一个跨平台的项目管理工具，主要用于基于java平台的项目构建，依赖管理。</p>
<p>如图为项目构建的过程</p>
<p> <img src="http://img.blog.csdn.net/20160308115250226" alt="这里写图片描述"></p>
<h2 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h2><h3 id="Maven的安装"><a href="#Maven的安装" class="headerlink" title="Maven的安装"></a>Maven的安装</h3><p><strong><em>Jdk的情况</em></strong></p>
<pre><code>Jdk必须1.6以上的版本
</code></pre><p><strong><em>从官网下载maven</em></strong></p>
<pre><code>从http://maven.apache.org/官网上下载最新版本的maven
</code></pre><p><strong><em>设定path路径</em></strong></p>
<pre><code>1、配置M2_HOME的环境变量，新建一个系统变量：M2_HOME，路径是maven的安装目录
2、配置path环境变量，在path值的末尾添加&quot;%M2_HOME%\bin&quot;
</code></pre><p><strong><em>建库</em></strong></p>
<pre><code>打开conf文件夹下的settings.xml文件，找到第53行，把注释去掉，修改成：&lt;localRepository&gt;D:\Maven\repo&lt;/localRepository&gt;，当然了，前提是在某个路径下，手动建立了一个名为 repo的文件夹，然后把本地仓库指向该路径。
</code></pre><p><strong><em>利用命令行检查是否成功</em></strong></p>
<pre><code>mvn -v
</code></pre><h3 id="maven的约定"><a href="#maven的约定" class="headerlink" title="maven的约定"></a>maven的约定</h3><pre><code>src/main/java        存放项目的java文件
src/main/resources   存放项目的资源文件，如spring，hibernate的配置文件
src/test/java        存放所有的测试的java文件
src/test/resources   存放测试用的资源文件
target               项目输出位置
pom.xml              项目配置文件
</code></pre><h3 id="maven的命令"><a href="#maven的命令" class="headerlink" title="maven的命令"></a>maven的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mvn archetype:create ：创建 Maven 项目</div><div class="line">mvn compile ：编译源代码</div><div class="line">mvn test-compile ：编译测试代码</div><div class="line">mvn test ： 运行应用程序中的单元测试</div><div class="line">mvn site ： 生成项目相关信息的网站</div><div class="line">mvn clean ：清除目标目录中的生成结果</div><div class="line">mvn package ： 依据项目生成 jar 文件</div><div class="line">mvn install ：在本地 Repository 中安装 jar</div><div class="line">mvn eclipse:eclipse ：生成 Eclipse 项目文件</div><div class="line">mvn -Dmaven.test.skip=true : 忽略测试文档编译</div></pre></td></tr></table></figure>
<h2 id="maven项目快速入门"><a href="#maven项目快速入门" class="headerlink" title="maven项目快速入门"></a>maven项目快速入门</h2><h3 id="hello项目"><a href="#hello项目" class="headerlink" title="hello项目"></a>hello项目</h3><ul>
<li>在myeclipse建立一个项目Hello，删除自动生成的src文件，建立4个Source Folder文件夹，名字如图所示：<br>　　　　<img src="http://img.blog.csdn.net/20160308191157113" alt="列表内容"></li>
<li>创建一个包cn.itcast.maven，并在该包下创建一个<strong><em>类</em></strong> Hello</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Hello&#123;</div><div class="line">    public void hello()&#123;</div><div class="line">        System.out.println(&quot;say hello&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在src/test/java中创建一个包cn.itcast.maven，创建一个<strong><em>测试类</em></strong> HelloTest，测试类中调用Hello类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class HelloTest&#123;</div><div class="line">    public void testHello()&#123;</div><div class="line">        Hello hello = new Hello();</div><div class="line">        hello.hello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>编辑pom.xml文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">	&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;Hello&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;name&gt;Hello&lt;/name&gt;</div><div class="line">	</div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;4.9&lt;/version&gt;</div><div class="line">			&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<ul>
<li>用maven命令编译项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mvn compile</div><div class="line"></div><div class="line">命令行出现BUILD SUCCESS，表明编译成功</div></pre></td></tr></table></figure>
<ul>
<li>target文件夹的变化，可以看到编译后的文件全部放入到了target里。    </li>
</ul>
<p><img src="http://img.blog.csdn.net/20160310104705856" alt="列表内容"></p>
<ul>
<li>clean，执行命令<strong>mvn clean</strong>,可以看到target的目录没有了。</li>
<li>test，执行<strong>mvn test</strong>命令，自动生成测试报告</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160308192143954" alt="这里写图片描述"></p>
<pre><code>说明：
target/classes 存放编译后的类
target/test-classes 存放编译后的测试类
target/surefire-reports 存放测试报告
</code></pre><ul>
<li>package，执行mvn package，完成打包工作</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160308192628080" alt="这里写图片描述"></p>
<pre><code>说明：
target/classes 编译后的类的路径
target/test-classes 编译后的测试类的路径
target/surefire-reports 测试报告
target/maven-archiver 执行package的归档
Hello-0.0.1-SNAPSHOT.jar 执行完package命令后打成的jar包
</code></pre><h3 id="Hellofriend项目"><a href="#Hellofriend项目" class="headerlink" title="Hellofriend项目"></a>Hellofriend项目</h3><ul>
<li>建立HelloFriend项目工程</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160310110111565" alt="这里写图片描述"></p>
<ul>
<li>建立cn.itcast.maven包及HelloFriend类</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160310111901071" alt="这里写图片描述"></p>
<ul>
<li>编辑HelloFriend类，引用之前编写的Hello类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class HelloFriend &#123;</div><div class="line">	public void helloFriend()&#123;</div><div class="line">		Hello hello = new Hello();</div><div class="line">		hello.hello();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>编写pom.xml文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">	&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;HelloFriend&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;name&gt;HelloFriend&lt;/name&gt;</div><div class="line">	</div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;4.9&lt;/version&gt;</div><div class="line">			&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;Hello&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">			&lt;scope&gt;compile&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line">	</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>执行mvn compile命令</p>
<p>  执行这个命令的时候会出错，因为HelloFriend项目是建立在Hello项目基础之上的，但是现在工程中没有引入Hello.java这个类。所以会出错。</p>
</li>
<li><p>执行mvn clean install命令</p>
<p>  1、    打开命令行<br>  2、    把当前路径调节到Hello工程的根目录<br>  3、    执行mvn clean install命令，把Hello整个工程放入到仓库中</p>
</li>
</ul>
<p>如果执行成功，则会在仓库中看到</p>
<p><img src="http://img.blog.csdn.net/20160310111201493" alt="这里写图片描述"></p>
<ul>
<li><p>执行mvn package命令打包HelloFriend工程</p>
<p>  可以看到成功以后，在target目录下多了一个jar包<br>  该jar包为当前工程的jar包。</p>
</li>
<li><p>建立cn.itcast.maven包和测试类HelloFriendTest类</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160310112454683" alt="列表内容"></p>
<ul>
<li>编辑HelloFriendTest类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class testHeloFriend &#123;</div><div class="line"></div><div class="line">	public void testHelloFriend()&#123;</div><div class="line">		HelloFriend helloFriend = new HelloFriend();</div><div class="line">		helloFriend.helloFriend();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>执行mvn package命令</p>
<p>  上图中的”say hello”就是输出的结果。</p>
</li>
</ul>
<h2 id="maven的核心概念"><a href="#maven的核心概念" class="headerlink" title="maven的核心概念"></a>maven的核心概念</h2><h3 id="项目对象模型"><a href="#项目对象模型" class="headerlink" title="项目对象模型"></a>项目对象模型</h3><p><img src="http://img.blog.csdn.net/20160310173933529" alt="这里写图片描述"></p>
<pre><code>说明：
maven根据pom.xml文件，把它转化成项目对象模型(POM)，这个时候要解析依赖关系，然后去相对应的maven库中查找到依赖的jar包。
在clean，compile，test，package等阶段都有相应的Plug-in来做这些事情。
而这些plug-in会产生一些中间产物。
</code></pre><h3 id="插件的位置"><a href="#插件的位置" class="headerlink" title="插件的位置"></a>插件的位置</h3><pre><code>在maven解压后的位置D:\Maven\apache-maven-3.0.5-bin\apache-maven-3.0.5有一个bin文件夹，里面有一个文件m2.config文件  

set maven.home default ${user.home}/m2，其中该路径指明了仓库的存储位置。
</code></pre><p>其中settings.xml文件中,</p>
<pre><code>&lt;localRepository&gt;D:/Maven/repo&lt;/localRepository&gt;
</code></pre><p>这个说明了仓库中的位置。</p>
<pre><code>D:\Maven\repo\org\apache\maven\plugins
</code></pre><p>这里的插件就是执行maven的各种命令所需要的插件。</p>
<h3 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h3><p>maven坐标的主要组成</p>
<pre><code>groupId：定义当前maven项目属于哪个项目
artifactId：定义实际项目中的某一个模块
version：定义当前项目的当前版本
packaging：定义当前项目的打包方式

根据这些坐标，在maven库中可以找到唯一的jar包
</code></pre><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><pre><code>具体案例在3 Maven项目。
1、项目HelloSuperFriend依赖项目HelloFriend，项目HelloFriend依赖项目Hello。
2、在HelloSuperFriend依赖项中加入
    &lt;dependency&gt;
        &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;
        &lt;artifactId&gt;HelloFriend&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
3、能够编译通过，体现了依赖的传递性
</code></pre><h3 id="继承管理★★★★★"><a href="#继承管理★★★★★" class="headerlink" title="继承管理★★★★★"></a>继承管理★★★★★</h3><pre><code>现有一A项目，B、C项目同时依赖A项目，这是需要用到继承
</code></pre><p>1、创建一个项目ParentJunit</p>
<p><img src="http://img.blog.csdn.net/20160314203938379" alt="这里写图片描述"><br>　　　　<br>2、ParentJunit添加一个Junit依赖</p>
<p><img src="http://img.blog.csdn.net/20160314204137520" alt="这里写图片描述"></p>
<p>3、新建一个项目：HelloJunit，编写POM文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">    &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;ParentJunit&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure>
<p>4、只需要继承ParentJunit，所以junit就被引入到HelloJunit中了</p>
<h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><pre><code>可以根据maven坐标定义每一个jar包在仓库中的存储位置。
大致为：groupId/artifactId/version/
仓库的分类：
1、本地仓库
    ~/.m2/repository/，每一个用户也可以拥有一个本地仓库
2、远程仓库
    2.1 中央仓库：Maven默认的远程仓库，http://repo1.maven.org/maven2
    2.2 私服：是一种特殊的远程仓库，它是架设在局域网内的仓库
    2.3 镜像：用来替代中央仓库，速度一般比中央仓库快
</code></pre><p>jar查找顺序<br><img src="http://img.blog.csdn.net/20160314211004957" alt="这里写图片描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/[Maven]Maven基础POM配置讲解/" itemprop="url">
                  Maven基础POM配置讲解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-18T00:00:00+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index">
                    <span itemprop="name">Maven</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h2><h3 id="maven坐标的主要组成"><a href="#maven坐标的主要组成" class="headerlink" title="maven坐标的主要组成"></a>maven坐标的主要组成</h3><pre><code>groupId：定义当前maven项目属于哪个项目
artifactId：定义实际项目中的某一个模块
version：定义当前项目的当前版本
packaging：定义当前项目的打包方式 jar、war

根据这些坐标，在maven库中可以找到唯一的jar包
其中groupId、artifactId、version是必须定义的，packaging是可选的（默认是jar）
</code></pre><h3 id="Maven模块概念"><a href="#Maven模块概念" class="headerlink" title="Maven模块概念"></a>Maven模块概念</h3><p>1、Maven中，一个项目会被划分成很多模块，比如org.SpringFramework项目，对应的Maven模块有很多：spring-core、spring-context</p>
<p>2、groudId不应该只对应到公司（组织）的名称，而应定义到项目名</p>
<h2 id="POM-xml"><a href="#POM-xml" class="headerlink" title="POM.xml"></a>POM.xml</h2><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; #这个是POM的版本号，现在都是4.0.0 的，必须得有，但不需要修改。

    &lt;groupId&gt;com.smart&lt;/groupId&gt; #定义当前maven项目属于哪个项目
    &lt;artifactId&gt;smart-demo&lt;/artifactId&gt; #定义实际项目中的某一个模块
    &lt;version&gt;1.0&lt;/version&gt; #定义当前项目的当前版本
    &lt;packaging&gt;war&lt;/packaging&gt; #定义当前项目的打包方式

    &lt;name&gt;smart-demo Maven Webapp&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt; #name、ur表示该项目的名称与 URL 地址，意义不大，可以省略。

    &lt;dependencies&gt; #定义该项目的依赖关系
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;3.8.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt; #表示与构建相关的配置，这里的 finalName 表示最终构建后的名称 smart-demo.war，这里的 finalName 还可以使用另一种方式来定义
        &lt;finalName&gt;smart-demo&lt;/finalName&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre><h2 id="树形图表示POM-xml"><a href="#树形图表示POM-xml" class="headerlink" title="树形图表示POM.xml"></a>树形图表示POM.xml</h2><p><img src="http://i.imgur.com/4VMt6qa.png" alt=""></p>
<p>可见，除了<strong><em>项目的基本信息</em></strong>（<strong><em>Maven 坐标</em></strong>、<strong><em>打包方式</em></strong>等）以外，每个 pom.xml 都应该包括：</p>
<ol>
<li>Lifecycle（生命周期）</li>
<li>Plugins（插件）</li>
<li>Dependencies（依赖）</li>
</ol>
<p>Lifecycle 是项目构建的生命周期，它包括 9 个 Phase（阶段）。</p>
<p>大家知道，Maven 是一个核心加上多个插件的架构，而这些插件提供了一系列非常重要的功能，这些插件会在许多阶段里发挥重要作用。</p>
<p><img src="http://i.imgur.com/8YUbAxw.png" alt=""></p>
<h2 id="依赖Scope（作用域）★★★★★"><a href="#依赖Scope（作用域）★★★★★" class="headerlink" title="依赖Scope（作用域）★★★★★"></a>依赖Scope（作用域）★★★★★</h2><p>我们可以在 pom.xml 中定义一些列的项目依赖（构件包），每个构件包都会有一个 Scope（作用域），它表示该构件包在什么时候起作用，包括以下五种：</p>
<ol>
<li><p>compile：默认作用域，在编译、测试、运行时有效</p>
</li>
<li><p>test：对于测试时有效</p>
</li>
<li><p>runtime：对于测试、运行时有效</p>
</li>
<li><p>provided：对于编译、测试时有效，但在运行时无效（jar包在编译运行时有效，但在发布时由容器提供，不需要发布）</p>
</li>
<li><p>system：与 provided 类似，但依赖于系统资源</p>
</li>
</ol>
<p>可以一张表格表示：</p>
<p><img src="http://i.imgur.com/v8GTA8V.png" alt=""></p>
<h2 id="POM模版"><a href="#POM模版" class="headerlink" title="POM模版"></a>POM模版</h2><pre><code>&lt;dependencies&gt;
    &lt;!-- JUnit --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.25&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- Servlet --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- AspectJ --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
        &lt;version&gt;1.7.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.7.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Hibernate4 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- for JPA, use hibernate-entitymanager instead of hibernate-core --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 以下可选 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-envers&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-proxool&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-infinispan&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
        &lt;version&gt;3.2.0.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt;
        &lt;version&gt;1.0.0.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss&lt;/groupId&gt;
        &lt;artifactId&gt;jandex&lt;/artifactId&gt;
        &lt;version&gt;1.1.0.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 为了让Hibernate使用代理模式，需要javassist --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.javassist&lt;/groupId&gt;
        &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;version&gt;3.18.1-GA&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;
        &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;
        &lt;version&gt;3.1.3.GA&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.spec.javax.annotation&lt;/groupId&gt;
        &lt;artifactId&gt;jboss-annotations-api_1.2_spec&lt;/artifactId&gt;
        &lt;version&gt;1.0.0.Final&lt;/version&gt;
    &lt;/dependency&gt;


    &lt;dependency&gt;
        &lt;groupId&gt;antlr&lt;/groupId&gt;
        &lt;artifactId&gt;antlr&lt;/artifactId&gt;
        &lt;version&gt;2.7.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dom4j&lt;/groupId&gt;
        &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
        &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;commons-collections&lt;/groupId&gt;
        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
        &lt;version&gt;3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
        &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
        &lt;version&gt;1.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-pool&lt;/groupId&gt;
        &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
        &lt;version&gt;1.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-jpa-2.0-api&lt;/artifactId&gt;
        &lt;version&gt;1.0.0.Final&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- tomcat7.0.35 数据库连接池 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt;
        &lt;version&gt;7.0.35&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Maven 那点事儿<br><a href="http://my.oschina.net/huangyong/blog/194583" target="_blank" rel="external">http://my.oschina.net/huangyong/blog/194583</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/12/[Hibernate]Hibernate笔记/" itemprop="url">
                  Hibernate笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-12T17:55:00+08:00" content="2016-08-12">
              2016-08-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h2><ul>
<li><strong><em>Hibernate是对jdbc进行轻量级封装的ORM框架，位于数据持久层</em></strong></li>
<li>ORM全称对象关系映射，框架在Java对象与关系数据库之间建立 <strong><em>映射</em></strong>，以实现 <strong><em>直接存取</em></strong> Java对象</li>
</ul>
<h2 id="Hibernate参考资料"><a href="#Hibernate参考资料" class="headerlink" title="Hibernate参考资料"></a>Hibernate参考资料</h2><p>Hibernate3.2API.chm<br><a href="https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/Hibernate3.2API.chm" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/Hibernate3.2API.chm</a></p>
<p>hibernate3.2_reference.pdf<br><a href="https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate3.2_reference.pdf" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate3.2_reference.pdf</a></p>
<h2 id="ORM概述"><a href="#ORM概述" class="headerlink" title="ORM概述"></a>ORM概述</h2><ul>
<li>传统数据持久化编程中，需要使用JDBC并配合大量的SQL语句。<strong><em>JDBC API与SQL语句夹杂在一起</em></strong>，开发效率都很低下</li>
<li>后来出现DAO模式，所有的JDBC API和SQL语句均移到了DAO层，<strong><em>但仍然需要编写大量的SQL语句</em></strong></li>
<li>ORM框架的思路是通过配置文件，将Java对象 <strong><em>映射</em></strong> 到关系型数据库，<strong><em>自动生成SQL语句</em></strong> 并执行</li>
<li>举个例子，<strong><em>插入数据</em></strong> 时就是把POJO的各个属性拼装成SQL语句，保存进数据库；<strong><em>读取数据</em></strong> 时，就是用SQL语句读取数据库，然后拼装成POJO对象返回</li>
</ul>
<h2 id="为什么需要Hibernate？"><a href="#为什么需要Hibernate？" class="headerlink" title="为什么需要Hibernate？"></a>为什么需要Hibernate？</h2><ul>
<li>使用jdbc操作数据库，SQL语句编写比较麻烦</li>
<li>切换数据库时需要重写SQL语句</li>
<li>我们程序员希望不关注数据库本身，而是关注业务本身</li>
</ul>
<p><img src="http://i.imgur.com/0aHzHBf.png" alt=""></p>
<p>　　引入Hibernate后，程序员在业务逻辑中使用hql语句（一种万能语句），Hibernate会自动完成数据库的操作，这种方式程序员只需关注业务本身，提高开发效率，程序也具有很好的移植性<br>　　<strong><em>学习Hibernate关键是1、Hibernate API 2、Hibernate核心配置文件 3、对象关系映射文件</em></strong></p>
<h2 id="Hibernate开发的三种方式"><a href="#Hibernate开发的三种方式" class="headerlink" title="Hibernate开发的三种方式"></a>Hibernate开发的三种方式</h2><p><img src="http://i.imgur.com/9vM5xkp.png" alt=""></p>
<p>数据库中的表与java domain对象，通过Hibernate的对象关系映射文件关联起来，该文件会说明表和对象的关系，以及<strong><em>对象的属性与表的字段的对应关系</em></strong></p>
<ul>
<li>开发方式一：由Domain对象 ——&gt; Mapping ——&gt; DB</li>
<li>开发方式二：由DB开始，用工具生成mapping和Domain object（使用较多）</li>
<li>开发方式三：由映射文件开始</li>
</ul>
<h2 id="Hibernate快速入门（第二种开发方式）★★★★★★"><a href="#Hibernate快速入门（第二种开发方式）★★★★★★" class="headerlink" title="Hibernate快速入门（第二种开发方式）★★★★★★"></a>Hibernate快速入门（第二种开发方式）★★★★★★</h2><h3 id="github代码"><a href="#github代码" class="headerlink" title="github代码"></a>github代码</h3><p><a href="https://github.com/rhapsody1290/Hibernate_Study" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study</a></p>
<h3 id="创建employee表"><a href="#创建employee表" class="headerlink" title="创建employee表"></a>创建employee表</h3><p><img src="http://i.imgur.com/tdPdlVh.png" alt=""></p>
<h3 id="开发domain对象"><a href="#开发domain对象" class="headerlink" title="开发domain对象"></a>开发domain对象</h3><ul>
<li><p>建议<strong><em>domain对象</em></strong> 的名称就是对应表的首字母大写，同时</p>
<ol>
<li>需要一个无参的构造函数(用于hibernate反射该对象)</li>
<li>应当有一个无业务逻辑的主键属性.</li>
<li>给每个属性提供 get/set 方法.</li>
<li>在domian对象中的属性，只有配置到了对象映射文件后，才会被hibernate管理.</li>
<li>属性一般是private范围</li>
</ol>
</li>
<li><p>该pojo按照规范应当序列化，目的是可以唯一标该对象。同时可以在网络和文件上传输</p>
</li>
</ul>
<pre><code>public class Employee implements Serializable{
    private Integer id;
    private String name;
    private String email;
    private  java.util.Date hiredate;

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Date getHiredate() {
        return hiredate;
    }

    public void setHiredate(Date hiredate) {
        this.hiredate = hiredate;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><h3 id="对象关系映射文件"><a href="#对象关系映射文件" class="headerlink" title="对象关系映射文件"></a>对象关系映射文件</h3><p>对象关系映射文件作用是用于指定domain对象和表的映射关系，该文件的取名有规范：<strong><em>domain对象.hbm.xml</em></strong>，一般我们放在和domain对象同一个文件夹下(包下)</p>
<pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping package=&quot;cn.apeius.domain&quot;&gt;

    &lt;class name=&quot;Employee&quot; table=&quot;employee&quot;&gt;
        &lt;!--id文件用于指定主键属性--&gt;
        &lt;id name = &quot;id&quot; column=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
            &lt;generator class=&quot;increment&quot;/&gt;
        &lt;/id&gt;
        &lt;!--对其他属性配置--&gt;
        &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
            &lt;column name=&quot;name&quot; length=&quot;255&quot; not-null=&quot;true&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;email&quot; type=&quot;java.lang.String&quot;&gt;
            &lt;column name=&quot;email&quot; length=&quot;255&quot; not-null=&quot;false&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;hiredate&quot; type=&quot;java.util.Date&quot;&gt;
            &lt;column name=&quot;hiredate&quot; length=&quot;255&quot; not-null=&quot;false&quot;/&gt;
        &lt;/property&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre><p><strong><em>细节</em></strong></p>
<p>对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如</p>
<pre><code>&lt;class table=&quot;?&quot; &gt; table值不配，则以类的小写做表名
&lt;property type=&quot;?&quot;&gt; type不配置，则hibernate会根据类的属性类型，选择一个适当的类型
</code></pre><h3 id="手动配置我们的hibernate-cfg-xml文件"><a href="#手动配置我们的hibernate-cfg-xml文件" class="headerlink" title="手动配置我们的hibernate.cfg.xml文件"></a>手动配置我们的hibernate.cfg.xml文件</h3><p>该文件用于配置连接的数据库的类型、driver、用户名、密码、url等，同时管理对象关系映射文件。<strong><em>该文件的名称，我们一般不修改</em></strong>.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;!--hibernate常用改的配置见：hibernate.properties--&gt;
        &lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&gt;
        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt;
        &lt;!--显示出对应的SQL语句--&gt;
        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;
        &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;
        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;
        &lt;mapping resource=&quot;Employee.hbm.xml&quot;/&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre><h3 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h3><pre><code>import cn.apeius.domain.Employee;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

/**
 * Created by Asus on 2016/8/16.
 */
public class Main {
    public static void main(String[] args){
        //1、创建configuration，该对象用于读取hibernate.ctf.xml，并完成初始化
        Configuration configuration = new Configuration().configure();
        //2、创建sessionFactory，这是一个会话工厂，是个重量级的对象，应当保证连接一个数据库SessionFactory是单例
        SessionFactory sessionFactory = configuration.buildSessionFactory();
        //3、创建session，相当于jdbc connection
        Session session = sessionFactory.openSession();
        //4、在进行增加、删除、修改的时候使用事务提交
        Transaction transaction = session.beginTransaction();
        //添加一个雇员
        Employee employee = new Employee();
        employee.setName(&quot;qm1&quot;);
        employee.setEmail(&quot;qm1@126.com&quot;);
        employee.setHiredate(new java.util.Date());
        //保存
        session.save(employee);
        //提交
        transaction.commit();
        session.close();
    }
}
</code></pre><h3 id="修改用户（先查后改）"><a href="#修改用户（先查后改）" class="headerlink" title="修改用户（先查后改）"></a>修改用户（先查后改）</h3><p>注意：SessionFactory是个重量级对象，应保证其实单例。在util包中封装了SessionFactory</p>
<pre><code>//获取一个会话
Session session = MySessionFactory.getInstatnce().openSession();
Transaction transaction = session.beginTransaction();
//修改用户1、获得要修改的对象2、修改
//load是通过主键属性，获取该对象实例
Employee employee = (Employee) session.load(Employee.class,2);//产生select .. where id = 2
employee.setName(&quot;钱明&quot;);//这句话会产生update语句
transaction.commit();
session.close();
</code></pre><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><pre><code>//获取一个会话
Session session = MySessionFactory.getInstatnce().openSession();
Transaction transaction = session.beginTransaction();
Employee employee = (Employee) session.load(Employee.class,2);
session.delete(employee);
transaction.commit();
session.close();
</code></pre><h2 id="模版（加入了异常回滚）★★★★★★"><a href="#模版（加入了异常回滚）★★★★★★" class="headerlink" title="模版（加入了异常回滚）★★★★★★"></a>模版（加入了异常回滚）★★★★★★</h2><pre><code>public static void updateEmployee() {
    //获取一个会话
    //Session session = MySessionFactory.getInstatnce().openSession();
    Session session = HibernateUtil.getCurrentSession();
    Transaction transaction = null;
    try{
        transaction = session.beginTransaction();
        //do...
        //修改用户1、获得要修改的对象2、修改
        //load是通过主键属性，获取该对象实例
        Employee employee = (Employee) session.load(Employee.class,3);//产生select .. where id = 2
        employee.setName(&quot;钱明&quot;);//这句话会产生update语句
        //出现异常
        //int i = 9/0;
        transaction.commit();
    }catch (Exception e){
        if(transaction != null){
            transaction.rollback();
        }
        throw new RuntimeException(e.getMessage());
    }finally {
        //关闭session
        if(session != null &amp;&amp; session.isOpen()){
            session.close();
        }
    }
}
</code></pre><h2 id="SessionFactory单例"><a href="#SessionFactory单例" class="headerlink" title="SessionFactory单例"></a>SessionFactory单例</h2><ul>
<li>SessionFactory是个重量级对象，在开发中保证只有一个SessionFactory</li>
<li>一个数据库对应一个SessionFactory对象</li>
</ul>
<pre><code>//单例模式
public class MySessionFactory {
    private MySessionFactory(){}
    private static class HoldClass{
        private static final SessionFactory instance = new Configuration().configure().buildSessionFactory();
    }
    public static SessionFactory getInstatnce(){
        return HoldClass.instance;
    }
}
</code></pre><h2 id="Maven下载各数据库JDBC及Hibernate配置文件"><a href="#Maven下载各数据库JDBC及Hibernate配置文件" class="headerlink" title="Maven下载各数据库JDBC及Hibernate配置文件"></a>Maven下载各数据库JDBC及Hibernate配置文件</h2><p>各数据库连接配置与maven依赖安装<br><a href="http://blog.163.com/luowei505050@126/blog/static/119907206201210223827126/" target="_blank" rel="external">http://blog.163.com/luowei505050@126/blog/static/119907206201210223827126/</a></p>
<h2 id="Hibernate切换数据库★★★★★"><a href="#Hibernate切换数据库★★★★★" class="headerlink" title="Hibernate切换数据库★★★★★"></a>Hibernate切换数据库★★★★★</h2><ul>
<li>使用Hibernate自动完成domain ——&gt; 映射文件 ——&gt; 表的工作</li>
<li>重新配置Hibernate数据库，以sqlserver2000为例</li>
<li><font color="red">增加属性hibernate.hbm2ddl.auto</font><ul>
<li>create : 当我们的应用程序加载hibernate.cfg.xml [ new Configuration().config(); ]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!!</li>
<li>update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则更新.</li>
<li>create-drop: 在显示关闭 sessionFactory时，将drop掉数据库的schema</li>
<li>validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致</li>
<li>在开发测试中，我们配置哪个都可以测试，但是如果项目发布后，最好自己配置一次，让对应的数据库生成，完后取消配置， </li>
</ul>
</li>
<li>修改主键生成策略</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;!--hibernate常用改的配置见：hibernate.properties--&gt;
        &lt;!-- 配置dialect方言,明确告诉hibernate连接是哪种数据库 --&gt;
        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;net.sourceforge.jtds.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:jtds:sqlserver://localhost:1433/hibernate&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.username&quot;&gt;sa&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.password&quot;&gt;sa&lt;/property&gt;
        &lt;!--显示出对应的SQL语句--&gt;
        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;
        &lt;!--让hibernate自动创建表 create:如果没有这张表则创建--&gt;
        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;
        &lt;mapping resource=&quot;Employee.hbm.xml&quot;/&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre><h2 id="Hibernate的核心类和接口★★★★★★★★★★"><a href="#Hibernate的核心类和接口★★★★★★★★★★" class="headerlink" title="Hibernate的核心类和接口★★★★★★★★★★"></a>Hibernate的核心类和接口★★★★★★★★★★</h2><p><img src="http://i.imgur.com/Xi1skxd.png" alt=""></p>
<h3 id="Configuration-类"><a href="#Configuration-类" class="headerlink" title="Configuration 类"></a>Configuration 类</h3><ul>
<li>读取hibernate.cfg.xml</li>
<li>加载hibernate的驱动、url、用户..</li>
<li>管理对象关系映射文件 <code>&lt;mapping resource=&quot;&quot;&gt;</code></li>
<li>管理hibernate配置信息</li>
</ul>
<h3 id="SessionFactory-（会话工厂）"><a href="#SessionFactory-（会话工厂）" class="headerlink" title="SessionFactory （会话工厂）"></a>SessionFactory （会话工厂）</h3><ul>
<li>可以缓存sql语句和数据(称为session级缓存)!!</li>
<li>是一个重量级的类，因此我们需要保证一个数据库，有一个SessionFactory</li>
<li>如果某个应用访问多个数据库，则要创建多个会话工厂，一个数据库一个会话工厂实例<br><img src="http://i.imgur.com/3zKcZfm.png" alt=""></li>
<li><p>通过SessionFactory接口可以获得Session实例，有两种方式：</p>
<ul>
<li>openSession() 是获取一个新的session</li>
<li>getCurrentSession () 获取和当前线程绑定的session,换言之，在同一个线程中，我们获取的session是同一session，这样更利于事务控制</li>
<li>使用 getCurrentSession 需要配置 hibernate.cfg.xml中配置<br>①如果使用本地事务（jdbc事务）<br><code>&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;</code><br>②如果使用全局事务（jta事务）<br><code>&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt;</code></li>
<li>如何选择<br>①如果需要在同一线程中，保证使用<strong><em>同一个Session</em></strong>，则使用getCurrentSession()<br>②如果在一个线程中，需要使用<strong><em>不同的Session</em></strong>,则使用opentSession()</li>
<li>通过 getCurrentSession() 获取的session在事务提交后，会自动关闭，通过openSession()获取的session则必须手动关闭</li>
<li><strong><em>如果是通过getCurrentSession()获取sesssion,进行查询需要事务提交</em></strong>.</li>
</ul>
</li>
</ul>
<p>　　<strong><em>使用同一个Session案例</em></strong></p>
<p><img src="http://i.imgur.com/pgTOK72.png" alt=""></p>
<p>　　在一个http请求中，需要同时进行操作、更新、删除等操作，三个操作在不同service中进行，但要将三个操作在一个事务中进行控制。三个service分别会调用hibernate，使用getCurrentSession，可以将三个操作在一个事务中进行（http请求只要不结束，就看成一个线程）</p>
<p>　　<strong><em>本地事务与全局事务</em></strong></p>
<p><img src="http://i.imgur.com/1xjDVPD.png" alt=""></p>
<p>　　本地事务：增对一个数据库的事务<br>　　全局事务：跨数据库的事务（JTA）。以银行转账为例，需要在农行账户中增加10元，在工行账户中减去10元，涉及到多个数据库中的事务</p>
<h3 id="session接口的理解"><a href="#session接口的理解" class="headerlink" title="session接口的理解"></a>session接口的理解</h3><ul>
<li><p>Session(会话)接口的理解：SessionFactory常驻内存，每次连接数据库会化工厂建立与数据库的session，图中横线就是一个session。</p>
</li>
<li><p>如何查看session是否关闭：查看数据库连接端口是否关闭，如mysql 3306端口是否关闭</p>
</li>
</ul>
<p><img src="http://i.imgur.com/CrHatM0.png" alt=""></p>
<p><img src="http://i.imgur.com/cvdhJFx.png" alt=""></p>
<p>session接口它的主要功能和作用是:</p>
<ul>
<li>Session一个实例代表与数据库的一次操作(当然一次操作可以是crud组合)</li>
<li>Session实例通过SessionFactory获取，用完需要关闭</li>
<li><strong><em>Session是线程不同步的(不安全),因此要保证在同一线程中使用,可以用 getCurrentSessiong()</em></strong></li>
<li>Session可以看做是持久化管理器,它是与持久化操作相关的接口</li>
</ul>
<h3 id="Session查询详解★★★★★★"><a href="#Session查询详解★★★★★★" class="headerlink" title="Session查询详解★★★★★★"></a>Session查询详解★★★★★★</h3><ul>
<li><p>如果查询不到数据，get 会返回 <strong><em>null</em></strong>,但是不会报错, load 如果查询不到数据，则<strong><em>报错ObjectNotFoundException</em></strong></p>
<pre>
Employee employee1 = (Employee) session.load(Employee.class,10);
System.out.println(employee1);//ObjectNotFoundException
Employee employee2 = (Employee) session.get(Employee.class,10);
System.out.println(employee2);//null
</pre>
</li>
<li><p>使用get去查询数据，先到缓存（session缓存、二级缓存）中去查，如果没有就到DB中取查，即立即向db发出查询请求(select …),</p>
</li>
<li>如果你使用的是load查询数据，先到缓存(session缓存、二级缓存)中查询，如果没有则返回一个代理对象（不马上到DB中去查）。等后面使用这个代理对象时才到DB中查询，如果后面没有使用查询结果，它不会真的向数据库发select，这个现象我们称为懒加载(lazy)<strong><em>【load是懒加载，返回代理对象，使用时候才去数据库查询】</em></strong><pre>
Employee employee1 = (Employee) session.load(Employee.class,1);
System.out.println(employee1);//如果这句话注释，不会向数据库发送sql语句，等到使用给代理对象时才到DB中查询
</pre></li>
<li>通过修改配置文件，我们可以取消懒加载<br><code>&lt;class  name=&quot;Employee&quot; lazy=&quot;false&quot; table=&quot;employee&quot;&gt;</code></li>
<li><strong><em>如何选择使用哪个：如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）</em></strong></li>
</ul>
<h3 id="Hibernate缓存原理★★★★★★"><a href="#Hibernate缓存原理★★★★★★" class="headerlink" title="Hibernate缓存原理★★★★★★"></a>Hibernate缓存原理★★★★★★</h3><p><img src="http://i.imgur.com/FIm3Wt8.png" alt=""></p>
<ul>
<li>接受到一个load查询，先去session缓存中查询，如果没有再去二级缓存查找，如果还没有，就不查询了，返回一个代理对象proxy obj = load</li>
<li>如果使用这个代理对象后，就会去数据库查询，<strong><em>并把这条记录放入二级缓存</em></strong></li>
<li>等到下次查询时，先查询session缓存，找不到，然后去二级缓存中取得对象，并返回结果。<strong><em>同时把这条记录放入一级缓存</em></strong></li>
<li>get查询也类似，先查询一级缓存，再查询二级缓存<br></li>
<li>Hibernate缓存机制可以减少对数据库的查询<pre>
Employee employee1 = (Employee) session.load(Employee.class,1);//发送select语句，放缓存
System.out.println(employee1);
Employee employee2 = (Employee) session.get(Employee.class,1);//从缓存中取，没有select语句
System.out.println(employee2);
Employee employee3 = (Employee) session.get(Employee.class,100);//缓存中找不到，向数据库发送select语句
System.out.println(employee3);
</pre>

</li>
</ul>
<h3 id="HibernateUtil（线程局部模式：获取全新的Session或与线程绑定的Session）★★★★★★"><a href="#HibernateUtil（线程局部模式：获取全新的Session或与线程绑定的Session）★★★★★★" class="headerlink" title="HibernateUtil（线程局部模式：获取全新的Session或与线程绑定的Session）★★★★★★"></a>HibernateUtil（线程局部模式：获取全新的Session或与线程绑定的Session）★★★★★★</h3><p>注意：不再需要配置 hibernate.cfg.xml</p>
<pre><code>final public class HibernateUtil { //SqlHelper
    private static SessionFactory sessionFactory = null;
    //使用线程局部模式
    private static ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();

    static {
        sessionFactory=new Configuration().configure().buildSessionFactory();
    }

    private HibernateUtil(){}

    //获取全新的全新的sesession
    public static Session openSession(){
        return sessionFactory.openSession();
    }
    //获取和线程关联的session
    public static Session getCurrentSession(){
        Session session = threadLocal.get();
        //判断是否得到
        if(session == null){
            session = sessionFactory.openSession();
            //把session对象设置到 threadLocal,相当于该session已经和线程绑定
            threadLocal.set(session);
        }
        return session;
    }
}
</code></pre><p><strong><em>测试</em></strong></p>
<pre><code>System.out.println(HibernateUtil.getCurrentSession().hashCode());
System.out.println(HibernateUtil.getCurrentSession().hashCode());
System.out.println(HibernateUtil.openSession().hashCode());
System.out.println(HibernateUtil.openSession().hashCode());
结果：
    725455968
    725455968
    1473790157
    914784201
</code></pre><p><strong><em>线程局部模式</em></strong></p>
<p><img src="http://i.imgur.com/sAHw9by.png" alt=""></p>
<p>在一个线程中，某个时间点通过set将对象放入ThredLocal，又在某个点通过get方法取出对象。这个变量与线程绑定</p>
<h3 id="query接口★★★★★★"><a href="#query接口★★★★★★" class="headerlink" title="query接口★★★★★★"></a>query接口★★★★★★</h3><p>通过query接口我们可以完成更加复杂的查询任务<br>举例: 通过用户来查询数据.</p>
<pre><code>//获取query引用
Query query = session.createQuery(&quot;from Employee where id = 1&quot;);
//通过List方法获取结果，这个list会自动封装成domain对象
List&lt;Employee&gt; list = query.list();
for(Employee e : list){
    System.out.println(e.getName() + &quot; &quot; + e.getHiredate());
}
</code></pre><p>注意：Employee是Java对象而不是表名，id也是类的属性名</p>
<h3 id="Criteria接口（不常用）"><a href="#Criteria接口（不常用）" class="headerlink" title="Criteria接口（不常用）"></a>Criteria接口（不常用）</h3><p>Criteria接口也可用于面向对象方式的查询，关于它的具体用法我们这里先不做介绍,简单看几个案例.</p>
<pre><code>Criteria cri = session.createCriteria(Employee.class)
        .setMaxResults(2)
        .addOrder(Order.asc(&quot;id&quot;));
List&lt;Employee&gt; list = cri.list();
for(Employee e : list){
    System.out.println(e.getId() + &quot; &quot; + e.getName());
}
</code></pre><h2 id="工具生成domain对象和对象关系映射文件"><a href="#工具生成domain对象和对象关系映射文件" class="headerlink" title="工具生成domain对象和对象关系映射文件"></a>工具生成domain对象和对象关系映射文件</h2><ul>
<li><p>使用IntelliJ IDEA开发SpringMVC网站（三）数据库配置★★★<br><a href="http://blog.csdn.net/chenxiao_ji/article/details/50849365" target="_blank" rel="external">http://blog.csdn.net/chenxiao_ji/article/details/50849365</a></p>
</li>
<li><p>在创建工程的时候勾选上hibernate支持。</p>
</li>
</ul>
<p><img src="http://i.imgur.com/tadYPC3.png" alt=""></p>
<ul>
<li>在主界面右侧找到database，点击添加数据库</li>
</ul>
<p><img src="http://i.imgur.com/592uDna.png" alt=""></p>
<ul>
<li>在新界面中添加数据库驱动和数据库链接信息</li>
</ul>
<p><img src="http://i.imgur.com/dpI2qNp.png" alt=""></p>
<ul>
<li>保存后在主面板左侧有persistence，在hibernate图标上点击右键-Generate Persistence Mapping-By Database Scheme</li>
</ul>
<p><img src="http://i.imgur.com/duTZSlM.png" alt=""></p>
<ul>
<li>选好数据库，选好包的位置，在下面勾上要生成的表对应的pojo，并且勾上为每一个pojo生成XML即可</li>
</ul>
<p><img src="http://i.imgur.com/PXz7CeO.png" alt=""></p>
<h2 id="IDEA一对多关系设置"><a href="#IDEA一对多关系设置" class="headerlink" title="IDEA一对多关系设置"></a>IDEA一对多关系设置</h2><ul>
<li>模拟一个学生选课系统 ，创建三张表：student、studCourse、course</li>
<li>数据库备份<br><a href="https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate.sql" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/blob/master/doc/hibernate.sql</a></li>
<li>student与studCourse的关系为一对多，即一个学生可以选择多门课程。Student类中有一个studCourse的集合属性，studCourse中有一个Student的成员变量</li>
<li><p>设置student与studCourse之间的关系</p>
<ul>
<li>原则：在有外键的表上设置表之间的关系，本例中在studCourse上设置关系    </li>
<li>在上图中选中studCourse表，studCourse通过外键sid和cid关联student表和couse表。注意外键不打勾</li>
<li>点击左上角绿色的加号或右键选择<code>add relationship</code></li>
<li>studCourse类中有一个类型为Course的course变量，Course类中有一个名为studCourses的集合，两个表通过cid关联起来<br><img src="http://i.imgur.com/6hDMVCk.png" alt=""></li>
</ul>
</li>
<li><p>同理设置studCourse与student关系</p>
</li>
<li>设置完成后观察属性是否正确<br><img src="http://i.imgur.com/5tEWDh7.png" alt=""></li>
<li>生成的domain对象及hdm文件见github<br><a href="https://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/java/cn/apeius/domain" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/java/cn/apeius/domain</a><br><a href="https://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/resources" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/tree/master/src/main/resources</a></li>
</ul>
<h2 id="HQL语句详解★★★★★★"><a href="#HQL语句详解★★★★★★" class="headerlink" title="HQL语句详解★★★★★★"></a>HQL语句详解★★★★★★</h2><h3 id="关系模型和对象模型映射"><a href="#关系模型和对象模型映射" class="headerlink" title="关系模型和对象模型映射"></a>关系模型和对象模型映射</h3><p><img src="http://i.imgur.com/6cu2JfO.png" alt=""></p>
<ul>
<li>studCourse表有两个外键，一个是与student表关联的sid，另一个是与course关联的cid</li>
<li>一个学生可以选择多门课程，一个课程可以被多名学生选择，两个表是多对多的关系</li>
<li>在对象模型中，一个学生可以选择多个课程，所以它有一个set集合的成员变量，存放studcourse</li>
<li>在对象模型中，一个课程可以可以被多名学生选择，所以它有一个set集合的成员变量，存放studcourses</li>
</ul>
<h3 id="取出部分属性"><a href="#取出部分属性" class="headerlink" title="取出部分属性"></a>取出部分属性</h3><ul>
<li>在讲解jdbc中，要查询什么字段就查询什么字段，不要<code>select * from..</code></li>
<li>但是在Hibernate中，建议把整个对象的属性都查询</li>
</ul>
<p><strong><em>查询整个对象的属性</em></strong><br>list方法返回的是整个Student对象</p>
<pre><code>List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list();
for(Student s : list){
    System.out.println(s.getSname() + &quot; &quot;  + s.getSid());
}
</code></pre><p><strong><em>查询部分属性</em></strong></p>
<p>因为只是查询部分属性，hibernate没有把返回的结果封装成Student对象，而只是Object数组</p>
<pre><code>List list = session.createQuery(&quot;select sname,sid from Student&quot;).list();
for(int i = 0; i &lt; list.size(); i++){
    Object[] obj = (Object[]) list.get(i);
    System.out.println(obj[0] + &quot; &quot; + obj[1]);
}
</code></pre><p>或（推荐）</p>
<pre><code>List&lt;Object[]&gt; list = session.createQuery(&quot;select sname,sid from Student&quot;).list();
for(Object[] obj : list){
    System.out.println(obj[0] + &quot; &quot; + obj[1]);
}
</code></pre><p>原理：创建list对象，对于每条记录创建一个对象数组，并加入list中</p>
<p><img src="http://i.imgur.com/jO4KEIX.png" alt=""></p>
<p><strong><em>如果我们返回的是一列数据</em></strong></p>
<pre><code>//这时我们的取法是直接取出list-&gt;object 而不是 list-&gt;Object[]
List&lt;Object&gt; list = session.createQuery(&quot;select sname from Student&quot;).list();
for(Object obj : list){
    System.out.println(obj);
}
</code></pre><h3 id="对象模型关联查询"><a href="#对象模型关联查询" class="headerlink" title="对象模型关联查询"></a>对象模型关联查询</h3><p><strong><em>查询学生就能查出于课程关联的全部信息</em></strong></p>
<pre><code>List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list();
for(Student s : list){
    System.out.print(s.getSname());
    if(s.getStudcourses().size() == 0){
        System.out.println(&quot;没有选课&quot;);
    }else{
        System.out.print(&quot;选了&quot;);
        for(Studcourse studcourse : s.getStudcourses()){
            System.out.print(studcourse.getCourse().getCname() + &quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><p><strong><em>请显示所有选择了21号课程的学生信息</em></strong></p>
<pre><code>String sql = &quot;select student.sname,student.sage from Studcourse where course.cid = 21&quot;;
List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null);
for(Object[]  s : list){
    System.out.println(s[0] + &quot; &quot; + s[1]);
}
</code></pre><h3 id="uniqueResult方法-只有一个对象"><a href="#uniqueResult方法-只有一个对象" class="headerlink" title="uniqueResult方法(只有一个对象)"></a>uniqueResult方法(只有一个对象)</h3><p>当<code>session.createQuery(&quot;from xxx where cardid=&#39;xxx&#39;&quot;).uniqueResult();</code>返回的结果<strong><em>只有一个对象</em></strong>时，可以使用<code>uniqueResult()</code>得到该对象，效率高。但是，如果结果是多条，使用该方法就会抛出异常。</p>
<pre><code>Student student = (Student) session.createQuery(&quot;from Student where id = 20050003&quot;).uniqueResult();
if(student != null) System.out.println(student.getSname()); else System.out.println(&quot;记录不存在&quot;);
</code></pre><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><pre><code>String sql = &quot;select sname,sage from Student where sname like &apos;林%&apos;&quot;;
List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null);
for(Object[] s : list){
    System.out.println(s[0] + &quot; &quot; + s[1]);
}
</code></pre><h3 id="distinct的用法（过滤重复的记录）"><a href="#distinct的用法（过滤重复的记录）" class="headerlink" title="distinct的用法（过滤重复的记录）"></a>distinct的用法（过滤重复的记录）</h3><p>比如，显示所有学生的性别和年龄</p>
<pre><code>List list=session.createQuery(&quot;select distinct sage,ssex from Student&quot;).list();
for(int i=0;i&lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString());
}
</code></pre><h3 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h3><p>年龄在20岁到22岁的学生</p>
<pre><code>List list=session.createQuery(&quot;select distinct sage,ssex,sname from Student where sage between 20 and 22&quot;).list();
for(int i=0;i&lt;list.size();i++){
    Object []  objs=(Object[]) list.get(i);
    System.out.println(objs[0].toString()+&quot; &quot;+objs[1].toString()+objs[2].toString());
}
</code></pre><h3 id="in-not-in"><a href="#in-not-in" class="headerlink" title="in /not in"></a>in /not in</h3><p>查询计算机系和外语系的学生信息</p>
<pre><code>List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept in (&apos;计算机系&apos;,&apos;外语系&apos;)&quot;).list();
for(Student s:list){
    System.out.println(s.getSname()+&quot; &quot;+s.getSaddress()+&quot; &quot;+s.getSdept());
}
</code></pre><h3 id="group-by使用"><a href="#group-by使用" class="headerlink" title="group by使用"></a>group by使用</h3><p>显示各个系的学生的平均年龄</p>
<pre><code>List&lt;Object[]&gt; list=session.createQuery(&quot;select avg(sage),sdept from  Student group by sdept&quot;).list();
for(Object[] obj:list){
    System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
</code></pre><h3 id="having的使用"><a href="#having的使用" class="headerlink" title="having的使用"></a>having的使用</h3><p>对分组查询后的结果，进行筛选</p>
<p><strong><em>1.请显示人数大于3的系名称</em></strong></p>
<pre><code>//a. 查询各个系分别有多少学生 b.筛选    
List&lt;Object[]&gt; list=session.createQuery(&quot;select count(*) as c1,sdept from  Student group by sdept having count(*)&gt;3&quot;).list();
//取出1. for 增强
for(Object[] obj:list){
    System.out.println(obj[0].toString()+&quot; &quot;+obj[1].toString());
}
</code></pre><p><strong><em>2.查询女生少于200人的系</em></strong></p>
<pre><code>List&lt;Object[]&gt; list = session.createQuery(&quot;select count(*),sdept from Student  where ssex = &apos;F&apos;group by sdept having count(*) &lt; 200&quot;).list();
for(Object[] obj : list){
    System.out.println(obj[0] + &quot; &quot; + obj[1]);
}
</code></pre><h3 id="聚集函数的使用-count-avg-max-min-sum"><a href="#聚集函数的使用-count-avg-max-min-sum" class="headerlink" title="聚集函数的使用 count(),avg(),max(),min(),sum()"></a>聚集函数的使用 count(),avg(),max(),min(),sum()</h3><p><strong><em>1.查询计算机系共多少人</em></strong></p>
<pre><code>Long count = (Long) session.createQuery(&quot;select count(*) from Student where sdept=&apos;计算机系&apos;&quot;).uniqueResult();
System.out.println(count);
</code></pre><p><strong><em>2.查询选修11号课程的最高分和最低分</em></strong></p>
<pre><code>List&lt;Object[]&gt; list=session.
createQuery(&quot;select 11,max(grade),min(grade) from Studcourse where course.cid=11&quot;).list();
for(Object[] obj:list){
    System.out.println(obj[0].toString()+&quot; max=&quot;+obj[1].toString()+&quot; min=&quot;+obj[2].toString());
    }
</code></pre><p><strong><em>3.计算各个科目不及格的学生数量</em></strong></p>
<pre><code>List&lt;Object[]&gt; list=session.createQuery(&quot;select count(*),course.cname from Studcourse where grade &lt; 60 group by course.cname&quot;).list();
for(Object[] obj:list){
    System.out.println(obj[0].toString()+ &quot; &quot; + obj[1]);
}
</code></pre><p><strong><em>4.显示各科考试不及格学生的名字，科目和分数</em></strong></p>
<pre><code>List&lt;Object[]&gt; list=session.createQuery(&quot;select student.sname,course.cname,grade from Studcourse where grade &lt; 60&quot;).list();
for(Object[] obj:list){
    System.out.println(obj[0].toString()+ &quot; &quot; + obj[1] + &quot; &quot; + obj[2]);
}
</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页原理见Java基础常用</p>
<p><strong><em>函数使用</em></strong></p>
<p>  List q=session.createQuery(hql).setFirstResultl(从第几条取//从0开始计算).setMaxResult(取出几条).list();</p>
<p><strong><em>据用户输入的pageNow 和pageSize显示对象</em></strong></p>
<pre><code>Session session = HibernateUtil.getCurrentSession();
Transaction transaction = null;

int pageNow  = 1;
int pageSize = 3;
int pageCount = 0;
int rowCount = 0;
try{
    transaction = session.beginTransaction();
    //do...
    rowCount = Integer.parseInt(session.createQuery(&quot;select count(*) from Student&quot;).uniqueResult().toString());
    pageCount = (rowCount -1)/pageSize + 1;
    //遍历
    for(int i = 0; i &lt;= pageCount; i++){
        System.out.println(&quot;***********************************&quot;);
        List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).setFirstResult(pageSize*i).setMaxResults(pageSize).list();
        for(Student s : list){
            System.out.println(s.getSname());
        }
    }
    transaction.commit();
}catch (Exception e){
    e.printStackTrace();
    if (transaction != null){
        transaction.rollback();
    }
    throw new RuntimeException(e.getMessage());
}finally {
    if(session != null &amp;&amp; session.isOpen()){
        session.close();
    }
}
</code></pre><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><pre><code>select * from student where sage=2412 or 1=1
</code></pre><p>上面我们使得WHERE恒真，所以该查询中WHERE已经不起作用了</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p><strong><em>使用参数绑定的好处：</em></strong></p>
<ol>
<li>可读性提高</li>
<li>效果高 </li>
<li>防止sql注入漏洞</li>
</ol>
<p><strong><em>面试题: 如果不使用参数绑定，怎样防止登录时， sql注入?</em></strong></p>
<p>　　思路: 1. 通过用户名，查询出该用户名在数据库中对应的密码，然后再与用户输入的密码比较，如果相等，则用户和法，否则，非法.</p>
<p><strong><em>参数绑定有两种形式</em></strong></p>
<pre><code>Query q=session.createQuery(from Student where sdept=:dept and sage&gt;:age)
</code></pre><p>如果我们的参数是:冒号形式给出的，则我们的参数绑定应当这样:</p>
<pre><code>List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept=:a1 and sage&gt;:sage&quot;).setString(&quot;a1&quot;, &quot;计算机系&quot;).setString(&quot;sage&quot;, &quot;2&quot;).list();
</code></pre><p>还有一种形式:</p>
<pre><code>Query q=session.createQuery(from Student where sdept=? and sage&gt;?)
</code></pre><p>如果我们的参数是以 ? 形式给出的则，参数绑定应当:</p>
<pre><code>List&lt;Student&gt; list=session.createQuery(&quot;from Student where sdept=? and sage&gt;?&quot;).setString(0, &quot;计算机系&quot;).setString(1, &quot;2&quot;).list();
</code></pre><p>参数的绑定，可以分开写：</p>
<pre><code>Query query=session.createQuery(&quot;from Student where sdept=? and sage&gt;?&quot;);        
query.setString(0, &quot;计算机系&quot;);
query.setString(1, &quot;2&quot;);
List &lt;Student&gt; list=query.list();
for(int i=0;i&lt;list.size();i++){
    Student s= list.get(i);
    System.out.println(s.getSname()+&quot; &quot;+s.getSage());
}
</code></pre><p>把HibernateUtil升级了</p>
<h3 id="多表查询★★★"><a href="#多表查询★★★" class="headerlink" title="多表查询★★★"></a>多表查询★★★</h3><p>在实际项目中，我们不可能只对一张表进行查询，通常有多张表联合查询</p>
<h4 id="hibernate对象之间关系"><a href="#hibernate对象之间关系" class="headerlink" title="hibernate对象之间关系"></a>hibernate对象之间关系</h4><ol>
<li>one – to – one : 身份证&lt;—&gt;人 </li>
<li>one – to – many  部门 &lt;—&gt; 员工</li>
<li>many-to-one   员工&lt;—&gt;部门</li>
<li>many-to-many  学生&lt;—&gt;老师 </li>
</ol>
<h4 id="多对多关系转换成两个一对多"><a href="#多对多关系转换成两个一对多" class="headerlink" title="多对多关系转换成两个一对多"></a>多对多关系转换成两个一对多</h4><p><img src="http://i.imgur.com/d8X9T9W.png" alt=""></p>
<ul>
<li>一个学生可以选择多门课程，一门课程可以被多名学生选择，在实际开发中应将其转成两个一对多或多两个多对一。这样程序好控制，同时不会有冗余</li>
<li>对象配置文件可以体现出，Student.hbm.xml和Course.xml中是one-to-many，而Studcourse是many-to-one</li>
</ul>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>请显示林青霞 选择的所有课程名，和成绩</p>
<pre><code>String sql = &quot;select course.cname,grade from Studcourse where student.sname = &apos;林青霞&apos;&quot;;
List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql,null);
for(Object[] s : list){
    System.out.println(s[0] + &quot; &quot; + s[1]);
}
</code></pre><h2 id="Criteria—略讲"><a href="#Criteria—略讲" class="headerlink" title="Criteria—略讲"></a>Criteria—略讲</h2><pre><code>//查询年龄大于10岁的学生
//获取一个会话
Session session = HibernateUtil.getCurrentSession();
Transaction transaction = null;
try {
    transaction = session.beginTransaction();
    Criteria cri = session.createCriteria(Student.class);
    //增加检索条件
    cri.add(Restrictions.gt(&quot;sage&quot;,10));
    List&lt;Student&gt; list = cri.list();
    for(Student s : list){
        System.out.println(s.getSname());
    }
    transaction.commit();
} catch (Exception e) {
    if (transaction != null) {
        transaction.rollback();
    }
    throw new RuntimeException(e.getMessage());
} finally {
    //关闭session
    if (session != null &amp;&amp; session.isOpen()) {
        session.close();
    }
}
</code></pre><h2 id="hibernate对象的三种状态"><a href="#hibernate对象的三种状态" class="headerlink" title="hibernate对象的三种状态"></a>hibernate对象的三种状态</h2><h3 id="如果判断一个对象处于怎样的状态？"><a href="#如果判断一个对象处于怎样的状态？" class="headerlink" title="如果判断一个对象处于怎样的状态？"></a>如果判断一个对象处于怎样的状态？</h3><p>主要的依据是: 1. 看该对象是否处于session管理下 2. 看在数据库中有没有对应的记录</p>
<ul>
<li>瞬时态: <font color="blue">没有session管理</font>，同时数据库没有对应记录</li>
<li>持久态: <font color="red">有session管理</font>，同时在数据库中有记录。相关联的session没有关闭，事务没有提交，持久对象状态发生改变，在事务提交时会影响到数据库，即hibernate能检测到变化</li>
<li>脱管态/游离态： <font color="blue">没有session管理</font>，但是在数据库中有记录。脱管对象状态发生改变，hibernate不能检测到</li>
</ul>
<h3 id="对象三种状态"><a href="#对象三种状态" class="headerlink" title="对象三种状态"></a>对象三种状态</h3><pre><code>//对象三种状态
Course c1 = new Course();//没有在session管理下，数据库没记录，c1就是瞬时态
c1.setCid(100);
c1.setCcredit(3);
c1.setCname(&quot;php&quot;);

Session session = null;
Transaction tx  = null;
try{
    session = HibernateUtil.getCurrentSession();
    tx = session.beginTransaction();
    session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态
    tx.commit();
    session.close();
    //c1没有处于session管理下，单被保存到数据库中，c1就是脱管态（游离态）
    System.out.println(c1.getCname());
}catch (Exception e){
    e.printStackTrace();
}
</code></pre><p><img src="http://i.imgur.com/Vdl8u49.png" alt=""></p>
<h3 id="持久态中改变属性，反应到数据库中"><a href="#持久态中改变属性，反应到数据库中" class="headerlink" title="持久态中改变属性，反应到数据库中"></a>持久态中改变属性，反应到数据库中</h3><pre>
//对象三种状态
Course c1 = new Course();//c1就是瞬时态
c1.setCid(100);
c1.setCcredit(3);
<font color="red">c1.setCname("php1");</font>

Session session = null;
Transaction tx  = null;
try{
    session = HibernateUtil.getCurrentSession();
    tx = session.beginTransaction();
    session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态
    <font color="red">c1.setCname("php2");</font>//处于持久态，c1的改变有效，加入的数据php2
    tx.commit();
    session.close();
    //这时c1被保存到数据库中，同时没有处于session管理下，c1就是脱管态（游离态）
    <font color="red">c1.setCname("php3");</font>
    System.out.println(c1.getCname());//<font color="blue">结果为php3，但数据库中时php2</font>
}catch (Exception e){
    e.printStackTrace();
}
</pre>

<h3 id="持久态中删除记录"><a href="#持久态中删除记录" class="headerlink" title="持久态中删除记录"></a>持久态中删除记录</h3><pre><code>Course c1 = new Course();//c1就是瞬时态
c1.setCid(100);
c1.setCcredit(3);
c1.setCname(&quot;php1&quot;);
Session session = null;
Transaction tx  = null;
try{
    session = HibernateUtil.getCurrentSession();
    tx = session.beginTransaction();
    session.save(c1);//c1这时处于session管理下，同时c1对象被保存到数据库，c1处于持久态
    c1.setCname(&quot;php2&quot;);//处于持久态，c1的改变有效，加入的数据php2
    session.delete(c1);//删除数据库记录，c1处于瞬时态
    tx.commit();
    session.close();
    //c1对应的记录被删除，同时没有处于session管理下，c1处于瞬时态
    c1.setCname(&quot;php3&quot;);
    System.out.println(c1.getCname());
}catch (Exception e){
    e.printStackTrace();
}
</code></pre><h3 id="对象状态-完整版"><a href="#对象状态-完整版" class="headerlink" title="对象状态 - 完整版"></a>对象状态 - 完整版</h3><p><img src="http://i.imgur.com/uXvnw1s.png" alt=""></p>
<h2 id="Hibernate关系映射★★★★★★★"><a href="#Hibernate关系映射★★★★★★★" class="headerlink" title="Hibernate关系映射★★★★★★★"></a>Hibernate关系映射★★★★★★★</h2><h3 id="多对一（内含懒加载问题）★★★★★★★"><a href="#多对一（内含懒加载问题）★★★★★★★" class="headerlink" title="多对一（内含懒加载问题）★★★★★★★"></a>多对一（内含懒加载问题）★★★★★★★</h3><h4 id="多对一案例"><a href="#多对一案例" class="headerlink" title="多对一案例"></a>多对一案例</h4><p><img src="http://i.imgur.com/DouTjzj.png" alt=""></p>
<p>采用开发方式一：从Domain和对象关系映射文件开始写，自动创建对应表</p>
<p><strong><em>Department.java</em></strong></p>
<pre><code>package cn.apeius.domain;

public class Department implements java.io.Serializable {

    private Integer id;
    private String name;
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><p><strong><em>Department.hbm.xml</em></strong></p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
&lt;hibernate-mapping package="cn.apeius.domain">
    &lt;class name="Department" lazy="false" table='department'>
        &lt;!-- 配置主键属性 -->
        &lt;id name="id" column='id' type="java.lang.Integer">
            &lt;!-- 生成策略 -->
            &lt;generator class="increment"/>
        &lt;/id>
        &lt;property name="name" type="java.lang.String">
            &lt;column name="name" length="255" not-null="true"/>
        &lt;/property>
    &lt;/class>
&lt;/hibernate-mapping>
</pre>

<p><strong><em>Intern.java</em></strong></p>
<pre>
package cn.apeius.domain;

public class Intern implements java.io.Serializable{

    private Integer id;
    private String name;
    <font color="red">private Department dept;</font>
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public Department getDept() {
        return dept;
    }
    public void setDept(Department dept) {
        this.dept = dept;
    }
}
</pre>

<p><strong><em>Intern.hbm.xml</em></strong></p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
&lt;hibernate-mapping package="cn.apeius.domain">
    &lt;class name="cn.apeius.domain.Intern" table='intern'>
        &lt;id name="id" column='id' type="java.lang.Integer">
            &lt;generator class="increment"/>
        &lt;/id>
        &lt;property name="name" type="java.lang.String">
            &lt;column name="name" length="255"/>
        &lt;/property>
        &lt;!--对于private Department dept;就不能使用property-->
        &lt;!--column="dept_id" 表示将来自动生成的表的外键名-->
        &lt;!--class可选，默认是通过反射得到属性类型-->
        <font color="red">&lt;many-to-one name="dept" class = 'Department' column="dept_id"/></font>
    &lt;/class>
&lt;/hibernate-mapping>    
</pre>

<p><strong><em>hibernate.cfg.xml</em></strong></p>
<pre><code>&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;
</code></pre><p><strong><em>Main</em></strong></p>
<pre><code>//创建实习生
Intern intern = new Intern();
intern.setName(&quot;宋江&quot;);
//创建部门
Department department = new Department();
department.setName(&quot;财务部&quot;);
//实习生分配部门
intern.setDept(department);
//保存
session.save(department);
session.save(intern);
</code></pre><p><strong><em>结论一</em></strong></p>
<ul>
<li>应当先保存部门，再保存实习生</li>
<li>保存部门后，产生部门id；当保存实习生时再将部门id存入实习生表中</li>
<li>若先保存实习生，此时还不知道部门id，dept_id的值为null；当保存部门并生成部门id时，在更新实习生表；这样比方式一效率低</li>
</ul>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>当我们查询一个对象的时候，在默认情况下,返回的只是该对象的<strong><em>普通属性</em></strong>，当用户去<strong><em>使用对象属性</em></strong> 时，才会向<strong><em>数据库</em></strong> 发出再一次的查询.这种现象我们称为lazy现象.</p>
<pre><code>Intern intern = (Intern) session.get(Intern.class,3);
//System.out.println(intern.getName() + &quot; &quot; + intern.getDept().getName());//可以读出部门名称
transaction.commit();
session.close();
System.out.println(intern.getName() + &quot; &quot; + intern.getDept().getName());//session关闭，不可以读出部门名称
</code></pre><ul>
<li>在session未关闭时，可以通过学生名得到部门名</li>
<li>session关闭后，由于懒加载机制，会报错，不能得到部门名</li>
</ul>
<h4 id="解决懒加载"><a href="#解决懒加载" class="headerlink" title="解决懒加载"></a>解决懒加载</h4><ul>
<li>显示初始化Hibernate.initized(代理对象)</li>
</ul>
<pre>
Intern intern = (Intern) session.get(Intern.class,3);
<font color="red">Hibernate.initialize(intern.getDept());</font>
transaction.commit();
session.close();//关闭session，若没有显示初始化代理对象，则会报错
System.out.println(intern.getName() + " " + intern.getDept().getName());//session关闭，不可以读出部门名称
</pre>

<ul>
<li>在department映射文件中加入lazy=’false’</li>
</ul>
<pre><code>&lt;class name=&quot;Department&quot; lazy=&quot;false&quot;&gt;
</code></pre><ul>
<li>通过过滤器(web项目) openSessionInView</li>
</ul>
<pre><code>many-to-one的many这方，如果你配置了 &lt;class name=&quot;Student&quot; lazy=&quot;false&quot;&gt;
那么hibernate就会在 查询学生 many 方时，把它相互关联的对象也查询,这里我们可以看出，对select语句查询影响不大,

one-to-many 的one 的这方，如果你配置 &lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt;
当你去查询一个部门的时候，该部门关联的学生全部返回，不管你使用否!!!
如果设置lazy=&quot;true&quot;，在session关闭后如果需要查询部门所在的学生就会报错
</code></pre><p><strong><em>矛盾: 如何让我们在需要使用的时候才去查询？即如何让我们的session范围更大？</em></strong></p>
<ul>
<li>一个http请求所在一个session，缺点是session关闭会延时<br><img src="http://i.imgur.com/wI2ANRU.png" alt=""></li>
<li>过滤器配合实现</li>
</ul>
<pre><code>public class MyFilter1 extends HttpServlet implements Filter {

    public void doFilter(ServletRequest arg0, ServletResponse arg1,
            FilterChain arg2) throws IOException, ServletException {
        // TODO Auto-generated method stub
        Session s=null;
        Transaction tx=null;
        try {
            s =HibernateUtil.getCurrentSession();
            tx=s.beginTransaction();
            arg2.doFilter(arg0, arg1);
            //代码运行到这，整个请求结束
            tx.commit();

        } catch (Exception e) {
            if(tx!=null){
                tx.rollback();
            }
            throw new RuntimeException(e.getMessage());
        }finally{        
            HibernateUtil.closeCurrentSession();
        }
    }
}
</code></pre><ul>
<li>HibernateUtil加入关闭session方法</li>
</ul>
<pre><code>public static void closeCurrentSession() {

    Session s = getCurrentSession();

    if (s != null &amp;&amp; s.isOpen()) {
        s.close();
        threadLocal.set(null);
    }
}
</code></pre><ul>
<li>利用Spring可以更好得解决</li>
</ul>
<h3 id="一对多（内含级联操作）"><a href="#一对多（内含级联操作）" class="headerlink" title="一对多（内含级联操作）"></a>一对多（内含级联操作）</h3><p>需求：通过一个部门号1，来获取该部门的所有学生?</p>
<p><img src="http://i.imgur.com/wRgVmDq.png" alt=""></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><strong><em>Department.java</em></strong></p>
<pre>
package cn.apeius.domain;

import java.util.Set;

public class Department implements java.io.Serializable {

    private Integer id;
    private String name;
    //配置一个set集合，对应多个学生
    <font color="red">private Set&lt;Intern> interns;</font>
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Set<intern> getInterns() {
        return interns;
    }

    public void setInterns(Set<intern> interns) {
        this.interns = interns;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

}
</intern></intern></pre>

<p><strong><em>Department.hbm.xml</em></strong></p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
&lt;hibernate-mapping package="cn.apeius.domain">
    &lt;class name="Department" lazy="false" table = 'department'>
        &lt;!-- 配置主键属性 -->
        &lt;id name="id" type="java.lang.Integer" column = 'id' >
            &lt;!-- 生成策略 -->
            &lt;generator class="increment"/>
        &lt;/id>
        &lt;property name="name" type="java.lang.String">
            &lt;column name="name" length="255" not-null="true"/>
        &lt;/property>
        <font color="red">&lt;!--配置one-to-many的关系-->
        &lt;set name="interns" <font color="blue">cascade="save-update"></font>
            &lt;!--指定intern类对应的外键-->
            &lt;key column="dept_id"/>
            &lt;!--集合中的类名-->
            &lt;one-to-many class="Intern"/>
        &lt;/set></font>
    &lt;/class>
&lt;/hibernate-mapping>
</pre>

<p><strong><em>Intern.java</em></strong></p>
<pre>
package cn.apeius.domain;
public class Intern implements java.io.Serializable{
    private Integer id;
    private String name;
    <font color="red">private Department dept;</font>
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public Department getDept() {
        return dept;
    }
    public void setDept(Department dept) {
        this.dept = dept;
    }
}
</pre>

<p><strong><em>Intern.hbm.xml</em></strong></p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
&lt;hibernate-mapping package="cn.apeius.domain">
    &lt;class name="cn.apeius.domain.Intern">
        &lt;id name="id" type="java.lang.Integer" column = 'id'>
            &lt;generator class="increment"/>
        &lt;/id>
        &lt;property name="name" type="java.lang.String">
            &lt;column name="name" length="255"/>
        &lt;/property>
        &lt;!--对于private Department dept;就不能使用property-->
        &lt;!--column="dept_id" 表示将来自动生成的表的外键名-->
        &lt;!--class可选，默认是通过反射得到属性类型-->
        <font color="red">&lt;many-to-one name="dept" class='Department' column="dept_id"/></font>
    &lt;/class>
&lt;/hibernate-mapping>
</pre>

<p><strong><em>查询部门的实习生</em></strong></p>
<pre><code>Department department = (Department) session.get(Department.class,1);
//取出该部门的实习生
Set&lt;Intern&gt; set = department.getInterns();
for(Intern intern : set)
    System.out.println(intern.getName());
</code></pre><p><strong><em>部门中添加实习生</em></strong></p>
<pre>
//创建部门
Department department = new Department();
department.setName("业务部");
//创建实习生
Intern intern1 = new Intern();
intern1.setName("实习生1");
Intern intern2 = new Intern();
intern2.setName("实习生2");
//部门分配学生
Set<intern> set = new HashSet<intern>();
set.add(intern1);
set.add(intern2);
<font color="red">//级联添加，在department.hdm.xml中添加cascade属性 &lt;set name="interns" cascade="save-update"></font>
department.setInterns(set);
//保存
session.save(department);
</intern></intern></pre>

<h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><p>所谓级联操作就是说，当你进行某个操作(添加/修改/删除…)，就由hibernate自动给你完成</p>
<p><strong><em>案例:如何配置级联操作，当删除某个部门的时候，我们自动删除其学生.</em></strong></p>
<p><strong><em>首先我们在 配置文件中修改:</em></strong></p>
<pre><code>&lt;!-- 配置one-to-many关系     cascade=&quot;delete&quot; 当删除该部门的时候(主对象，则级联删除它的学生从对象) --&gt;
&lt;set name=&quot;stus&quot; cascade=&quot;delete&quot;&gt;
&lt;!-- 指定Student类对应的外键 --&gt;
    &lt;key column=&quot;dept_id&quot; /&gt;
    &lt;one-to-many class=&quot;Student&quot; /&gt;
&lt;/set&gt;
</code></pre><p><strong><em>java代码中操作:</em></strong></p>
<pre><code>//演示删除级联
//获取到某个部分
Department department=(Department) s.get(Department.class, 41);
s.delete(department);
</code></pre><p><strong><em>演示save-update</em></strong></p>
<pre><code>配置文件:
&lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot;&gt;
&lt;!-- 指定Student类对应的外键 --&gt;
&lt;key column=&quot;dept_id&quot; /&gt;
&lt;one-to-many class=&quot;Student&quot; /&gt;
&lt;/set&gt;
</code></pre><p><strong><em>代码：</em></strong></p>
<pre><code>//添加学生
Department department=new Department();
department.setName(&quot;业务部门3&quot;);

Student stu1=new Student();
stu1.setName(&quot;顺平6&quot;);
Student stu2=new Student();
stu2.setName(&quot;小明6&quot;);

Set&lt;Student&gt; students=new HashSet&lt;Student&gt;();
students.add(stu1);
students.add(stu2);
department.setStus(students);

s.save(department);
</code></pre><p><strong><em>说明: </em></strong></p>
<pre><code>① 在集合属性和普通属性中都能使用cascade
② 一般讲cascade配置在one-to-many(one的一方,比如Employee-Department),和one-to-one(主对象一方)
</code></pre><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><h4 id="基于主键的one-to-one"><a href="#基于主键的one-to-one" class="headerlink" title="基于主键的one-to-one"></a>基于主键的one-to-one</h4><p><img src="http://i.imgur.com/8pSzSoU.png" alt=""></p>
<p>测试代码如下</p>
<ul>
<li>生成两张表，person表和idCard表。person中id为主键，idCard表中id既为主键，也为外键</li>
<li>person指定id和name，IdCard的主键由person的id指定</li>
<li><font color="red">IdCard设置外键可以多对一，但当外键同时也为主键时，可以保证一对一</font>


</li>
</ul>
<pre><code>Person p1 = new Person();
p1.setId(100);
p1.setName(&quot;成龙&quot;);
IdCard idCard = new IdCard();
idCard.setValidateDte(new Date());
//表示idCard对象是属于p1这个对象
idCard.setPerson(p1);

session.save(p1);
session.save(idCard);
</code></pre><h4 id="基于外键的one-to-one"><a href="#基于外键的one-to-one" class="headerlink" title="基于外键的one-to-one"></a>基于外键的one-to-one</h4><p><img src="http://i.imgur.com/Qwp0a37.png" alt=""></p>
<ul>
<li>在关系模型中，idCard设置外键person_id，则person与idCard是一对多的关系。如何限制约束使得一个person对应一个idCard，只需在references增加约束unique</li>
<li>IdCard关系映射文件，在many-to-one中增加约束unique=’true’，外键名为person_id</li>
</ul>
<p>测试代码</p>
<pre><code>Person p1 = new Person();
p1.setId(10);
p1.setName(&quot;成龙&quot;);

IdCard idCard = new IdCard();
idCard.setId(100);
idCard.setValidateDte(new Date());
//表示idCard对象是属于p1这个对象
idCard.setPerson(p1);

session.save(p1);
session.save(idCard);
</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>在操作和性能方面都不太理想，所以多对多的映射使用较少，实际使用中最好转换成一对多的对象模型</p>
<p><img src="http://i.imgur.com/dobH4GE.png" alt=""></p>
<h2 id="Hibernate一级缓存"><a href="#Hibernate一级缓存" class="headerlink" title="Hibernate一级缓存"></a>Hibernate一级缓存</h2><h3 id="缓存原理图"><a href="#缓存原理图" class="headerlink" title="缓存原理图"></a>缓存原理图</h3><p><img src="http://i.imgur.com/6uIqrv1.png" alt=""></p>
<p>从上图看出: 当我们去查询对象的时候，首先到一级缓存去取数据，如果有，则不到数据库中取，如果没有则到数据库中取，同时在一级缓存中放入对象.</p>
<h3 id="缓存的细节"><a href="#缓存的细节" class="headerlink" title="缓存的细节"></a>缓存的细节</h3><p>①什么操作会向一级缓存放入数据</p>
<pre><code>save,update,saveOrUpdate,load,get,list,iterate,lock
</code></pre><p>save 案例:</p>
<pre><code>//添加一个学生
Student student=new Student();
student.setName(&quot;小东&quot;);    
s.save(student);//放入一级缓存

//我马上查询
Student stu2=(Student) s.get(Student.class, student.getId()); //select
System.out.println(&quot;你刚刚加入的学生名字是&quot;+stu2.getName());
</code></pre><p>②什么操作会从一级缓存取数据</p>
<pre><code>get/load/list
</code></pre><ul>
<li>get/load会首先从一级缓存中取，如没有,再有不同的操作</li>
<li>get会立即向数据库发请求，而load 会返回一个代理对象，直到用户真的去使用数据，才会向数据库发请求</li>
</ul>
<p>list会不会从session缓存取数据？</p>
<pre><code>//查询45号学生
Student stu=(Student) s.get(Student.class, 45);
System.out.println(&quot;|||||||||||||||||||&quot;);
String hql=&quot;from Student where id=45&quot;;
Student stu2=(Student) s.createQuery(hql).uniqueResult();
System.out.println(stu2.getName());
</code></pre><p>从上面的案例，我看出 query.list() query.uniueResut() <strong><em>不会从一级缓取数据</em></strong> ! 但是query.list 或者query.uniqueRestu() 会<strong><em>向一级缓存放数据</em></strong>的</p>
<p>③一级缓存不需要配置，就可以使用,它本身没有保护机制，所以我们程序员要考虑这个问题,我们可以同 evict 或者 clear来清除session缓存中对象. evict 是清除一个对象，clear是清除所有的sesion缓存对象</p>
<p>④session级缓存中对象的生命周期, 当session关闭后，就自动销毁</p>
<p>⑤我们自己用HashMap来模拟一个Session缓存，加深对缓存的深入</p>
<pre><code>import java.util.*；
public class MyCache {
    //使用map来模拟缓存
    static Map&lt;Integer,Student&gt; maps=new HashMap&lt;Integer,Student&gt;();

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        getStudent(1);
        getStudent(1);
        getStudent(1);
        getStudent(1);
        getStudent(3);
        getStudent(3);

    }

    public static Student getStudent(Integer id){  //s.get()

        //先到缓存去
        if(maps.containsKey(id)){
            //在缓存有
            System.out.println(&quot;从缓存取出&quot;);
            return maps.get(id);
        }else{
            System.out.println(&quot;从数据库中取&quot;);
            //到数据库取
            Student stu=MyDB.getStudentFromDB(id);
            //放入缓存
            maps.put(id, stu);
            return stu;
        }    

    }

}

//我的数据库
class MyDB{

    static List&lt;Student&gt; lists=new  ArrayList&lt;Student&gt;();

    //初始化数据库,假设有三个学生
    static{
        Student s1=new Student();
        s1.setId(1);
        s1.setName(&quot;aaa&quot;);
        Student s2=new Student();
        s2.setId(2);
        s2.setName(&quot;bbb&quot;);
        Student s3=new Student();
        s3.setId(3);
        s3.setName(&quot;ccc&quot;);
        lists.add(s1);
        lists.add(s2);
        lists.add(s3);

    }

    public static Student getStudentFromDB(Integer id){
        for(Student s: lists){
            if(s.getId().equals(id)){
                return s;
            }
        }
        return null;// 在数据库中没有.
    }
}

class Student{
    private Integer id;
    private String name;
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><h2 id="Hibernate二级缓存"><a href="#Hibernate二级缓存" class="headerlink" title="Hibernate二级缓存"></a>Hibernate二级缓存</h2><h3 id="为什么需要二级缓存？"><a href="#为什么需要二级缓存？" class="headerlink" title="为什么需要二级缓存？"></a>为什么需要二级缓存？</h3><p>因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题，SessionFactory关闭后缓存才消失</p>
<ol>
<li>需要配置</li>
<li>二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache</li>
<li>二级缓存的对象可能放在内存，也可能放在磁盘.</li>
<li>二级缓存的原理</li>
</ol>
<p><img src="http://i.imgur.com/1MPLBrn.png" alt=""></p>
<h3 id="快速入门案例"><a href="#快速入门案例" class="headerlink" title="快速入门案例"></a>快速入门案例</h3><p>使用OsCache来演示二级缓存的使用</p>
<p>1、配置二级缓存</p>
<pre><code>&lt;!-- 启动二级缓存 --&gt;
&lt;property name=&quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
&lt;!-- 指定使用哪种二级缓存 --&gt;
&lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.OSCacheProvider&lt;/property&gt;
&lt;mapping resource=&quot;com/hsp/domain/Department.hbm.xml&quot; /&gt;
&lt;mapping resource=&quot;com/hsp/domain/Student.hbm.xml&quot; /&gt;
&lt;!-- 指定哪个domain启用二级缓存 
特别说明二级缓存策略:
    1. read-only只读缓存
    2. read-write读写缓存
    3. nonstrict-read-write不严格读写缓存
    4. transcational事务缓存
--&gt;
&lt;class-cache class=&quot;com.hsp.domain.Student&quot; usage=&quot;read-write&quot;/&gt;
</code></pre><p>2、把oscahe.properties文件放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小默认1000</p>
<p>3、使用</p>
<pre><code>//通过获取一个sesion,让hibernate框架运行(config-&gt;加载hibernate.cfg.xml)
Session s=null;
Transaction tx=null;    
try {
    //我们使用基础模板来讲解.
    s=HibernateUtil.openSession();
    tx=s.beginTransaction();        
    //查询45号学生    
    Student stu1=(Student) s.get(Student.class, 45);//45-&gt;一级缓存        
    System.out.println(stu1.getName());
    tx.commit();        
} catch (Exception e) {
    e.printStackTrace();
    if(tx!=null){
        tx.rollback();
    }
}finally{        
    if(s!=null &amp;&amp; s.isOpen()){
        s.close();
    }
}

System.out.println(&quot;*********************************&quot;);
try {
    //我们使用基础模板来讲解.
    s=HibernateUtil.openSession();
    tx=s.beginTransaction();        
    //查询45号学生
    Student stu1=(Student) s.get(Student.class, 45);    
    System.out.println(stu1.getName());

    Student stu3=(Student) s.get(Student.class, 46);    
    System.out.println(stu3.getName());
        tx.commit();

} catch (Exception e) {
    e.printStackTrace();
    if(tx!=null){
        tx.rollback();
    }
}finally{

    if(s!=null &amp;&amp; s.isOpen()){
        s.close();
    }
}

//完成一个统计，统计的信息在Sessfactory
//SessionFactory对象.
Statistics statistics= HibernateUtil.getSessionFactory().getStatistics();
System.out.println(statistics);
System.out.println(&quot;放入&quot;+statistics.getSecondLevelCachePutCount());
System.out.println(&quot;命中&quot;+statistics.getSecondLevelCacheHitCount());
System.out.println(&quot;错过&quot;+statistics.getSecondLevelCacheMissCount());
</code></pre><p>4、在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高</p>
<h2 id="主键增长策略"><a href="#主键增长策略" class="headerlink" title="主键增长策略"></a>主键增长策略</h2><p>① increment</p>
<pre><code>自增，每次增长1, 适用于所有数据库。但是不要使用在多进程、主键类型是数值型
select max(id) from Student
</code></pre><p>② identity</p>
<pre><code>自增，每次增长1, 适用于支持identity的数据(mysql,sql server), 主键类型是数值
</code></pre><p>③ sequence</p>
<pre><code>依赖于底层数据库系统的序列，前提条件:需要数据库支持序列机制（如:oracle等）,而且OID必须为数值类型,比如long,int,short类型。
</code></pre><p>④ native</p>
<pre><code>会根据数据类型来选择，使用identity,sequence,hilo 
select hibernate_sequence.nextval from dual
主键类型是数值long , short ,int
&lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; 
    &lt;generator class=&quot;native&quot;/&gt;
&lt;/id&gt;
</code></pre><p>⑤ hilo</p>
<pre><code>hilo标识符生成器由Hibernate按照一种high/low算法生成标识符
用法:
&lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot; column=&quot;ID&quot;&gt;
    &lt;generator class=&quot;hilo&quot;&gt;
        &lt;param name=&quot;table&quot;&gt;my_hi_value&lt;/param&gt;
        &lt;param name=”column”&gt;next_value&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;
</code></pre><p>⑥ uuid</p>
<pre><code>会根据uuid算法，生成128-bit的字串
主键属性类型不能是数值型，而是字串型
</code></pre><p>⑦ assigned</p>
<pre><code>用户自己设置主键值，所以主键属性类型可以是数值，字串
</code></pre><p>⑧ 映射复合主键<br>⑨ foreign </p>
<pre><code>在one-to-one的关系中，有另一张表的主键(Person)来决定自己主键/外键(IdCard)[既是主键也是外键]
</code></pre><h3 id="一个简单选择原则"><a href="#一个简单选择原则" class="headerlink" title="一个简单选择原则"></a>一个简单选择原则</h3><ul>
<li>针对 mysql [主键是 int/long/short 建议使用increment/assigend，如果是字串 UUId/assigned]</li>
<li>针对 sql server [主键是 int/long/short 建议使用 identity/native/assinged，如果主键是字串，使用uuid/assigned ]</li>
<li>one-to-one 又是基于主键的则使用foreign</li>
</ul>
<h2 id="Hibernate最佳实践"><a href="#Hibernate最佳实践" class="headerlink" title="Hibernate最佳实践"></a>Hibernate最佳实践</h2><h3 id="Hibernate不适合的场景"><a href="#Hibernate不适合的场景" class="headerlink" title="Hibernate不适合的场景"></a>Hibernate不适合的场景</h3><ul>
<li>不适合OLAP(On-Line Analytical Processing <strong><em>联机分析处理</em></strong> )，以查询分析数据为主的系统；适合OLTP（on-line transaction processing <strong><em>联机事务处理</em></strong> ）</li>
</ul>
<p><img src="http://i.imgur.com/kqShTak.png" alt=""></p>
<ul>
<li>对于些关系模型设计不合理的老系统，也不能发挥hibernate优势</li>
<li>数据量巨大，性能要求苛刻的系统，hibernate也很难达到要求, 批量操作数据的效率也不高 </li>
</ul>
<h3 id="Hibernate最佳实践-1"><a href="#Hibernate最佳实践-1" class="headerlink" title="Hibernate最佳实践"></a>Hibernate最佳实践</h3><ul>
<li>对于数据量大，性能要求高系统，不太适用使用hiberante</li>
<li>主要用于事务操作比较多的项目(oa/某个行业软件[石油、税务、crm, 财务系统]</li>
<li>OLAP-&gt;hibernate用的比较少   </li>
<li>OLTP-&gt;hibernate</li>
</ul>
<h2 id="Hibernate开发过程（总结）"><a href="#Hibernate开发过程（总结）" class="headerlink" title="Hibernate开发过程（总结）"></a>Hibernate开发过程（总结）</h2><p><strong><em>hibernate.cfg.xml</em></strong></p>
<pre><code>Hibernate快速入门 - hibernate.cfg.xml
</code></pre><p><strong><em>domain对象</em></strong></p>
<pre><code>Hibernate快速入门 - 开发domain对象
</code></pre><p><strong><em>关系映射文件</em></strong></p>
<pre><code>Hibernate快速入门 - 手动配置我们的hibernate.cfg.xml文件
</code></pre><p><strong><em>基础模版</em></strong></p>
<pre><code>//获取一个会话
Session session = HibernateUtil.getCurrentSession();
Transaction transaction = null;
try{
    transaction = session.beginTransaction();
    //do...

    transaction.commit();
}catch (Exception e){
    e.printStackTrace();
    if(transaction != null){
        transaction.rollback();
    }
    throw new RuntimeException(e.getMessage());
}finally {
    //关闭session
    if(session != null &amp;&amp; session.isOpen()){
        session.close();
    }
}
</code></pre><p><strong><em>HibernateUtil（增删改查）</em></strong><br><a href="https://github.com/rhapsody1290/Hibernate_Study/blob/master/src/main/java/cn/apeius/util/HibernateUtil.java" target="_blank" rel="external">https://github.com/rhapsody1290/Hibernate_Study/blob/master/src/main/java/cn/apeius/util/HibernateUtil.java</a></p>
<p><strong><em>查询</em></strong></p>
<pre><code>#查询全部
String sql = &quot;from Student&quot;;
List&lt;Student&gt; list = HibernateUtil.executeQuery(sql, null);
for(Student s : list)
    System.out.println(s.getSname());
#条件查询
String sql = &quot;from Student where sdept = ? and sage &gt; ?&quot;;
String[] parameters = {&quot;计算机系&quot;, &quot;3&quot;};
List&lt;Student&gt; list = HibernateUtil.executeQuery(sql, parameters);
for(Student s : list)
    System.out.println(s.getSname());
#部分查询
String sql = &quot;select sname, saddress from Student where sdept = ? and sage &gt; ?&quot;;
String[] parameters = {&quot;计算机系&quot;, &quot;3&quot;};
List&lt;Object[]&gt; list = HibernateUtil.executeQuery(sql, parameters);
for(Object[] s : list)
    System.out.println(s[0] + &quot; &quot; + s[1]);
</code></pre><p><strong><em>分页</em></strong></p>
<pre><code>String sql = &quot;from Student order by sage&quot;;
List&lt;Student&gt; list = HibernateUtil.executeQueryByPage(sql, null,4,2);
for(Student s : list)
    System.out.println(s.getSname());
</code></pre><p><strong><em>添加</em></strong></p>
<pre><code>Course c = new Course();
c.setCid(61);
c.setCname(&quot;servlet&quot;);
HibernateUtil.save(c);
</code></pre><p><strong><em>修改</em></strong></p>
<pre><code>String sql = &quot;update Course set ccredit = 2 where cid = 61&quot;;
HibernateUtil.executeUpdate(sql,null);
</code></pre><p><strong><em>删除</em></strong></p>
<pre><code>String sql = &quot;delete from Course where cid = 61&quot;;
HibernateUtil.executeUpdate(sql,null);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
