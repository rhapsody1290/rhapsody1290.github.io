<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://qianmingxs.com/page/14/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/page/14/"/>





  <title>Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/14/[Servlet]JSP笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/14/[Servlet]JSP笔记/" itemprop="url">JSP笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-14T11:09:00+08:00">
                2016-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p><strong><em>Java片段</em></strong>  </p>
<pre><code>&lt;%!  %&gt; jsp声明，在这里面声明的变量是全局变量，也可以函数定义
&lt;%  %&gt; Java片段，在这里面声明的变量是局部变量，
注释 &lt;%-- --%&gt;，&lt;%// % &gt;，&lt;%/* */% &gt;
&lt;%=  %&gt; 表达式
</code></pre><h2 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h2><ul>
<li>在web开发过程中，发现servlet做界面比较麻烦（out.println），于是又有一个新的技术JSP</li>
<li>JSP（Java Servlet Page）运行在服务器的语言，响应客户端请求，动态生成网页的技术</li>
</ul>
<h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h2><p><img src="http://i.imgur.com/WeHcjuc.png" alt=""></p>
<ul>
<li>如果是第一次访问jsp文件，web服务器就会把showTime.jsp <strong><em>翻译</em></strong> 成一个showTime_jsp.java（IDEA中showTIme_jsp.java的目录：<pre>C:\Users\Asus\.IntelliJIdea15\system\tomcat\Unnamed_JSP_Study\work\Catalina\localhost\JSP_Study\org\apache\jsp\showTime_jsp.java）</pre></li>
<li><font color="red">再将其编译成一个showTime_jsp.class，并把class加载到内存</font></li>
<li>然后创建一个该Servlet的实例，调用其jspInit方法，该方法在Servlet生命周期中只被执行一次，并调用实例的jspService()方法</li>
<li>如果是第二次或者以后，就直接访问内存中的实例的jspService()方法。JSP也是单例，所以第一次访问JSP网站速度比较慢，后面访问JSP的速度就变快了</li>
<li>如果某个JSP文件被修改了，就相当于重新访问JSP（相当于第一次访问）</li>
</ul>
<h2 id="JSP显示页面"><a href="#JSP显示页面" class="headerlink" title="JSP显示页面"></a>JSP显示页面</h2><p>Jsp页面中的html排版标签是如何被发送到客户端的？答：JSP中被翻译成Servlet时，HTML标签会<font color="red"><strong><em>以out.write()的形式打印出来</em></strong>，</font>例如：</p>
<pre><code>out.write(&quot;&lt;table border=1&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;tr&gt;&lt;td&gt;apple&lt;/td&gt;&lt;td&gt;melon&lt;/td&gt;&lt;td&gt;orange&lt;/td&gt;&lt;/tr&gt;\r\n&quot;);
out.write(&quot;&lt;/table&gt;\r\n&quot;);
</code></pre><h2 id="JSP中的Java片段"><a href="#JSP中的Java片段" class="headerlink" title="JSP中的Java片段"></a>JSP中的Java片段</h2><p>Jsp页面中的java代码，服务器是如何执行的？比如JSP中的Java代码:</p>
<pre><code>&lt;%
    int i=90;
    int j=i+90;
%&gt;
&lt;h1&gt;测试.&lt;/h1&gt;
&lt;%
    out.println(&quot;j=&quot;+j);
%&gt;
</code></pre><p>  当被翻译成Servlet后，格式如下</p>
<pre><code>public void _jspService(HttpServletRequest request, HttpServletResponse response)
    throws java.io.IOException, ServletException {
    int i=90;
    int j=i+90;
    out.println(&quot;j=&quot;+j);
}
</code></pre><ol>
<li>就是有多个&lt;% %&gt; 其实相当于是一个大的 &lt;% %&gt;，所有代码会<strong><em>放在一个_jspService函数中</em></strong></li>
<li>在&lt;% %&gt; 中定义的变量，会成为service函数的局部变量.</li>
</ol>
<h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><p>Web服务器在调用jsp时，会给jsp提供一些内置对象，<strong><em>这些内置对象无需创建可直接使用</em></strong>。前五个较常用，分别与Servlet中的几个对象对应</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>request：请求对象</td>
<td>javax.servlet.ServletRequest的子类</td>
<td>Request</td>
</tr>
<tr>
<td>response：响应对象</td>
<td>javax.servlet.ServletResponse的子类</td>
<td>Page</td>
</tr>
<tr>
<td>pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面</td>
<td>javax.servlet.jsp.PageContext</td>
<td>Page</td>
</tr>
<tr>
<td>session：会话对象，用于保存用户信息，跟踪用户行为</td>
<td>javax.servlet.http.HttpSession</td>
<td>Session</td>
</tr>
<tr>
<td>application：应用程序对象，多个用户共享该对象，可以做计数器</td>
<td>javax.servlet.ServletContext</td>
<td>Application</td>
</tr>
<tr>
<td>out：输出对象</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>Page</td>
</tr>
<tr>
<td>config：配置对象</td>
<td>javax.servlet.ServletConfig</td>
<td>Page</td>
</tr>
<tr>
<td>page：页面对象，代表JSP实例本身，使用较少</td>
<td>java.lang.Object</td>
<td>Page</td>
</tr>
<tr>
<td>exception：异常对象</td>
<td>java.lang.Throwable</td>
<td>Page</td>
</tr>
</tbody>
</table>
<h2 id="JSP的语法"><a href="#JSP的语法" class="headerlink" title="JSP的语法"></a>JSP的语法</h2><h3 id="指令元素"><a href="#指令元素" class="headerlink" title="指令元素"></a>指令元素</h3><p>　　概念: 用于从jsp发送一个信息到容器，比如设置全局变量,文字编码,引入包</p>
<h4 id="①page指令"><a href="#①page指令" class="headerlink" title="①page指令"></a>①page指令</h4><pre><code>&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;    
</code></pre><p><strong><em>常用的属性</em></strong>  </p>
<pre><code>language = &quot;xx&quot;，jsp中嵌入代码语言，通常是java
import = &quot;包.类名&quot;，在jsp页面引入类
errorPage=&quot;err.jsp&quot;，当JSP页面出现错误时，自动跳转到指定页面

contentType 和 pageEncoding的区别：
    contentType = &quot;text/html;charset=utf-8&quot; 指定网页以什么方式显示页面
    pageEncoding=&quot;utf-8&quot; 指定Servlet引擎以什么方法翻译jsp-&gt;servlet并指定网页以什么方式显示页面
</code></pre><h4 id="②include指令"><a href="#②include指令" class="headerlink" title="②include指令"></a>②include指令</h4><pre>
&lt;%@ include file="文件路径" %&gt;
</pre>

<ul>
<li>该指令用于引入一个文件（通常是JSP文件），JSP引擎会把两个JSP文件翻译成一个Servlet文件，因此也称为静态引入</li>
<li>被引入的JSP文件，只需保留page指令即可，html，body等均可省略★★★</li>
</ul>
<h4 id="③taglib指令"><a href="#③taglib指令" class="headerlink" title="③taglib指令"></a>③taglib指令</h4><p>　　允许在JSP页面使用自定义的标签</p>
<pre><code>&lt;mytag:yourTag num1 = &quot;123&quot; /&gt; 
</code></pre><h3 id="脚本元素-理解为脚本片段"><a href="#脚本元素-理解为脚本片段" class="headerlink" title="脚本元素(理解为脚本片段)"></a>脚本元素(理解为脚本片段)</h3><h4 id="java片段"><a href="#java片段" class="headerlink" title="java片段"></a>java片段</h4><pre><code>&lt;% java 代码 %&gt;
</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><pre><code>&lt;%=表达式 %&gt;，例如&lt;%=i*78-23%&gt;
</code></pre><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>全局变量</p>
<pre><code>&lt;%! int i=90; %&gt;
</code></pre><p>局部变量</p>
<pre><code>&lt;% int i=90;%&gt;
</code></pre><h4 id="定义函数★★★★★"><a href="#定义函数★★★★★" class="headerlink" title="定义函数★★★★★"></a>定义函数★★★★★</h4><pre><code>&lt;%!
    public int getResult(int a,int b){
        return a+b;
    }
%&gt;
注意：函数不能在&lt;% %&gt; 定义.
</code></pre><h3 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h3><p><strong><em>jsp:forward</em></strong></p>
<pre><code>&lt;jsp:forword file=&quot;xxx&quot;&gt;&lt;/jsp:forword&gt;页面跳转
</code></pre><p>　　在开发JSP的过程中，我们通常把JSP放入WEB-INF目录，目的是为了防止用户直接访问这些jsp文件.<br>　　在WebRoot下我们有一个入口页面,它的主要转发</p>
<pre><code>&lt;jsp:forword file=&quot;/WEB-INF/xx.jsp&quot;&gt;&lt;/jsp:forword&gt;
</code></pre><p><strong><em>jsp:incluce</em></strong>  </p>
<pre><code>&lt;%@ include file=&quot;&quot;%&gt; 静态引入
&lt;jsp:incluce  file=&quot;&quot;&gt;&lt;/jsp:incule&gt; 动态引入
相同点： 把一个文件引入到另外一个文件
区别：
    静态引入，把两个jsp翻译成一个Servlet,所以被引入的文件不要包含&lt;body&gt;&lt;html&gt;
    动态引入，把两个jsp分别翻译,所以被引入的jsp包含有&lt;html&gt;&lt;body&gt;也可以
</code></pre><h2 id="EL表达式语言"><a href="#EL表达式语言" class="headerlink" title="EL表达式语言"></a>EL表达式语言</h2><ul>
<li>EL表达式语言可以<strong><em>方便读取应用程序中的数据</em></strong>，JSP2.0以上版本即使没有JSTL（JSP标准标签库）也能使用EL</li>
<li>EL表达式以 <code>${</code> 开头，并以 <code>}</code> 结束，如${x + y}，从左向右取值，返回结果类型为String</li>
<li>EL表达式写在JSP的HTML代码中，而不能写在”&lt;%%&gt;”引起的JSP脚本中</li>
<li><font color="red"><strong>使用 <code>[]</code> 和 <code>.</code> 运算符来访问对象的属性，形式可以是${object.peopertyName}或${object[“peopertyName”]}</strong></font>


</li>
</ul>
<h3 id="EL内置对象"><a href="#EL内置对象" class="headerlink" title="EL内置对象"></a>EL内置对象</h3><p>我们知道jsp有九个内置对象，而EL表达式有11个对象，这些内置对象无需创建可直接使用</p>
<h4 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h4><p>pageContext对象表示当前JSP页面的javax.servlet.jsp.PageContext，包含了9大JSP内置对象</p>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>request：请求对象</td>
<td>javax.servlet.ServletRequest的子类</td>
<td>Request</td>
</tr>
<tr>
<td>response：响应对象</td>
<td>javax.servlet.ServletResponse的子类</td>
<td>Page</td>
</tr>
<tr>
<td>pageContext：页面上下文对象，也是一个域对象，可以setAttribute，其作用范围只是本页面</td>
<td>javax.servlet.jsp.PageContext</td>
<td>Page</td>
</tr>
<tr>
<td>session：会话对象，用于保存用户信息，跟踪用户行为</td>
<td>javax.servlet.http.HttpSession</td>
<td>Session</td>
</tr>
<tr>
<td>application：应用程序对象，多个用户共享该对象，可以做计数器</td>
<td>javax.servlet.ServletContext</td>
<td>Application</td>
</tr>
<tr>
<td>out：输出对象</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>Page</td>
</tr>
<tr>
<td>config：配置对象</td>
<td>javax.servlet.ServletConfig</td>
<td>Page</td>
</tr>
<tr>
<td>page：页面对象，代表JSP实例本身，使用较少</td>
<td>java.lang.Object</td>
<td>Page</td>
</tr>
<tr>
<td>exception：异常对象</td>
<td>java.lang.Throwable</td>
<td>Page</td>
</tr>
</tbody>
</table>
<p>例：获得客户端IP</p>
<pre><code>${pageContext.request.remoteAddr}
</code></pre><h4 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h4><p>包含所有初始化参数的Map，可以获取初始化参数</p>
<p>例，设置初始化参数</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>获得初始化参数</p>
<pre><code>${initParam.encoding}
</code></pre><h4 id="param"><a href="#param" class="headerlink" title="param"></a>param</h4><p>包含所有参数的Map，可以获取参数，返回String</p>
<p>例：url</p>
<pre><code>http://localhost:8080/SpringMVC_study/?name=xxx
</code></pre><p>获得参数</p>
<pre><code>${param.name}    
</code></pre><h4 id="paramValues"><a href="#paramValues" class="headerlink" title="paramValues"></a>paramValues</h4><p>包含所有参数的Map，可获取参数数组，返回String[]</p>
<p>例：请求url</p>
<pre><code>http://localhost:8080/SpringMVC_study/?name=aaa&amp;name=bbb
</code></pre><p>提交的参数name有多个值{“aaa”,”bbb”}，使用param只能获取第一个值，二使用paramValues能够获得其他的值</p>
<pre><code>${paramValues.name[0]}
${paramValues.name[1]}
</code></pre><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>包含所有头信息的Map，可以获取头信息</p>
<p>例：获得请求主机</p>
<pre><code>${header.host}
</code></pre><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>包含所有Cookie的Map，key为Cookie的name</p>
<pre><code>${cookie.JSESSIONID.value}
</code></pre><h4 id="applicationScope，sessionScope，requestScope，pageScope"><a href="#applicationScope，sessionScope，requestScope，pageScope" class="headerlink" title="applicationScope，sessionScope，requestScope，pageScope"></a>applicationScope，sessionScope，requestScope，pageScope</h4><p>分别是包含application，session，request，page作用域变量的Map</p>
<p>以requestScope为例：</p>
<p>使用<jsp:usebean id="person" class="com.jsp.bean.Person">声明person对象后，${pageScope.person.age}将输出person的age属性，useBean域默认的作用域为request</jsp:usebean></p>
<p>若输出session域中的变量，声明使<jsp:usebean id="person" class="com.jsp.bean.Person" scope="session"></jsp:usebean></p>
<h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>JSP标准标签库，用来解决遍历map或集合，格式化数字和日期等常见问题</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><p>JSTL 核心标签库标签共有13个，功能上分为4类：</p>
<ol>
<li>表达式控制标签：out、set、remove、catch</li>
<li>流程控制标签：if、choose、when、otherwise</li>
<li>循环标签：forEach、forTokens</li>
<li>URL操作标签：import、url、redirect</li>
</ol>
<h3 id="JSTL核心库"><a href="#JSTL核心库" class="headerlink" title="JSTL核心库"></a>JSTL核心库</h3><p><font color="red"><strong><em>使用标签时，一定要在jsp文件头加入以下代码：</em></strong></font></p>

<pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
</code></pre><h3 id="完整JSTL标签使用"><a href="#完整JSTL标签使用" class="headerlink" title="完整JSTL标签使用"></a>完整JSTL标签使用</h3><p><a href="http://www.cnblogs.com/lihuiyy/archive/2012/02/24/2366806.html" target="_blank" rel="external">http://www.cnblogs.com/lihuiyy/archive/2012/02/24/2366806.html</a></p>
<h3 id="遍历行为：-lt-c-forEach-gt"><a href="#遍历行为：-lt-c-forEach-gt" class="headerlink" title="遍历行为：&lt;c:forEach&gt;"></a>遍历行为：&lt;c:forEach&gt;</h3><p>语法：<br>&lt;c:forEach var=”name” items=”Collection” varStatus=”statusName” begin=”begin” end=”end” step=”step”&gt;&lt;/c:forEach&gt;</p>
<p>该标签根据循环条件遍历集合 Collection 中的元素。 var 用于存储从集合中取出的元素；items 指定要遍历的集合；</p>
<p><strong><em>遍历list</em></strong></p>
<pre>
&lt;%
    List a=new ArrayList();
    a.add("贝贝");
    a.add("晶晶");
    a.add("欢欢");
    a.add("莹莹");
    a.add("妮妮");
    request.setAttribute("a",a);
%>

<font color="red">&lt;c:forEach var="fuwa" items="${a}">
    &nbsp;&lt;c:out value="${fuwa}"/>&lt;br>
&lt;/c:forEach></font>
</pre>

<p><strong><em>遍历Map</em></strong></p>
<pre><code>&lt;%
    Map&lt;String, String&gt; capitals = new HashMap&lt;String,String&gt;();
    capitals.put(&quot;Indonesia&quot;,&quot;Jakarta&quot;);
    capitals.put(&quot;Malaysia&quot;,&quot;Kuala Lumpur&quot;);
    capitals.put(&quot;Thailand&quot;,&quot;Bangkok&quot;);
    request.setAttribute(&quot;capitals&quot;,capitals);
%&gt;

&lt;c:forEach var=&quot;capital&quot; items=&quot;${capitals}&quot;&gt;
    ${capital.key} ${capital.value} &lt;br/&gt;
&lt;/c:forEach&gt;
</code></pre><p><strong><em>forEach嵌套</em></strong></p>
<pre><code>&lt;%
    Map&lt;String, String[]&gt; bigCities = new HashMap&lt;String,String[]&gt;();
    bigCities.put(&quot;Australia&quot;,new String[]{&quot;Sydney&quot;,&quot;Melbourne&quot;,&quot;Perth&quot;});
    bigCities.put(&quot;New Zealand&quot;,new String[]{&quot;Auckland&quot;,&quot;Christchurch&quot;,&quot;Wellington&quot;});
    bigCities.put(&quot;Indonesia&quot;,new String[]{&quot;Jakarta&quot;,&quot;Surabaya&quot;,&quot;Medan&quot;});
    request.setAttribute(&quot;bigCities&quot;,bigCities);
%&gt;

&lt;c:forEach var=&quot;mapItem&quot; items=&quot;${bigCities}&quot;&gt;
    ${mapItem.key} :
        &lt;c:forEach var=&quot;city&quot; items=&quot;${mapItem.value}&quot;&gt;
            ${city}
        &lt;/c:forEach&gt;
    &lt;br/&gt;
&lt;/c:forEach&gt;
</code></pre><h3 id="格式化日期和时间"><a href="#格式化日期和时间" class="headerlink" title="格式化日期和时间"></a>格式化日期和时间</h3><pre><code>&lt;b&gt;格式化日期&lt;/b&gt;&lt;br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; dateStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;格式化时间&lt;/b&gt;&lt;/br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;time&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;格式化日期和时间&lt;/b&gt;&lt;/br/&gt;
default：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot;/&gt; &lt;br/&gt;
short：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;short&quot;/&gt; &lt;br/&gt;
medium：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;medium&quot;/&gt; &lt;br/&gt;
long：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;long&quot;/&gt; &lt;br/&gt;
full：&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; timeStyle=&quot;full&quot;/&gt; &lt;br/&gt;&lt;br/&gt;

&lt;b&gt;定制格式化日期和时间&lt;/b&gt;&lt;/br/&gt;
&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;br/&gt;
&lt;fmt:formatDate value=&quot;${now}&quot; type=&quot;both&quot; pattern=&quot;yy/MM/dd HH:mm:ss&quot;/&gt; &lt;br/&gt;
</code></pre><p>浏览器显示：</p>
<p><img src="http://i.imgur.com/4NLTcOv.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/13/[Java]Java中配置文件放在哪里/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/13/[Java]Java中配置文件放在哪里/" itemprop="url">Java中配置文件放在哪里</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-13T22:04:00+08:00">
                2016-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><p>　　Java中路径可分为相对路径和绝对路径两种方式。<font color="red">相对路径</font>是相对当前工作目录，例如当使用命令</p>
<pre><code>C:\Users\Asus&gt;java MyClass xxx.properties  
</code></pre><p>要求在<code>C:\Users\Asus</code>目录下有xxx.properties文件，而在使用</p>
<pre><code>C:\&gt;java MyClass xxx.properties
</code></pre><p>时则要求在C盘根目录下有xxx.properties文件，所以使用相对路径是<strong>飘忽不定</strong>的，不建议使用。<br>　　但如果给出<font color="red">绝对路径</font>，<code>D:\xxx.properties</code>,当工程给用户时，若用户没有D盘，就会出现问题。<br>　　<strong>综上所述</strong>，仍旧采用绝对路径的方式来确定资源文件的地址，但是需要通过函数方法得到项目路径,在通过字符串连接的方式拼接得到绝对路径。</p>
<pre><code>//此时config.properties文件放在工程文件根目录下，即选择工程右键后，新建config.properties文件
InputStream ips = new FileInputStream(&quot;config.properties&quot;);
Properties properties = new Properties();
properties.load(ips);
System.out.println(properties.getProperty(&quot;name&quot;));  
</code></pre><h2 id="Java中比较常用的加载资源的方式"><a href="#Java中比较常用的加载资源的方式" class="headerlink" title="Java中比较常用的加载资源的方式"></a>Java中比较常用的加载资源的方式</h2><p>　　类加载器把字节码加载到内存中，即它可以加载.class文件，也可以加载普通文件。<br>　　当工程完成后，不会将工程目录下中的Src目录给用户（怎么可能会把源代码给用户），而是将bin目录下的文件，一些字节码等文件在用户电脑上运行。<br>　　eclipse会自动将Java文件编译，并存放字节码在 <code>工程目录/bin/包名</code>目录下，Java文件对应编译后的字节码，普通文件(如config.properties文件)仍原封不动拷贝过去。<br>　　类加载器会在<code>classPath</code>中搜索。<br>　　<font color="red">使用类加载器时，默认的主目录是src</font></p>
<pre><code>public class ReflectTest {
    public static void main(String[] args) throws Exception{
        /*InputStream ips = new FileInputStream(&quot;config.properties&quot;);
        Properties properties = new Properties();
        properties.load(ips);
        System.out.println(properties.getProperty(&quot;name&quot;));   */ 
        InputStream ipsInputStream = ReflectTest.class.getClassLoader().getResourceAsStream(&quot;com/qianming/config.properties&quot;);

        //在class类中直接有一个getResourceAsStream方法，路径名相对当前包名的相对路径，所以这里可以直接写config.properties
        //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;config.properties&quot;);
        //如果路径中写上&apos;/&apos;，则此时需相对根目录写路径
        //InputStream ipsInputStream = ReflectTest.class.getResourceAsStream(&quot;/com/qianming/config.properties&quot;);

        Properties properties = new Properties();
        properties.load(ipsInputStream);
        System.out.println(properties.getProperty(&quot;name&quot;));
    }
}
</code></pre><p><strong><em>注意:</em></strong><br>　　这里使用的路径是<code>com/qianming/config.properties</code>，即在<code>包/资源文件</code>的形式不能在com前加 <strong>“/“</strong>,记忆就行，否则会报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/08/[Java]Java基础常用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/08/[Java]Java基础常用/" itemprop="url">Java基础常用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-08T14:49:00+08:00">
                2016-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读取文件根目录"><a href="#读取文件根目录" class="headerlink" title="读取文件根目录"></a>读取文件根目录</h2><pre><code>根目录在工程目录
InputStream ips = new FileInputStream(&quot;src/xx.properties&quot;);
类加载器根目录在src下
InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;);
maven项目根目录为resources
InputStream ips = test.class.getClassLoader().getResourceAsStream(&quot;xx.properties&quot;);
</code></pre><h2 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h2><pre><code>//读取文件
String realPath = this.getServletContext().getRealPath(&quot;record.txt&quot;);
FileReader fileReader = new FileReader(realPath);
BufferedReader br = new BufferedReader(fileReader);
String nums = br.readLine();
//一定要关闭流
br.close();
fileReader.close();
out.println(nums);
//写入文件
FileWriter fileWriter = new FileWriter(realPath);
BufferedWriter bw = new BufferedWriter(fileWriter);
bw.write(String.valueOf(Integer.parseInt(nums) + 1));
bw.close();
fileWriter.close();
</code></pre><h2 id="从控制台读取数据"><a href="#从控制台读取数据" class="headerlink" title="从控制台读取数据"></a>从控制台读取数据</h2><pre><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(br.readLine());
</code></pre><h2 id="Java读取资源文件"><a href="#Java读取资源文件" class="headerlink" title="Java读取资源文件"></a>Java读取资源文件</h2><pre><code>/**
 * 文件类型是UTF-8，在String生成字符时需指定解码方式为utf-8；
 */
InputStream ips = null;
try {
    ips = MyServer.class.getClassLoader().getResourceAsStream(&quot;com/main/戏曲.txt&quot;);
    int hasRead = 0;
    byte[] buffer = new byte[1024];
    StringBuffer content = new StringBuffer();
    while((hasRead = ips.read(buffer)) &gt; 0){
        content.append(new String(buffer, 0, hasRead, &quot;utf-8&quot;));
    }
    System.out.println(content);
} catch (Exception e) {
    e.printStackTrace();
}finally{
    if (ips != null) {
        try {
            ips.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>四舍五入
float totalMoney = 123.124f;
BigDecimal b = new BigDecimal(totalMoney);  
totalMoney  = b.setScale(2,BigDecimal.ROUND_HALF_UP).floatValue();  
保留两位小数
String.format(&quot;%.2f&quot;, totalMoney)
</code></pre><h2 id="生成指定长度的随机字符串"><a href="#生成指定长度的随机字符串" class="headerlink" title="生成指定长度的随机字符串"></a>生成指定长度的随机字符串</h2><pre><code>//生成指定长度的随机字符串    
public static String GenRandomString(int length){
    Random random = new Random();    
    char[] charArray = &quot;abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
    char[] randomChar = new char [length];
    for(int i = 0; i &lt; randomChar.length; i++){
        randomChar[i] = charArray[random.nextInt(charArray.length)];
    }        
    return new String(randomChar);    
}
</code></pre><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>MAVEN依赖：http://blog.csdn.net/earbao/article/details/44900083
连接步骤：http://www.cnblogs.com/hongten/archive/2011/03/29/1998311.html
</code></pre><p><strong><em>JDBC查询</em></strong></p>
<pre><code>//到数据库中验证
/*
* 1.加载驱动
* 2.得到连接
* 3.创建PrepareStatment
* 4.执行操作
* 5.根据结果做处理
* */
Connection connection = null;
PreparedStatement ps = null;
ResultSet rs = null;

try {
    //1.加载驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
    //2.获得连接
    connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/servlet_users_manager&quot;,&quot;root&quot;,&quot;root&quot;);
    //3.创建prepareStatement
    ps = connection.prepareStatement(&quot;select * from users where username = ? and passwd = ?&quot;);
    ps.setObject(1,username);
    ps.setObject(2,password);
    //4.执行操作
    rs = ps.executeQuery();
    //5.根据结果做处理
    if(rs.next()){
        //说明用户合法
        System.out.println(rs.getString(&quot;username&quot;) + &quot; &quot; + rs.getString(&quot;passwd&quot;));
        request.getRequestDispatcher(&quot;/MainFrame&quot;).forward(request,response);
    }else{
        request.getRequestDispatcher(&quot;/Login&quot;).forward(request,response);
    }
} catch (Exception e) {
    e.printStackTrace();
}finally {
    //关闭资源
    if(rs != null){   // 关闭记录集
        try{
            rs.close();
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
    if(ps != null){   // 关闭声明
        try{
            ps.close() ;
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
    if(connection != null){  // 关闭连接对象
        try{
            connection.close() ;
        }catch(Exception e){
            e.printStackTrace() ;
        }
    }
}
</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><strong><em>定义四个分页变量</em></strong></p>
<pre><code>pageNow   表示第几页,该变量是由用户来决定,因此变化
pageSize  每页显示几条记录,由程序指定,也可以由用户定制
pageCount 表示共有多少页, 该变量是计算出来-&gt;思考 怎样确定
rowCount  共有多少条记录,该变量是查询数据库得到
</code></pre><p><strong><em>如何确定pageCount</em></strong>    </p>
<pre><code>(1)
if(rowCount% pageSize==0){
    pageCount=rowCount/pageSize;
}else{
    pageCount= rowCount/pageSize+1;
}
试试: 比如 users表 9 条记录 pageSize=3  =&gt;pageCount=3
       比如 users表 10 条记录 pageSize=3  =&gt;pageCount=4
(2)
上面的算法等价于
pageCount=rowCount% pageSize==0 ? rowCount/pageSize: rowCount/pageSize+1;

该运算称为三目运算
(3)
更简单的算法是:★★★★★
pageCount=(rowCount-1)/pageSize+1;
试试: 比如 users表 9 条记录 pageSize=3  =&gt;pageCount=3
       比如 users表 11 条记录 pageSize=3  =&gt;pageCount=4
为什么？
    如果pageSize整除rowCount，值不需要加一；
    如果pageSize不整除rowCount，值需要加一。
    我们可以使rowCount-1，保证每次都不能整除，这样可以得到统一公式:
        pageCount = （rowCount-1）/pageSize + 1
</code></pre><h3 id="项目中传递参数"><a href="#项目中传递参数" class="headerlink" title="项目中传递参数"></a>项目中传递参数</h3><p>客户端传递：pageNow、pageSize（为保证程序健壮性，服务器中设置pageNow和pageSize的默认值）<br>服务器传递：数据和rowCount</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>利用Java自带的MD5加密</p>
<pre><code>class MD5Util {
    public final static String MD5(String s) {
        char hexDigits[] = { &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,
                &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; };
        try {
            byte[] strTemp = s.getBytes();
            MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;);
            mdTemp.update(strTemp);
            byte[] md = mdTemp.digest();
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i &lt; j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];
                str[k++] = hexDigits[byte0 &amp; 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            return null;
        }
    }

    public static void main(String[] args) {
        // MD5_Test aa = new MD5_Test();
        System.out.print(MD5Util.MD5(&quot;qm&quot;));
    }
}
</code></pre><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><pre><code>public class check_code extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 7.禁止浏览器缓存随机图片
        response.setDateHeader(&quot;Expires&quot;, -1);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        // 6.通知客户机以图片方式打开发送过去的数据
        response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);
        // 1.在内存中创建一副图片
        BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB);
        // 2.向图片上写数据
        Graphics g = image.getGraphics();
        // 设背景色
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 60, 30);
        // 3.设置写入数据的颜色和字体
        g.setColor(Color.RED);
        g.setFont(new Font(null, Font.BOLD, 20));
        // 4.向图片上写数据
        String num = makeNum();
        //这句话就是把随机生成的数值，保存到session
        request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了
        g.drawString(num, 5, 22);
        // 5.把写好数据的图片输出给浏览器
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }
    //该函数时随机生成4位数字
    public String makeNum() {
        Random r = new Random();
        //9999999 可以生成7位
        String num = r.nextInt(9999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        //如果不够4位，前面补零
        for (int i = 0; i &lt; 4 - num.length(); i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
</code></pre><h2 id="list转string"><a href="#list转string" class="headerlink" title="list转string[]"></a>list转string[]</h2><p>方法一：单个元素转换</p>
<pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);
//转化成Object数组
Object[] objs = array.toArray();
//新建数组
String[] strings = new String[array.size()];
//每个元素类型转换
int i = 0;
for(Object obj : objs){
    if(obj instanceof String){
        strings[i++] = (String)obj;
    }
}
for(String s : strings){
    System.out.println(s);
}
</code></pre><p>方法二：整个转</p>
<pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);

String[] strings = new String[array.size()];
array.toArray(strings);
for(String s : strings){
    System.out.println(s);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/08/[Java]JAVA分层思想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/08/[Java]JAVA分层思想/" itemprop="url">JAVA分层思想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-08T14:49:00+08:00">
                2016-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用户管理系统系统框架【需改造】"><a href="#用户管理系统系统框架【需改造】" class="headerlink" title="用户管理系统系统框架【需改造】"></a>用户管理系统系统框架【需改造】</h2><p><strong><em>存在的问题</em></strong>  </p>
<p>　　LoginClServlet中太过臃肿，既有业务逻辑，又有对数据库的操作，后期难以进行维护</p>
<p><img src="http://img.blog.csdn.net/20160611213134633" alt="这里写图片描述"></p>
<h2 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h2><p>① 业务逻辑代码和界面分离<br>② 把常用的代码(对数据库的连接和操作)封装到工具类SqlHelper【有时也称为DAO，数据访问对象，是对数据库进行操作】</p>
<h2 id="具体的方法"><a href="#具体的方法" class="headerlink" title="具体的方法"></a>具体的方法</h2><p>①    每一张表对应一个<font color="red">domain类</font>(表示数据)，还要对应一个<font color="red">Service类</font>（表示操作）<br>比如 users 表 对应 Users 类(domain 类)，UserService类(该类会封装对users表的各种操作)</p>
<p>每个表对应一个domain对象和Service类，将关系模型转化为对象模型（如下图），实际上这里体现出数据和操作分离的思想<br>② view负责与用户进行交互，并将数据传递给controller<br>③ controller接收view中传递的数据，进行数据校验，并调用service方法，根据返回结果的不同跳转到不同的显示页面</p>
<p><img src="http://img.blog.csdn.net/20160611212436607" alt="这里写图片描述"></p>
<h2 id="改造后系统框架"><a href="#改造后系统框架" class="headerlink" title="改造后系统框架"></a>改造后系统框架</h2><p><img src="http://i.imgur.com/DDiJspS.png" alt=""></p>
<ul>
<li>web层，structs位于web层，体现MVC的数据输入、数据处理、数据显示分离，当然web层需要调用service层中的方法完成数据处理。显示页面为MVC中的V，控制器为MVC中的C</li>
<li>model层可以划分为业务层（service）、DAO层、数据持久层，这里强调一下，在一个项目中不一定全部有，可以根据实际情况选择</li>
<li>hiberate（orm框架），处于数据持久层，主要解决关系模型和对象模型之间的阻抗，体现oop</li>
</ul>
<p><strong><em>详细文档</em></strong>  </p>
<p><a href="https://github.com/rhapsody1290/servlet_study_usersmanager_MVC_change/blob/master/doc/%E5%88%86%E5%B1%82.xls" target="_blank" rel="external">https://github.com/rhapsody1290/servlet_study_usersmanager_MVC_change/blob/master/doc/%E5%88%86%E5%B1%82.xls</a></p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p><strong><em>完成分页的mvc模式改写</em></strong><br>　　首先在UsersService类中添加方法getUsersByPage,然后再<br><strong><em>为什么要返回ArrayList ,而不是我们想到 ResultSet?</em></strong><br>　　1. ArrayList 中封装 User对象，更加符合面向对象的编程方式  OOP<br>　　2. 我们通过Resulst-&gt;User对象-&gt;ArrayList这样ArrayList和 Resultset没有关系，就可以及时关闭数据库资源</p>
<hr>
<pre><code>//按照分页来获取用户列表
public ArrayList&lt;Users&gt; getUsersByPage(int pageNow, int pageSize){
    ArrayList&lt;Users&gt; al = new ArrayList&lt;Users&gt;();

    ResultSet rs = SqlHelper.executeQuery(&quot;select * from users limit &quot; +
            (pageNow - 1) * pageSize + &quot;,&quot; + pageSize, null);
    try {
        while(rs.next()){
            Users user = new Users();
            user.setId(rs.getInt(&quot;id&quot;));
            user.setUsername(rs.getString(&quot;username&quot;));
            user.setEmail(rs.getString(&quot;email&quot;));
            user.setGrade(rs.getInt(&quot;grade&quot;));
            user.setPasswd(rs.getString(&quot;passwd&quot;));
            al.add(user);
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        SqlHelper.close(rs,SqlHelper.getPs(),SqlHelper.getCt());
    }
    return al;
}
</code></pre><h2 id="Web-Service-DAO（数据访问层）大讨论"><a href="#Web-Service-DAO（数据访问层）大讨论" class="headerlink" title="Web-Service-DAO（数据访问层）大讨论"></a>Web-Service-DAO（数据访问层）大讨论</h2><p>　　mvc规定我们应该怎样去开发软件（把数据输入，数据处理，数据显示分离）<br>　　web(jsp V/Servlet C)-servie(M)-dao(M)这是一种mvc的具体实现<br>　　web(jsp V/Servlet C)-service(M)开发方式也是一种具体的实现</p>
<p><img src="http://i.imgur.com/j26engw.png" alt=""></p>
<ul>
<li>举个例子，UserService.java中只包含业务逻辑，UserBean.java为数据对象，而对数据库的操作放在UserDao.java中</li>
<li>这种分层的好处是使数据和操作分离</li>
<li>将整个model层分为service层和dao层（数据访问层）</li>
<li>若UserService中业务需要对多张表进行操作，可以通过多个DAO的组合操作来实现</li>
<li>但在实际项目中，很多持久化逻辑本身就是业务逻辑（比如增加一个用户，增加用户信息到数据库时持久化逻辑，增加用户是业务逻辑），省略DAO层有时候更方便，更实用</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/08/[IDEA]IDEA快捷键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/08/[IDEA]IDEA快捷键/" itemprop="url">IDEA快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-08T00:00:00+08:00">
                2016-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index">
                    <span itemprop="name">IDEA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://blog.csdn.net/dc_726/article/details/42784275" target="_blank" rel="external">http://blog.csdn.net/dc_726/article/details/42784275</a></p>
<h2 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h2><ul>
<li>Alt + /基本代码提示 <font color="gray">CTRL+空格(和系统输入法冲突，请在Settings-&gt;Keymap-&gt;mainmenu -&gt; code -Completion-&gt;basic，右键添加自己的快捷键)，可以设置为Alt + /</font></li>
<li>Ctrl + Alt + /更智能地按类型信息提示 <font color="gray">默认为Ctrl+Shift+Space</font></li>
<li><strong>ALT + Enter 快速修复，类似Eclipse中的Quick Fix功能</strong></li>
<li>Ctrl+Shift+Enter 自动补全末尾的字符，例如敲完if/for时也可以自动补上{}花括号</li>
<li><strong>F2/ Shift+F2 移动到有错误的代码</strong></li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul>
<li>Ctrl+Shift+Alt+T 重构功能大汇总快捷键，叫做Refactor This</li>
<li>Shift+F6 直接就是改名</li>
<li>Ctrl+Alt+V 提取变量</li>
</ul>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><ul>
<li>Ctrl+J 可以查看所有模板</li>
<li>Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等</li>
</ul>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul>
<li><strong>Ctrl + Shift + 上下 ： 上下移动当前行</strong></li>
<li>Ctrl + Shift + 左右 ：代替鼠标选中代码</li>
<li>Ctrl + Alt + 上下 ： 复制一行</li>
<li>Alt + 上下 ： 光标函数间跳转</li>
<li><strong>Alt + 左右 ： tab切换</strong></li>
<li><strong>Ctrl + D ： 删除一行</strong></li>
<li>Ctrl + / ： 注释</li>
<li>Ctrl + / Ctrl + Shift + / ： 折叠代码</li>
<li>Ctrl + ‘+’ Ctrl + Shift + ‘+’： 展开代码</li>
<li><strong><em>Ctrl+N / Ctrl+Shift+N 可以打开类或资源</em></strong></li>
<li>Shift+Shift 在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等</li>
<li>Ctrl+F/Ctrl+Shift+F 在当前窗口或全工程中查找</li>
<li>F3/Shift+F3前后移动到下一匹配处</li>
<li><strong>格式化代码  </strong><br>　　格式化import列表：Ctrl+Alt+O<br>　　格式化代码：Ctrl+Alt+L</li>
</ul>
<h2 id="自动代码"><a href="#自动代码" class="headerlink" title="自动代码"></a>自动代码</h2><ul>
<li><strong><em>CTRL+ALT+L  格式化代码</em></strong>    </li>
<li>CTRL+E或者ALT+SHIFT+C 最近更改的代码  </li>
<li>CTRL+SHIFT+SPACE 自动补全代码  </li>
<li>CTRL+ALT+SPACE  类名或接口名提示  </li>
<li><strong><em>CTRL+P   方法参数提示</em></strong>  </li>
<li><strong><em>CTRL+ALT+T  代码模版</em></strong></li>
<li><strong>Ctrl+Shift+T 自动生成测试类</strong></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>CIRL+U   大小写切换</li>
<li>CTRL+Z   倒退</li>
<li>CTRL+SHIFT+Z  向前</li>
<li><strong><em>CTRL+ALT+F12  资源管理器打开文件夹在WINDOW窗口快速定位到文件或者文件夹的位置</em></strong></li>
<li>ALT+F1   查找文件所在目录位置</li>
<li>SHIFT+ALT+INSERT 竖编辑模式</li>
<li>CTRL+/   注释//  </li>
<li>CTRL+SHIFT+/  注释</li>
<li>CTRL+B   快速打开光标处的类或方法</li>
<li><strong><em>page up 和 page down</em></strong></li>
<li><strong><em>ALT+ ←/→  切换代码视图</em></strong></li>
<li><strong><em>ALT+ ↑/↓  在方法间快速移动定位</em></strong></li>
<li>CTRL+ALT ←/→  返回上次编辑的位置</li>
<li><strong><em>SHIFT+F6  重构-重命名</em></strong></li>
<li>CTRL+H   显示类结构图</li>
<li><strong><em>CTRL+Q   显示注释文档</em></strong></li>
<li><strong><em>ALT+1   快速打开或隐藏工程面板</em></strong></li>
<li><strong><em>ALT + 4 Run Console</em></strong></li>
<li><strong><em>ALT + 5 Debug Console</em></strong></li>
<li><strong><em>在任何工具窗口里使用Escape键都可以把焦点移到编辑器上,Shift-Escape不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口</em></strong></li>
<li>CTRL+W   选中代码，连续按会有其他效果（我去掉了）</li>
<li><strong><em>CTRL+F4   关闭当前打开文件（我修改为CTRL + W）</em></strong></li>
<li><strong>Ctrl + Shift + F12 关闭所有工具栏</strong></li>
<li><strong><em>Ctrl+H 查看类的继承关系，打开类层次窗口</em></strong></li>
<li><strong><em>Ctrl+F12 查看当前类的所有方法</em></strong></li>
<li><strong><em>Ctrl+B/Ctrl+Alt+B 在继承层次上跳转，分别对应父类或父方法定义和子类或子方法实现</em></strong></li>
<li><strong><em>Ctrl + tab 切来切去</em></strong></li>
<li><strong><em>Ctrl + Shift + A 发号施令</em></strong></li>
<li><strong><em>CTRL+G 定位行</em></strong></li>
</ul>
<h2 id="JDK-doc绑定"><a href="#JDK-doc绑定" class="headerlink" title="JDK doc绑定"></a>JDK doc绑定</h2><p>CTRL + Q 查看注释文档</p>
<p><img src="http://i.imgur.com/vHEExEB.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/07/[Servlet]Intellij IDEA创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/07/[Servlet]Intellij IDEA创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂）/" itemprop="url">Intellij IDEA15创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-07T10:13:00+08:00">
                2016-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文的思路是先创建Maven项目，再加上Java Web模块支持</p>
<h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p><strong><em>File - New - Project，创建Maven项目</em></strong></p>
<p><img src="http://i.imgur.com/yCSg2OK.png" alt=""></p>
<p><strong><em>Next，填写GroupId，ArtifactId和Version</em></strong></p>
<p><img src="http://i.imgur.com/VlBtIOA.png" alt=""></p>
<p><strong><em>Next，这里在Properties中添加一个参数<code>archetypeCatalog=internal</code>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。</em></strong></p>
<pre><code>来自网上的解释：      
archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。
</code></pre><p><img src="http://i.imgur.com/YePrI2x.png" alt=""></p>
<p><strong><em>Next，填写项目名和module名称，项目名和模块名可以不一样（还不是很清楚两者的区别）</em></strong></p>
<p><img src="http://i.imgur.com/yrmOBcr.png" alt=""></p>
<p><strong><em>点击Finsh，项目的目录结构如下：</em></strong>  </p>
<p><img src="http://i.imgur.com/mppsHHu.png" alt=""></p>
<p>Maven规定，src文件下有<code>main</code>和<code>test</code>两个文件夹。其中：  </p>
<ul>
<li>main文件为项目主体目录，main下的java文件夹为源代码目录，resource为所需资源目录</li>
<li>test为项目测试目录，test下的java文件夹为测试代码目录，resources为测试所需资源目录</li>
</ul>
<p><strong><em>发现生成的Maven项目，没有Web目录！在项目名称右击，选择Add Framework Support</em></strong></p>
<p><img src="http://i.imgur.com/p5NAWmy.png" alt=""></p>
<p><strong><em>在Add Framework Support对话框中勾选Web Application，版本选择3.0并勾选Create web.xml</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248954_3896.png" alt=""></p>
<p><strong><em>点击OK后，看到如下界面，项目中出现了web文件夹，是不是很熟悉了，和MyEclipse中的项目结构类似</em></strong></p>
<p><img src="http://i.imgur.com/L5LXM7A.png" alt=""></p>
<h2 id="配置Tomcat服务器"><a href="#配置Tomcat服务器" class="headerlink" title="配置Tomcat服务器"></a>配置Tomcat服务器</h2><p><strong><em>点击右上角的倒三角，选择<code>Edit Configurations</code>，弹出服务器配置页面</em></strong></p>
<p><img src="http://i.imgur.com/77V6dHo.png" alt=""></p>
<p><strong><em>如下图，选择Local，然后点击Configure，在弹出的对话框中选择Tomcat安装目录</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248975_9849.png" alt=""></p>
<p><strong><em>选择Tomcat Server，然后点击绿色的“+”号</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248979_4524.png" alt=""></p>
<p><strong><em>点击“+”后选择Local，刚刚已经配置好了Local的Tomcat服务器</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248982_3705.png" alt=""></p>
<p><strong><em>这里会新建一个Tomcat服务，输入任意名字即可。Update的快捷键是Ctrl+F10</em></strong></p>
<p><img src="http://i.imgur.com/zVA6RYW.png" alt=""></p>
<p><strong><em>点击Deployment，然后点击右边的“+”，添加Artifact部署</em></strong></p>
<p><img src="http://img.my.csdn.net/uploads/201303/14/1363248993_1308.png" alt=""></p>
<p><strong><em>输入应用程序Context，输入路径:<code>/工程名</code></em></strong></p>
<p><img src="http://i.imgur.com/xsZHFqP.png" alt=""></p>
<p><strong><em>点击界面上方的启动按钮就可以启动Tomcat服务器，启动后服务器自动打开浏览器</em></strong></p>
<p><img src="http://i.imgur.com/fmJjfqg.png" alt=""></p>
<p><strong><em>回到主界面，如图，点击Run打开服务器视图，能看到项目的部署情况了，而且可以完成服务器重启/关闭，项目部署等操作</em></strong></p>
<p><img src="http://i.imgur.com/LMFpfTI.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/06/[Servlet]Servlet笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/06/[Servlet]Servlet笔记/" itemprop="url">Servlet笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-06T11:17:00+08:00">
                2016-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><pre><code>#网页输出
PrintWriter out = response.getWriter();
out.println(&quot;Hello World&quot;);
#请求头
request.getHeader(&quot;host&quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&lt;String&gt; names = request.getHeaderNames();
while(names.hasMoreElements()){
    String name = names.nextElement();
    System.out.println(name + &quot;：&quot; + request.getHeader(name));
}
#浏览器返回
response.setContentType(&quot;text/html;charset=utf-8&quot;);
response.setCharacterEncoding(&quot;utf-8&quot;);
#获得请求参数
String username = request.getParameter(&quot;username&quot;);
Enumeration&lt;String&gt; e = request.getParameterNames()
#跳转
1、request.getRequestDispatcher(&quot;/资源URI&quot;).forward(request,response)
2、response.sendRedirect(&quot;/web应用/资源URI&quot;);
#获得web应用根路径
String path = this.getServletContext().getRealPath(&quot;/&quot;);
#获得资源路径
String path = this.getServletContext().getRealPath(&quot;/image/无标题.png&quot;);
#session，可以存字符串和对象
request.getSession().setAttribute(&quot;username&quot;,username);
request.getSession().getAttribute(&quot;username&quot;)
</code></pre><h2 id="为什么需要Servlet技术？"><a href="#为什么需要Servlet技术？" class="headerlink" title="为什么需要Servlet技术？"></a>为什么需要Servlet技术？</h2><p>　　普通的java技术很难完成网站开发，sun 就开发了servlet技术供程序员使用</p>
<h2 id="servlet的介绍"><a href="#servlet的介绍" class="headerlink" title="servlet的介绍"></a>servlet的介绍</h2><ul>
<li>servlet 其实就是java程序(java类)</li>
<li>该 java程序(java 类)要遵循servlet开发规范，继承servlet类</li>
<li>serlvet是运行在服务端</li>
<li>serlvet功能强大,几乎可以完成网站的所有功能</li>
<li>是学习jsp基础</li>
</ul>
<h2 id="Tomcat-和-servlet-在网络中的位置"><a href="#Tomcat-和-servlet-在网络中的位置" class="headerlink" title="Tomcat 和 servlet 在网络中的位置"></a>Tomcat 和 servlet 在网络中的位置</h2><p><img src="http://i.imgur.com/jvuMyhS.png" alt=""></p>
<h3 id="Tomcat三大功能"><a href="#Tomcat三大功能" class="headerlink" title="Tomcat三大功能"></a>Tomcat三大功能</h3><ul>
<li>Web服务器，与浏览器通信，解析和处理HTTP请求，处理静态页面</li>
<li>Servlet容器（Catalina），处理Servlet</li>
<li>JSP容器，把JSP页面翻译成一般的Servlet</li>
</ul>
<h3 id="Servlet容器与Servlet关系★★★★★"><a href="#Servlet容器与Servlet关系★★★★★" class="headerlink" title="Servlet容器与Servlet关系★★★★★"></a>Servlet容器与Servlet关系★★★★★</h3><ul>
<li>Servlet技术的核心是Servlet，所有的Servlet类必须直接或间接实现Servlet接口</li>
<li><strong><em>Servlet接口定义了Servlet与Servlet容器之间的契约</em></strong>，即Servlet容器将Servlet类载入内存，并在Servlet实例是调用具体的方法，如用户请求时Servlet调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例</li>
</ul>
<h2 id="Web程序目录结构"><a href="#Web程序目录结构" class="headerlink" title="Web程序目录结构"></a>Web程序目录结构</h2><p><img src="http://i.imgur.com/0HhKiSj.png" alt=""></p>
<ul>
<li>静态页面、jsp直接放在web目录下</li>
<li>Servlet是Java程序，必须放在WEB-INF/classes目录下</li>
</ul>
<h2 id="Servlet工作流程★★★"><a href="#Servlet工作流程★★★" class="headerlink" title="Servlet工作流程★★★"></a>Servlet工作流程★★★</h2><p><img src="http://i.imgur.com/6yEbnhC.png" alt=""></p>
<pre><code>用户输入的URL为http://localhost:8088/hspWeb1/MyFirstServlet
浏览器解析主机名（host文件，dns）
浏览器尝试连接web服务器（三次握手）
浏览器发送http请求
web服务器开始工作，首先解析主机名，选择使用哪个主机（引擎下有多个主机，有默认主机）
web服务器解析web应用，确定使用主机下的context
web服务器解析资源名，一个web应用下有多个资源，这里是MyFirstServlet
查询web.xml文件，确定MyFirstServlet在哪个包下
Web服务器利用反射机制，创建实例，并调用init方法（该方法只调用一次）
web服务器把接收到的http请求封装成Request对象，作为service的参数传入。service会被调用多次，没访问一次Servlet，它的service就会被调用一次
Servlet获得response对象，返回结果
web服务器把request的信息拆除，形成http响应格式
当在某些情况下（tomcat重启、reload该webapp、重启电脑）web服务器会调用Servlet的destroy方法，将该servlet销毁
</code></pre><h2 id="面试题-请简述servlet的生命周期-工作流程"><a href="#面试题-请简述servlet的生命周期-工作流程" class="headerlink" title="面试题: 请简述servlet的生命周期(工作流程)"></a>面试题: 请简述servlet的生命周期(工作流程)</h2><p>答:<br>　　当第一次访问某个servlet，web服务器将会创建一个该servlet的实例，并且调用 servlet的init()方法，init函数只会被调用一次；如果当服务器已经存在了一个servlet实例，那么，将直接使用此实例；每次请求都会调用service()方法，service()方法将根据客户端的请求方式来决定调用对应的doXXX()方法；当 web应用 reload 或者 关闭 tomcat 或者 关机，web服务器将调用destroy()方法，将该servlet从服务器内存中删除。</p>
<h2 id="开发Servlet程序"><a href="#开发Servlet程序" class="headerlink" title="开发Servlet程序"></a>开发Servlet程序</h2><p><strong><em>开发servlet有三种方法★★★</em></strong></p>
<ul>
<li>(1)    实现 Servlet接口(对Servlet的工作过程有清晰的认识)</li>
<li>(2)    通过继承 GenericServlet</li>
<li>(3)    通过继承 HttpServlet</li>
</ul>
<h3 id="①实现servlet接口的方式"><a href="#①实现servlet接口的方式" class="headerlink" title="①实现servlet接口的方式"></a>①实现servlet接口的方式</h3><p>需求如下: 请使用实现接口的方式，来开发一个Servlet，要求该Servlet可以显示Hello，world，同时显示当前时间</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、在webapps下建立一个web应用my<br>2、在my下建立 WEB-INF-&gt;web.xml [web.xml可以从 ROOT/WEB-INF/web.xml拷贝]<br>3、在WEB-INF下建立 classes 目录(我们的Servlet 就要在该目录开发)，建立lib文件夹<br>4、开发MyServlet.java  </p>
<pre>
package com.apeius;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class MyServlet implements Servlet
{
    //该函数用于初始化servlet,就是把该servlet装载到内存中,该函数只会被调用一次
    <font color="red">/*调用这个方法，Servlet容器会传入一个ServletConfig，
    * 一般会将ServletConfig赋给一个类级对象，这样可以在Servlet类中其他点来使用，
    * 但Servlet实例会被一个应用程序的所有用户共享，使用类级变量须是只读的，或者是
    * java.util.concurrent.atomic包的成员
    * /</font>
    public void init(ServletConfig config)
          throws ServletException{
    }

    //得到ServletConfig对象
    public ServletConfig getServletConfig(){
        return null;
    }

    //该函数是服务函数,我们的业务逻辑代码就是写在这里
    //该函数每次都会被调用
    public void service(ServletRequest req,
                    ServletResponse res)
             throws ServletException,
                    java.io.IOException{
        //在控制台输出时间
        System.out.println(new java.util.Date());
    }
    //该函数时得到servlet配置信息
    public java.lang.String getServletInfo(){
        return null;
    }
    //销毁该servlet,从内存中清除,该函数被调用一次
    public void destroy(){

    }
}
</pre>

<p>5、编译</p>
<p>如果使用javac去编译一个带package的java文件，则需要带命令参数<code>javac –d . java文件</code></p>
<p>6、根据Servlet规范，我们还需要部署Servlet</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
   version=&quot;2.5&quot;&gt;

    &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/ABC&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

服务器调用流程：http://localhost:8088/my/ABC---&gt;①---&gt;②---&gt;③---&gt;④
</code></pre><p>7、在浏览器中测试</p>
<p>　　在浏览器中输入<a href="http://localhost:8080/my/ABC" target="_blank" rel="external">http://localhost:8080/my/ABC</a></p>
<h3 id="②使用GenericServlet开发servlet（了解即可）"><a href="#②使用GenericServlet开发servlet（了解即可）" class="headerlink" title="②使用GenericServlet开发servlet（了解即可）"></a>②使用GenericServlet开发servlet（了解即可）</h3><h4 id="为什么使用GenericServlet"><a href="#为什么使用GenericServlet" class="headerlink" title="为什么使用GenericServlet"></a>为什么使用GenericServlet</h4><p>1、实现Servlet接口<strong><em>必须实现接口中的所有方法</em></strong>，即使有一些方法根本没有包含任何代码<br>2、此外还<strong><em>需要将ServletConfig对象保存到类级变量中</em></strong></p>
<h4 id="GenericServlet完成的任务"><a href="#GenericServlet完成的任务" class="headerlink" title="GenericServlet完成的任务"></a>GenericServlet完成的任务</h4><ul>
<li>将init方法中个ServletConfig赋给一个类级变量，以便可以通过getServletConfig获取</li>
<li>为Servlet接口中的所有方法提供默认的实现</li>
<li>提供方法，包围ServletConfig中的方法</li>
</ul>
<h4 id="GenericServlet原理"><a href="#GenericServlet原理" class="headerlink" title="GenericServlet原理"></a>GenericServlet原理</h4><p>GenericServlet通过将ServletConfig赋给init方法中的类级变量private transient ServletConfig config；来保存ServletConfig</p>
<pre><code>public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
</code></pre><p>但是，如果在子类中覆盖了这个方法，就会调用Servlet中的init方法，并且还必须调用super.init(servletConfig)来保存ServletConfig，为了避免上述麻烦，<strong><em>GenericServlet提供了第二个init方法，它不带参数。</em></strong>这个方法是在ServletConfig被赋给servletConfig后，由第一个init方法调用，子类改写后调用的是子类的无参数init方法</p>
<p><strong>总结：</strong><br>Tomcat调用Servlet接口的init(ServletConfig config)方法，其实现类是用户继承的子类，该子类重写了无参数的init方法进行初始化工作。首先调用父类中的init(ServletConfig config)方法，将config对象保存为类级变量，然后调用this.init()方法，this指针指向子类实例，init方法被重写，所以调用子类的init方法，若需要访问GenericServlet中的无参数init方法，则需要在子类中使用super.init()；</p>
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>继承GenericServlet</em></strong></p>
<pre><code>package com.hsp;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
public class MyGenericServlet extends GenericServlet
{
    public  void service(ServletRequest req,
                             ServletResponse res)
                      throws ServletException,
                             java.io.IOException{
        res.getWriter().println(&quot;hello,world,i am geneirc servlet&quot;);
    }
}
</code></pre><p><strong><em>将该Servlet部署到web.xml文件中:</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
 &lt;servlet&gt;
    &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
  &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
  &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
  &lt;servlet-class&gt;com.hsp.MyGenericServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    &lt;!--Servlet的映射--&gt;
 &lt;servlet-mapping&gt;
    &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
    &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
    &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分,默认命名规范:
    就是该Servlet的名字--&gt;
    &lt;url-pattern&gt;/MyGenericServlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><h3 id="③使用继承-HttpServlet-的方法来开发Serlvet"><a href="#③使用继承-HttpServlet-的方法来开发Serlvet" class="headerlink" title="③使用继承 HttpServlet 的方法来开发Serlvet"></a>③使用继承 HttpServlet 的方法来开发Serlvet</h3><ul>
<li>在软件公司 90%都是通过该方法开发.</li>
<li>举例说明，还是显示 hello,world 当前日期</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>HttpServlet类继承了GenericServlet类，并重写了service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，Tomcat调用Servlet接口的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，实际调用的是HttpServlet类中的的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，方法体内将ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse，并调用新添加的service方法</li>
</ul>
<pre><code>public void service(ServletRequest req, ServletResponse res)
    throws ServletException, IOException
    {
        HttpServletRequest    request;
        HttpServletResponse    response;

    try {
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
    } catch (ClassCastException e) {
        throw new ServletException(&quot;non-HTTP request or response&quot;);
    }

    service(request, response);
}
</code></pre><ul>
<li>HttpServlet中扩展了一个protected void service(HttpServletRequest req, HttpServletResponse resp)方法，根据不同的请求方法，调用不同的doXXX方法</li>
</ul>
<pre><code>protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
    {
    String method = req.getMethod();

    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
        // servlet doesn&apos;t support if-modified-since, no reason
        // to go through further expensive logic
        doGet(req, resp);
        } else {
        long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
        if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) {
            // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
            maybeSetLastModified(resp, lastModified);
            doGet(req, resp);
        } else {
            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        }
        }

    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);

    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);    

    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);

    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);

    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);

    } else {
        //
        // Note that this means NO servlet supports whatever
        // method was requested, anywhere on this server.
        //

        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);

        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}
</code></pre><ul>
<li>子类继承后，通过改写doGet和doPost方法，实现方法的调用</li>
</ul>
<h4 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>代码</em></strong></p>
<pre><code>package com.apeius;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class MyHttpServlet extends HttpServlet
{
    //在HttpServlet 中，设计者对post 提交和 get提交分别处理
    //回忆 &lt;form action=&quot;提交给?&quot; method=&quot;post|get&quot;/&gt;,默认是get

    protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
              throws ServletException,
                     java.io.IOException{
        resp.getWriter().println(&quot;i am httpServet doGet()&quot;);

    }
    protected void doPost(HttpServletRequest req,
                      HttpServletResponse resp)
               throws ServletException,
                      java.io.IOException{ 
        resp.getWriter().println(&quot;i am httpServet doPost() post name=&quot;+req.getParameter(&quot;username&quot;));
    }
}
</code></pre><p><strong><em>还有一个login.html</em></strong></p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;/my/MyHttpServlet&quot; method=&quot;post&quot;&gt;
    u:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong><em>部署</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyHttpServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/MyHttpServlet&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
</code></pre><h2 id="使用myeclipse来开发servlet，IDEA类似"><a href="#使用myeclipse来开发servlet，IDEA类似" class="headerlink" title="使用myeclipse来开发servlet，IDEA类似"></a>使用myeclipse来开发servlet，IDEA类似</h2><p><strong><em>(1)    建立web工程</em></strong></p>
<p><img src="http://i.imgur.com/6IcaPJQ.gif" alt=""></p>
<p><strong><em>(2)    在Src 目录下创建了一个包 com.hsp.servlet</em></strong></p>
<p><img src="http://i.imgur.com/VYwK3wL.png" alt=""></p>
<p><strong><em>添加Package，方法一般只需创建doGet()和doPost()方法，修改Servlet/JSP Mapping URL</em></strong></p>
<p><img src="http://i.imgur.com/ogGRxkN.png" alt=""></p>
<p><strong><em>(3)    开发一个Servlet</em></strong></p>
<pre><code>MySerlvet 的代码:
public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        response.setContentType(&quot;text/html&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;hello &quot;+new java.util.Date().toString() );
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        this.doGet(request, response);
    }
}
</code></pre><h2 id="使用IDEA来开发Servlet程序"><a href="#使用IDEA来开发Servlet程序" class="headerlink" title="使用IDEA来开发Servlet程序"></a>使用IDEA来开发Servlet程序</h2><p>　　见另一篇博文:<a href="https://rhapsody1290.github.io/2016/07/07/[Servlet]Intellij%20IDEA%E5%88%9B%E5%BB%BAMaven%E7%AE%A1%E7%90%86%E7%9A%84Java%20Web%E9%A1%B9%E7%9B%AE/" target="_blank" rel="external">Intellij IDEA15创建Maven管理的Java Web项目</a></p>
<h2 id="Servlet的细节问题-映射、单例、通配符、自启动"><a href="#Servlet的细节问题-映射、单例、通配符、自启动" class="headerlink" title="Servlet的细节问题[映射、单例、通配符、自启动]"></a>Servlet的细节问题[映射、单例、通配符、自启动]</h2><h3 id="①-一个已经注册的Servlet可以被多次映射即"><a href="#①-一个已经注册的Servlet可以被多次映射即" class="headerlink" title="① 一个已经注册的Servlet可以被多次映射即:"></a>① 一个已经注册的Servlet可以被多次映射即:</h3><pre><code>&lt;servlet&gt;
&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;
&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;
&lt;!-- servlet的注册名 --&gt;
&lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
&lt;!-- servlet类的全路径(包名+类名) --&gt;
&lt;servlet-class&gt;com.hsp.servlet.MyServlet1&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!-- 对一个已经注册的servlet的映射 --&gt;
&lt;!-- 映射1 --&gt;
&lt;servlet-mapping&gt;
    &lt;!-- servelt的注册名 --&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;!-- servlet的访问路径 --&gt;
    &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- 映射2 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hsp&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h3 id="②-映射一个servlet时候，可以多层，比如"><a href="#②-映射一个servlet时候，可以多层，比如" class="headerlink" title="② 映射一个servlet时候，可以多层，比如"></a>② 映射一个servlet时候，可以多层，比如</h3><pre><code>&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt;
</code></pre><p>　　从这里还可以看出，后缀名是 html 不一定就是 html,可能是假象.</p>
<h3 id="③-用通配符在servlet映射到URL中"><a href="#③-用通配符在servlet映射到URL中" class="headerlink" title="③ 用通配符在servlet映射到URL中"></a>③ 用通配符在servlet映射到URL中</h3><p><strong><em>有两种格式:</em></strong></p>
<ul>
<li>第一种格式  <code>*.扩展名</code>，比如 <code>*.do</code>，<code>*.ss</code></li>
<li>第二种格式  以 <code>/</code> 开头，同时以 <code>/*</code> 结尾。比如  <code>/*</code>,<code>/news/*</code> </li>
</ul>
<p><strong><em>在匹配的时候，要参考的标准:</em></strong></p>
<ul>
<li>看谁的匹配度高，谁就被选择</li>
<li><code>*.do</code>的优先级最低</li>
</ul>
<p><strong><em>通配符练习题：</em></strong></p>
<pre><code>● Servlet1 映射到 /abc/* 
● Servlet2 映射到 /* 
● Servlet3 映射到 /abc 
● Servlet4 映射到 *.do 
问题(面试题)：
当请求URL为&apos;/abc/a.html&apos;，&apos;/abc/*&apos;和&apos;/*&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为&apos;/abc&apos;时，&apos;/abc/*&apos;和&apos;/abc&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
</code></pre><h3 id="④Servlet单例问题"><a href="#④Servlet单例问题" class="headerlink" title="④Servlet单例问题"></a>④Servlet单例问题</h3><ul>
<li>当Servlet被第一次访问后，就被加载到内存，以后该实例对各个请求服务，即在使用中是单例</li>
<li><strong><em>Servlet实例会在一个应用程序中被所有用户共享，因此不建议使用类级变量</em></strong> ，除非它们是只读的，或者是java.util.concurrent.atomic包的成员</li>
</ul>
<p><strong><em>证明：</em></strong></p>
<p>　　在Servlet中定义一个变量i，当浏览器访问时i++，并输出i；如果Servlet是单例，则每次输出i都会增加</p>
<p><strong><em>问题：</em></strong></p>
<p>　　因为 Servlet是单例，因此会出现线程安全问题: 比如:售票系统. 如果不加同步机制，则会出现问题:</p>
<p><strong><em>原则:</em></strong></p>
<ul>
<li>（1）如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制  </li>
</ul>
<pre>
synchronized (对象){
  //同步代码
}
</pre>

<ul>
<li>（2）如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题  </li>
</ul>
<h3 id="⑤servlet中的-lt-load-on-startup-gt-配置"><a href="#⑤servlet中的-lt-load-on-startup-gt-配置" class="headerlink" title="⑤servlet中的&lt;load-on-startup&gt;配置"></a>⑤servlet中的&lt;load-on-startup&gt;配置</h3><p><strong><em>需求</em></strong></p>
<p>　　当我们的网站启动的时候，可能会要求初始化一些数据，(比如创建临时表), 在比如：我们的网站有一些要求定时完成的任务[ 定时写日志，定时备份数据.. 定时发送邮件..]</p>
<p><strong><em>解决方法</em></strong></p>
<p>　　可以通过 &lt; load-on-startup &gt; 配合线程知识搞定.<br>　　一般在有用户访问该Servlet时才会被加载进内存，现在需要在网站启动的时候自动启动Servlet。首先在web.xml下，该Servlet下进行配置<br><code>&lt;load-on-startup &gt;1（数字Servlet启动优先级）&lt;/load-on-startup&gt;</code><br>　　这样该Servlet在网站启动时将会被自动创建.</p>
<h2 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h2><ul>
<li>调用Servlet的init方法时，Servlet容器会传入一个ServletConfig实例，该对象主要用于读取 servlet的配置信息</li>
</ul>
<p><strong><em>案例</em></strong></p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.hsp.servlet.ServletConfigTest&lt;/servlet-class&gt;
    &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

获得配置参数
String encoding=this.getServletConfig().getInitParameter(&quot;encoding&quot;);
</code></pre><p><strong><em>补充说明</em></strong></p>
<p>　　这种配置参数的方式，只能被某个Servlet独立使用.如希望让所有的Servlet都去读取某个参数,这样配置:</p>
<pre><code>&lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;

获得配置参数
String encoding = this.getServletContext().getInitParameter(&quot;encoding&quot;)
</code></pre><p><strong><em>如果要把所有的参数都读取，则使用 如下方法 ：</em></strong></p>
<pre><code>Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames();
while(names.hasMoreElements()){
    String name=names.nextElement();
    System.out.println(name);
    System.out.println(this.getServletConfig().getInitParameter(name));
}
</code></pre><h2 id="ServletContext★★★★★（包含读取文件路径）"><a href="#ServletContext★★★★★（包含读取文件路径）" class="headerlink" title="ServletContext★★★★★（包含读取文件路径）"></a>ServletContext★★★★★（包含读取文件路径）</h2><p>在访问某个网站时，首页会显示您是第几个浏览者，这个怎么实现的？除了数据库，文件等方式，最方便的是使用ServletContext。  </p>
<font color="red">ServletContext是一个公共的空间，可以被所有客户访问</font>

<p><img src="http://i.imgur.com/ZyoAE8n.png" alt=""></p>
<ul>
<li>Web容器在启动时，它会为每个Web应用程序创建一个对应的ServletContext对象，它代表当前Web应用。当web应用关闭/tomcat关闭/对web应用reload会造成servletContext销毁.</li>
<li>ServletContext对象通过ServletConfig.getServletContext方法获得对ServletContext对象的引用，也可以通过this.getServletContext()来获得其对象的引用</li>
<li><strong><em>每个Web应用程序只有一个上下文，一个Web应用中所有的Servlet共享同一个ServletContext对象</em></strong>，因此Servlet对象之间可以通过ServletContext对象实现通讯。ServletContext对象通常也被称为context域对象，公共聊天室就会用到它</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>获取:
this.getServletContext();  #在HttpServlet中直接获取
this.getServletConfig().getServletContext(); # 在ServletConfig中获取
request.getSession().getServletContext(); #通过HttpRequest获得 
添加属性:
servletcontext.setAttribute(string,object);
取出属性
servletcontext.getAttribute(“属性名”)
删除
setvletContext.removeAttribute(“属性名”);
</code></pre><h3 id="ServletContext的应用"><a href="#ServletContext的应用" class="headerlink" title="ServletContext的应用"></a>ServletContext的应用</h3><h4 id="获取WEB应用的初始化参数"><a href="#获取WEB应用的初始化参数" class="headerlink" title="获取WEB应用的初始化参数"></a>获取WEB应用的初始化参数</h4><pre><code>&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;name&lt;/param-name&gt;
    &lt;param-value&gt;scott&lt;/param-value&gt;
&lt;/context-param&gt;
如何获取
String val= this.getServletContext().getInitParameter(&quot;name&quot;);
</code></pre><h4 id="使用ServletContext实现跳转"><a href="#使用ServletContext实现跳转" class="headerlink" title="使用ServletContext实现跳转"></a>使用ServletContext实现跳转</h4><pre><code>//目前我们跳转到下一个页面的方法
//1 response.sendRedirect(&quot;/web应用名/资源名&quot;);
//2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);
/*
 * 区别1. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器
 *     2. 如果request.setAttribute(&quot;name&quot;,&quot;顺平&quot;) 希望下一个页面可以使用 属性值，则使用 getRequestDispatcher
 *       3. 如果session.setAttribute(&quot;name2&quot;,&quot;顺平3&quot;), 希望下一个页面可以使用 属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher
 *     4. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect
 */
//3.这种方法和2一样
this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response);
</code></pre><h4 id="读取文件，和获取文件全路径"><a href="#读取文件，和获取文件全路径" class="headerlink" title="读取文件，和获取文件全路径"></a>读取文件，和获取文件全路径</h4><p>　　读Web目录下和WEB-INF目录下的文件</p>
<pre><code>//首先读取到文件dbinfo.properties放在web根目录下
InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;);

//创建Properties
Properties pp=new Properties();
pp.load(inputStream);

out.println(&quot;name=&quot;+pp.getProperty(&quot;username&quot;));
</code></pre><p>　　如果文件放在src目录下(如果是maven项目，则resources目录下为根目录)，则使用类加载器</p>
<pre><code>//如果文件放在上述目录下，我们应该使用类加载器来读取
InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;)
//如果放在包下，则带上包名，例如cn/apeius/xx.properties
</code></pre><p>　　获取文件全路径（以WEB目录为根目录）</p>
<pre><code>//如果读取到一个文件的全路径（dbinfo.properties在web目录下）
String path=this.getServletContext().getRealPath(&quot;dbinfo.properties&quot;);
out.println(&quot;paht = &quot;+path);
</code></pre><h4 id="网站计数器"><a href="#网站计数器" class="headerlink" title="网站计数器"></a>网站计数器</h4><ul>
<li>我们建立一个文件recoder.txt文件，用于保存访问量,可以可以保证稳定增长.</li>
<li>建立InitServlet,Web项目启动时自动加载该Servlet，读取record.txt，初始化Servletcontext中的访问量，和在关闭tomcat时保存访问量如record.txt</li>
<li>如果我们的tomcat异常退出，使用线程定时把ServletContext的值，刷新到recorder.txt</li>
</ul>
<h2 id="http请求消息头"><a href="#http请求消息头" class="headerlink" title="http请求消息头"></a>http请求消息头</h2><pre><code>1.    Accept: text/html,image/*   [告诉服务器，我可以接受 文本，网页，图片]
2.    Accept-Charset: ISO-8859-1 [接受字符编码 iso-8859-1]
3.    Accept-Encoding: gzip,compress [可以接受 gzip,compress压缩后数据.]
4.    Accept-Language: en-us,zh-cn [浏览器支持中，英文]
5.    Host: www.sohu.com:80 [我要找主机是 www.sohu.com:80]
6.    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT [ 告诉服务器，我的缓冲中有这个资源文件，该文件的时间是 。。。，文件有更新才发送]
7.    Referer: http://www.sohu.com/index.jsp  [告诉服务器，我来自哪里,该消息头，常用于防止盗链]
8.    User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)[告诉服务器，浏览器内核]
9.    Cookie [cookie后面介绍]
10.    Connection: close/Keep-Alive   [保持连接，发完数据后，我不关闭连接]
11.    Date: Tue, 11 Jul 2000 18:23:51 GMT [浏览器发送该http请求的时间]
</code></pre><h2 id="http响应消息头"><a href="#http响应消息头" class="headerlink" title="http响应消息头"></a>http响应消息头</h2><pre><code>Location: http://www.baidu.org/index.jsp  【让浏览器重新定位到url】
Server:apache tomcat 【告诉浏览器我是tomcat】
Content-Encoding: gzip 【告诉浏览器我使用 gzip】
Content-Length: 80  【告诉浏览器会送的数据大小80节】
Content-Language: zh-cn 【支持中文】
Content-Type: text/html; charset=GB2312 [内容格式text/html; 编码gab2312]
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 【告诉浏览器，该资源上次更新时间】
Refresh: 1;url=http://www.baidu.com 【过多久去，刷新到 http://www.baidu.com】
Content-Disposition: attachment; filename=aaa.zip 【告诉浏览器，有文件下载】
Transfer-Encoding: chunked  [传输的编码]
Set-Cookie:SS=Q0=5Lb_nQ; path=/search[后面详讲]
Expires: -1[告诉浏览器如何缓存页面IE]
Cache-Control: no-cache  [告诉浏览器如何缓存页面火狐]
Pragma: no-cache   [告诉浏览器如何缓存页面]
Connection: close/Keep-Alive   [保持连接 1.1是Keep-Alive]
Date: Tue, 11 Jul 2000 18:23:51 GMT
</code></pre><h2 id="http响应的状态行"><a href="#http响应的状态行" class="headerlink" title="http响应的状态行"></a>http响应的状态行</h2><pre><code>200 就是整个请求和响应过程没有发生错误，这个最常见.
302: 表示当你请求一个资源的时候，服务器返回302 表示，让浏览器转向到另外一个资源，比如: response.sendRedirect(“/web应用/资源名”)

案例:
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/servletPro/Servlet2&quot;);
    // 上面两句话等价 response.sendRedirect(&quot;/servletPro/Servlet2&quot;);

404： 找不到资源
500: 服务器端错误
</code></pre><h2 id="http响应头应用★★★-防盗链、定时、文件下载、缓存"><a href="#http响应头应用★★★-防盗链、定时、文件下载、缓存" class="headerlink" title="http响应头应用★★★[防盗链、定时、文件下载、缓存]"></a>http响应头应用★★★[防盗链、定时、文件下载、缓存]</h2><h3 id="防盗链-Referer"><a href="#防盗链-Referer" class="headerlink" title="防盗链 - Referer"></a>防盗链 - Referer</h3><pre><code>//获取用户浏览器Referer
String referer=request.getHeader(&quot;Referer&quot;);
if(referer==null||!referer.startsWith(&quot;http://localhost:8088/servletPro&quot;)){
    response.sendRedirect(&quot;/servletPro/Error&quot;);
    return;
}
</code></pre><h3 id="定时刷新Refresh使用"><a href="#定时刷新Refresh使用" class="headerlink" title="定时刷新Refresh使用"></a>定时刷新Refresh使用</h3><pre><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=/servletPro/Servlet2&quot;);
</code></pre><h3 id="文件下载-Content-Disposition"><a href="#文件下载-Content-Disposition" class="headerlink" title="文件下载 Content-Disposition"></a>文件下载 Content-Disposition</h3><pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

    response.setContentType(&quot;text/html&quot;);
    //★★★需要注释
    //PrintWriter out = response.getWriter();

    //演示下载文件
    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=winter.jpg&quot;);

    //打开文件.说明一下web 站点下载文件的原理
    //1.获取到要下载文件的全路径
    String path=this.getServletContext().getRealPath(&quot;/images/Winter.jpg&quot;);
    //System.out.println(&quot;path=&quot;+path);
    //2创建文件输入流
    FileInputStream fis=new FileInputStream(path);
    //做一个缓冲字节数组
    byte buff[]=new byte[1024];
    int len=0;//表示实际每次读取了多个个字节
    OutputStream os=response.getOutputStream();
    while((len=fis.read(buff))&gt;0){
        os.write(buff, 0, len);
    }
    //关闭
    os.close();
    fis.close();
}
</code></pre><h3 id="缓存讲解"><a href="#缓存讲解" class="headerlink" title="缓存讲解"></a>缓存讲解</h3><p>　　提出问题：浏览器默认情况下，会缓存我们的页面，这样出现一个问题：如果我们的用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用cache中取数据（刷新还是会重新向服务器请求数据）。</p>
<p><strong><em>（1）有些网站要求及时性很高，因此要求我们不缓存页面</em></strong></p>
<pre><code>//指定该页面不缓存 Ie
response.setDateHeader(&quot;Expires&quot;, -1);//【针对IE浏览器设置不缓存】
//为了保证兼容性.
response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//【针对火狐浏览器等】
response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//【其他浏览器】
</code></pre><p><strong><em>（2）有些网站要求网页缓存一定时间,比如缓存一个小时</em></strong></p>
<pre><code>response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+3600*1000*24);后面一个参数表示设置的缓存保持时间，-1表示永远缓存
</code></pre><h2 id="HttpServletResponse的再说明"><a href="#HttpServletResponse的再说明" class="headerlink" title="HttpServletResponse的再说明"></a>HttpServletResponse的再说明</h2><p>HttpServletResponse中输出流两个方法：</p>
<ul>
<li>getWriter()</li>
<li>getOutputStream()</li>
</ul>
<p><strong><em>区别</em></strong></p>
<p>1、    getWriter() 用于向客户机回送字符数据</p>
<pre><code>PrintWriter out = response.getWriter();
out.println(&quot;hello,world&quot;);
</code></pre><p>2、    getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据(二进制数据)，但也可以输出文本内容</p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
</code></pre><p><strong><em>如何选择:</em></strong></p>
<ul>
<li>如果我们是回送字符数据，则使用PrintWriter对象,效率高</li>
<li>如果我们是回送字节数据(binary date),则只能使用OutputStream</li>
<li>这两个流不能同时使用.</li>
</ul>
<p><strong><em>比如：</em></strong></p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
PrintWriter out=response.getWriter();
out.println(&quot;abc&quot;);
就会报错:
java.lang.IllegalStateException: getOutputStream() has already been called for this response
</code></pre><p><strong><em>注意：</em></strong><br>　　Web服务器会自动检查并关闭流，为什么我们没有主动关闭流，程序也没有问题的原因.当然：你主动关闭流，更好.
　　</p>
<h2 id="参数的传递方式sendRedirect-和session"><a href="#参数的传递方式sendRedirect-和session" class="headerlink" title="参数的传递方式sendRedirect()和session()"></a>参数的传递方式sendRedirect()和session()</h2><p><img src="http://img.blog.csdn.net/20160607204306776" alt="这里写代码片"></p>
<p><strong><em>需求:</em></strong><br>　　当用户登录成功后，把该用户名字显示在登录成功页面;  </p>
<p><strong><em>解决方法</em></strong></p>
<ul>
<li><p>使用 java 基础 static，专门用一个类来存储静态数据</p>
</li>
<li><p>使用 sendRedirect()，在url上加上需要传递的参数</p>
</li>
</ul>
<pre>
response.sendRedirect("/UsersManager/MainFrame?uname="+username+"&pwd="+password);

说明:
基本格式:
response.sendRedirect("/Context/servlet的?参数名=参数值&参数名=参数值...");
</pre>

<ul>
<li>使用session传递</li>
</ul>
<p>　　session既可以传递字符串，也可以传递对象</p>
<pre><code>A.传递字符串
放入session   
    request.getSession.setAttribute(&quot;loginUser&quot;,username); 
取出session     
    在JSP中通过session取出 request.getSession.getAttribute(&quot;loginUser&quot;);

B．传递对象
User user= new User();
user.setName(&quot;xiaoli&quot;);
user.setPassWord(“123”);

放入session   
    request.getSession.setAttribute(&quot;userObj&quot;,userObj); 
取出session     
    User user=(User)request.getSession.getAttribute(&quot;userObj&quot;);
</code></pre><h2 id="中文乱码处理"><a href="#中文乱码处理" class="headerlink" title="中文乱码处理"></a>中文乱码处理</h2><p>　　发生中文乱码有三种情况，我们应当尽量使用post方式提交</p>
<h3 id="①表单form"><a href="#①表单form" class="headerlink" title="①表单form"></a>①表单form</h3><p><img src="http://i.imgur.com/zplY6DJ.png" alt=""></p>
<ul>
<li>(1)表单以post方式提交<br><br>　　浏览器把请求发送给web服务器[utf-8]，web服务器以ISO-8859-1编码方式进行接收，产生乱码，之后进行传递也都是乱码。<br>　　在接收参数时，采用正确的编码，即可解决问题，在服务器端设置成浏览器端的编码方式。</li>
</ul>
<pre>request.setCharacterEncoding("utf-8"); //gbk gb2312 big5</pre>

<ul>
<li>(2)表单以get方式提交<br><br>　　请求内容是以请求行URL进行提交，而不是用请求体，所以使用setCharacterEncoding无效</li>
</ul>
<p>写一个工具类:</p>
<pre><code>package com.hsp.utils;
public class MyTools {
    public static String getNewString(String str) {
        String newString=&quot;&quot;;
        try {
            newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;);
        } catch (Exception e) {
            e.printStackTrace();
            // 把iso-8859-1 转换成 utf-8
        } 
        return newString;
    }
}
</code></pre><h3 id="②超链接"><a href="#②超链接" class="headerlink" title="②超链接"></a>②超链接</h3><p>　　数据以get方式进行传递，该方法和get处理方法一样.</p>
<pre><code>&lt;a href=”http://www.sohu.com?name=函数后”&gt;测试&lt;/a&gt;
</code></pre><h3 id="③sendRedirect-发生乱码"><a href="#③sendRedirect-发生乱码" class="headerlink" title="③sendRedirect() 发生乱码"></a>③sendRedirect() 发生乱码</h3><p>　　客户端会重新发送一个http请求，该方法和get处理方法一样</p>
<pre><code>response.sendRedirect(&quot;servlet地址?username=顺平&quot;); 
</code></pre><h3 id="版本低导致的乱码"><a href="#版本低导致的乱码" class="headerlink" title="版本低导致的乱码"></a>版本低导致的乱码</h3><p>　　特别说明，如果你的浏览器是 ie6 或以下版本，则我们的 ② 和 ③中情况会出现乱码(当中文是奇数的时候)<br>解决方法是 ：</p>
<pre><code>String info=java.net.URLEncoder.encode(&quot;你好吗.jpg&quot;, &quot;utf-8&quot;);
&lt;a href=&quot;http://www.sohu.com?name=&quot;+ info &gt;测试&lt;/a&gt;
response.sendRedirect(&quot;servlet地址?username=&quot; + info);
</code></pre><h3 id="★★★★返回浏览器显示乱码"><a href="#★★★★返回浏览器显示乱码" class="headerlink" title="★★★★返回浏览器显示乱码"></a>★★★★返回浏览器显示乱码</h3><p>　　在服务端是中文，在response的时候，也要考虑浏览器显示是否正确,一般我们通过</p>
<pre><code>　response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre><h3 id="下载提示框中文乱码"><a href="#下载提示框中文乱码" class="headerlink" title="下载提示框中文乱码"></a>下载提示框中文乱码</h3><p>　　补充一个知识点: 当我们下载文件的时候，可能提示框是中文乱码 </p>
<pre><code>String temp=java.net.URLEncoder.encode(&quot;传奇.mp3&quot;,&quot;utf-8&quot;);
response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename=&quot;+temp);
</code></pre><h2 id="HttpServletRequest对象的详解"><a href="#HttpServletRequest对象的详解" class="headerlink" title="HttpServletRequest对象的详解"></a>HttpServletRequest对象的详解</h2><p>　　该对象表示浏览器的请求(http请求), 当web服务器得到该请求后，会把请求信息封装成一个HttpServletRequest 对象</p>
<ul>
<li>getRequestURL方法返回客户端发出请求时的完整URL。</li>
<li>getRequestURI方法返回请求行中的资源名部分。</li>
<li>getQueryString方法返回请求行中的参数部分(参数名+值)。该函数可以获取请求部分的数据，比如<br><code>http://localhost/web名?username=abc&amp;pwd=123request.getQueryString();</code><br>就会得到  username=abc&amp;pwd=123</li>
<li>getRemoteAddr方法返回发出请求的客户机的IP地址</li>
<li>getRemoteHost方法返回发出请求的客户机的完整主机名，如果该客户机没有在dns注册，则返回ip地址</li>
<li>getRemotePort方法返回客户机所使用的网络端口号，客户机的端口号是随机选择的，web服务器的端口号是一定的</li>
<li>getLocalPort方法返回web服务器所使用的网络端口号</li>
<li>getLocalAddr方法返回WEB服务器的IP地址。</li>
<li>getLocalName方法返回WEB服务器的主机名</li>
</ul>
<h2 id="url-和-uri-的区别"><a href="#url-和-uri-的区别" class="headerlink" title="url 和 uri 的区别"></a>url 和 uri 的区别</h2><pre><code>比如：
    Url=http://localhost:8088/servletPort3/GetinfoServlet 完整的请求
    Uri=/servletPort3/GetinfoServlet web应用的名称+资源的名称
</code></pre><h2 id="请求转发getRequestDispatcher"><a href="#请求转发getRequestDispatcher" class="headerlink" title="请求转发getRequestDispatcher"></a>请求转发getRequestDispatcher</h2><pre><code>#请求转发
requeset.getRequestDispatcher(资源地址).forward(request,response);
#可以在request的域对象中存储数据，request中的attribute在一次请求中有效
request.setAttribute(&quot;username&quot;,username);
</code></pre><p>　　资源地址：不需要项目名。因为它只是在WEB服务器内部转发。<br>　　<br><img src="http://img.blog.csdn.net/20160608153021012" alt="这里写图片描述"></p>
<p>　　Servlet接收到数据后，可以把数据放入到request域对象，Request中的Attribute在一次请求有效。<br>　　一次请求：浏览器发送一次http请求到接收到响应成为一次http请求，只要没有停止，也没有回到浏览器重定向，就算一次  </p>
<p><strong><em>请求转发的的(uml)图</em></strong></p>
<p><img src="http://img.blog.csdn.net/20160608154011510" alt="这里写图片描述"></p>
<ol>
<li>使用forward不能转发到该web应用外的url</li>
<li>因为 forward 是发生在web服务器，所以 Servlet1 和 Servlet 2使用的是用一个request 和response.</li>
<li>使用sendRedirect() 方法不能通过request.setAttribute() 把 属性传递给下一个Servlet</li>
</ol>
<p><strong><em>面试题：请问sendRedirect和 forward的区别是什么？</em></strong><br>答:  </p>
<pre><code>1. 叫法sendRedirect()请求重定向，转发forward()叫请求转发  
2. 实际发生的位置不一样    
　　sendRedirect发生在浏览器，由浏览器重新发出http请求  
　　forward发生web服务器，请求在web服务器转发  
3. 用法不一样    
　　request.getRequestDispatcher(“/资源URI”).forward(request,response)
　　response.sendRedirect(“/web应用/资源URI”);  
4. 能够去URL范围不一样  
　　sendRedirect可以去外边URL  
　　forward只能去当前的WEB应用的资源
</code></pre><h2 id="会话技术cookie"><a href="#会话技术cookie" class="headerlink" title="会话技术cookie"></a>会话技术cookie</h2><h3 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话"></a>什么是会话</h3><p>　　基本概念: 指用户开一个浏览器，访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话。比如打电话</p>
<p><strong><em>为什么需要cookie技术(会话技术)</em></strong>  </p>
<ul>
<li>如何保存用户上次登录时间</li>
<li>如何显示用户浏览历史</li>
<li>如何把登录的用户名和密码电脑，下次登录，不需要重新输入</li>
</ul>
<h3 id="cookie的原理图"><a href="#cookie的原理图" class="headerlink" title="cookie的原理图"></a>cookie的原理图</h3><p><img src="http://i.imgur.com/ihpk6OJ.png" alt=""></p>
<h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><pre><code>//创建cookie
Cookie cookie = new Cookie(&quot;name&quot;,&quot;qm&quot;);
//设置cookie的生命周期
cookie.setMaxAge(3600);
//把cookie会写给浏览器
response.addCookie(cookie);
</code></pre><h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><pre><code>Cookie[] cookies = request.getCookies();
System.out.println(cookies.length);
for(Cookie c : cookies){
    out.println(c.getName() + &quot; &quot; + c.getValue() + &quot;&lt;br/&gt;&quot;);
}
</code></pre><h3 id="cookie的小结★★★"><a href="#cookie的小结★★★" class="headerlink" title="cookie的小结★★★"></a>cookie的小结★★★</h3><ul>
<li>cookie 是在服务端创建</li>
<li>cookie 是保存在浏览器这端</li>
<li>cookie 的生命周期可以通过cookie.setMaxAge(2000);如果不设置setMaxAge则该cookie的生命周期当浏览器关闭时，就消亡</li>
<li><font color="red">同一个浏览器<strong><em>多个实例</em></strong>共享cookie，若cookie没到期，关闭浏览器后还能共享该cookie。当然不同浏览器之间是不能共享cookie的，因为每个浏览器存放cookie的路径不一样(与session的区别，session在关闭浏览器后，不采取任何方式，无法访问到session)</font></li>
<li>我们可以把cookie想成一张表<br><img src="http://i.imgur.com/jnEcC7g.png" alt=""></li>
<li>如果cookie重名就会替换存在的cookie值</li>
<li>一个web应用可以保存多个cookie,但保存在客户端浏览器下同一个cookie文本中</li>
<li>浏览器访问web应用时，会携带该web应用相关的cookie</li>
<li>cookie存放的时候是以明文方式存放，因此安全较低，我们可以通过加密后保存[MD5算法见Java基础常用-MD5]</li>
</ul>
<h3 id="举例-保存上次登录时间★★★"><a href="#举例-保存上次登录时间★★★" class="headerlink" title="举例 - 保存上次登录时间★★★"></a>举例 - 保存上次登录时间★★★</h3><pre><code>//先获取cookie
// 假设我们 保存上次登录时间的cookie &quot;lasttime&quot; &quot;2011-11-11 12:12:12&quot;;
// 这里我们要考虑一个情况: 用户第一次登录 &apos;您是第一次登录..&apos;
Cookie[] cookies = request.getCookies();
boolean b = false;//假设没有lasttime cookie
if (cookies != null) { //保证有cookie,取遍历
    for (Cookie cookie : cookies) {
        //取出名
        String name = cookie.getName();
        if (&quot;lasttime&quot;.equals(name)) {
            //显示
            out.println(&quot;您上次登录时间是 &quot; + cookie.getValue());
            //更新时间
            //把当前日期保存cookie
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String nowTime = simpleDateFormat.format(new java.util.Date());
            cookie.setValue(nowTime);
            cookie.setMaxAge(7 * 3600 * 24);//保存一周
            response.addCookie(cookie);
            b = true;
            break;
        }
    }
}

if (!b) {
    //没有找到
    out.println(&quot;您是第一次登录..&quot;);
    //把当前日期保存cookie
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String nowTime = simpleDateFormat.format(new java.util.Date());
    Cookie cookie = new Cookie(&quot;lasttime&quot;, nowTime);
    cookie.setMaxAge(7 * 3600 * 24);//保存一周
    response.addCookie(cookie);
}
</code></pre><h3 id="cookie的细节★★★"><a href="#cookie的细节★★★" class="headerlink" title="cookie的细节★★★"></a>cookie的细节★★★</h3><p>① 一个浏览器最多放入300cookie，一个web站点，最多20cookie，而且一个cookie大小限制子4k<br>② cookie生命周期的再说明:</p>
<ul>
<li><font color="red">cookie默认生命周期是会话级别，即浏览器关闭，cookie生命周期结束</font></li>
<li>通过setMaxAge() 可以设置生命周期<ul>
<li>setMaxAge(正数)，即多少秒后该cookie失效</li>
<li>setMaxAge(0)，删除该cookie</li>
<li>setMaxAge(负数)，相当于该cookie生命周期是会话级别</li>
</ul>
</li>
<li>cookie的生命周期，指的是累计时间，例如设置生命周期为30s，那么在30s之后cookie消亡（与session区别，session是发呆时间，即在一段时间内没有访问session就会消亡）</li>
</ul>
<p><strong><em>案例 ：</em></strong></p>
<pre><code>//先得到该cookie
Cookie cookies[]=request.getCookies();
for(Cookie cookie: cookies){
    if(cookie.getName().equals(&quot;id&quot;)){
        System.out.println(&quot;id&quot;);
        //删除
        cookie.setMaxAge(0);
        response.addCookie(cookie);//一定带上这句话，否则不能删除
    }
}
</code></pre><p>特别说明: 如果该web应用只有一个cookie ，则删除该cookie后，在浏览器的临时文件夹下没有该cookie文件，如果该web应用有多个cookie,则删除一个cookie后，文件还在，只是该cookie没有</p>
<p>③    cookie存放中文，怎么处理</p>
<p>进行URLEncoder</p>
<pre><code>存放:
String val=java.net.URLEncoder.encode(&quot;顺平&quot;,&quot;utf-8&quot;);
Cookie cookie=new Cookie(&quot;name&quot;,val);
取出:
String val=java.net.URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;);
out.println(&quot;name =&quot;+val);
</code></pre><h2 id="会话技术session（生成验证码）"><a href="#会话技术session（生成验证码）" class="headerlink" title="会话技术session（生成验证码）"></a>会话技术session（生成验证码）</h2><h3 id="session有什么用"><a href="#session有什么用" class="headerlink" title="session有什么用?"></a>session有什么用?</h3><p>　　问题1: 如何实现在不同的页面，可以去查看信息(比如说购物车)，同时还要实现不同的用户看到的信息是自己.<br>　　Session是服务端技术，可以为每一个用户的浏览器创建一个独享的session对象</p>
<h3 id="session工作原理图"><a href="#session工作原理图" class="headerlink" title="session工作原理图"></a>session工作原理图</h3><p> <img src="http://i.imgur.com/FlOMxdb.png" alt=""></p>
<ul>
<li>session对象一行就代表一个属性，键值对  </li>
<li>request.getSession()获得session，若第一次访问session会自动被创建，该浏览器第二次访问时将字节返回之前创建的session，不会创建新的。</li>
<li><font color="red">一个浏览器关联一个session。</font>如果此时有新的浏览器2访问Servlet1，那么就会创建一个新的sesssion与浏览器2对应</li>
<li>session默认的生命周期是30分钟</li>
<li>session中使用setAttribute时使用相同的属性名，属性值会被替换</li>
</ul>
<h3 id="session基本使用"><a href="#session基本使用" class="headerlink" title="session基本使用"></a>session基本使用</h3><pre><code>//访问session[当发现没有session时候，就会自动创建session]
HttpSession session = request.getSession();
//向session中添加属性
session.setAttribute(&quot;name&quot;,&quot;姓名&quot;);
//从session中得到某个属性
String name = (String) session.getAttribute(&quot;name&quot;);
out.println(name + &quot;&lt;br/&gt;&quot;);
//从session中删除某个属性
session.removeAttribute(&quot;name&quot;);
out.println((String) session.getAttribute(&quot;name&quot;) + &quot;&lt;br/&gt;&quot;);
</code></pre><h3 id="session小结"><a href="#session小结" class="headerlink" title="session小结"></a>session小结</h3><p>① session是存在服务器的内存中<br>② 一个用户浏览器，独享一个session域对象（不能浏览器会创建新的session）<br>③ session中的属性的默认生命周期是30min，你可以通过web.xml来修改<br>④ 3种session生命周期的设置</p>
<pre><code>（1）一个地方是 tomcat/conf/web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;//表示30分钟的意思
    &lt;/session-config&gt;
    对所有的web应用生效
（2）另外一个地方，就是在单个web应用的下去修改 web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;session精确到分钟,cookie精确到秒
    &lt;/session-config&gt;
    如果发生冲突，则以自己的web应用优先级高
（3）session.setMaxInactiveinterval(60) 六十秒为发呆时间，即在这六十秒内没有访问过session，则session中所有属性失效
</code></pre><p><img src="http://i.imgur.com/LarH0Wk.png" alt=""></p>
<ul>
<li>session周期是发呆时间，如果我们设置session是10s，是指在10s内，没有访问过session，session属性失效，如果在9s时候，你访问session，session就会重新计时</li>
<li>如果重启tomcat，或者reload web应用，或者关机了，session失效</li>
<li>我们也可以通过函数，让session失效。invalidate()方法让所有属性失效，通常用于用户安全退出</li>
<li>如果你希望某个session属性失效，可以使用方法removeAttribute</li>
</ul>
<p>⑤ session中可以存放多个属性<br>⑥ session可以存放对象<br>⑦ 如果session.setAttribute(“name”,val)，如果名字重复，则会替换该属性.</p>
<h3 id="session的更深入理解"><a href="#session的更深入理解" class="headerlink" title="session的更深入理解"></a>session的更深入理解</h3><p><strong><em>为什么服务器能够为不同的浏览器提供不同session？</em></strong>  </p>
<p>　　图中浏览器A第一次访问Servlet1的时候，没有携带JSESSIONID，调用getSession()就会自动给你创建一个session，id为110，并创建cookie：JSESSIONID=110.<br>　　第二次浏览器访问Servlet2时，携带cookie：JSESSIONID=110，说明session已经创建，getSession（）方法返回id=110的session，能够获得session中的数据<br>　　同理，浏览器B访问servlet1时会新建一个新的session，id=119<br>　　每个浏览器独享一个session对象<br>　　<font color="red">session自动返回的cookie不会被写入文件，所以不同浏览器访问servlet会获取不同的session</font></p>
<p><img src="http://i.imgur.com/Klh1fzm.png" alt=""></p>
<h3 id="生成验证码案例"><a href="#生成验证码案例" class="headerlink" title="生成验证码案例"></a>生成验证码案例</h3><pre><code>public class check_code extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 7.禁止浏览器缓存随机图片
        response.setDateHeader(&quot;Expires&quot;, -1);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        // 6.通知客户机以图片方式打开发送过去的数据
        response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);
        // 1.在内存中创建一副图片
        BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB);
        // 2.向图片上写数据
        Graphics g = image.getGraphics();
        // 设背景色
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 60, 30);
        // 3.设置写入数据的颜色和字体
        g.setColor(Color.RED);
        g.setFont(new Font(null, Font.BOLD, 20));
        // 4.向图片上写数据
        String num = makeNum();
        //这句话就是把随机生成的数值，保存到session
        request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了
        g.drawString(num, 5, 22);
        // 5.把写好数据的图片输出给浏览器
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }
    //该函数时随机生成4位数字
    public String makeNum() {
        Random r = new Random();
        //9999999 可以生成7位
        String num = r.nextInt(9999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        //如果不够4位，前面补零
        for (int i = 0; i &lt; 4 - num.length(); i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
</code></pre><h3 id="IE上购买商品后关闭，再打开IE，要求上次的商品还在"><a href="#IE上购买商品后关闭，再打开IE，要求上次的商品还在" class="headerlink" title="IE上购买商品后关闭，再打开IE，要求上次的商品还在"></a>IE上购买商品后关闭，再打开IE，要求上次的商品还在</h3><p><strong><em>分析</em></strong></p>
<ul>
<li>设session生命周期为30min,该session不会随浏览器的关闭而自动销毁。而会到30min后，才会被服务器销毁</li>
<li>关闭浏览器后，再打开。由于服务器端传回来的cookie：JSESSIONID没有设置生命周期，那么在浏览器关闭后cookie的生命周期结束。下次打开浏览器时，没有携带cookie：JSESSIONID，访问Servlet又会创建一个新的session</li>
<li>我们使用代码来实现该功能(session + cookie结合使用)</li>
</ul>
<p><strong><em>分析实现的思路:</em></strong></p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
    //创建一个session，并放入一个属性
    HttpSession session = request.getSession();
    session.setAttribute(&quot;name&quot;, &quot;xxx&quot;);
    out.println(&quot;创一个session并放入姓名属性&quot;);
    //把session_id保存在cookie，cookie名字必须按照规范命名，必须大写JSESSIONID
    Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());
    ////如果不设置时间生命周期，cookie在浏览器关闭后就消亡
    cookie.setMaxAge(60*30);
    response.addCookie(cookie);
}
</code></pre><h3 id="ie禁用cookie后使用session的方法"><a href="#ie禁用cookie后使用session的方法" class="headerlink" title="ie禁用cookie后使用session的方法"></a>ie禁用cookie后使用session的方法</h3><p><strong><em>简易购物车的实例</em></strong></p>
<p><img src="http://i.imgur.com/mqreaNv.png" alt=""></p>
<p><strong><em>思路</em></strong></p>
<pre><code>当用户点击购买商品时，我们把该商品保存到session中，该session的结构是:
name             val
mybookds    hashMap对象
而hashmap的结构是    
key     val
书号   书对象.
</code></pre><p>若禁用cookie后，每次访问Servlet不携带cookie数据，创建一个新的session，购物车商品不能保存</p>
<p><strong><em>解决方法</em></strong></p>
<p>URL重写</p>
<ul>
<li>response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写</li>
<li>response.encodeRedirectURL(java.lang.String url)用于对sendRedirect方法后的url地址进行重写</li>
</ul>
<p>Servlet.java</p>
<pre><code>request.getSession();//必须访问一下sesion
String url = response.encodeURL(&quot;/ServletStudy/cl&quot;);
out.println(&quot;&lt;form method = &apos;post&apos; action = &apos;&quot;+url+&quot;&apos;&gt;&quot;);
out.println(&quot;&lt;input type = &apos;submit&apos;/&gt;&quot;);
out.println(&quot;&lt;/form&gt;&quot;);
</code></pre><p>cl.java</p>
<pre><code>HttpSession session = request.getSession();
ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;) session.getAttribute(&quot;array&quot;);
if(null == array){
    array = new ArrayList&lt;String&gt;();
    session.setAttribute(&quot;array&quot;,array);
}
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String time = simpleDateFormat.format(new java.util.Date());
array.add(time);

for(String s : array){
    out.println(s + &quot;&lt;br/&gt;&quot;);
}
String url = response.encodeURL(&quot;/ServletStudy/Servlet&quot;);
out.println(&quot;&lt;a href = &apos;&quot;+url+&quot;&apos;&gt;返回&lt;/a&gt;&quot;);
</code></pre><h2 id="cookie-vs-session"><a href="#cookie-vs-session" class="headerlink" title="cookie vs session"></a>cookie vs session</h2><h3 id="存在的位置"><a href="#存在的位置" class="headerlink" title="存在的位置"></a>存在的位置</h3><ul>
<li>cookie存在客户端的临时文件夹</li>
<li>session存在服务器的内存中，一个sessio与对象为一个用户浏览器服务</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>cookie是以明文方式存放在客户端，安全性弱，可以通过加密md5再存放</li>
<li>session是存放在服务端的内存中，安全性好</li>
</ul>
<h3 id="网络传输量"><a href="#网络传输量" class="headerlink" title="网络传输量"></a>网络传输量</h3><ul>
<li>cookie会传递信息，给服务端</li>
<li>session的属性值不会给客户端</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>cookie的生命周期是累计时间，即如果我们给cookie设置setMaxAge（30），则cookie在30s后失效</li>
<li>session额生命周期是间隔时间，如果我们设置session 20min，指在20min内，如果没有访问session，则session失效（指的是session属性失效），在关闭tomcat,reload web应用，时间到，invalidate也会让session失效</li>
</ul>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><p>　　因为session会占用服务器的内存，因此不要向session存放过多的对象，会影响性能</p>
<h2 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器 Filter"></a>过滤器 Filter</h2><ul>
<li>客户端请求request在<strong>抵达Servlet之前</strong>、服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>会经过过滤器，过滤器用于在Servlet之外<strong>对request或者response进行修改</strong></li>
<li>Filter体现的是设计模式中的Filter模式</li>
</ul>
<h3 id="过滤器链-FilterChain"><a href="#过滤器链-FilterChain" class="headerlink" title="过滤器链 FilterChain"></a>过滤器链 FilterChain</h3><p>一个过滤器链包括多个Filter，客户端请求request在<strong>抵达Servlet之前</strong>会经过FilterChain里的所有Filter，服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>之前也会经过FilterChain里的所有Filter</p>
<p><img src="http://i.imgur.com/5S0gzS0.png" alt=""></p>
<h3 id="防盗链Filter"><a href="#防盗链Filter" class="headerlink" title="防盗链Filter"></a>防盗链Filter</h3><pre><code>public class ImageRedirectFilter implements Filter {

    public void init(FilterConfig config) throws ServletException {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 禁止缓存
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);
        response.setHeader(&quot;Pragrma&quot;, &quot;no-cache&quot;);
        response.setDateHeader(&quot;Expires&quot;, 0);

        // 链接来源地址
        String referer = request.getHeader(&quot;referer&quot;);

        if (referer == null || !referer.contains(request.getServerName())) {

            /**
             * 如果 链接地址来自其他网站，则返回错误图片
             */
            request.getRequestDispatcher(&quot;/error.gif&quot;).forward(request,
                    response);

        } else {

            /**
             * 图片正常显示
             */
            chain.doFilter(request, response);
        }

    }

    public void destroy() {
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;
</code></pre><h3 id="字符编码-Filter"><a href="#字符编码-Filter" class="headerlink" title="字符编码 Filter"></a>字符编码 Filter</h3><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><pre><code>public class CharacterEncodingFilter implements Filter {

    private String characterEncoding;
    private boolean enabled;

    @Override
    public void init(FilterConfig config) throws ServletException {

        characterEncoding = config.getInitParameter(&quot;characterEncoding&quot;);

        enabled = &quot;true&quot;.equalsIgnoreCase(characterEncoding.trim())
                || &quot;1&quot;.equalsIgnoreCase(characterEncoding.trim());
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {

        if (enabled || characterEncoding != null) {
            request.setCharacterEncoding(characterEncoding);
            response.setCharacterEncoding(characterEncoding);
        }

        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        characterEncoding = null;
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.CharacterEncodingFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;characterEncoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;enable&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h4 id="Spring-mvc自带"><a href="#Spring-mvc自带" class="headerlink" title="Spring mvc自带"></a>Spring mvc自带</h4><pre><code>&lt;!-- 编码过滤器，UTF8编码，对POST有效 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="异常捕捉-Filter"><a href="#异常捕捉-Filter" class="headerlink" title="异常捕捉 Filter"></a>异常捕捉 Filter</h3><pre><code>public class ExceptionHandlerFilter implements Filter {

    public void destroy() {}

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } catch (Exception e) {
            Throwable rootCause = e;
            while (rootCause.getCause() != null) {
                rootCause = rootCause.getCause();
            }
            String message = rootCause.getMessage();
            message = message == null ? &quot;异常：&quot; + rootCause.getClass().getName()
                    : message;
            request.setAttribute(&quot;message&quot;, message);
            request.setAttribute(&quot;e&quot;, e);

            if (rootCause instanceof AccountException) {
                request.getRequestDispatcher(&quot;/accountException.jsp&quot;).forward(
                        request, response);
            } else if (rootCause instanceof BusinessException) {
                request.getRequestDispatcher(&quot;/businessException.jsp&quot;).forward(
                        request, response);
            } else {
                request.getRequestDispatcher(&quot;/exception.jsp&quot;).forward(request,
                        response);
            }
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</code></pre><h3 id="内容替换-Filter"><a href="#内容替换-Filter" class="headerlink" title="内容替换 Filter"></a>内容替换 Filter</h3><p>需求：有时候需要对网站的内容进行控制，防止输出非法内容或者敏感内容<br>解决方案：</p>
<ul>
<li>方案一：在Servlet里输出到客户端时进行内容替换，这种方案需要对每个Servlet<br>都进行替换，工作量大，业务耦合比较严重</li>
<li>方案二：在Servlet将内容输出到response时，response将内容缓存起来，<br>在Filter中进行替换，然后再输出到客户端浏览器。但是默认的response并不能严格的<br>缓存输出内容，因此需要<font color="red"><strong><em>自定义一个具有缓存功能的response</em></strong></font></li>
</ul>
<p>要点：自定义的一个response只是一个伪装的response。Servlet会通过它输出内容到客户端，但是它内部只是将内容缓存起来了（<font color="red"><strong><em>使用自己创建的PrintWriter</em></strong></font>），并没有真正输出到客户端。最终输出到客户端还是通过原来的resonse完成的</p>
<p>框图：</p>
<p><img src="http://i.imgur.com/OirpKFm.png" alt=""></p>
<p>具体操作：</p>
<p>1、通过扩展HttpServletResponseWrapper类来<font color="red"><strong><em>实现自定义的response</em></strong></font>，该类覆盖了getWriter()方法，当Servlet使用该response对象调用getWriter()莱输出内容时，内容将被输出到CharArrayWriter对象中，达到缓存的效果</p>
<pre>
public class HttpCharacterResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">private CharArrayWriter charArrayWriter = new CharArrayWriter();</font>

    public HttpCharacterResponseWrapper(HttpServletResponse response) {
        super(response);
    }

    <font color="red">@Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(charArrayWriter);
    }</font>

    public CharArrayWriter getCharArrayWriter() {
        return charArrayWriter;
    }
}
</pre>

<p>2、Filter将自定义的response传进Servlet中</p>
<pre>
public class OutputReplaceFilter implements Filter {

    private Properties pp = new Properties();

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("file");
        String realPath = config.getServletContext().getRealPath(file);
        try {
            pp.load(new FileInputStream(realPath));
        } catch (IOException e) {
        }
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        <font color="red">// 自定义的 response
        HttpCharacterResponseWrapper response = new HttpCharacterResponseWrapper(
                (HttpServletResponse) res);

        // 提交给 Servlet 或者下一个 Filter
        chain.doFilter(req, response);</font>

        // 得到缓存在自定义 response 中的输出内容
        String output = response.getCharArrayWriter().toString();

        // 修改，替换
        for (Object obj : pp.keySet()) {
            String key = (String) obj;
            output = output.replace(key, pp.getProperty(key));
        }

        <font color="red">// 输出
        PrintWriter out = res.getWriter();
        out.write(output);</font>
        out.println("<!-- Generated at " + new java.util.Date() + " -->");
    }

    public void destroy() {
    }
}
</pre>

<h3 id="GZIP-压缩-Filter"><a href="#GZIP-压缩-Filter" class="headerlink" title="GZIP 压缩 Filter"></a>GZIP 压缩 Filter</h3><p>Servlet中操作输入输出流：</p>
<pre>
String path = request.getSession().getServletContext().getRealPath("/error.jpg");
InputStream inputStream = new FileInputStream(path);
int len = -1;
byte[] buffer = new byte[1024];
<font color="red">OutputStream outputStream = response.getOutputStream();</font>
while((len = inputStream.read(buffer)) != -1){
    <font color="red">outputStream.write(buffer,0,len);</font>
}
<font color="red">outputStream.close();</font>
inputStream.close();
</pre>

<p>要点：<br>1、替换response，并且替换的response中重写response中的getOutputStream()方法[也需要重写getWrite()，因为除了压缩二进制文件，还要压缩文本文件]<br>2、重写ServletOutputStream，当调用write方法时，使用JDK自带的GZIPOutputStream类进行数据压缩★★★★★★★★（核心）</p>
<p>总体操作框图：</p>
<p><img src="http://i.imgur.com/V7Ec9aU.png" alt=""></p>
<pre>
①自定义的GZipResponseWrapper替换tomcat传入的respone
    <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);</font>
    chain.doFilter(request, gzipResponse);
②Servlet中调用response中的getOutputStream()获得输出流，数据写入缓存，调用close方法进行压缩
    OutputStream outputStream = response.<font color="red">getOutputStream();</font>
    while((len = inputStream.read(buffer)) != -1){
        outputStream.write(buffer,0,len);
    }
    <font color="red">outputStream.close();</font>
    inputStream.close();
③输出压缩数据
    gzipResponse.finishResponse();
</pre>

<p>GZIPOutputStream类API：</p>
<pre><code>void finish() 
      完成将压缩数据写入输出流的操作，无需关闭底层流。 
void write(byte[] buf, int off, int len) 
      将字节数组写入压缩输出流。 
</code></pre><p>1、GZipFilter，如果客户端支持GZip自动解压，则进行GZIP压缩，否则不压缩</p>
<pre>
public class GZipFilter implements Filter {

    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        String acceptEncoding = request.getHeader("Accept-Encoding");
        System.out.println("Accept-Encoding: " + acceptEncoding);

        if (acceptEncoding != null
                && acceptEncoding.toLowerCase().indexOf("gzip") != -1) {

            // 如果客户浏览器支持 GZIP 格式, 则使用 GZIP 压缩数据
            <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);
            chain.doFilter(request, gzipResponse);</font>

            <font color="red">/*
            * 输出压缩数据，一般由用户在调用outputStream.close()自己关闭输出流，
            * 此处调用是为了防止用户忘记
            */
            gzipResponse.finishResponse();</font>

        } else {
            // 否则, 不压缩
            chain.doFilter(request, response);
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</pre>

<p>2、GZipResponseWrapper伪装response，GZipOutputStream为它的成员变量，Servlet中的输出就是对GZipOutputStream的操作</p>
<ul>
<li>GZipResponseWrapper为自定义的response类，内部将对输出的内容进行GZIP压缩。它继承HttpServletResponseWrapper，也是一个伪装的response，不真正输出内容到客户端</li>
<li>由于该response要处理二进制内容，又要处理字符内容，因此需要覆盖getOutputStream和getWriter</li>
<li><strong>GZipResponseWrapper中的方法是实现对GZipOutputStream的操作</strong></li>
</ul>
<pre>
public class GZipResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">/*
    * 传入默认的response，保存起来作为成员变量
    */</font>
    private HttpServletResponse response;

    <font color="red">/*
    * 可以不保存，如果用户自己关闭输入流，则无需调用finishResponse方法来关闭文本或二进制输出流。
    * 但是为了增加可靠性，在response抵达客户端浏览器前进行关闭流操作
    */</font>
    // 自定义的 outputStream, 执行close()的时候对数据压缩，并输出
    private GZipOutputStream gzipOutputStream;
    // 自定义 printWriter，将内容输出到 GZipOutputStream 中
    private PrintWriter writer;

    public GZipResponseWrapper(HttpServletResponse response) throws IOException {
        super(response);
        this.response = response;
    }

    public ServletOutputStream getOutputStream() throws IOException {
        if (gzipOutputStream == null)
            <font color="red">gzipOutputStream = new GZipOutputStream(response);</font>
        return gzipOutputStream;
    }

    public PrintWriter getWriter() throws IOException {
        if (writer == null)
            <font color="red">writer = new PrintWriter(new OutputStreamWriter(
                    new GZipOutputStream(response), "UTF-8"));</font>
        return writer;
    }

    // 压缩后数据长度会发生变化 因此将该方法内容置空
    public void setContentLength(int contentLength) {
    }

    public void flushBuffer() throws IOException {
        gzipOutputStream.flush();
    }

    <font color="red">public void finishResponse() throws IOException {
        if (gzipOutputStream != null)
            gzipOutputStream.close();
        if (writer != null)
            writer.close();
    }</font>
}
</pre>

<p>3、自定义GZipOutputStream类，继承ServletOutputStream，使用JDK自带的GZIP压缩类将数据缓存起来，之后调用finish函数进行数据压缩，并输出到客户端浏览器</p>
<pre>
public class GZipOutputStream extends ServletOutputStream {

    private HttpServletResponse response;

    // JDK 自带的压缩数据的类
    private GZIPOutputStream gzipOutputStream;

    // 将压缩后的数据存放到 ByteArrayOutputStream 对象中
    private ByteArrayOutputStream byteArrayOutputStream;

    <font color="red">/*
    * GZipResponseWrapper中调用构造函数，创建实例，数据缓存在ByteArrayOutputStream
    */</font>
    public GZipOutputStream(HttpServletResponse response) throws IOException {
        this.response = response;
        byteArrayOutputStream = new ByteArrayOutputStream();
        gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);
    }

    <font color="red">/*
    * Servlet中调用write方法，将数据写入缓存
    */</font>
    public void write(int b) throws IOException {
        gzipOutputStream.write(b);
    }

    <font color="red">/*
    * Servlet中调用close方法，并不是直接关闭输入流，而是先执行压缩操作，然后调用浏览器本身的输出流，在写入到客户端浏览器
    */</font>
    public void close() throws IOException {

        // 压缩完毕 一定要调用该方法
        gzipOutputStream.finish();

        // 将压缩后的数据输出到客户端
        byte[] content = byteArrayOutputStream.toByteArray();

        // 设定压缩方式为 GZIP, 客户端浏览器会自动将数据解压
        response.addHeader("Content-Encoding", "gzip");
        response.addHeader("Content-Length", Integer.toString(content.length));

        // 输出
        ServletOutputStream out = response.getOutputStream();
        out.write(content);
        out.close();
    }

    public void flush() throws IOException {
        gzipOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        gzipOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        gzipOutputStream.write(b);
    }
}
</pre>

<h3 id="图像水印-Filter"><a href="#图像水印-Filter" class="headerlink" title="图像水印 Filter"></a>图像水印 Filter</h3><p>使用Filter在图像上动态打上一个水印LOGO，工作原理与GZIP压缩类似，先把图像数据缓存起来，然后对图像进行水印处理后输出到客户端浏览器</p>
<p>图像水印Filter需要自定义response与servletOutputStream</p>
<p>1、WaterMarkFilter，在Filter初始化参数里设置水印图片文件路径</p>
<pre>
public class WaterMarkFilter implements Filter {

    // 水印图片，配置在初始化参数中
    private String waterMarkFile;

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("waterMarkFile");
        waterMarkFile = config.getServletContext().getRealPath(file);
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 自定义的response
        WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

        chain.doFilter(request, waterMarkRes);

        // 打水印，输出到客户端浏览器
        waterMarkRes.finishResponse();
    }

    public void destroy() {
    }

}
</pre>

<p>2、WaterMarkResponseWrapper继承HttpServletResponseWrapper，改写了getOutputStream方法，finishResponse方法将缓存的数据进行水印处理，并输出到客户端浏览器。水印处理的代码被封装到ImageUtil类的静态方法waterMark()中</p>
<pre>
public class WaterMarkResponseWrapper extends HttpServletResponseWrapper {

    // 水印图片位置
    private String waterMarkFile;

    // 原response
    private HttpServletResponse response;

    // 自定义servletOutputStream，用于缓冲图像数据
    private WaterMarkOutputStream waterMarkOutputStream;

    public WaterMarkResponseWrapper(HttpServletResponse response,
            String waterMarkFile) throws IOException {
        super(response);
        this.response = response;
        this.waterMarkFile = waterMarkFile;
        this.waterMarkOutputStream = new WaterMarkOutputStream();
    }

    // 覆盖getOutputStream()，返回自定义的waterMarkOutputStream
    public ServletOutputStream getOutputStream() throws IOException {
        return waterMarkOutputStream;
    }

    public void flushBuffer() throws IOException {
        waterMarkOutputStream.flush();
    }

    // 将图像数据打水印，并输出到客户端浏览器
    public void finishResponse() throws IOException {

        // 原图片数据
        byte[] imageData = waterMarkOutputStream.getByteArrayOutputStream()
                .toByteArray();

        // 打水印后的图片数据
        byte[] image = ImageUtil.waterMark(imageData, waterMarkFile);

        // 将图像输出到浏览器
        response.setContentLength(image.length);
        response.getOutputStream().write(image);

        waterMarkOutputStream.close();
    }
}
</pre>

<p>3、WaterMarkOutputStream类将图像数据缓存起来</p>
<pre>
public class WaterMarkOutputStream extends ServletOutputStream {

    // 缓冲图片数据
    private ByteArrayOutputStream byteArrayOutputStream;

    public WaterMarkOutputStream() throws IOException {
        byteArrayOutputStream = new ByteArrayOutputStream();
    }

    public void write(int b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public void close() throws IOException {
        byteArrayOutputStream.close();
    }

    public void flush() throws IOException {
        byteArrayOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        byteArrayOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public ByteArrayOutputStream getByteArrayOutputStream() {
        return byteArrayOutputStream;
    }

}
</pre>

<p>4、ImageUtil类使用JDK的图像处理类完成添加水印的操作</p>
<pre>
public class ImageUtil {

    /**
     * 
     * @param imageData
     *            JPG 图像文件
     * @param waterMarkFile
     *            水印图片
     * @return 加水印后的图像数据
     * @throws IOException
     */
    public static byte[] waterMark(byte[] imageData, String waterMarkFile)
            throws IOException {

        // 水印图片的右边距 下边距
        int paddingRight = 10;
        int paddingBottom = 10;

        // 原始图像
        Image image = new ImageIcon(imageData).getImage();
        int imageWidth = image.getWidth(null);
        int imageHeight = image.getHeight(null);

        // 水印图片
        Image waterMark = ImageIO.read(new File(waterMarkFile));
        int waterMarkWidth = waterMark.getWidth(null);
        int waterMarkHeight = waterMark.getHeight(null);

        // 如果图片尺寸过小，则不打水印，直接返回
        if (imageWidth < waterMarkWidth + 2 * paddingRight
                || imageHeight < waterMarkHeight + 2 * paddingBottom) {
            return imageData;
        }
        BufferedImage bufferedImage = new BufferedImage(imageWidth,
                imageHeight, BufferedImage.TYPE_INT_RGB);

        Graphics g = bufferedImage.createGraphics();

        // 绘制原始图像
        g.drawImage(image, 0, 0, imageWidth, imageHeight, null);
        // 绘制水印图片
        g.drawImage(waterMark, imageWidth - waterMarkWidth - paddingRight,
                imageHeight - waterMarkHeight - paddingBottom, waterMarkWidth,
                waterMarkHeight, null);
        g.dispose();

        // 转成JPEG格式
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
        encoder.encode(bufferedImage);
        byte[] data = out.toByteArray();
        out.close();
        return data;
    }
}
</pre>

<p>5、配置文件</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter&gt;
    &lt;filter-name&gt;waterMarkFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.watermark.WaterMarkFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;waterMarkFile&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/logo.png&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h3 id="内容替换、GZIP、图像水印-Filter-总结★★★★★★"><a href="#内容替换、GZIP、图像水印-Filter-总结★★★★★★" class="headerlink" title="内容替换、GZIP、图像水印 Filter 总结★★★★★★"></a>内容替换、GZIP、图像水印 Filter 总结★★★★★★</h3><p>以图像水印 Filter 为例</p>
<p>1、过滤器中自定义response包裹类，将原生response作为参数传入。自定义的response替换原生response传入Servlet；response返回客户端之前，调用新定义的finishResponse方法，输出到客户端浏览器</p>
<pre><code>// 自定义的response
WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

chain.doFilter(request, waterMarkRes);

// 打水印，输出到客户端浏览器
waterMarkRes.finishResponse();
</code></pre><p>2、自定义response包裹类有一个存放原生response的成员变量，一个自定义的输出流，起到缓存数据的功能。重写getOutputStream()方法或getWriter()方法，返回自定义输出流，添加finishResponse方法，将缓存中的数据进行处理，输出到客户端浏览器</p>
<p>3、重写ServletOutputStream类对数据进行，对数据缓存</p>
<h3 id="缓存-Filter"><a href="#缓存-Filter" class="headerlink" title="缓存 Filter"></a>缓存 Filter</h3><p><strong><em>对于访问量比较大的网站（淘宝），反复地查询数据库要消耗很多时间</em></strong>。如果第一次访问某页面查询了数据库，那么就可以把页面的内容缓存起来，下一次访问的时候直接返回缓存结果就行。使用缓存能将数据库读写次数较少都最少，从而提高服务器的响应速度</p>
<p>缓存Filter的工作流程：<br>1、截获浏览器提交的request<br>2、如果request为POST方式，则不进行缓存<br>3、<strong>如果request为GET方式，且请求的页面有缓存并且缓存没有过期</strong>，则直接返回缓存结果，这样就避免读取数据库<br>4、如果没有缓存或者缓存已过期，则重新请求Servlet，将Servlet返回的内容缓存并输出到客户端浏览器</p>
<p>使用缓存注意点：</p>
<p>1、缓存Filter不易用于数据会实时变化的数据，如报表、股票等，它适用于数据变化不大，但是访问次数多的内容，如论坛、博客、新闻等<br>2、缓存Filter不能用于POST方式提交数据，如登录、发表文章等<br>3、<strong>当缓存更新后，要更新缓存，或者直接将缓存删掉</strong><br>4、被缓存的内容不能依赖于Session，而要依赖于Cookie。即要使用Cookie来记录客户身份而不要使用Session，并且<strong>无论客户身份是管理员还是普通浏览者，Servlet输出内容都是一样的，只能在浏览器使用js根据cookie来决定显示什么内容</strong>。但是注意：由于菜单的显示与否并没有在服务器端进行权限检查，<font color="red"><strong><em>因此当客户单击链接操作的时候，一定要做权限检查，否则会引发安全问题</em></strong></font></p>
<p>框图：</p>
<p><img src="http://i.imgur.com/S75GBO8.png" alt=""></p>
<p>①如果存在缓存文件，直接缓存文件中读取数据并输出到客户端浏览器，不进入Servlet<br>②没有缓存或缓存过期，在Servlet将输出的内容缓存起来<br>③缓存Filter将缓存内容写入到缓存文件，并读取缓存文件将数据输出</p>
<p>程序流程图：</p>
<p><img src="http://i.imgur.com/SSL3f5N.png" alt=""></p>
<p>1、缓存Filter</p>
<pre>
public class CacheFilter implements Filter {

    private ServletContext servletContext;

    // 缓存文件夹，使用Tomcat工作目录
    private File temporalDir;

    // 缓存时间，配置在Filter初始化参数中
    private long cacheTime = Long.MAX_VALUE;

    public void init(FilterConfig config) throws ServletException {
        temporalDir = (File) config.getServletContext().getAttribute(
                "javax.servlet.context.tempdir");
        servletContext = config.getServletContext();
        cacheTime = new Long(config.getInitParameter("cacheTime"));
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        <font color="red">// 如果为 POST, 则不经过缓存</font>
        if ("POST".equals(request.getMethod())) {
            chain.doFilter(request, response);
            return;
        }

        <font color="red">// 请求的 URI，忽略应用程序名称</font>
        String uri = request.getRequestURI();
        if (uri == null)
            uri = "";
        uri = uri.replace(request.getContextPath() + "/", "");
        uri = uri.trim().length() == 0 ? "index.jsp" : uri;
        uri = request.getQueryString() == null ? uri : (uri + "?" + request
                .getQueryString());

        // 对应的缓存文件
        File cacheFile = new File(temporalDir, URLEncoder.encode(uri, "UTF-8"));
        System.out.println(cacheFile);

        // 如果缓存文件不存在 或者已经超出缓存时间 则请求 Servlet
        if (!cacheFile.exists()
                || cacheFile.length() == 0
                || cacheFile.lastModified() < System.currentTimeMillis()
                        - cacheTime) {

            CacheResponseWrapper cacheResponse = new CacheResponseWrapper(
                    response);

            chain.doFilter(request, cacheResponse);

            // 将内容写入缓存文件
            char[] content = cacheResponse.getCacheWriter().toCharArray();

            temporalDir.mkdirs();<font color="red">//递归创建文件夹</font>
            cacheFile.createNewFile();<font color="red">//创建文件</font>

            Writer writer = new OutputStreamWriter(new FileOutputStream(
                    cacheFile), "UTF-8");
            writer.write(content);
            writer.close();
        }

        // 请求的ContentType
        String mimeType = servletContext.getMimeType(request.getRequestURI());
        response.setContentType(mimeType);

        // 读取缓存文件的内容，写入客户端浏览器
        Reader ins = new InputStreamReader(new FileInputStream(cacheFile),
                "UTF-8");
        StringBuffer buffer = new StringBuffer();
        char[] cbuf = new char[1024];
        int len;
        while ((len = ins.read(cbuf)) > -1) {
            buffer.append(cbuf, 0, len);
        }
        ins.close();
        // 输出到客户端
        response.getWriter().write(buffer.toString());
    }

    public void destroy() {
    }
}
</pre>

<p>2、CacheResponseWrapper强Servlet中输出的内容缓存起来，然后被缓存Filter写入到缓存文件中。本缓存Filter只缓存字符类网页，因此只覆盖了getWriter()方法</p>
<pre><code>public class CacheResponseWrapper extends HttpServletResponseWrapper {

    // 缓存字符类输出
    private CharArrayWriter cacheWriter = new CharArrayWriter();

    public CacheResponseWrapper(HttpServletResponse response)
            throws IOException {
        super(response);
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(cacheWriter);
    }

    @Override
    public void flushBuffer() throws IOException {
        cacheWriter.flush();
    }

    public void finishResponse() throws IOException {
        cacheWriter.close();
    }

    public CharArrayWriter getCacheWriter() {
        return cacheWriter;
    }

    public void setCacheWriter(CharArrayWriter cacheWriter) {
        this.cacheWriter = cacheWriter;
    }
}
</code></pre><p>3、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.cache.CacheFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cache&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cacheTime&lt;/param-name&gt;
        &lt;param-value&gt;1000000&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="XSLT-转换-Filter"><a href="#XSLT-转换-Filter" class="headerlink" title="XSLT 转换 Filter"></a>XSLT 转换 Filter</h3><p>XSLT转换时XML文件的功能之一，是利用XSLT样式文件将XML文件转换成其他格式，使用XSLT 转换 Filter，浏览器访问请求XML格式，返回浏览器时已经是转换后的HTML文件了</p>
<p>1、该Filter使用JDK自带的标准XML工具包进行XML格式转换。MSN的聊天记录是用XML形式保存的，浏览器访问XML格式，返回转换后的HTML文件</p>
<pre><code>public class XSLTFilter implements Filter {

    private ServletContext servletContext;

    public void init(FilterConfig config) throws ServletException {
        servletContext = config.getServletContext();
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 格式样本文件：/book.xsl
        Source styleSource = new StreamSource(servletContext
                .getRealPath(&quot;/MessageLog.xsl&quot;));

        // 请求的 xml 文件
        Source xmlSource = new StreamSource(servletContext.getRealPath(request
                .getRequestURI().replace(request.getContextPath() + &quot;&quot;, &quot;&quot;)));
        try {

            // 转换器工厂
            TransformerFactory transformerFactory = TransformerFactory
                    .newInstance();

            // 转换器
            Transformer transformer = transformerFactory
                    .newTransformer(styleSource);

            // 将转换的结果保存到该对象中
            CharArrayWriter charArrayWriter = new CharArrayWriter();
            StreamResult result = new StreamResult(charArrayWriter);

            // 转换
            transformer.transform(xmlSource, result);

            // 输出转换后的结果
            response.setContentType(&quot;text/html&quot;);
            response.setContentLength(charArrayWriter.toString().length());
            PrintWriter out = response.getWriter();
            out.write(charArrayWriter.toString());

        } catch (Exception ex) {
        }
    }

    public void destroy() {
    }
}
</code></pre><p>2、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.helloweenvsfei.xml.XSLTFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/msn/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器 Listener"></a>监听器 Listener</h2><p>Listener用于监听Java Web程序中的事件，例如创建、修改、删除Session、request、context等</p>
<h3 id="Listener使用"><a href="#Listener使用" class="headerlink" title="Listener使用"></a>Listener使用</h3><p>使用Listener需要实现相应的Listener接口，<strong><em>触发Listener事件时，Tomcat会自动调用Listener的方法</em></strong></p>
<h4 id="实现Listener接口"><a href="#实现Listener接口" class="headerlink" title="实现Listener接口"></a>实现Listener接口</h4><p>创建Session服务器会调用sessionCreated()方法，销毁Session（包括sesson超时自动销毁）服务器会调用sessionDestroyed()方法</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener {

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        //Session创建时被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;创建了一个session：&quot; + session);
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        //销毁Session前被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;销毁了一个Session：&quot; + session);
    }
}
</code></pre><h4 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h4><p>&lt;listener&gt;标签一般配置在&lt;servlet&gt;前面</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h3 id="Listener的分类★★★★★★"><a href="#Listener的分类★★★★★★" class="headerlink" title="Listener的分类★★★★★★"></a>Listener的分类★★★★★★</h3><h4 id="监听对象的创建与销毁"><a href="#监听对象的创建与销毁" class="headerlink" title="监听对象的创建与销毁"></a>监听对象的创建与销毁</h4><ul>
<li>HttpSessionListener：监听Session的创建与销毁。创建Session时执行sessionCreated方法，超时或执行session.invalidate()时执行sessionDestroyed方法。<font color="red"><strong><em>该Listener可以收集在线者信息</em></strong></font></li>
<li>ServletContextListener：监听context的创建与销毁。<strong>context代表当前的Web应用程序</strong>，服务器启动或者热部署war包时执行contextInitialized，服务器关闭或关闭该Web时会执行contextDestroyed方法。<font color="red"><strong><em>该Listener可用于启动时读取web.xml里配置的初始化参数</em></strong></font></li>
<li>ServletRequestListener：监听request的创建与销毁，用户每次请求都会执行requestInitialized方法，request处理完毕自动销毁前执行requestDestroyed。注意如果一个HTML页面包含多个图片，则一次请求可能会多次触发request事件</li>
</ul>
<h4 id="实例：监听Session、request、servletContext"><a href="#实例：监听Session、request、servletContext" class="headerlink" title="实例：监听Session、request、servletContext"></a>实例：监听Session、request、servletContext</h4><p>自定义监听器类同时实现HttpSessionListener、ServletContextListener、ServletRequestListener接口，使得多种监听器一块工作</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener,
        ServletContextListener, ServletRequestListener {


    //Log log = LogFactory.getLog(getClass());
    Logger log = Logger.getLogger(SessionListenerTest.class);

    // 创建 session
    public void sessionCreated(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;新创建一个session, ID为: &quot; + session.getId());
    }

    // 销毁 session
    public void sessionDestroyed(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;销毁一个session, ID为: &quot; + session.getId());
    }

    // 加载 context
    public void contextInitialized(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将启动&quot; + servletContext.getContextPath());
    }

    // 卸载 context
    public void contextDestroyed(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将关闭&quot; + servletContext.getContextPath());
    }

    // 创建 request
    public void requestInitialized(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        String uri = request.getRequestURI();
        uri = request.getQueryString() == null ? uri : (uri + &quot;?&quot; + request
                .getQueryString());

        request.setAttribute(&quot;dateCreated&quot;, System.currentTimeMillis());

        log.info(&quot;IP &quot; + request.getRemoteAddr() + &quot; 请求 &quot; + uri);
    }

    // 销毁 request
    public void requestDestroyed(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        long time = System.currentTimeMillis()
                - (Long) request.getAttribute(&quot;dateCreated&quot;);

        log.info(request.getRemoteAddr() + &quot;请求处理结束, 用时&quot; + time + &quot;毫秒. &quot;);
    }
}
</code></pre><p>配置到web.xml</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h4 id="监听对象的属性变化"><a href="#监听对象的属性变化" class="headerlink" title="监听对象的属性变化"></a>监听对象的属性变化</h4><ul>
<li>另一类Listener用于监听Session、context、request的属性变化，接口名称格式为xxxAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener</li>
<li>当想被监听对象中添加、更新、移除属性时，会分别执行xxxAdded()、xxxReplace()、xxxRemoved()方法，xxx分别代表Session、Context、request</li>
</ul>
<pre><code>public class SessionAttributeListenerTest implements
        HttpSessionAttributeListener {

    Log log = LogFactory.getLog(getClass());

    // 添加属性
    public void attributeAdded(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;新建session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 删除属性
    public void attributeRemoved(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;删除session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 修改属性
    public void attributeReplaced(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        Object oldValue = se.getValue();
        log.info(&quot;修改session属性：&quot; + name + &quot;, 原值：&quot; + oldValue + &quot;, 新值：&quot;
                + session.getAttribute(name));
    }
}
</code></pre><h4 id="监听Session内的对象"><a href="#监听Session内的对象" class="headerlink" title="监听Session内的对象"></a>监听Session内的对象</h4><p>除了上面的6中Listener，有两种Listener用于监听Session内的对象，分别是HttpSessionBindingListener、HttpSessionActivationListener，他们的触发时机是：</p>
<ul>
<li>HttpSessionBindingListener：当对象被放到Session里是执行valueBound方法，当对象从Session里移除时执行valueUnbound，<strong><em>对象必须实现该Listener接口</em></strong></li>
<li>HttpSessionActivationListener：服务器关闭时，会将Session里的内容保存到硬盘上，这个过程叫做钝化。服务器重启时，会将Session里的内容从硬盘上重新加载，钝化时会执行sessionWillPassivate方法，对象被重新加载时执行sessionDidActivate方法，<strong><em>对象必须实现该Listener接口</em></strong></li>
</ul>
<p>这两个Listener监听的是Session中的对象而非Session等，因此不需要再web.xml中声明</p>
<p>PersonInfo对象被放进、移出Session或者启动、关闭服务器都会触发PersonInfo内的Listener时间：</p>
<pre><code>public class PersonInfo implements HttpSessionActivationListener,
        HttpSessionBindingListener, Serializable {

    private static final long serialVersionUID = -4780592776386225973L;

    Log log = LogFactory.getLog(getClass());

    private String name;

    private Date dateCreated;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    // 从硬盘加载后
    public void sessionDidActivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;已经成功从硬盘中加载。sessionId: &quot; + session.getId());
    }

    // 即将被钝化到硬盘时
    public void sessionWillPassivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;即将保存到硬盘。sessionId: &quot; + session.getId());
    }

    // 被放进session前
    public void valueBound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被绑定到session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上&quot;);

        // 记录放到session中的时间
        this.setDateCreated(new Date());
    }

    // 从session中移除后
    public void valueUnbound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被从session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上移除&quot;);
    }

    @Override
    public String toString() {
        return &quot;PersonInfo(&quot; + name + &quot;)&quot;;
    }

}
</code></pre><h3 id="Listener使用案例"><a href="#Listener使用案例" class="headerlink" title="Listener使用案例"></a>Listener使用案例</h3><h4 id="单态登录"><a href="#单态登录" class="headerlink" title="单态登录"></a>单态登录</h4><ul>
<li><font color="red"><strong>单态登录就是一个账号只能在一台机器上登录，如果在其他机器上登录了，则原来的登录无效</strong></font></li>
<li>单态登录的目的是为了防止多台机器同时使用一个账号</li>
</ul>
<h5 id="Listener方式实现"><a href="#Listener方式实现" class="headerlink" title="Listener方式实现"></a>Listener方式实现</h5><ul>
<li>见JavaWeb王者归来205页</li>
<li>思路：当成功验证用户信息，准备往session中存放用户的信息时，被监听器监听到，调用attributeAdded或attributeReplaced方法，方法中需要判断用户是否在别的机器上登录过，如果登录了则使以前的登录失效</li>
<li>使用这种方式Listener与登录模块没有代码耦合，部署Listener后将实现单态登录，拆掉该Listener后登录模块照常工作，只是不再保证是单态登录</li>
</ul>
<pre>
public class LoginSessionListener implements HttpSessionAttributeListener {

    Log log = LogFactory.getLog(this.getClass());

    Map<string, httpsession=""> map = new HashMap<string, httpsession="">();

    public void attributeAdded(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 登录
        if (name.equals("personInfo")) {

            PersonInfo personInfo = (PersonInfo) event.getValue();

            if (map.get(personInfo.getAccount()) != null) {

                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                PersonInfo oldPersonInfo = (PersonInfo) session
                        .getAttribute("personInfo");

                log.info("帐号" + oldPersonInfo.getAccount() + "在"
                        + oldPersonInfo.getIp() + "已经登录，该登录将被迫下线。");

                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }

            // 将session以用户名为索引，放入map中
            map.put(personInfo.getAccount(), event.getSession());
            log.info("帐号" + personInfo.getAccount() + "在" + personInfo.getIp()
                    + "登录。");
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 注销
        if (name.equals("personInfo")) {
            // 将该session从map中移除
            PersonInfo personInfo = (PersonInfo) event.getValue();
            map.remove(personInfo.getAccount());
            log.info("帐号" + personInfo.getAccount() + "注销。");
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 没有注销的情况下，用另一个帐号登录
        if (name.equals("personInfo")) {

            // 移除旧的的登录信息
            PersonInfo oldPersonInfo = (PersonInfo) event.getValue();
            map.remove(oldPersonInfo.getAccount());

            // 新的登录信息
            PersonInfo personInfo = (PersonInfo) event.getSession()
                    .getAttribute("personInfo");

            // 也要检查新登录的帐号是否在别的机器上登录过
            if (map.get(personInfo.getAccount()) != null) {
                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }
            map.put("personInfo", event.getSession());
        }

    }

}
</string,></string,></pre>

<h5 id="自己的实现"><a href="#自己的实现" class="headerlink" title="自己的实现"></a>自己的实现</h5><ul>
<li>如果没有要求单态登录，成功验证用户信息后，返回客户端token，在服务器端创建session，并将用户信息存入到session，之后客户端再次访问，根据token恢复session，如果session中存放了用户信息，则用户合法，否则退回登录页面</li>
<li>实现单态登录，需要在验证用户信息后，<font color="red"><strong><em>判断账号是否在别的机器上登录</em></strong></font>。</li>
<li>具体实现：用一个HashMap存储在线用户信息，主键为用户名，键值为session。成功验证用户信息后，根据用户名获取session，如果session不为空，说明用户已经在别的机器上登录，则使sesson无效，在HashMap上移除该值，这样之前登录的用户操作前，会检查session中没有用户信息，则必须重新登录，做到强制退出的目的</li>
<li>图示：红框是单态登录加入的模块</li>
</ul>
<p><img src="http://i.imgur.com/4vvjT4z.png" alt=""></p>
<pre>
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.setCharacterEncoding("utf-8");
    response.setCharacterEncoding("utf-8");
    response.setContentType("text/html;charset=utf-8");
    PrintWriter out = response.getWriter();

    String action = request.getParameter("action");
    if("login".equalsIgnoreCase(action)){
        String name = request.getParameter("name");
        String password = request.getParameter("password");
        User user = new User();
        user.setName(name);
        user.setPassword(password);
        if("qm".equals(name) && "123".equals(password)){
            <font color="red">//判断帐号是否在别的机器登录
            HttpSession oldSession = map.get(name);
            if(oldSession != null){//1、别的机器登录 2、重复登录
                oldSession.removeAttribute("user");
                <font color="blue">//oldSession.invalidate();不要删除session除了用户信息的其他属性，下次用户在本机登录还能获得先前的数据</font>
                map.remove(name);
            }</font>

            HttpSession session = request.getSession();
            session.setAttribute("user",user);
            map.put(name,session);
            out.println("登录成功");
        }else{
            out.println("登录失败");
        }
    }else if("logout".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //session.invalidate();
        session.removeAttribute("user");
        map.remove(user.getName());
        out.println("注销成功");
    }else if("main".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //往session添加其他属性
        Integer count = (Integer) session.getAttribute("count");
        if(count == null){
            count = 0;
            session.setAttribute("count", count);
        }
        count ++;
        session.setAttribute("count",count);

        //在线用户
        out.println(session.getAttribute("count"));
    }
}
</pre>

<h4 id="显示在线用户"><a href="#显示在线用户" class="headerlink" title="显示在线用户"></a>显示在线用户</h4><p>存放服务器信息、用户信息的类：</p>
<pre><code>public class ApplicationConstants {

    // 所有的 Session，session_id与session组成键值对
    public static Map&lt;String, HttpSession&gt; SESSION_MAP = new HashMap&lt;String, HttpSession&gt;();

    // 当前登录的用户总数
    public static int CURRENT_LOGIN_COUNT = 0;

    // 历史访客总数
    public static int TOTAL_HISTORY_COUNT = 0;

    // 服务器启动时间
    public static Date START_DATE = new Date();

    // 最高在线时间
    public static Date MAX_ONLINE_COUNT_DATE = new Date();

    // 最高在线人数
    public static int MAX_ONLINE_COUNT = 0;
}
</code></pre><p>使用ServletContextListener来监听服务器的启动与关闭，记录服务器启动时间等</p>
<pre><code>public class MyContextListener implements ServletContextListener {

    public void contextInitialized(ServletContextEvent event) {
        // 启动时，记录服务器启动时间
        ApplicationConstants.START_DATE = new Date();
    }

    public void contextDestroyed(ServletContextEvent event) {
        // 关闭时，将结果清除。也可以将结果保存到硬盘上，下次启动时再加载到ApplicationConstants中
        ApplicationConstants.START_DATE = null;
        ApplicationConstants.MAX_ONLINE_COUNT_DATE = null;
    }
}
</code></pre><p>对Session的监听，维护在线用户列表、总访问人数：</p>
<ul>
<li>使用Map来索引所有的Session，Session创建的时候放到Map中，Session销毁时从Map中剔除</li>
<li>什么时候用户数改变？成功验证用户信息后往session中存入用户信息、用户注销、用户被强退，attributeAdded和attributeReplaced的区别就是用户人数是否需要增加</li>
</ul>
<pre>
public class MySessionListener implements HttpSessionListener,
        HttpSessionAttributeListener {

    public void sessionCreated(HttpSessionEvent sessionEvent) {

        HttpSession session = sessionEvent.getSession();

        <font color="red">// 将 session 放入 map
        ApplicationConstants.SESSION_MAP.put(session.getId(), session);</font>
        // 总访问人数++
        ApplicationConstants.TOTAL_HISTORY_COUNT++;

        // 如果当前在线人数超过历史记录，则更新最大在线人数，并记录时间
        if (ApplicationConstants.SESSION_MAP.size() > ApplicationConstants.MAX_ONLINE_COUNT) {
            ApplicationConstants.MAX_ONLINE_COUNT = ApplicationConstants.SESSION_MAP
                    .size();
            ApplicationConstants.MAX_ONLINE_COUNT_DATE = new Date();
        }
    }

    public void sessionDestroyed(HttpSessionEvent sessionEvent) {
        HttpSession session = sessionEvent.getSession();
        // 将session从map中移除
        ApplicationConstants.SESSION_MAP.remove(session.getId());
    }

    public void attributeAdded(HttpSessionBindingEvent event) {

        if (event.getName().equals("personInfo")) {

            // 当前登录用户数++
            ApplicationConstants.CURRENT_LOGIN_COUNT++;
            HttpSession session = event.getSession();

            // 查找该帐号有没有在其他机器上登录
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {

                // 如果该帐号已经在其他机器上登录，则以前的登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        // 注销 当前登录用户数--
        if (event.getName().equals("personInfo")) {
            ApplicationConstants.CURRENT_LOGIN_COUNT--;
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        // 重新登录，但人数不用增加
        if (event.getName().equals("personInfo")) {
            HttpSession session = event.getSession();
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {
                // 如果新帐号在其他机器上登录过，则以前登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

}
</pre>

<p>监听request主要是记录客户的IP地址、访问次数等，也可以记录用户访问的URI：</p>
<pre>
public class MyRequestListener implements ServletRequestListener {

    public void requestDestroyed(ServletRequestEvent event) {
    }

    public void requestInitialized(ServletRequestEvent event) {

        HttpServletRequest request = (HttpServletRequest) event
                .getServletRequest();

        <font color="red">/*
        * 如果session为空，则重新创建一个session，主要是之前session.invalidate()会销毁session        
        */</font>
        HttpSession session = request.getSession(true);

        // 记录IP地址
        session.setAttribute("ip", request.getRemoteAddr());

        // 记录访问次数，只记录访问 .html, .do, .jsp, .action 的累计次数
        String uri = request.getRequestURI();
        String[] suffix = { ".html", ".do", ".jsp", ".action" };
        for (int i=0; i&lt;suffix.length; i++) {
            if (uri.endsWith(suffix[i])) {
                break;
            }
            if(i == suffix.length-1)
                return;
        }

        Integer activeTimes = (Integer) session.getAttribute("activeTimes");

        if (activeTimes == null) {
            activeTimes = 0;
        }

        session.setAttribute("activeTimes", activeTimes + 1);
    }
}
</pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/06/[Tomcat]Tomcat笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/06/[Tomcat]Tomcat笔记/" itemprop="url">Tomcat笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-06T10:14:00+08:00">
                2016-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tomcat的目录结构文件"><a href="#Tomcat的目录结构文件" class="headerlink" title="Tomcat的目录结构文件"></a>Tomcat的目录结构文件</h2><p><img src="http://i.imgur.com/Dp2gPgS.png" alt=""></p>
<pre><code>bin: 启动和关闭tomcat的bat文件
conf: 配置文件 
    --&gt;server.xml : 该文件用于配置和 server 相关的信息, 比如 tomcat启动端口后,配置Host,  配置Context 即web应用 
    --&gt;web.xml : 该文件配置与 web应用(web应用就相当于是一个 web站点)
    --&gt;tomcat-users.xml: 该文件用户配置tomcat 的用户密码 和 权限
lib目录: 该目录放置运行tomcat 运行需要的jar包
logs目录：存放日志, 当我们需要去查看日志的时候，很有用!,当我们启动tomcat错误时候，可以查询信息.
webapps目录: 该目录下，放置我们的web应用(web 站点)
work: 工作目录: 该目录用于存放jsp被访问后 生成的对应的 server文件 和.class文件
</code></pre><h2 id="首页面设置及目录规范结构"><a href="#首页面设置及目录规范结构" class="headerlink" title="首页面设置及目录规范结构"></a>首页面设置及目录规范结构</h2><p><img src="http://i.imgur.com/UJt4wAM.png" alt=""></p>
<p><em>配置访问首目录</em></p>
<pre><code>①在web文件夹下配置WEB-INF文件夹
②在 web.xml 文件中添加配置的代码:
  &lt;welcome-file-list&gt;
    &lt;welcome-file&gt;hello1.html&lt;/welcome-file&gt;
  &lt;/welcome-file-list&gt;
③通过http://localhost:8088/web1来访问hello1.html
</code></pre><p><em>目录结构</em></p>
<pre><code>web-inf目录下的 classes目录将来是存放 class文件
lib 目录将来时存放 jar文件
web.xml 配置当前这个web应用的信息.
</code></pre><h2 id="Tomcat体系"><a href="#Tomcat体系" class="headerlink" title="Tomcat体系"></a>Tomcat体系</h2><p><img src="http://i.imgur.com/7cYZp67.png" alt=""></p>
<p><strong><em>理解服务、引擎、host（主机）、Web应用[Context]概念</em></strong></p>
<ul>
<li>查看Tomcat中的server.xml文件，最外面节点为Server，Service下一个节点服务<code>&lt;Service name = &quot;Catalina&quot;&gt;</code>，所以我们有时把Tomcat服务叫做Catalina服务。</li>
<li>服务下有引擎（engine）<code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code>，它可以管理多个主机host。</li>
<li>主机下有多个Web应用[Context]</li>
<li>与引擎并列的有连接器（connector），有支持不同类型协议（http、https等）的连接器。不同协议使用不同的连接器    </li>
</ul>
<h2 id="配置默认主机"><a href="#配置默认主机" class="headerlink" title="配置默认主机"></a>配置默认主机</h2><p>　　当我们在浏览器中输入<a href="http://127.0.0.1:8080/web应用，引擎是如何知道用户要访问那个`主机`下的web应用？答：配置一个默认主机" target="_blank" rel="external">http://127.0.0.1:8080/web应用，引擎是如何知道用户要访问那个`主机`下的web应用？答：配置一个默认主机</a></p>
<pre><code>在tomcat/conf/server.xml 文件
&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;主机名&quot;&gt;

默认是localhost，即在webapps目录下，查找web应用
&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;
            xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;
</code></pre><h2 id="配置域名-host"><a href="#配置域名-host" class="headerlink" title="配置域名[host]"></a>配置域名[host]</h2><p><em>步骤：</em></p>
<pre><code>(1) 在C:\WINDOWS\system32\drivers\etc 下的host文件 添加127.0.0.1 www.sina.com.cn[浏览器向Tomcat发送请求，但Tomcat认为自己不是www.sina.com，可以拒绝，所以需添加主机名]
(2) 在tomcat 的server.xml文件添加主机名 
&lt;Host name=&quot;www.sina.com&quot; appBase=&quot;d:\web3”&gt;
    &lt;Context path=&quot;/&quot; docBase=&quot;d:\web3&quot; /&gt;
&lt;/Host&gt;
(3) 在d:\web3 加入了一个 /WEB-INF/web.xml 把 hello2.html设为首页面
如果连端口都不希望带，则可以吧tomcat的启动端口设为80即可.
(4) 重启生效
</code></pre><h2 id="CATALINA-BASE与CATALINA-HOME的区别"><a href="#CATALINA-BASE与CATALINA-HOME的区别" class="headerlink" title="CATALINA_BASE与CATALINA_HOME的区别"></a>CATALINA_BASE与CATALINA_HOME的区别</h2><ul>
<li>CATALINA_HOME是Tomcat的<strong><em>安装目录</em></strong>，CATALINA_BASE是Tomcat的<strong><em>工作目录</em></strong></li>
<li>如果我们想要运行Tomcat的多个实例，但是不想安装多个Tomcat软件副本。那么我们可以配置多个工作目录，每个运行实例独占一个工作目录，但是共享同一个安装目录</li>
<li>Tomcat每个运行实例需要使用自己的conf、logs、temp、webapps、work和shared目录，因此CATALINA_BASE就指向这些目录。 而其他目录主要包括了Tomcat的二进制文件和脚本，CATALINA_HOME就指向这些目录</li>
</ul>
<h2 id="Tomcat管理虚拟目录-context"><a href="#Tomcat管理虚拟目录-context" class="headerlink" title="Tomcat管理虚拟目录[context]"></a>Tomcat管理虚拟目录[context]</h2><p><em>需求</em></p>
<p>当我们把 web 应用放到 webapps目录，tomcat会自动管理，如果我们希望tomcat可以管理其它目录下的web应用?　　-&gt; 虚拟目录配置</p>
<p>假设我在d盘有一个web应用文件夹web2</p>
<p><em>步骤</em></p>
<pre><code>1、找到server.xml文件
2、编辑host节点，在Host节点中添加Context
    在server.xml中添加：&lt;Context path=&quot;/myweb2&quot; docBase=&quot;d:\web2&quot;/&gt;
    myweb2：是访问时输入的web名,实际取出的是web2中的资源（★★★★url与文件夹有映射关系）
    &quot;d:\web2&quot;：web应用文件夹在计算机中绝对路径
实际访问时输入的地址：http://localhost:8088/myweb2/hello2.html
</code></pre><h2 id="定义上下文"><a href="#定义上下文" class="headerlink" title="定义上下文"></a>定义上下文</h2><h3 id="显式定义"><a href="#显式定义" class="headerlink" title="显式定义"></a>显式定义</h3><p>1、在Tomcat的conf/Catalina/localhost目录下创建一个XML文件。例如把一个commerce.xml文件放在conf/Catalina/localhost目录下，那么应用程序的上下文路径就是commerce，下面给出一个范例：</p>
<pre><code>&lt;Context docBase=&quot;C://apps/commerce&quot; reloadable=&quot;true&quot;/&gt;
</code></pre><p>docBase是必要的属性，用来定义应用程序的位置；reloadable属性是可选的，如果值为true，一旦应用程序中Java类文件或者其他资源有增加、减少或者更新，Tomcat都会侦测到，就会重新加载应用程序</p>
<p>2、在Tomcat的conf/server.xml文件中添加一个Context元素[同Tomcat管理虚拟目录]</p>
<pre><code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;
            xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;

    &lt;Context path = &quot;/commerce&quot; docBase=&quot;C:/apps/commerce&quot; reloadable=&quot;true&quot; /&gt; 

&lt;/Host&gt;
</code></pre><h3 id="隐式定义"><a href="#隐式定义" class="headerlink" title="隐式定义"></a>隐式定义</h3><p>通过将一个war文件或者整个应用程序复制到Tomcat的webapps目录下，就可以隐式地部署应用程序</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/06/[设计模式]设计模式的艺术之道笔记/" itemprop="url">设计模式的艺术之道笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-06T00:00:00+08:00">
                2016-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。</p>
<p>在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的newInstance()方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例</p>
<h2 id="XMLUtil"><a href="#XMLUtil" class="headerlink" title="XMLUtil"></a>XMLUtil</h2><pre><code>//工具类XMLUtil.java  
import javax.xml.parsers.*;  
import org.w3c.dom.*;  
import org.xml.sax.SAXException;  
import java.io.*;  

public class XMLUtil {  
//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象  
    public static Object getBean() {  
        try {  
            //创建DOM文档对象  
            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();  
            DocumentBuilder builder = dFactory.newDocumentBuilder();  
            Document doc;                             
            doc = builder.parse(new File(&quot;config.xml&quot;));   

            //获取包含类名的文本节点  
            NodeList nl = doc.getElementsByTagName(&quot;className&quot;);  
            Node classNode=nl.item(0).getFirstChild();  
            String cName=classNode.getNodeValue();  

            //通过类名生成实例对象并将其返回  
            Class c=Class.forName(cName);  
            Object obj=c.newInstance();  
            return obj;  
        }     
        catch(Exception e) {  
            e.printStackTrace();  
            return null;  
         }  
    }  
} 
</code></pre><p>文件</p>
<pre><code>&lt;!— config.xml --&gt;  
&lt;?xml version=&quot;1.0&quot;?&gt;  
&lt;config&gt;  
    &lt;className&gt;FileLoggerFactory&lt;/className&gt;  
&lt;/config&gt;  
</code></pre><h3 id="单例模式：确保一个类只有一个实例"><a href="#单例模式：确保一个类只有一个实例" class="headerlink" title="单例模式：确保一个类只有一个实例"></a>单例模式：确保一个类只有一个实例</h3><p>1、构造方法私有，外部不能通过new创建对象<br>2、静态变量保存唯一实例<br>3、静态的getInstance方法，是外部能够访问</p>
<p>饿汉模式:在类加载的时候已经创建了单例对象</p>
<pre><code>//staic final静态常量
private static final Singleton instance = new Singleton();
private Singleton(){}
public static Singleton getInstance(){return instance;}
</code></pre><p>懒汉模式：第一次调用的时候创建对象实例</p>
<pre><code>private static Singleton instatnce = null;
private Singleton(){}
//注意同步控制关键字 Synchronized
synchronized public Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre><p>方法二：synchronized同步控制代码块，双重检查锁定（单次判断实例不为空，如果一个线程正在创建对象但还未创建完成，另一个线程进入实例不为空的判断，最终产生两个实例，未被单一对象的原则）</p>
<pre><code>//使用volatile保证可见性
private volatile static Singleton instatnce = null;
private Singleton(){}
public static Singleton getInstance(){
    //第一重判断
    if(instance == null){
        synchronized(Singleton.class){
            //第二重判断
            if(instance == null){
                    instance = new Singleton();
            }
        }
    }
    return instance;
}
</code></pre><p>为什么需要使用volatile？不是同步快结束完之后，会将instance对象写入内存？</p>
<p>答：<strong>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</strong></p>
<ul>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ul>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<font color="red"><strong>解析</strong>：</font>

<pre><code>线程1创建调用getInstance（）方法执行到instance=new Singleton()，但是这条语句不是原子性的，他分为三个步骤：1、分配内存 2、初始化 3、instance对象指向内存空间，执行完这步后instance为非空了。

但是jvm存在指令重排序的优化，如果指令按照1，3，2的执行方式，但是线程1在执行3之后，但未执行2之前，此时instance已经不为null了，这时候线程2调用getInstance（）方法（注意这时线程2可以调拥这个方法，因为只有进入一重检查锁之后才是临界区。）执行第一重判断if(instance == null){，此时instance不为null，直接调用return instance语句返回对象，但对象并没有真正得实例化完毕，调用就会出现错误
</code></pre><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<p>有些人认为使用 volatile 的原因是<strong>可见性</strong>，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：<strong>禁止指令重排序优化</strong>。也就是说，在 volatile 变量的<strong>赋值操作后面会有一个内存屏障</strong>（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，<strong>读操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</strong>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>方法三（最优）：静态内部类中保持对象的实例，在第一次调用的时候创建单例对象</p>
<pre><code>private static class Hold{
    private static final Singleton instance = new Singleton();
}
private Singleton(){}

public static Singleton getInstance(){
    return Hold.inistance;
}
</code></pre><p>饿汉式和懒汉式对比：饿汉式在类加载的时候创建，不管用不用，都占据内存；懒汉式在第一次使用的时候创建，必须加锁，多线程时性能受影响</p>
<h2 id="第4章：集中式工厂的实现——简单工厂模式"><a href="#第4章：集中式工厂的实现——简单工厂模式" class="headerlink" title="第4章：集中式工厂的实现——简单工厂模式"></a>第4章：集中式工厂的实现——简单工厂模式</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>1、定义抽象产品类，将产品 <strong>公共的代码</strong> 移至抽象产品类，并在抽象产品类中声明一些 <strong>抽象方法</strong>，供不同的具体产品类来实现<br>2、具体产品类继承抽象产品类，实现抽象类中抽象方法<br>3、工厂类提供一个创建产品的工厂方法，根据传入参数不同创建不同具体产品的对象</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://i.imgur.com/EGuKZbM.png" alt=""></p>
<p>抽象产品类</p>
<pre><code>abstract class Product {  
    //所有产品类的公共业务方法  
    public void methodSame() {  
        //公共方法的实现  
    }  

    //声明抽象业务方法  
    public abstract void methodDiff();  
}  
</code></pre><p>具体产品类</p>
<pre><code>class ConcreteProduct extends Product {  
    //实现业务方法  
    public void methodDiff() {  
        //业务方法的实现  
    }  
} 
</code></pre><p>工厂类</p>
<pre><code>class Factory {  
    //静态工厂方法  
    public static Product getProduct(String arg) {  
        Product product = null;  
        if (arg.equalsIgnoreCase(&quot;A&quot;)) {  
            product = new ConcreteProductA();  
            //初始化设置product  
        }  
        else if (arg.equalsIgnoreCase(&quot;B&quot;)) {  
            product = new ConcreteProductB();  
            //初始化设置product  
        }  
        return product;  
    }  
}  
</code></pre><h3 id="简单工厂模式的简化"><a href="#简单工厂模式的简化" class="headerlink" title="简单工厂模式的简化"></a>简单工厂模式的简化</h3><p><img src="http://i.imgur.com/Mw6iOgv.png" alt=""></p>
<p>将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p>
<h3 id="创建对象与使用对象"><a href="#创建对象与使用对象" class="headerlink" title="创建对象与使用对象"></a>创建对象与使用对象</h3><p>与一个对象相关的职责通常有3类：对象本身所具有的职责、创建对象的职责、使用对象的职责</p>
<p>在Java语言中，通常有以下几种创建对象的方式：</p>
<p>1、使用new关键字直接创建对象<br>2、通过反射机制创建对象<br>3、通过clone方法创建对象<br>4、通过工厂类创建对象</p>
<h2 id="第5章：多态工厂的实现——工厂方法模式"><a href="#第5章：多态工厂的实现——工厂方法模式" class="headerlink" title="第5章：多态工厂的实现——工厂方法模式"></a>第5章：多态工厂的实现——工厂方法模式</h2><p>简单工厂虽然简单，但存在一个很严重的问题，当系统中需要引入新产品时，由于静态工厂方法 <strong>通过传入参数的不同来创建不同的产品</strong>，这必定要修改工厂类的源代码，<strong>违背开闭原则</strong></p>
<p>在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂</p>
<h3 id="工厂方法模式结构图"><a href="#工厂方法模式结构图" class="headerlink" title="工厂方法模式结构图"></a>工厂方法模式结构图</h3><p><img src="http://i.imgur.com/eJUCJtW.png" alt=""></p>
<ul>
<li>具体产品实现抽象产品接口，具体产品和具体工厂之间一一对应</li>
<li>与简单工厂模式相比，工厂方式模式组重要的区别是引入了抽象工厂角色，在抽象工厂中声明工厂方法，由具体工厂类实现</li>
<li>客户端针对抽象工厂编程，在运行时再指定具体工厂类，<strong>不同的具体工厂可以创建不同的具体产品</strong></li>
<li>具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以 <strong>负责产品对象的初始化工作以及一些资源和环境配置工作</strong>，例如连接数据库、创建文件等。</li>
</ul>
<h3 id="使用工厂方法模式设计的日志记录器"><a href="#使用工厂方法模式设计的日志记录器" class="headerlink" title="使用工厂方法模式设计的日志记录器"></a>使用工厂方法模式设计的日志记录器</h3><p><img src="http://i.imgur.com/22oEW71.jpg" alt=""></p>
<p>抽象产品：</p>
<pre><code>//日志记录器接口：抽象产品
interface Logger {
    public void writeLog();
}
</code></pre><p>具体产品：</p>
<pre><code>//数据库日志记录器：具体产品
class DatabaseLogger implements Logger {
    public void writeLog() {
        System.out.println(&quot;数据库日志记录。&quot;);
    }
}

//文件日志记录器：具体产品
class FileLogger implements Logger {
    public void writeLog() {
        System.out.println(&quot;文件日志记录。&quot;);
    }
}
</code></pre><p>抽象工厂：</p>
<pre><code>//日志记录器工厂接口：抽象工厂
interface LoggerFactory {
    public Logger createLogger();
}
</code></pre><p>具体工厂：</p>
<pre><code>//数据库日志记录器工厂类：具体工厂
class DatabaseLoggerFactory implements LoggerFactory {
    public Logger createLogger() {
            //连接数据库，代码省略
            //创建数据库日志记录器对象
            Logger logger = new DatabaseLogger(); 
            //初始化数据库日志记录器，代码省略
            return logger;
    }    
}

//文件日志记录器工厂类：具体工厂
class FileLoggerFactory implements LoggerFactory {
    public Logger createLogger() {
            //创建文件日志记录器对象
            Logger logger = new FileLogger(); 
            //创建文件，代码省略
            return logger;
    }    
}
</code></pre><p>客户端测试:</p>
<pre><code>class Client {  
    public static void main(String args[]) {  
        LoggerFactory factory;  
        Logger logger;  
        factory = new FileLoggerFactory(); //可引入配置文件实现  
        logger = factory.createLogger();  
        logger.writeLog();  
    }  
}  
</code></pre><h2 id="第6章：产品族的创建——抽象工厂模式"><a href="#第6章：产品族的创建——抽象工厂模式" class="headerlink" title="第6章：产品族的创建——抽象工厂模式"></a>第6章：产品族的创建——抽象工厂模式</h2><p>工厂方法模式中每个工厂只生产一类产品，<strong>可能会导致系统中存在大量的工厂类</strong>，势必会增加系统的开销，此时可以考虑将<strong>一些相关的产品组成一个”产品族”</strong>，由同一个工厂统一生产（抽象工厂中声明多个工厂方法，用于创建不同类型的产品，这些产品构成了一个产品族）</p>
<h3 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h3><p>(1) 产品等级结构：<strong>产品等级结构即产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则 <strong>抽象电视机与具体品牌的电视机之间构成了一个产品等级结构</strong>，抽象电视机是父类，而具体品牌的电视机是其子类。</p>
<p>(2) 产品族：在抽象工厂模式中，产品族是指由<strong>同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如 <strong>海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机</strong> 位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p>
<p><img src="http://i.imgur.com/CbRwljs.jpg" alt=""></p>
<p>不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构</p>
<h3 id="抽象工厂模式结构图"><a href="#抽象工厂模式结构图" class="headerlink" title="抽象工厂模式结构图"></a>抽象工厂模式结构图</h3><p><img src="http://i.imgur.com/03wHvRx.jpg" alt=""></p>
<p>在抽象工厂模式中，每一个具体的工厂都提供了 <strong>多个工厂方法</strong> 用于产生多种不同类型的产品，<strong>这些产品构成了一个产品族</strong></p>
<p>抽象工厂的典型代码如下：</p>
<pre><code>abstract class AbstractFactory {  
    public abstract AbstractProductA createProductA(); //工厂方法一  
    public abstract AbstractProductB createProductB(); //工厂方法二  
    ……  
}
</code></pre><p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂创建的产品对象构成了一个产品族：</p>
<pre><code>class ConcreteFactory1 extends AbstractFactory {  
    //工厂方法一  
    public AbstractProductA createProductA() {  
        return new ConcreteProductA1();  
    }  

    //工厂方法二  
    public AbstractProductB createProductB() {  
        return new ConcreteProductB1();  
    }  

    ……  
}  
</code></pre><h3 id="完整解决方案"><a href="#完整解决方案" class="headerlink" title="完整解决方案"></a>完整解决方案</h3><p>使用抽象工厂模式来重构界面皮肤库的设计，<em>要求同一风格的具体界面组件要一起显示</em>，其基本结构如图所示：</p>
<p><img src="http://i.imgur.com/Z9Nc3VN.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p>
<ul>
<li>能够保证客户端始终使用只使用同一个产品族中的产品</li>
<li><strong>增加新的产品族很方便</strong>，无需修改已有系统</li>
</ul>
<p>缺点：</p>
<p><strong>增加新的等级结构麻烦</strong>，需要对原有系统进行较大的修改，甚至需要修改抽象层的代码</p>
<p>使用场景：</p>
<p><strong>属于同一产品族的产品要在一起使用，这一约束必须在系统的设计中体现出来</strong>，例如：</p>
<p>1、同一操作系统下的按钮和文本，按钮和文本没有直接关系，但他们都属于某一操作系统，此时具有一个 <strong>约束条件</strong> 就是：同一个操作系统</p>
<h2 id="第8章：复杂对象的组装与创建——建造者模式"><a href="#第8章：复杂对象的组装与创建——建造者模式" class="headerlink" title="第8章：复杂对象的组装与创建——建造者模式"></a>第8章：复杂对象的组装与创建——建造者模式</h2><p>建造者模式是为了解决这类问题：<strong>如何一步一步地创建一个包含多个组个组成部分的复杂对象</strong></p>
<ul>
<li>建造者模式将包含多个组成部分的复杂对象的创建过程分离</li>
<li><strong>不同具体的建造者定义了不同的创建过程</strong></li>
<li>建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性</li>
</ul>
<h3 id="有Director的建造者模式"><a href="#有Director的建造者模式" class="headerlink" title="有Director的建造者模式"></a>有Director的建造者模式</h3><p>Director类有两个作用：</p>
<ul>
<li>隔离了客户与创建过程，客户只要与Director类进行交互</li>
<li><strong>控制产品的创建过程</strong>，传入不同具体的建造者，输出产品</li>
</ul>
<p>Builder类的作用：创建对象的各个组件</p>
<p><img src="http://i.imgur.com/mNnbWcu.png" alt=""></p>
<p>Actor：定义输出的对象类型</p>
<pre><code>public class Actor {
    private String type;
    private String sex;

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return &quot;Actor{&quot; +
                &quot;sex=&apos;&quot; + sex + &apos;\&apos;&apos; +
                &quot;, type=&apos;&quot; + type + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>AbstractActorBuilder：抽象的对象创建方法，对象的组建过程分为两步：buildtType、buildSex，然后调用getResult方法输出，组建方法需要由子类改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }
}
</code></pre><p>HeroActorBuilder、AngelActorBuilder：定义了不同的组建过程</p>
<pre><code>public class HeroActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;英雄&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;男&quot;);
    }
}

public class AngelActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;Angle&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;女&quot;);
    }
}
</code></pre><p>Director：导演类封装了复杂对象的组建过程，客户端只需调用contruct方法，并传入对应的组建类，就可以得到所需要创建的类</p>
<pre><code>public class Director {
    public Actor contruct(AbstractActorBuilder builder){
        builder.buildtType();
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h3 id="省略Director"><a href="#省略Director" class="headerlink" title="省略Director"></a>省略Director</h3><p>AbstractActorBuilder需要承担创建复杂对象各个部分的职责，还要控制整个对象组建的顺序，但对系统的灵活性和可扩展性并没有任何影响</p>
<p>建议将construct方法单独封装在Director中，这样做更符合单一职责原则</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor construct() {
        buildtType();
        buildSex();
        return actor;
    }
}
</code></pre><h3 id="钩子方法的引入"><a href="#钩子方法的引入" class="headerlink" title="钩子方法的引入"></a>钩子方法的引入</h3><p>通过Director类可以更加精细地<strong>控制产品的创建过程</strong>，比如说增加一类钩子方法来控制是否调用某个build方法</p>
<p>钩子方法的返回类型一般是boolena类型，方法名一般是isXXX（）</p>
<p>钩子方法定义在抽象建造类中</p>
<p>下面案例，定义了一个钩子方法hasType()，默认都是返回true；可以在子类中改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }

    public boolean hasType(){
        return true;
    }
}
</code></pre><p>在Director中调用钩子方法hasType，如果返回结果是true，则调用buildType方法，否则不调用</p>
<pre><code>public class Director {
    public Actor construct(AbstractActorBuilder builder){
        if(builder.hasType()){
            builder.buildtType();
        }
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h2 id="第9章：适配器模式"><a href="#第9章：适配器模式" class="headerlink" title="第9章：适配器模式"></a>第9章：适配器模式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有的笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何才能让20V的笔记本电脑能够在220V的电压下工作，答案是引入一个电源适配器</p>
<h3 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h3><ul>
<li>应用程序定义了一个接口，且已经有开发人员面向该接口进行编程，所以目标接口不能修改</li>
<li>代码库中有已经实现类似该接口的功能，但接口不一致（请求参数、方法名不同），为了开发效率决定重用代码库中的类</li>
<li>引入一个适配器类，通过适配器类来调用代码库中的接口</li>
</ul>
<h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><ul>
<li>应用程序调用适配器的方法时，适配器内部将调用适配者类的方法</li>
<li><strong>适配器模式可以将一个类的接口和另一个类的接口匹配起来</strong>，而无须修改原来适配者接口和抽象目标类的接口</li>
</ul>
<p><img src="http://i.imgur.com/nGDvXzt.png" alt=""></p>
<p>具体实现代码请见清单 1-4。<br>清单 1. 客户端使用的接口</p>
<pre><code>/*
 * 定义客户端使用的接口，与业务相关
 */
public interface Target {
     /*
     * 客户端请求处理的方法
     */
    public void request();
}
</code></pre><p>清单 2. 被适配的对象</p>
<pre><code>/*
 * 已经存在的接口，这个接口需要配置
 */
public class Adaptee {
     /*
     * 原本存在的方法
     */
    public void specificRequest(){
        //业务代码
    }
}
</code></pre><p>清单 3. 适配器实现</p>
<pre><code>/*
 * 适配器类
 */
public class Adapter implements Target{
     /*
     * 持有需要被适配的接口对象
     */
    private Adaptee adaptee;
        /*
         * 构造方法，传入需要被适配的对象
         * @param adaptee 需要被适配的对象
         */
    public Adapter(Adaptee adaptee){
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // TODO Auto-generated method stub
        adaptee.specificRequest();
    }

}
</code></pre><p>清单 4. 客户端代码</p>
<pre><code>/*
 * 使用适配器的客户端
 */
public class Client {
     public static void main(String[] args){
         //创建需要被适配的对象
         Adaptee adaptee = new Adaptee();
         //创建客户端需要调用的接口对象
         Target target = new Adapter(adaptee);
         //请求处理
         target.request();
     }
}
</code></pre><h3 id="电脑适配器的例子"><a href="#电脑适配器的例子" class="headerlink" title="电脑适配器的例子"></a>电脑适配器的例子</h3><p>电</p>
<pre><code>public interface Electricity {
    public void support();
}

public class ElectricityImpl implements Electricity {

    private Integer value;

    public ElectricityImpl(Integer value){
        this.value = value;
    }

    public void support(){
        System.out.println(&quot;提供&quot;+ value +&quot;电&quot;);
    }
}
</code></pre><p>适配器</p>
<pre><code>public interface Adapter {
    public void transform();
}

public class Adapter220To12V implements Adapter{

    private Electricity electricity;

    public Adapter220To12V(Electricity electricity){
        this.electricity = electricity;
    }

    public void transform(){
        electricity.support();
        System.out.println(&quot;220V电压转成12V&quot;);
    }
}

public class Adapter330To12V implements Adapter{

    Electricity electricity;

    public Adapter330To12V(Electricity electricity){
        this.electricity = electricity;
    }

    @Override
    public void transform() {
        electricity.support();
        System.out.println(&quot;330V转成12V&quot;);
    }
}
</code></pre><p>电脑</p>
<pre><code>public interface Computer {
    public void work();
}

public class ComputerImpl implements Computer{

    private Adapter adapter;

    public ComputerImpl(Adapter adapter){
        this.adapter = adapter;
    }

    public void work(){
        adapter.transform();
        System.out.println(&quot;电脑运行需要12v&quot;);
    }
}
</code></pre><p>测试</p>
<pre><code>public class App {
    public static void main(String[] args){

        //电
        Electricity electricity = new ElectricityImpl(220);

        //适配器
        Adapter adapter = new Adapter220To12V(electricity);

        //电脑
        ComputerImpl computer = new ComputerImpl(adapter);
        computer.work();

        System.out.println(&quot;---------------------------&quot;);

        //电
        electricity = new ElectricityImpl(330);

        //适配器
        adapter = new Adapter330To12V(electricity);

        //电脑
        computer = new ComputerImpl(adapter);
        computer.work();

    }
}
</code></pre><p>结果</p>
<pre><code>提供220电
220V电压转成12V
电脑运行需要12v
---------------------------
提供330电
330V转成12V
电脑运行需要12v
</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>面向接口编程，程序有扩展性和灵活性</p>
<h3 id="缺省适配器模式"><a href="#缺省适配器模式" class="headerlink" title="缺省适配器模式"></a>缺省适配器模式</h3><p>当不需要实现一个接口所提供的所有方法时，<strong>可先设计一个抽象类实现该接口</strong>，并未接口中每个方法提供一个默认实现（空方法），<strong>那么该抽象类的子类可以选择性覆盖父类的某些方法来实现需求</strong>，它适用于不想使用一个接口中的所有方法的情况，又称单接口适配器模式</p>
<h2 id="第12章：扩展系统功能——装饰模式"><a href="#第12章：扩展系统功能——装饰模式" class="headerlink" title="第12章：扩展系统功能——装饰模式"></a>第12章：扩展系统功能——装饰模式</h2><p><a href="http://blog.csdn.net/lovelion/article/details/7425873" target="_blank" rel="external">http://blog.csdn.net/lovelion/article/details/7425873</a></p>
<p><strong>根据合成复用的原则，在实现功能复用的时候，要多用关联，少用继承</strong></p>
<ul>
<li>装饰模式可以在不改变一个对象本身功能的基础上给对象<strong>增加额外的新行为</strong></li>
<li>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系</li>
</ul>
<h3 id="装饰模式结构图"><a href="#装饰模式结构图" class="headerlink" title="装饰模式结构图"></a>装饰模式结构图</h3><p><img src="http://i.imgur.com/whQUxwW.png" alt=""></p>
<p>1、可以将一个具体构件注入装饰器类，再通过具体装饰类进行装饰<br>2、可以将一个已经装饰过Decorator子类的对象再注入其中进行多次装饰，从而对原有功能进行多次扩展</p>
<p>客户端调用：</p>
<pre><code>Component c = new ConcreteComponent();
Component component = new ConcreteDecoratorA(c);
component.operation();
</code></pre><h3 id="只有一个具体构建类的装饰模式"><a href="#只有一个具体构建类的装饰模式" class="headerlink" title="只有一个具体构建类的装饰模式"></a>只有一个具体构建类的装饰模式</h3><p><img src="http://i.imgur.com/aqAKcXE.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以对一个对象进行多次装饰，采用继承的方式在单继承语言中无法复用多个父类的功能</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>Sunny软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高 级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加 密。试使用装饰模式设计该多重加密系统。</p>
<p>类图：</p>
<p><img src="http://i.imgur.com/lor8whj.png" alt=""></p>
<p>抽象构件类</p>
<pre><code>/**
 * 抽象构件类&lt;br&gt;
 * 加密字符串抽象类
 *
 */
public abstract class StrEncrypt {

    /**
     * 加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public abstract String encryptStr(String str);

}
</code></pre><p>具体构件类</p>
<pre><code>/**
 * 具体构件类&lt;br&gt;
 * 加密字符串实现类
 *
 */
public class StrEncryptOperate extends StrEncrypt {

    @Override
    public String encryptStr(String str) {
        String encrypt = &quot;**&quot; + str + &quot;**&quot;;
        return encrypt;
    }

}
</code></pre><p>抽象装饰类</p>
<pre><code>/**
 * 抽象装饰类&lt;br&gt;
 * 加密字符串抽象装饰类
 *
 */
public class StrEncryptDecorator extends StrEncrypt {

    private StrEncrypt strEncrypt;

    public StrEncryptDecorator(StrEncrypt strEncrypt){
        this.strEncrypt = strEncrypt;
    }

    @Override
    public String encryptStr(String str) {
        return strEncrypt.encryptStr(str);
    }

}
</code></pre><p>具体装饰类 - 逆向加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 逆向加密字符串实现类
 *
 */
public class ReverseEncryptDecorator extends StrEncryptDecorator {

    public ReverseEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.reverseStr(super.encryptStr(str));
    }

    /**
     * 逆向加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String reverseStr(String str){
        String encrypt = &quot;$$&quot; + str + &quot;$$&quot;;
        return encrypt;
    }

}
</code></pre><p>具体装饰类 - 高级加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 高级加密字符串实现类
 *
 */
public class AdvanceEncryptDecorator extends StrEncryptDecorator {

    public AdvanceEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.advanceStr(super.encryptStr(str));
    }

    /**
     * 高级加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String advanceStr(String str){
        String encrypt = &quot;&amp;&amp;&quot; + str + &quot;&amp;&amp;&quot;;
        return encrypt;
    }

}
</code></pre><p>测试</p>
<pre><code>public class Test {

    public static void main(String[] args) {

        String str = &quot;aa&quot;;

        //加密字符串
        StrEncrypt strEncrypt = new StrEncryptOperate();

        //逆向加密
        StrEncrypt reverse = new ReverseEncryptDecorator(strEncrypt);
        //高级加密
        StrEncrypt advance = new AdvanceEncryptDecorator(reverse);

        System.out.println(advance.encryptStr(str));

    }

}
</code></pre><p>执行结果：&amp;&amp;$$<strong>aa</strong>$$&amp;&amp;</p>
<h2 id="第13章：提供统一入口——外观模式"><a href="#第13章：提供统一入口——外观模式" class="headerlink" title="第13章：提供统一入口——外观模式"></a>第13章：提供统一入口——外观模式</h2><p><strong>有时候客户端需要与多个子系统进行复杂的交互，而增加一个外观角色后，客户端只需要直接与外观角色交互</strong>，客户端与子系统之间原有的复杂关系由外观角色来实现，从而降低了系统的耦合度</p>
<p><img src="http://i.imgur.com/c6WHHLA.png" alt=""></p>
<p>总结：</p>
<ul>
<li>外观模式通过引入一个外观角色来简化客户端与子系统之间的交互，<strong>为复杂的子系统调用提供一个统一的入口</strong>，使子系统与客户端的耦合度降低，且客户端调用非常方便</li>
<li><strong>外观模式并不给系统增加任何新功能，它的作用就是简化调用接口</strong></li>
</ul>
<h2 id="第15章：代理模式"><a href="#第15章：代理模式" class="headerlink" title="第15章：代理模式"></a>第15章：代理模式</h2><p>客户端使用对象时，返回这个对象的代理对象，这个代理对象控制对原对象的引用，对于客户端的使用是透明的</p>
<p><img src="http://i.imgur.com/Czffk8B.png" alt=""></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><img src="http://i.imgur.com/F5VGhOh.png" alt=""></p>
<p>1、定义接口Subject</p>
<pre><code>public interface Subject {
    public void request();
}
</code></pre><p>2、实现接口</p>
<pre><code>public class Proxy implements Subject{

    public void request() {

    }

}

public class RealSubject implements Subject{
    public void request() {
        System.out.println(&quot;处理请求&quot;);
    }
}
</code></pre><p>3、代理类中存放目标类的实例，并且添加新的方法、调用目标类的方法</p>
<pre><code>public class Proxy implements Subject{
    private RealSubject realSubject;
    public Proxy(RealSubject realSubject){
        this.realSubject = realSubject;
    }

    public void request() {
        preRequest();
        realSubject.request();
        postRequest();
    }

    private void postRequest() {
        System.out.println(&quot;记录时间&quot;);
    }

    private void preRequest() {
        System.out.println(&quot;日志记录&quot;);
    }
}
</code></pre><p>4、测试</p>
<pre><code>public class Run {
    public static void main(String[] args){
        RealSubject realSubject = new RealSubject();
        Subject proxy = new Proxy(realSubject);
        proxy.request();
    }
}
</code></pre><p>结果：</p>
<pre><code>日志记录
处理请求
记录时间
</code></pre><p>在不增加目标类的情况下，扩展了方法</p>
<h3 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h3><ul>
<li>通常情况下，代理类所实现的接口和所代理的方法都被固定，这种代理称之为 <strong>静态代理</strong></li>
<li>静态代理若需要对不同目标对象进行代理，或者对同一目标类代理不同的方法，都需要增加新的代理类，这就造成类的个数急剧增加</li>
<li>动态代理可以让一个类 <strong>代理多个不同的目标类</strong>，而且可以 <strong>代理不同的方法</strong></li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、调用处理函数程序类，传入目标对象、调用目标函数的方法、扩展方法</p>
<pre><code>class SubjectHandler implements InvocationHandler{
    //目标类的引用，通过构造方法传入对象
    private Object target;

    public SubjectHandler(Object target){
        this.target = target;
    }

    /*
    * 调用代理对象的方法时，调用此方法
    * Object proxy是代理的对象, Method method是真实对象中调用方法的Method类, Object[] args是真实对象中调用方法的参数

    */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        preHandler();
        Object o = method.invoke(target, args);
        postHandler();
        return o;
    }

    private void postHandler() {
        System.out.println(&quot;后置方法&quot;);
    }

    private void preHandler() {
        System.out.println(&quot;前置方法&quot;);
    }
}
</code></pre><p>2、创建动态代理</p>
<pre><code>public class Client {
    public static void main(String[] args){

        //目标类
        RealSubject realSubject = new RealSubject();
        //调用处理处理程序
        InvocationHandler invocationHandler = new SubjectHandler(realSubject);
        /** 创建代理类的实例
         *  第一个参数表示代理类的类加载器
         *  第二个参数表示代理类所实现的接口列表
         *  第三个参数为调用处理程序类，可以是new Class[]{Subject.class}，
         *      也可以 RealSubject.class.getInterfaces()
         */
        Subject proxy = (Subject) Proxy.newProxyInstance(Client.class.getClassLoader(), new Class[]{Subject.class},invocationHandler);
        proxy.request();
    }
}
</code></pre><p>原理：</p>
<p><a href="http://www.cnblogs.com/flyoung2008/p/3251148.html" target="_blank" rel="external">http://www.cnblogs.com/flyoung2008/p/3251148.html</a></p>
<p>Proxy静态方法newProxyInstance-&gt;类Proxy的getProxyClass方法<strong>调用ProxyGenerator的 generateProxyClass方法产生ProxySubject.class的二进制数据，需要传入参数类名和实现接口</strong>，以下为测试ProxyGenerator的generateProxyClass方法：</p>
<pre><code>byte[] proxyClassFile =    ProxyGenerator.generateProxyClass(&quot;xxx&quot;, new Class[]{Subject.class});
OutputStream o = new FileOutputStream(&quot;xxx.class&quot;);
o.write(proxyClassFile,0,proxyClassFile.length);
o.close();
</code></pre><p>产生字节码，经反编译后得到的结果：<br>生成的类继承Proxy，而且实现传入的接口方法request，每次调用接口方法，将会调用InvocationHandler的invoke方法</p>
<pre>
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

import Proxy.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class xxx <font color="red">extends Proxy implements Subject</font> {
    private static Method m1;
    private static Method m3;
    private static Method m0;
    private static Method m2;

    public xxx(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    <font color="red">//接口实现的方法</font>
    public final void request() throws  {
        try {
            //调用h为InvocationHandler类型，为Proxy的成员变量，创建代理对象的时候作为参数传入
            <font color="red">super.h.invoke(this, m3, (Object[])null);</font>
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
            m3 = Class.forName("Proxy.Subject").getMethod("request", new Class[0]);
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</pre>

<p>总结：</p>
<ul>
<li>使用：1、创建目标对象 2、自定义类实现InvocationHandler接口，构造函数中传入目标对象，在实现的接口方法Invoke中对根据选择对方法进行代理 3、调用Proxy.newProxyInstance方法中传入是三个参数，分别是类加载器，代理的接口和自定义InvocationHandler实例，返回代理对象</li>
<li>原理：1、调用ProxyGenerator的generateProxyClass方法产生ProxySubject.class的二进制数据，需要传入参数类名和实现接口，生成的代理类在调用接口方法时，会调用传入的InvocationHandler的invoke方法 2、利用反射创建代理对象的实例，并且传入InvocationHandler参数，返回代理对象实例</li>
<li>设计：</li>
</ul>
<h4 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h4><p>1、动态代理需要 <strong>代理不同的目标对象</strong> 和 <strong>同一目标对象的不同方法</strong>，所以动态代理类中需要传入代理方法（<strong>接口</strong>）和<strong>代理对象</strong><br>2、在Object newProxyInstance(ClassLoader loader,     Class&lt;?&gt;[] interfaces,InvocationHandler h)方法中直接传入接口，和InvocationHandler的实例，其中实例中传入目标对象，和调用处理方法，根据要求对不同方法进行代理</p>
<h3 id="其他的代理类型"><a href="#其他的代理类型" class="headerlink" title="其他的代理类型"></a>其他的代理类型</h3><p>1、远程代理：位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机，也可以在另一台主机中。在Java语言中，可以通过RMI机制来实现远程代理</p>
<p>2、虚拟代理：如果需要创建一个资源消耗较大的资源，先创建一个消耗相对较小的对象来表示，真是对象只是在需要时才会被真正创建。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<h2 id="第22章：对象间的联动——观察者模式"><a href="#第22章：对象间的联动——观察者模式" class="headerlink" title="第22章：对象间的联动——观察者模式"></a>第22章：对象间的联动——观察者模式</h2><p>观察者模式定义对象之间的一种一对多依赖关系，使得 <strong>当一个对对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</strong></p>
<p>在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者</p>
<h3 id="观察者模式示意代码"><a href="#观察者模式示意代码" class="headerlink" title="观察者模式示意代码"></a>观察者模式示意代码</h3><p>定义一个抽象目标Subject</p>
<pre><code>import java.util.*;
abstract class Subject {
    //定义一个观察者集合用于存储所有观察者对象
    protected ArrayList observers&lt;Observer&gt; = new ArrayList();

    //注册方法，用于向观察者集合中增加一个观察者
    public void attach(Observer observer) {
        observers.add(observer);
    }

    //注销方法，用于在观察者集合中删除一个观察者
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    //声明抽象通知方法
    public abstract void notify();
}    
</code></pre><p>具体目标类ConcreteSubject（如果无须扩展目标类，则具体目标类可省略）</p>
<pre><code>class ConcreteSubject extends Subject {  
    //实现通知方法  
    public void notify() {  
        //遍历观察者集合，调用每一个观察者的响应方法  
        for(Object obs:observers) {  
            ((Observer)obs).update();  
        }  
    }     
}  
</code></pre><p>抽象观察者角色一般定义为一个接口，通常只声明一个update()方法</p>
<pre><code>interface Observer {  
    //声明响应方法  
    public void update();  
}  
</code></pre><p>具体观察者ConcreteObserver中实现了update()方法</p>
<pre><code>class ConcreteObserver implements Observer {  
    //实现响应方法  
    public void update() {  
        //具体响应代码  
    }  
} 
</code></pre><h3 id="多人联机对战游戏结构图"><a href="#多人联机对战游戏结构图" class="headerlink" title="多人联机对战游戏结构图"></a>多人联机对战游戏结构图</h3><p><img src="http://i.imgur.com/hfZUs1B.jpg" alt=""></p>
<p>抽象观察类  </p>
<pre><code>interface Observer {  
    public String getName();  
    public void setName(String name);  
    public void help(); //声明支援盟友方法  
    public void beAttacked(AllyControlCenter acc); //声明遭受攻击方法  
}  
</code></pre><p>战队成员类：具体观察者类  </p>
<pre><code>class Player implements Observer {  
    private String name;  

    public Player(String name) {  
        this.name = name;  
    }  

    public void setName(String name) {  
        this.name = name;  
    }  

    public String getName() {  
        return this.name;  
    }  

    //支援盟友方法的实现  
    public void help() {  
        System.out.println(&quot;坚持住，&quot; + this.name + &quot;来救你！&quot;);  
    }  

    //遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver()来通知盟友  
    public void beAttacked(AllyControlCenter acc) {  
        System.out.println(this.name + &quot;被攻击！&quot;);  
        acc.notifyObserver(name);         
    }  
}  
</code></pre><p>战队控制中心类：目标类  </p>
<pre><code>abstract class AllyControlCenter {  
    protected String allyName; //战队名称  
    protected ArrayList&lt;Observer&gt; players = new ArrayList&lt;Observer&gt;(); //定义一个集合用于存储战队成员  

    public void setAllyName(String allyName) {  
        this.allyName = allyName;  
    }  

    public String getAllyName() {  
        return this.allyName;  
    }  

    //注册方法  
    public void join(Observer obs) {  
        System.out.println(obs.getName() + &quot;加入&quot; + this.allyName + &quot;战队！&quot;);  
        players.add(obs);  
    }  

    //注销方法  
    public void quit(Observer obs) {  
        System.out.println(obs.getName() + &quot;退出&quot; + this.allyName + &quot;战队！&quot;);  
        players.remove(obs);  
    }  

    //声明抽象通知方法  
    public abstract void notifyObserver(String name);  
}  
</code></pre><p>具体战队控制中心类：具体目标类  </p>
<pre><code>class ConcreteAllyControlCenter extends AllyControlCenter {  
    public ConcreteAllyControlCenter(String allyName) {  
        System.out.println(allyName + &quot;战队组建成功！&quot;);  
        System.out.println(&quot;----------------------------&quot;);  
        this.allyName = allyName;  
    }  

    //实现通知方法  
    public void notifyObserver(String name) {  
        System.out.println(this.allyName + &quot;战队紧急通知，盟友&quot; + name + &quot;遭受敌人攻击！&quot;);  
        //遍历观察者集合，调用每一个盟友（自己除外）的支援方法  
        for(Object obs : players) {  
            if (!((Observer)obs).getName().equalsIgnoreCase(name)) {  
                ((Observer)obs).help();  
            }  
        }         
    }  
}  
</code></pre><p>编写如下客户端测试代码：</p>
<pre><code>class Client {  
    public static void main(String args[]) {  
        //定义观察目标对象  
        AllyControlCenter acc;  
        acc = new ConcreteAllyControlCenter(&quot;金庸群侠&quot;);  

        //定义四个观察者对象  
        Observer player1,player2,player3,player4;  

        player1 = new Player(&quot;杨过&quot;);  
        acc.join(player1);  

        player2 = new Player(&quot;令狐冲&quot;);  
        acc.join(player2);  

        player3 = new Player(&quot;张无忌&quot;);  
        acc.join(player3);  

        player4 = new Player(&quot;段誉&quot;);  
        acc.join(player4);  

        //某成员遭受攻击  
        Player1.beAttacked(acc);  
    }  
} 
</code></pre><h2 id="JDK对观察者模式的支持"><a href="#JDK对观察者模式的支持" class="headerlink" title="JDK对观察者模式的支持"></a>JDK对观察者模式的支持</h2><p><img src="http://i.imgur.com/D8P7zwo.jpg" alt=""></p>
<p>(1)Observer接口<br>在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：</p>
<pre><code>void  update(Observable o, Object arg);
</code></pre><p>当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。</p>
<p>(2)Observable类<br>java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象</p>
<p>实例：</p>
<p>观察者：</p>
<pre><code>public class Listener implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;update&quot;);
    }
}
</code></pre><p>观察目标：</p>
<pre><code>public class Source extends Observable {

    public void fire(){
        setChanged();
        notifyObservers();
    }
}
</code></pre><p>测试：</p>
<pre><code>public class APP {
    public static void main(String[] args){
        Observer listener = new Listener();
        Source source = new Source();
        source.addObserver(listener);

        source.fire();
    }
}
</code></pre><h2 id="ThreadLocal设计模式"><a href="#ThreadLocal设计模式" class="headerlink" title="ThreadLocal设计模式"></a>ThreadLocal设计模式</h2><p><a href="https://my.oschina.net/pingpangkuangmo/blog/376321" target="_blank" rel="external">https://my.oschina.net/pingpangkuangmo/blog/376321</a></p>
<p>ThreadLocal设计模式：<br>（1）ThreadLocal所操作的数据是<strong>线程间不共享的</strong>。它不是用来解决多个线程竞争同一资源的多线程问题<br>（2）ThreadLocal所操作的数据主要用于<strong>线程内共享数据</strong>，可以避免同一线程内函数间的传参数问题</p>
<p>ThreadLocal更像是一个操作线程数据的工具类，哪个线程调用它，它就操作哪个线程的数据。 </p>
<p>其中ThreadUtil就是用ThreadLocal来实现的，ThreadLocal完全可以这样理解，它就是操作线程数据的工具类，哪个线程调用它的get或set方法，它就会操作调用它的线程中的数据如下：</p>
<pre><code>public class ThreadUtil {

    private static ThreadLocal&lt;String&gt; nameLocal=new ThreadLocal&lt;String&gt;();

    public static String getName(){
        return nameLocal.get();
    }

    public static void setName(String name){
        nameLocal.set(name);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
