<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://qianmingxs.com/page/11/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/page/11/"/>





  <title>Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/11/01/[Java]Java 接口和抽象类区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/01/[Java]Java 接口和抽象类区别/" itemprop="url">Java 接口和抽象类区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-01T20:52:00+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://blog.csdn.net/xw13106209/article/details/6923556" target="_blank" rel="external">http://blog.csdn.net/xw13106209/article/details/6923556</a></p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>OOP面向对象的编程，如果要提高程序的复用率，增加程序的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，<strong>正确地使用接口、抽象类这些有用的抽象类型作为你结构层次上的顶层</strong>。</p>
<h2 id="Java接口和抽象类"><a href="#Java接口和抽象类" class="headerlink" title="Java接口和抽象类"></a>Java接口和抽象类</h2><p>1、<strong>[最大区别]</strong> Java接口和Java抽象类最大的一个区别，就在于Java抽象类既可以有没有具体实现的抽象方法，也可以提供某些方法的部分实现；而Java接口只能定义方法，不能有方法的实现 </p>
<p>2、<strong>[抽象类优势]</strong> Java的抽象类非常有用，如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而如果向Java接口中加入一个新方法，所有实现这个接口的类都无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点</p>
<p>3、<strong>[接口优势]</strong> 一个抽象类的实现只能由具体子类给出，但是由于Java的单继承特性，一个具体子类继承了抽象类，<strong>这个子类的类型就比较单一</strong>；在这一点，Java接口的优势就出来了，任何一个实现了Java接口的的类都可以具有这个接口的类型，而且一个类可以实现多个Java接口，<strong>类型就比较多</strong>；Java接口是定义混合类型的理想工具，混合类表示一个类不仅仅具有某个主类型的行为，而且具有其他次要行为</p>
<p>4、★★★<strong>[总结]</strong> 抽象类的优势是抽象类中既可以有具体的实现方法，也可以有没有具体实现的抽象方法，继承的子类都可以拥有抽象类实现的方法，缺点是由于Java的单继承性，实现抽象类的子类类型比较单一；一个类可以实现多个接口，因此一个类就可以拥有多个类型，缺点是接口中只能定义方法的类型，实现接口必须实现接口的全部方法</p>
<p>5、<strong>[缺省适配模式]</strong> 声明类型的工作仍然由Java接口承担，但是同时给出一个Java抽象类，且实现了这个Java接口；而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类；<strong>在层次结构中，Java接口在最上面，然后紧跟着抽象类</strong>，这下两个优点都能发挥到极致</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/17/[SSM]Shiro笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/17/[SSM]Shiro笔记/" itemprop="url">Shiro笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-17T23:00:00+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="术语（Terminology）"><a href="#术语（Terminology）" class="headerlink" title="术语（Terminology）"></a>术语（Terminology）</h2><p>Authentication（鉴权，身份验证）：校验Subject（主体）的身份是否合法<br>Authorization（授权）：根据主体的角色和权限来决定允许或拒绝访问请求<br>Cipher：执行加密或解密的算法<br>Principal：一个主体的标识属性，独一无二的标识，可以是昵称、用户ID、安全码……<br>Credential（证书）：验证主体身份的信息<br>Cryptography（密码学）：密码学保护信息不被不比希望让他看的人的看到<br>Hash：数据经过hash方法得到的结果不可逆<br>Permission：描述原始的功能，定义应用程序能够做的一些操作<br>Realm（领域）：可以访问应用程序的安全数据，例如用户、角色和权限的组件。可以当做安全的DAO，将应用程序数据翻译成Shiro能够理解的格式，这样Shiro可以提供简洁的API，不管有多少数据源或者应用程序<br><strong>Role：权限的集合，并取一个独一无二的名字</strong><br>Session：主体与软件交互过程中的有状态数据环境，当用户使用应用程序时可以在Session中增加/读取/删除数据，当用户退出应用程序，Session终止<br>Subject：应用程序用户，但他不一定但指一个人，它也可以代表调用你应用程序的外部进程，或者一个间断执行操作的守护系统账户，它可以抽象表示为操作应用程序的主体</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Shiro是一个强大易用的Java安全框架，提供鉴权、授权、加密、会话管理的综合解决方法。在实践中达到管理应用程序安全的作用，而减少与应用程序的耦合</p>
<p>Shiro可以在任何环境中运行，从最简单的命令行应用程序到企业级web程序和集群应用程序</p>
<h2 id="Shiro快速入门（j2se）"><a href="#Shiro快速入门（j2se）" class="headerlink" title="Shiro快速入门（j2se）"></a>Shiro快速入门（j2se）</h2><p>官方地址：<a href="http://shiro.apache.org/10-minute-tutorial.html" target="_blank" rel="external">http://shiro.apache.org/10-minute-tutorial.html</a></p>
<h3 id="Shiro-API"><a href="#Shiro-API" class="headerlink" title="Shiro API"></a>Shiro API</h3><pre><code>import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.*;
import org.apache.shiro.config.IniSecurityManagerFactory;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.session.Session;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.Factory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Quickstart {

    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);

    public static void main(String[] args) {

        /*
        * 创建Shiro SecurityManager，同时设置realms、users、roles、permissions，
        * 最简单的方式是创建一个.ini，通过它返回一个SecurityManager实例。ini文件见下一节
        */
        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);
        SecurityManager securityManager = factory.getInstance();

        // 设置 SecurityManager 为一个静态实例，可以被 JVM 访问到
        SecurityUtils.setSecurityManager(securityManager);

        // 设置Shiro环境完毕，看下它的操作★★★★★

        // 获得当前操作的用户，此时currentUser为空，用户还未登录
        Subject currentUser = SecurityUtils.getSubject();

        // 用Session存储数据（web或EJB容器不需要！！！）
        Session session = currentUser.getSession();
        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);
        String value = (String) session.getAttribute(&quot;someKey&quot;);
        if (value.equals(&quot;aValue&quot;)) {
            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);
        }

        // 用户登录，校验角色和权限
        if (!currentUser.isAuthenticated()) {
            //获得用户名和密码
            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);
            token.setRememberMe(true);
            try {
                currentUser.login(token);
            } catch (UnknownAccountException uae) {
                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());
            } catch (IncorrectCredentialsException ice) {
                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);
            } catch (LockedAccountException lae) {
                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +
                        &quot;Please contact your administrator to unlock it.&quot;);
            }
            // 捕捉更多的异常，可以是用户自定义
            catch (AuthenticationException ae) {
                //unexpected condition?  error?
            }
        }

        // 查看用户标识
        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);

        // 测试用户是否具备角色
        if (currentUser.hasRole(&quot;schwartz&quot;)) {
            log.info(&quot;May the Schwartz be with you!&quot;);
        } else {
            log.info(&quot;Hello, mere mortal.&quot;);
        }

        // 测试用户是否具备某个权限
        if (currentUser.isPermitted(&quot;lightsaber:weild&quot;)) {
            log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);
        } else {
            log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);
        }

        // 测试用户是否具备某个权限
        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) {
            log.info(&quot;You are permitted to &apos;drive&apos; the winnebago with license plate (id) &apos;eagle5&apos;.  &quot; +
                    &quot;Here are the keys - have fun!&quot;);
        } else {
            log.info(&quot;Sorry, you aren&apos;t allowed to drive the &apos;eagle5&apos; winnebago!&quot;);
        }

        // 注销用户
        currentUser.logout();

        System.exit(0);
    }
}
</code></pre><h3 id="shiro-ini"><a href="#shiro-ini" class="headerlink" title="shiro.ini"></a>shiro.ini</h3><pre>
# 用户和他们分配的角色
[users]
# 用户'root'的密码是'secret'，包含'admin'的角色
root = secret, admin
# 用户'guest'的密码是'guest'，包含'guest'的角色
guest = guest, guest
# 用户'presidentskroob'的密码是'12345'，包含'president'的角色
presidentskroob = 12345, president
# 用户'darkhelmet'的密码是'ludicrousspeed'，包含角色'darklord'和schwartz'
darkhelmet = ludicrousspeed, darklord, schwartz
# 用户'lonestarr'的密码是'vespa'，包含角色'goodguy'和'schwartz'
lonestarr = vespa, goodguy, schwartz

# 角色和他们分配的权限
[roles]
# 'admin'的角色拥有所有权限，用通配符'*'表示
admin = *
# 角色'schwartz'拥有lightsaber下的任意权限
schwartz = lightsaber:*
# 角色'goodguy'允许'drive' (action) the winnebago (type) with
# license plate 'eagle5' (instance specific id)
goodguy = winnebago:drive:eagle5
</pre>

<h2 id="Web应用程序整合"><a href="#Web应用程序整合" class="headerlink" title="Web应用程序整合"></a>Web应用程序整合</h2><p>官方文档：<a href="http://shiro.apache.org/webapp-tutorial.html" target="_blank" rel="external">http://shiro.apache.org/webapp-tutorial.html</a></p>
<h3 id="开启Shiro环境"><a href="#开启Shiro环境" class="headerlink" title="开启Shiro环境"></a>开启Shiro环境</h3><p>Shiro可以用多重方式配置，取决于你使用的web应用程序框架，如Spring，Guice等，这里采用Shiro默认，最简单的方式：基于INI文件的配置</p>
<h4 id="添加-shiro-ini-文件"><a href="#添加-shiro-ini-文件" class="headerlink" title="添加 shiro.ini 文件"></a>添加 shiro.ini 文件</h4><p>位置：src/main/webapp/WEB-INF/shiro.ini</p>
<pre><code>[main]
cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager
securityManager.cacheManager = $cacheManager
</code></pre><p>这个INI文件只简单包含main部分，和一些最小配置</p>
<ul>
<li>定义 cacheManager 的实例</li>
<li>在 Shiro securityManager 上配置新的cacheManager的实例</li>
</ul>
<h4 id="在web-xml文件中支持Shiro"><a href="#在web-xml文件中支持Shiro" class="headerlink" title="在web.xml文件中支持Shiro"></a>在web.xml文件中支持Shiro</h4><p>加载shiro.ini文件启动新的Shiro环境，使Web应用程序支持Shiro环境</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;filter&gt;
    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
    &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre><ul>
<li>定义一个 ServletContextListener，应用程序启动时启动Shiro环境（包括Shiro SecurityManager）。<strong>监听器默认寻找 WEB-INF/shiro.ini 文件</strong> 作为 Shiro 的配置文件</li>
<li>过滤器拦截所有请求，所以Shiro在请求达到应用程序之前，能够执行必要的身份验证和访问控制操作</li>
<li>&lt;filter-mapping&gt;声明确保所有请求类型都能被ShiroFilter拦截，一般filter-mapping声明不需要指定dispatcher元素，但是Shiro需要定义它们，这样可以过滤所有不同的请求类型</li>
</ul>
<h4 id="运行webapp"><a href="#运行webapp" class="headerlink" title="运行webapp"></a>运行webapp</h4><pre><code>mvn tomcat:run
</code></pre><p>这些输出指明Shiro确定在你的webapp中运行</p>
<pre><code>15:41:22.296 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.
15:41:22.733 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 435 ms.
</code></pre><h3 id="连接到用户仓库"><a href="#连接到用户仓库" class="headerlink" title="连接到用户仓库"></a>连接到用户仓库</h3><h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><ul>
<li>在我们登录、退出、执行访问控制等其他安全相关的操作之前，我们需要用户！所有我们会设置Shiro去访问用户仓库</li>
<li>用户仓库会有多种形式：MySQL数据库、MongoDB、LDAP、活动目录、简单文件、其他私有数据仓库，Shiro通过 <strong>Realm</strong> 来操作这些</li>
<li>Realm扮演Shiro与安全数据之间的桥梁，也可以说是连接器。当用户执行鉴权（登录）或授权（访问控制），Shiro从应用程序配置的所有Realm中寻找数据</li>
<li>Realm 是一个安全DAO，封装了连接细节，Shiro需要数据时通过Realm可以直接获取。Realm可以配置多个，但至少要有一个</li>
<li><strong>默认为iniRealm</strong></li>
</ul>
<h4 id="ini"><a href="#ini" class="headerlink" title="ini"></a>ini</h4><p>简单配置了两个用户，用户名密码分别为admin：admin，guest：guest</p>
<pre><code>[users]
admin=admin
guest=guest
</code></pre><h3 id="Shiro登录-退出与访问控制"><a href="#Shiro登录-退出与访问控制" class="headerlink" title="Shiro登录/退出与访问控制"></a>Shiro登录/退出与访问控制</h3><h4 id="ini文件，添加访问控制"><a href="#ini文件，添加访问控制" class="headerlink" title="ini文件，添加访问控制"></a>ini文件，添加访问控制</h4><pre><code>[main]
# 对于Shiro任何默认过滤器都有一个loginUrl属性，authc过滤器会跳转到登录页面
shiro.loginUrl = /login.jsp

# 用户
[users]
admin = admin
guest = guest

# 过滤请求，路径相对于应用程序路径[HttpServletRequest.getContextPath()]
[urls]
# 匹配到请求/login.jsp，开启authc过滤器，跳转到loginUrl页面
/login.jsp = authc
# 匹配到请求/logout，开启logout过滤器，跳转到首页
/logout = logout
# 匹配到请求/admin/**，开启authc过滤器，跳转到loginUrl页面
/admin/** = authc
</code></pre><h4 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h4><p>Shiro会默认读取username、password、rememberMe</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Apache Shiro Tutorial Webapp : Login&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- Add some nice styling and functionality.  We&apos;ll just use Twitter Bootstrap --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap-theme.min.css&quot;&gt;
    &lt;style&gt;
        body{padding-top:20px;}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
                &lt;div class=&quot;panel panel-default&quot;&gt;
                    &lt;div class=&quot;panel-heading&quot;&gt;
                        &lt;h3 class=&quot;panel-title&quot;&gt;Please sign in&lt;/h3&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;panel-body&quot;&gt;
                        &lt;form name=&quot;loginform&quot; action=&quot;&quot; method=&quot;POST&quot; accept-charset=&quot;UTF-8&quot; role=&quot;form&quot;&gt;
                            &lt;fieldset&gt;
                                &lt;div class=&quot;form-group&quot;&gt;
                                    &lt;input class=&quot;form-control&quot; placeholder=&quot;Username or Email&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;
                                &lt;/div&gt;
                                &lt;div class=&quot;form-group&quot;&gt;
                                    &lt;input class=&quot;form-control&quot; placeholder=&quot;Password&quot; name=&quot;password&quot; type=&quot;password&quot; value=&quot;&quot;&gt;
                                &lt;/div&gt;
                                &lt;div class=&quot;checkbox&quot;&gt;
                                    &lt;label&gt;
                                        &lt;input name=&quot;rememberMe&quot; type=&quot;checkbox&quot; value=&quot;true&quot;&gt; Remember Me
                                    &lt;/label&gt;
                                &lt;/div&gt;
                                &lt;input class=&quot;btn btn-lg btn-success btn-block&quot; type=&quot;submit&quot; value=&quot;Login&quot;&gt;
                            &lt;/fieldset&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;
    &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt;
    &lt;!--[if lt IE 9]&gt;
    &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="登录验证页面"><a href="#登录验证页面" class="headerlink" title="登录验证页面"></a>登录验证页面</h4><p>如果用户/密码正确，跳转到主页面，否则继续跳转到登录页</p>
<pre><code>public class LoginServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);

        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(username, password);
        try{
            subject.login(token);
        }catch (Exception e){
            request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request,response);
            return;
        }
        request.getRequestDispatcher(&quot;/WEB-INF/main.jsp&quot;).forward(request,response);
    }
}
</code></pre><h3 id="基于角色的权限控制★★★★★"><a href="#基于角色的权限控制★★★★★" class="headerlink" title="基于角色的权限控制★★★★★"></a>基于角色的权限控制★★★★★</h3><pre><code>[main]
# 认证页面
shiro.loginUrl = /login.jsp
# 用户没有权限时跳转页面
perms.unauthorizedUrl = /unauthorizedUrl.jsp
roles.unauthorizedUrl = /unauthorizedUrl.jspgi

[users]
# admin的密码是admin，拥有admin角色，包含admin下的所有权限
admin = admin,admin
# guest的密码是guest，拥有user角色，包含user下的所有权限
guest = guest,user
# qm的密码是qm，不拥有任何角色，即没有任何权限
qm = qm

[roles]
# admin拥有的权限
admin = admin:*,user:*
# user拥有的权限
user = user:*

[urls]
/login.jsp = annon
/logout = logout

# /admin/**路径只有拥有admin角色的用户才能访问
/admin/** = authc,roles[admin]
# 访问/user/list.jsp必须拥有user:list权限，所以拥有admin或者user的角色都可以访问
/user/list.jsp = authc,perms[user:list]
# 访问/user/** 只要认证用户都可以访问
/user/** = authc
</code></pre><p>当用户访问一个url时，Shiro从上到下扫描权限，如果有一个匹配则不继续往下进行扫描，所以优先级很重要。对于特殊的访问权限，放在上面</p>
<h2 id="Shiro细节"><a href="#Shiro细节" class="headerlink" title="Shiro细节"></a>Shiro细节</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h4 id="认证身份流程"><a href="#认证身份流程" class="headerlink" title="认证身份流程"></a>认证身份流程</h4><p><img src="http://i.imgur.com/aXcmnp3.png" alt=""></p>
<p>流程如下：<br>1、首先调用 Subject.login(token)进行登录，其会自动委托给 Security Manager，调用之前必<br>须通过 SecurityUtils. setSecurityManager()设置；<br>2、SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证；<br>3、 Authenticator 才是真正的身份验证者， Shiro API 中核心的身份认证入口点， 此处可以自定义插入自己的实现；<br>4、Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认<br>ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证；<br>5、Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返<br>回/抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p>
<h4 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h4><p>登录操作</p>
<pre><code>public class realm_test {
    public static void main(String[] args){
        // 设置SecurityManager
        SecurityManager securityManager = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;).getInstance();
        SecurityUtils.setSecurityManager(securityManager);

        //获取主体
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(&quot;admin&quot;,&quot;admin&quot;);
        try{
            //登录操作，登录不成功会抛出异常
            subject.login(token);
            //输出认证的用户名
            System.out.println(subject.getPrincipal());
        }catch (UnknownAccountException e){
            System.out.println(&quot;用户名不存在&quot;);
        }catch (IncorrectCredentialsException e){
            System.out.println(&quot;用户名密码错误&quot;);
        }
    }
}
</code></pre><p>自定义realm</p>
<pre><code>public class MyRealm implements Realm{

    //模拟数据库，放入一些用户名和密码
    private static Map&lt;String,String&gt; DB = new HashMap&lt;String,String&gt;();
    static {
        DB.put(&quot;admin&quot;,&quot;admin&quot;);
        DB.put(&quot;qm&quot;,&quot;qm&quot;);
    }

    @Override
    //Realm的名称
    public String getName() {
        return &quot;MyRealm&quot;;
    }

    @Override
    //该realm支持哪些token
    public boolean supports(AuthenticationToken authenticationToken) {
        return authenticationToken instanceof UsernamePasswordToken;
    }

    @Override
    //执行subject.login操作调用的方法
    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        //获取token中的用户和密码
        String username = authenticationToken.getPrincipal().toString();
        String password = new String((char[])authenticationToken.getCredentials());

        //验证失败
        if(!DB.containsKey(username)) throw new UnknownAccountException(&quot;用户名不存在&quot;);
        if(!password.equals(DB.get(username))) throw new IncorrectCredentialsException(&quot;用户名密码错误&quot;);
        //System.out.println(username + &quot; &quot; + password);

        //验证成功返回一个AuthenticationInfo
        return new SimpleAuthenticationInfo(username, password,getName());
    }
}
</code></pre><p>配置使用自定义realm</p>
<pre><code>[main]
#创建一个MyRealm实例，这句话等同于&lt;bean id = &quot;myRealm&quot; class = &quot;MyRealm&quot;/&gt;
myRealm = MyRealm
#依赖注入，在securityManager中传入自定义realm的实例
securityManager.realms = $myRealm
</code></pre><h4 id="多-Realm-配置"><a href="#多-Realm-配置" class="headerlink" title="多 Realm 配置"></a>多 Realm 配置</h4><pre><code>#声明一个 realm 
myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1 
myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2 
#指定 securityManager 的 realms 实现
securityManager.realms=$myRealm1,$myRealm2 
</code></pre><p>securityManager 会按照 realms 指定的顺序进行身份认证。此处我们使用 <strong>显示指定顺序的方式</strong> 指定了 Realm 的顺序，如果删除”securityManager.realms=$myRealm1,$myRealm2”，那么 securityManager 会<strong>按照 realm 声明的顺序进行使用</strong>（即无需设置 realms 属性，其会自动<br>发 现），当我们显示指定 realm 后 ， 他没有指定 realm 将被忽 略， 如”securityManager.realms=$myRealm1”，那么 myRealm2 不会被自动设置进去。</p>
<h4 id="Shiro-默认提供的-Realm及开发建议★★★★★"><a href="#Shiro-默认提供的-Realm及开发建议★★★★★" class="headerlink" title="Shiro 默认提供的 Realm及开发建议★★★★★"></a>Shiro 默认提供的 Realm及开发建议★★★★★</h4><p><img src="http://i.imgur.com/URoDJuv.png" alt=""></p>
<p>以后一般继承 <strong>AuthorizingRealm</strong> （授权）即可； 其继承了 AuthenticatingRealm （即身份验证） ，而且也间接继承了 CachingRealm（带有缓存实现）。其中主要默认实现如下：</p>
<ul>
<li>org.apache.shiro.realm.text.IniRealm： [users]部分指定用户名/密码及其角色； [roles]部分指定角色即权限信息；</li>
<li>org.apache.shiro.realm.text.PropertiesRealm：user.username=password,role1,role2 指定用户名/密码及其角色；role.role1=permission1,permission2 指定角色及权限信息；</li>
<li>org.apache.shiro.realm.jdbc.JdbcRealm：通过 sql 查询相应的信息，如 “select password from users where username =?”获取用户密码，”select password, password_salt from users where username =?”获取用户密码及盐；”select role_name from user_roles where username =?”<br>获取用户角色；”selectpermission from roles_permissions where role_name =?”获取角色对应的权限信息；也可以调用相应的 api 进行自定义 sql；</li>
</ul>
<p><strong>jdbcRealm使用</strong></p>
<p>1、依赖</p>
<pre><code>&lt;dependency&gt; 
    &lt;groupId&gt;mysql&lt;/groupId&gt; 
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 
    &lt;version&gt;5.1.25&lt;/version&gt; 
&lt;/dependency&gt; 
&lt;dependency&gt; 
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt; 
    &lt;artifactId&gt;druid&lt;/artifactId&gt; 
    &lt;version&gt;0.2.23&lt;/version&gt; 
&lt;/dependency&gt; 
</code></pre><p>2、配置数据库</p>
<p>查看jdbcReaml源代码，发现其中固定了一个sql语句，要求数据库中有一个users表，并且有username、password两个字段</p>
<p><img src="http://i.imgur.com/b2Degfn.png" alt=""></p>
<p>3、配置</p>
<pre><code>[main]
# 数据源
dataSource = com.alibaba.druid.pool.DruidDataSource
dataSource.driverClassName = com.mysql.jdbc.Driver
dataSource.url = jdbc:mysql://localhost:3306/jdbcRealm
dataSource.username = root
dataSource.password = root

#创建一个jdbcRealm实例，并且注入数据源
jdbcRealm = org.apache.shiro.realm.jdbc.JdbcRealm
jdbcRealm.dataSource = $dataSource
securityManager.realms = $jdbcRealm
</code></pre><p>4、验证</p>
<pre><code>public class realm_test {
    public static void main(String[] args){
        // 设置SecurityManager
        SecurityManager securityManager = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;).getInstance();
        SecurityUtils.setSecurityManager(securityManager);

        //获取主体
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(&quot;admin&quot;,&quot;admin&quot;);
        try{
            //登录操作，登录不成功会抛出异常
            subject.login(token);
            //输出认证的用户名
            System.out.println(subject.getPrincipal());
        }catch (UnknownAccountException e){
            System.out.println(&quot;用户名不存在&quot;);
        }catch (IncorrectCredentialsException e){
            System.out.println(&quot;用户名密码错误&quot;);
        }
    }
}
</code></pre><h4 id="Authenticator接口及其子类源码分析★★★★★★"><a href="#Authenticator接口及其子类源码分析★★★★★★" class="headerlink" title="Authenticator接口及其子类源码分析★★★★★★"></a>Authenticator接口及其子类源码分析★★★★★★</h4><p>1、定义接口Authenticator，定义了一个authenticate认证方法</p>
<pre><code>public interface Authenticator {
    public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)
            throws AuthenticationException;
}
</code></pre><p>2、抽象类AbstractAuthenticator实现Authenticator接口，类的作用是通过doAuthenticate方法来获取AuthenticationInfo并返回；doAuthenticate方法为抽象方法，由子类重写</p>
<pre><code>public abstract class AbstractAuthenticator implements Authenticator, LogoutAware {

    public final AuthenticationInfo authenticate(AuthenticationToken token) throws AuthenticationException {
        AuthenticationInfo info;
        info = doAuthenticate(token);
    }
    protected abstract AuthenticationInfo doAuthenticate(AuthenticationToken token)
                throws AuthenticationException;
    }
}
</code></pre><p>3、ModularRealmAuthenticator继承了AbstractAuthenticator，通过<strong>调用realm的getAuthenticationInfo方法获得AuthenticationInfo</strong></p>
<pre>
public class ModularRealmAuthenticator extends AbstractAuthenticator {

    <font color="red">//保存realm的实例</font>
    private Collection&lt;Realm> realms;
    private AuthenticationStrategy authenticationStrategy;

    protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException {

        assertRealmsConfigured();
        Collection<realm> realms = getRealms();
        if (realms.size() == 1) {
            return <font color="red">doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</font>
        } else {
            return <font color="red">doMultiRealmAuthentication(realms, authenticationToken);</font>
        }

    }

    protected AuthenticationInfo doSingleRealmAuthentication(Realm realm, AuthenticationToken token) {
        <font color="red">AuthenticationInfo info = realm.getAuthenticationInfo(token);</font>
        return info;
    }


    protected AuthenticationInfo doMultiRealmAuthentication(Collection<realm> realms, AuthenticationToken token) {
        //若有多个realm，遍历所有realm，根据AuthenticationStrategy 接口指定的策略，返回AuthenticationInfo；默认使用AtLeastOneSuccessfulStrategy策略
        AuthenticationStrategy strategy = getAuthenticationStrategy();
        AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);
        for (Realm realm : realms) {    
            aggregate = strategy.beforeAttempt(realm, token, aggregate);
            AuthenticationInfo info = null;
            info = realm.getAuthenticationInfo(token);
            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);
        }    
        aggregate = strategy.afterAllAttempts(token, aggregate);   
        return aggregate;
    }
}
</realm></realm></pre>

<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>角色代表了权限的集合，赋予用户角色，这样用户就可以拥有一组权限，赋予权限比较方便</p>
<ul>
<li>隐式角色：通过 <strong>判断用户是否有某个角色</strong> 来判断用户有没有操作权限，颗粒度是以角色为单位进行访问控制的，颗粒度较粗，如果应用中允许CTO、技术总监、开发工程师使用打印机，假设某天不允许开发工程师使用打印机了，就需要在相关代码的判断逻辑中移除技术总监角色，造成多处代码的修改</li>
<li>显示角色：程序中 <strong>通过权限</strong> 控制谁能访问某个资源。假设哪个角色不能访问某个资源，只需要从角色的权限集合中移除即可，颗粒度是以资源/实例为单位的，颗粒度较细</li>
</ul>
<h4 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h4><p>判断用户是否有某个角色来进行权限控制，颗粒度较大，很多地方对角色进行判断，如果有一天不需要了就要<strong>修改代码</strong>，在判断这个角色的地方把它删除</p>
<p><strong>ini配置文件：</strong></p>
<pre><code>[users]
admin = admin,r1,r2
</code></pre><p><strong>Shiro 提供了 hasRole/hasRole 用于判断用户是否拥有某个角色/某些权限</strong></p>
<pre><code>//判断是否拥有角色 r1
System.out.println(subject.hasRole(&quot;r1&quot;));
//必须同时拥有r1和r2才会true，否则返回false
System.out.println(subject.hasAllRoles(Arrays.asList(&quot;r1&quot;,&quot;r2&quot;)));
//返回boolean[]数组，相当于判断是否拥有每个角色
System.out.println(Arrays.toString(subject.hasRoles(Arrays.asList(&quot;r1&quot;,&quot;r3&quot;))));
</code></pre><p><strong>Shiro 提供的 checkRole/checkRoles 和 hasRole/hasAllRoles 不同的地方是它在判断为假的情<br>况下会抛出 UnauthorizedException 异常</strong></p>
<pre><code>subject().checkRole(&quot;role1&quot;); 
</code></pre><h4 id="基于资源的访问控制（显示角色）"><a href="#基于资源的访问控制（显示角色）" class="headerlink" title="基于资源的访问控制（显示角色）"></a>基于资源的访问控制（显示角色）</h4><p><strong>ini配置文件</strong></p>
<pre><code>[users]
admin = admin,r1

[roles]
r1=user:create,user:update
r2:user:create,user:delete
</code></pre><p><strong>测试</strong></p>
<pre><code>System.out.println(subject.isPermitted(&quot;user:create&quot;));
System.out.println(subject.isPermittedAll(&quot;user:create&quot;,&quot;user:update&quot;));
</code></pre><p><strong>checkPermission/checkPermissions</strong>会在失败的情况下抛出 UnauthorizedException 异常</p>
<p><strong>规则</strong></p>
<p>基于资源的访问控制（显示角色），也可以叫基于权限的访问控制，这种方式的一般规则是”资源标识符：操作”，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护”用户——角色，角色——权限（资源：操作）”之间的关系</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>规则：”资源标识符：操作：对象实例ID”，即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，”:”表示资源/操作/实例的分割；”,”表示操作的分割；”*”表示任意资源/操作/实例。</p>
<p>1、单个资源单个权限</p>
<pre><code>#ini文件
role1 = system:user:update
#测试
subject().checkPermissions(&quot;system:user:update&quot;); 
</code></pre><p>2、单个资源多个权限</p>
<pre><code>#ini文件
role41=system:user:update,system:user:delete
#测试
subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);
</code></pre><p>3、单个资源全部权限</p>
<pre><code>#ini文件
role52=system:user:* 
</code></pre><p>4、所有资源全部权限</p>
<pre><code>#ini文件
role61=*:view
#测试
subject().checkPermissions(&quot;user:view&quot;); 
</code></pre><p>5、实例级别的权限</p>
<p>《跟我我学Shiro》26页</p>
<h4 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h4><p><img src="http://i.imgur.com/S7tKDiy.png" alt=""></p>
<p>流程如下：<br>1、首先调用 Subject.isPermitted<em>/hasRole</em>接口，其会委托给 SecurityManager，而SecurityManager 接着会委托给 Authorizer；<br>2、Authorizer 是真正的授权者，如果我们调用如 isPermitted(“user:view”)，其首先会通过PermissionResolver 把字符串转换成相应的 Permission 实例；<br>3、在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限；<br>4、Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted<em>/hasRole</em>会返回 true，否则返回 false 表示授权失败。</p>
<h4 id="授权源码分析★★★★★"><a href="#授权源码分析★★★★★" class="headerlink" title="授权源码分析★★★★★"></a>授权源码分析★★★★★</h4><p>1、定义接口Authorizer接口，包括一些isPermitted、checkPermission、hasRole、checkRole一些方法</p>
<pre><code>public interface Authorizer {

    boolean isPermitted(PrincipalCollection principals, String permission);

    boolean isPermitted(PrincipalCollection subjectPrincipal, Permission permission);

    boolean[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions);

    boolean[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions);

    boolean isPermittedAll(PrincipalCollection subjectPrincipal, String... permissions);

    boolean isPermittedAll(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions);

    void checkPermission(PrincipalCollection subjectPrincipal, String permission) throws AuthorizationException;

    void checkPermission(PrincipalCollection subjectPrincipal, Permission permission) throws AuthorizationException;

    void checkPermissions(PrincipalCollection subjectPrincipal, String... permissions) throws AuthorizationException;

    void checkPermissions(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions) throws AuthorizationException;

    boolean hasRole(PrincipalCollection subjectPrincipal, String roleIdentifier);

    boolean[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers);

    boolean hasAllRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers);

    void checkRole(PrincipalCollection subjectPrincipal, String roleIdentifier) throws AuthorizationException;

    void checkRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;

    void checkRoles(PrincipalCollection subjectPrincipal, String... roleIdentifiers) throws AuthorizationException;

}
</code></pre><p>2、同样，和认证一样有一个ModularRealmAuthorizer实现，委托给realm的方法去实现</p>
<p>public class ModularRealmAuthorizer implements Authorizer, PermissionResolverAware, RolePermissionResolverAware {</p>
<pre><code>&lt;font color=&apos;red&apos;&gt;//保存realm的实例&lt;/font&gt;
protected Collection&lt;Realm&gt; realms;
protected PermissionResolver permissionResolver;
protected RolePermissionResolver rolePermissionResolver;


public boolean hasRole(PrincipalCollection principals, String roleIdentifier) {
    assertRealmsConfigured();
    for (Realm realm : getRealms()) {
        if (!(realm instanceof Authorizer)) continue;
        if (((Authorizer) realm).hasRole(principals, roleIdentifier)) {
            return true;
        }
    }
    return false;
}
</code></pre><p>}</p>
<h3 id="Realm及相关对象★★★★★"><a href="#Realm及相关对象★★★★★" class="headerlink" title="Realm及相关对象★★★★★"></a>Realm及相关对象★★★★★</h3><h4 id="用户、角色、权限的关系"><a href="#用户、角色、权限的关系" class="headerlink" title="用户、角色、权限的关系"></a>用户、角色、权限的关系</h4><p><img src="http://i.imgur.com/0Nrv45E.png" alt=""></p>
<ul>
<li>用户——角色之间是多对多关系，角色——权限之间是多对多关系，用户和权限之间通过角色建立关系</li>
<li>在系统中验证时通过权限验证，角色只是权限集合，即显示角色</li>
</ul>
<h4 id="realm接口及其子类源码分析"><a href="#realm接口及其子类源码分析" class="headerlink" title="realm接口及其子类源码分析"></a>realm接口及其子类源码分析</h4><p>1、定义Realm接口，吃、从数据源中获得安全数据（如用户，角色，权限），判断用户身份是否合法，判断用户是否有权限</p>
<pre><code>public interface Realm {

    //realm的名称
    String getName();

    //判断此 Realm 是否支持此 Token
    boolean supports(AuthenticationToken token);

    //传入用户凭证（用户名、密码），返回AuthenticationInfo
    AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;

}
</code></pre><p>2、CachingRealm，增加缓存的功能：维护一个CacheManager的成员变量；增加一个name成员变量，实现getName()方法</p>
<pre><code>public abstract class CachingRealm implements Realm, Nameable, CacheManagerAware, LogoutAware {

    private CacheManager cacheManager;

}
</code></pre><p>3、抽象类AuthenticatingRealm继承CachingRealm，主要功能是：1、从数据源中获取用户信息 2、利用CredentialsMatcher类，将用户传入的密码与数据库返回的密码进行比较（一般我们会自己创建service方法，判断用户名是否存在、密码是否正确，如果出现错误则抛出异常，验证通过返回AuthenticationInfo，此时Shiro会在帮你验证一次，其实没有必要，但框架这么写着你必须使用正确的CredentialsMatcher，使验证通过）；<strong>抽象方法doGetAuthenticationInfo需要由子类重写</strong></p>
<pre>
public abstract class AuthenticatingRealm extends CachingRealm implements Initializable {

    <font color="red">//CredentialsMatcher用于密码校验</font>
    private CredentialsMatcher credentialsMatcher;

    public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {


        AuthenticationInfo info = getCachedAuthenticationInfo(token);
        if (info == null) {
            //otherwise not cached, perform the lookup:
            <font color="red">//从数据源获得用户信息</font>
            <font color="red">info = doGetAuthenticationInfo(token);</font>
            log.debug("Looked up AuthenticationInfo [{}] from doGetAuthenticationInfo", info);
            if (token != null && info != null) {
                cacheAuthenticationInfoIfPossible(token, info);
            }
        } else {
            log.debug("Using cached authentication info [{}] to perform credentials matching.", info);
        }

        if (info != null) {
            <font color="red">//在Shiro中验证密码</font>
            <font color="red">assertCredentialsMatch(token, info);</font>
        } else {
            log.debug("No AuthenticationInfo found for submitted AuthenticationToken [{}].  Returning null.", token);
        }

        return info;
    }

    <font color="red">//从数据源获得用户信息由子类改写</font>
    protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;

    <font color="red">//利用CredentialsMatcher验证密码是否正确，默认是SimpleCredentialsMatcher，调用其doCredentialsMatch方法，根据字节来判断密码是否一样</font>
    protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException {
       <font color="red">CredentialsMatcher cm = getCredentialsMatcher();</font>
        if (cm != null) {
            if (<font color="red">!cm.doCredentialsMatch(token, info)</font>) {
                //not successful - throw an exception to indicate this:
                String msg = "Submitted credentials for token [" + token + "] did not match the expected credentials.";
                throw new IncorrectCredentialsException(msg);
            }
        } else {
            throw new AuthenticationException("A CredentialsMatcher must be configured in order to verify " +
                    "credentials during authentication.  If you do not wish for credentials to be examined, you " +
                    "can configure an " + AllowAllCredentialsMatcher.class.getName() + " instance.");
        }
    }

}
</pre>

<p>4、抽象类AuthorizingRealm，继承AuthenticatingRealm，主要功能是完成Authorizer委托的任务，完成isPermitted、hasRole等方法，所以实现了Authorizer接口；<strong>doGetAuthorizationInfo方法需要由子类改写</strong></p>
<p>注意：<br><strong>成员变量PermissionResolver、RolePermissionResolver，由Authorizer传入</strong></p>
<pre>
public abstract class AuthorizingRealm extends AuthenticatingRealm
    implements Authorizer, Initializable, PermissionResolverAware, RolePermissionResolverAware {

    //成员变量PermissionResolver、RolePermissionResolver，由Authorizer传入
    private PermissionResolver permissionResolver;
    private RolePermissionResolver permissionRoleResolver;

    <font color="red">/*
    * 1、调用getAuthorizationInfo方法从数据库获得权限信息
    * 2、查看用户是否有该操作的权限
    */</font>
    public boolean hasRole(PrincipalCollection principal, String roleIdentifier) {
        AuthorizationInfo info = getAuthorizationInfo(principal);
        return hasRole(roleIdentifier, info);
    }

    protected boolean hasRole(String roleIdentifier, AuthorizationInfo info) {
        return info != null && info.getRoles() != null && info.getRoles().contains(roleIdentifier);
    }

    protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);

    //权限：1、调用PermissionResolver，先把权限字符串转换为Permission
    public boolean isPermitted(PrincipalCollection principals, String permission) {
        Permission p = getPermissionResolver().resolvePermission(permission);
        return isPermitted(principals, p);
    }

    //2、判断权限
    public boolean isPermitted(PrincipalCollection principals, Permission permission) {
        AuthorizationInfo info = getAuthorizationInfo(principals);
        return isPermitted(permission, info);
    }

    //3、调用Permission的implies方法，将数据库的权限与用户传入的进行对比
    protected boolean isPermitted(Permission permission, AuthorizationInfo info) {
        Collection<permission> perms = getPermissions(info);
        if (perms != null && !perms.isEmpty()) {
            for (Permission perm : perms) {
                if (perm.implies(permission)) {
                    return true;
                }
            }
        }
        return false;
    }
}
</permission></pre>

<h4 id="realm相关对象"><a href="#realm相关对象" class="headerlink" title="realm相关对象"></a>realm相关对象</h4><p>实际开发过程中，自定义的realm继承AuthorizingRealm，改写doGetAuthenticationInfo和doGetAuthorizationInfo方法</p>
<ul>
<li>doGetAuthenticationInfo 获取身份验证相关信息：1、调用Subject.login(token)触发方法，根据token获得User信息，没找到用户、密码不正确时抛出异常 2、生成AuthenticationInfo信息并返回 3、父类AuthenticatingRealm 使用 CredentialsMatcher 进行判断密码是否匹配， 如果不匹配将抛出密码错误异常，如果密码重试重试次数太多将抛出重试次数异常</li>
<li>doGetAuthorizationInfo 获取授权信息：根据用户名获得角色及权限信息，并组装成AuthorizationInfo返回</li>
</ul>
<p><strong>AuthenticationToken</strong></p>
<p>AuthenticationToken 用于收集用户提交的身份（如用户名）及凭据（如密码）</p>
<p>Shiro 提供了一个直接拿来用的 UsernamePasswordToken，用于实现用户名/密码 Token 组，<br>另外其实现了 RememberMeAuthenticationToken 和 HostAuthenticationToken， 可以实现记住<br>我及主机验证的支持。</p>
<p><strong>AuthenticationInfo</strong></p>
<p>AuthenticationInfo 有两个作用：<br>1、如果 Realm 是 AuthenticatingRealm 子类，则提供给 AuthenticatingRealm 内部使用的<br>CredentialsMatcher 进行凭据验证； （如果没有继承它需要在自己的 Realm 中自己实现验证）；<br>2、提供给 SecurityManager 来创建 Subject（提供身份信息）；</p>
<p><strong>AuthorizationInfo</strong></p>
<p>AuthorizationInfo 用于聚合授权信息的</p>
<p>当我们使用 AuthorizingRealm 时 ， 如果身份验证成功 ， 在进行授权时就通过<br>doGetAuthorizationInfo 方法获取角色/权限信息用于授权验证</p>
<p><strong>Subject</strong></p>
<p>Subject 是 Shiro 的核心对象，基本所有身份验证、授权都是通过 Subject 完成。</p>
<h3 id="SecurityManager源码分析★★★★★"><a href="#SecurityManager源码分析★★★★★" class="headerlink" title="SecurityManager源码分析★★★★★"></a>SecurityManager源码分析★★★★★</h3><p>1、定义SecurityManager接口，同时继承Authenticator、Authorizer、SessionManager，为什么？<strong>代理模式，SecurityManager代理Authenticator、Authorize和SessionManager的操作，需要实现三者的接口</strong></p>
<pre><code>public interface SecurityManager extends Authenticator, Authorizer, SessionManager {

    Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;

    void logout(Subject subject);

    Subject createSubject(SubjectContext context);

}
</code></pre><p><img src="http://i.imgur.com/NMGskjt.png" alt=""></p>
<p>2、CachingSecurityManager维护一个CacheManager成员变量</p>
<pre><code>public abstract class CachingSecurityManager implements SecurityManager, Destroyable, CacheManagerAware, EventBusAware {

    private CacheManager cacheManager;

}
</code></pre><p>3、RealmSecurityManager，设置realm</p>
<pre><code>public abstract class RealmSecurityManager extends CachingSecurityManager {

    private Collection&lt;Realm&gt; realms;

    public void setRealm(Realm realm) {
        if (realm == null) {
            throw new IllegalArgumentException(&quot;Realm argument cannot be null&quot;);
        }
        Collection&lt;Realm&gt; realms = new ArrayList&lt;Realm&gt;(1);
        realms.add(realm);
        setRealms(realms);
    }
}
</code></pre><p>4、AuthenticatingSecurityManager保存一个Authenticator，默认是ModularRealmAuthenticator，代理认证的功能</p>
<pre><code>public abstract class AuthenticatingSecurityManager extends RealmSecurityManager {

    private Authenticator authenticator;

    public AuthenticatingSecurityManager() {
        super();
        this.authenticator = new ModularRealmAuthenticator();
    }

}
</code></pre><p>5、AuthorizingSecurityManager保存一个Authorizer功能，默认是ModularRealmAuthorizer，代理授权功能</p>
<pre><code>public abstract class AuthorizingSecurityManager extends AuthenticatingSecurityManager {

    private Authorizer authorizer;

    public AuthorizingSecurityManager() {
        super();
        this.authorizer = new ModularRealmAuthorizer();
    }

}
</code></pre><p>6、SessionsSecurityManager保存一个SessionManager，默认是DefaultSessionManager，代理会话管理</p>
<pre><code>public abstract class SessionsSecurityManager extends AuthorizingSecurityManager {

    private SessionManager sessionManager;

    public SessionsSecurityManager() {
        super();
        this.sessionManager = new DefaultSessionManager();
        applyCacheManagerToSessionManager();
    }
}
</code></pre><p>7、DefaultSecurityManager：利用SubjectDAO、SubjectFactory创建、存储Subject</p>
<pre><code>public class DefaultSecurityManager extends SessionsSecurityManager {

    protected RememberMeManager rememberMeManager;
    protected SubjectDAO subjectDAO;
    protected SubjectFactory subjectFactory;

    public DefaultSecurityManager() {
        super();
        this.subjectFactory = new DefaultSubjectFactory();
        this.subjectDAO = new DefaultSubjectDAO();
    }

    protected SubjectContext createSubjectContext() {
        return new DefaultSubjectContext();
    }

    public Subject createSubject(SubjectContext subjectContext) {
        SubjectContext context = copy(subjectContext);
        context = ensureSecurityManager(context);
        context = resolveSession(context);
        context = resolvePrincipals(context);
        Subject subject = doCreateSubject(context);
        save(subject);
        return subject;
    }

}
</code></pre><p>8、DefaultWebSecurityManager：增加了一些Session的维护</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>AuthenticatingRealm中的成员变量CredentialsMatcher进行密码验证服务，Shiro 提供了 redentialsMatcher 的散列实现 HashedCredentialsMatcher，它用于密码验证，且可以提供自己的盐</p>
<p>realm认证</p>
<pre><code>//判断认证
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
    //返回AuthenticationInfo后在AuthenticatingRealm的assertCredentialsMatch方法中还需要进行验证
    //数据库取出的用户名和密码
    String username = &quot;admin&quot;;
    String password = &quot;b433ce675b32a824e24d762ca0fa1ba9&quot;;//数据库密码md5(&quot;admin&quot;,&quot;user&quot;)
    String salt = &quot;user&quot;;

    SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, password, getName());
    simpleAuthenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(salt));
    return simpleAuthenticationInfo;
}
</code></pre><p>设置密码匹配规则</p>
<pre><code>staticRealm = StaticRealm
hashedCredentialsMatcher = org.apache.shiro.authc.credential.HashedCredentialsMatcher
hashedCredentialsMatcher.hashAlgorithmName = md5
staticRealm.credentialsMatcher = $hashedCredentialsMatcher
securityManager.realms = $staticRealm
</code></pre><h3 id="Web集成"><a href="#Web集成" class="headerlink" title="Web集成"></a>Web集成</h3><h4 id="ShiroFilter入口"><a href="#ShiroFilter入口" class="headerlink" title="ShiroFilter入口"></a>ShiroFilter入口</h4><p><strong>与 Spring 集成</strong></p>
<pre><code>&lt;filter&gt; 
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; 
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; 
    &lt;init-param&gt; 
        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; 
        &lt;param-value&gt;true&lt;/param-value&gt; 
    &lt;/init-param&gt; 
&lt;/filter&gt; 
&lt;filter-mapping&gt; 
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; 
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
&lt;/filter-mapping&gt;
</code></pre><p>DelegatingFilterProxy 作用是自动到 spring 容器查找名字为 shiroFilter（filter-name）的 bean，并把所有 Filter 的操作委托给它。然后将 ShiroFilter 配置到 spring 容器即可</p>
<pre><code>&lt;bean id=&quot;shiroFilter&quot;class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; 
    &lt;propertyname=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; 
    &lt;!—忽略其他，详见与 Spring 集成部分  --&gt; 
&lt;/bean&gt; 
</code></pre><p>最后不要忘了使用 org.springframework.web.context.ContextLoaderListener 加载这个 spring<br>配置文件即可</p>
<h4 id="URL匹配"><a href="#URL匹配" class="headerlink" title="URL匹配"></a>URL匹配</h4><pre><code>[urls] 
/login=anon 
/unauthorized=anon 
/static/**=anon 
/authenticated=authc 
/role=authc,roles[admin] 
/permission=authc,perms[&quot;user:create&quot;] 
</code></pre><p>urls中配置格式是：url=拦截器[参数]，拦截器[参数]，即 <strong>如果当前请求的 url 匹配[urls]部分的某个 url 模式， 将会执行其配置的拦截器</strong></p>
<ul>
<li>anon 拦截器表示匿名访问（即不需要登录即可访问）</li>
<li>authc 拦截器表示需要身份认证通过后才能访问</li>
<li>roles[admin] 拦截器表示需要有 admin 角色授权才能访问</li>
<li>perms[“user:create”] 拦截器表示需要有“user:create”权限才能访问</li>
</ul>
<p>url 模式使用 Ant 风格模式，Ant 路径通配符支持 <code>?</code> 、<code>*</code> 、<code>**</code>，注意通配符匹配不包括目录分隔符”/“：</p>
<ul>
<li><code>?</code>：匹配一个字符，如”/admin?”将匹配/admin1，但不匹配/admin 或/admin2；</li>
<li><code>*</code>：匹配零个或多个字符串，如/admin*将匹配/admin、/admin123，但不匹配/admin/1；</li>
<li><code>**</code>：匹配路径中的零个或多个路径，如/admin/**将匹配/admin/a 或/admin/a/b。</li>
</ul>
<p><strong>url 模式匹配顺序</strong></p>
<p>url 模式匹配顺序是按照在配置中的声明顺序匹配，即从头开始使用第一个匹配的 url 模式对应的拦截器链</p>
<h3 id="拦截器机制"><a href="#拦截器机制" class="headerlink" title="拦截器机制"></a>拦截器机制</h3><h4 id="Shiro拦截器源码分析"><a href="#Shiro拦截器源码分析" class="headerlink" title="Shiro拦截器源码分析"></a>Shiro拦截器源码分析</h4><p>Shiro拦截器的基础类图</p>
<p><img src="http://i.imgur.com/Vkfw4UF.png" alt=""></p>
<ul>
<li>AbstractFilter：实现Filter接口，<strong>类的主要功能是实现Filter接口init方法，保存FilterConfig作为成员变量，在init方法中调用无参的setFilterConfig，<font color="red">子类的初始化方法通过改写onFilterConfigSet方法</font></strong></li>
<li>NameableFilter：给Filter起个名字。在类中增加一个name成员变量，set/get方法</li>
<li>OncePerRequestFilter：一次请求中，保证过滤链中同一个过滤器只被执行一次，如内部的 forward 不会再多执行一次 doFilterInternal。<strong>重写Filter接口的doFilter方法，同时设置了enabled属性，表示是否开启该拦截器，<font color="red">子类需要重写doFilterInternal方法，加上具体的过滤操作</font></strong></li>
</ul>
<pre>
public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)  
        throws ServletException, IOException {  
    String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();  
    if (request.getAttribute(alreadyFilteredAttributeName) != null || shouldNotFilter(request)) {  
        log.trace("Filter '{}' already executed.  Proceeding without invoking this filter.", getName());  
        // Proceed without invoking this filter...  
        filterChain.doFilter(request, response);  
    } else {  
        // Do invoke this filter...  
        log.trace("Filter '{}' not yet executed.  Executing now.", getName());  
        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);  

        try {
            <font color="red">//抽象方法，由子类实现</font>  
            doFilterInternal(request, response, filterChain);  
        } finally {  
            // Once the request has finished, we're done and we don't  
            // need to mark as 'already filtered' any more.  
            request.removeAttribute(alreadyFilteredAttributeName);  
        }  
    }  
}  
</pre>

<ul>
<li>AbstractShiroFilter：Shiro过滤器前最后一个抽象类，有两个成员变量：WebSecurityManager（存储SecurityManager的引用，以便过滤器使用）、FilterChainResolver（首先拦截所有的url，再根据实际情况判断url是否需要拦截）；重写onFilterConfigSet方法，<strong><font color="red">子类的初始化方法通过重写init方法完成初始化工作</font></strong>;<strong>重写doFilterInternal方法，为subject的入口，重点★★★★★</strong></li>
</ul>
<pre><code>//重写onFilterConfigSet方法，子类重写init方法增加自定义初始化工作
protected final void onFilterConfigSet() throws Exception {
    //added in 1.2 for SHIRO-287:
    applyStaticSecurityManagerEnabledConfig();
    init();
    ensureSecurityManager();
    //added in 1.2 for SHIRO-287:
    if (isStaticSecurityManagerEnabled()) {
        SecurityUtils.setSecurityManager(getSecurityManager());
    }
}
</code></pre><ul>
<li>ShiroFilter、SpringShiroFilter、SpringShiroFilter 实现 AbstractShiroFilter，主要功能是创建过滤器对象，并将SecurityManager和FilterChainResolver属性的注入</li>
</ul>
<p><strong>另一条过滤器主线：与SpringMVC中的拦截器类似进行设计</strong></p>
<ul>
<li>AdviceFilter</li>
</ul>
<p>AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor：</p>
<p>1、preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续<br>拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验<br>证、授权）<br>2、postHandle： 类似于 AOP 中的后置返回增强； 在拦截器链执行完成后执行； 进行后处理 （如<br>记录执行时间之类的）；<br>3、afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行<br>清理资源（如接触 Subject 与线程的绑定之类的）；</p>
<pre>
//重写doFilterInternal方法
public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)
        throws ServletException, IOException {

    Exception exception = null;

    try {
        <font color="red">//前置方法，如果前置返回false，则不执行下一个过滤器</font>
        boolean continueChain = preHandle(request, response);
        if (log.isTraceEnabled()) {
            log.trace("Invoked preHandle method.  Continuing chain?: [" + continueChain + "]");
        }

        if (continueChain) {
            executeChain(request, response, chain);
        }
        <font color="red">//后置方法，访问Servlet后执行</font>
        postHandle(request, response);
        if (log.isTraceEnabled()) {
            log.trace("Successfully invoked postHandle method");
        }

    } catch (Exception e) {
        exception = e;
    } finally {
        <font color="red">//afterCompletion，不管有没有异常都会执行，可以进行清理资源</font>
        cleanup(request, response, exception);
    }
}
</pre>

<ul>
<li>PathMatchingFilter：提供了基于 Ant 风格的请求路径匹配功能及拦截器参数解析的功能，如<br>“roles[admin,user]”自动根据”，”分割解析到一个路径参数配置并绑定到相应的路径</li>
</ul>
<p>1、pathsMatch该方法用于 path 与请求路径进行匹配的方法；如果匹配返回 true；<br>2、onPreHandle：在 preHandle 中，当 pathsMatch 匹配一个路径后，会调用 opPreHandler 方法<br>并将路径绑定参数配置传给 mappedValue；然后可以在这个方法中进行一些验证（如角色<br>授权），如果验证失败可以返回 false 中断流程；默认返回 true；<strong>也就是说子类可以只实现<br>onPreHandle 即可</strong>， 无须实现 preHandle。 如果没有 path 与请求路径匹配， 默认是通过的 （即<br>preHandle 返回 true）。</p>
<pre>
protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {

    if (this.appliedPaths == null || this.appliedPaths.isEmpty()) {
        if (log.isTraceEnabled()) {
            log.trace("appliedPaths property is null or empty.  This Filter will passthrough immediately.");
        }
        return true;
    }

    <font color="red">for (String path : this.appliedPaths.keySet()) {
        // If the path does match, then pass on to the subclass implementation for specific checks
        //(first match 'wins'):
        if (pathsMatch(path, request)) {
            log.trace("Current requestURI matches pattern '{}'.  Determining filter chain execution...", path);
            Object config = this.appliedPaths.get(path);
            return isFilterChainContinued(request, response, path, config);
        }
    }</font>

    //no path matched, allow the request to go through:
    return true;
}

private boolean isFilterChainContinued(ServletRequest request, ServletResponse response,
                                       String path, Object pathConfig) throws Exception {

    if (isEnabled(request, response, path, pathConfig)) { //isEnabled check added in 1.2
        if (log.isTraceEnabled()) {
            log.trace("Filter '{}' is enabled for the current request under path '{}' with config [{}].  " +
                    "Delegating to subclass implementation for 'onPreHandle' check.",
                    new Object[]{getName(), path, pathConfig});
        }
        //The filter is enabled for this specific request, so delegate to subclass implementations
        //so they can decide if the request should continue through the chain or not:
        <font color="red">return onPreHandle(request, response, pathConfig);</font>
    }

    if (log.isTraceEnabled()) {
        log.trace("Filter '{}' is disabled for the current request under path '{}' with config [{}].  " +
                "The next element in the FilterChain will be called immediately.",
                new Object[]{getName(), path, pathConfig});
    }
    //This filter is disabled for this specific request,
    //return 'true' immediately to indicate that the filter will not process the request
    //and let the request/response to continue through the filter chain:
    return true;
}
</pre>

<ul>
<li><p>AnonymousFilter：继承PathMatchingFilter，重写preHandle方法，总是返回true，则允许所有请求通过</p>
</li>
<li><p>AccessControlFilter：继承PathMatchingFilter，重写onPreHandle方法</p>
</li>
</ul>
<pre><code>public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
    return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);
}
</code></pre><p>1、isAccessAllowed：表示是否允许访问；mappedValue 就是[urls]配置中拦截器参数部分，如果允许访问返回 true，否则 false；<br>2、onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；如果返回 false 表示该拦截器实例已经处理了，将直接返回即可</p>
<p><strong>总结：</strong></p>
<p>1、如果用户有访问资源的权限，则isAccessAllowed返回true，onAccessDenied方法不会执行；<br>2、如果没有访问权限，则isAccessAllowed返回false，而且会执行onAccessDenied方法，方法中可以进行页面跳转等操作，方法体一般返回false，表示不需要执行后面的过滤器了</p>
<p><strong>两个方法为抽象方法，都需要都子类重写</strong></p>
<p>另外 AccessControlFilter 还提供了如下方法用于处理如登录成功后/重定向到上一个请求：</p>
<pre><code>void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp 
String getLoginUrl() 
Subject getSubject(ServletRequest request, ServletResponse response) //获取 Subject 实例
boolean  isLoginRequest(ServletRequest  request,  ServletResponse  response)//当前请求是否是登录请求
void  saveRequestAndRedirectToLogin(ServletRequest  request,  ServletResponse  response) 
throws IOException //将当前请求保存起来并重定向到登录页面
void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请
求
void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面
</code></pre><ul>
<li>AuthenticationFilter继承AccessControlFilter，并重写isAccessAllowed方法，判断用户是否登录</li>
</ul>
<pre><code>protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {  
        Subject subject = getSubject(request, response);  
        return subject.isAuthenticated();  
    } 
</code></pre><h4 id="Shiro拦截器源码分析总结"><a href="#Shiro拦截器源码分析总结" class="headerlink" title="Shiro拦截器源码分析总结"></a>Shiro拦截器源码分析总结</h4><p>1、过滤器设计，顶层是接口，然后一个抽象类实现接口，每个抽象类中值承担一个职责！</p>
<ul>
<li>AbstractFilter保存filterConfig，并提供一个无参的onFilterConfigSet初始化方法</li>
<li>NameableFilter为过滤器取一个名字</li>
<li>OncePerRequestFilter重写doFilter方法，保证一个过滤器在一次请求中只执行一次，过滤器中个操作转移到doFilterInternal中。</li>
<li><strong>之后过滤器子类分为两个分支</strong>，一个是Shiro的主过滤器，配置在web.xml中，为Shiro的入口；另一个是AOP风格的过滤器形式，类时Spring MVC中的拦截器，进入ShiroFilter中先执行完Shiro的一些过滤器，在执行Tomcat中的其他过滤器</li>
<li>★★★★★AdviceFilter重写doFilterInternal方法，将过滤操作分为preHandle、postHandle、afterCompletion操作。如果preHandle返回true，执行下一个过滤器，否则访问终止</li>
<li>PathMatchingFilter重写preHandle方法，进行路径匹配，路径匹配后是否执行Tomcat其他过滤器由onPreHandle的返回结果决定，供子类改写</li>
<li>AccessControlFilter重写onPreHandle方法，可以重写isAccessAllowed、onAccessDenied来实现访问控制</li>
</ul>
<p><strong>开发建议：</strong><br><strong>如果我们想进行访问访问的控制就可以继承AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承 PathMatchingFilter</strong></p>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>Shiro 对 Servlet 容器的 FilterChain 进行了代理，即 ShiroFilter 在继续 Servlet 容器的 Filter 链的执行之前，通过 ProxiedFilterChain 对 Servlet 容器的 FilterChain 进行了代理；<strong>即先走Shiro 自己的 Filter 体系，然后才会委托给 Servlet 容器的 FilterChain 进行 Servlet 容器级别的 Filter 链执行</strong>； </p>
<p>Shiro 的 ProxiedFilterChain 执行流程：<br>1、 执行 Shiro 自己的 Filter 链； 2、再执行 Servlet 容器的 Filter 链（即原始的 Filter）</p>
<p><strong>★★★★★如何实现先执行Shiro自己的Filter链，然后执行Servlet容器的Filter链？</strong></p>
<p>1、调用Shiro的主过滤器后，执行AbstractShiroFilter类的doFilterInternal方法</p>
<pre>
protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)
            throws ServletException, IOException {
    ...
    subject.execute(new Callable() {
                    public Object call() throws Exception {
                        updateSessionLastAccessTime(request, response);
                        <font color="red">executeChain(request, response, chain);</font>
                        return null;
                    }
                });
    ...
}
</pre>

<p>2、AbstractShiroFilter类的executeChain方法，会返回一个Servlet过滤链的代理类ProxiedFilterChain，当执行doFilter方法时，如果Shiro内部的过滤器没有执行完，先执行内部过滤器，等全部执行完成后，在执行Servlet的下一个过滤器。代理Chain对Servlet是透明的</p>
<pre><code>protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)
        throws IOException, ServletException {
    FilterChain chain = getExecutionChain(request, response, origChain);
    chain.doFilter(request, response);
}
</code></pre><p>代理过滤器链ProxiedFilterChain的代码如下，包含原来的过滤链和所需要执行的Shiro过滤器；如果Shiro过滤器没有执行完，则首先执行Shiro过滤器，之后再执行 Servlet 过滤器</p>
<pre>
public class ProxiedFilterChain implements FilterChain {

    //TODO - complete JavaDoc

    private static final Logger log = LoggerFactory.getLogger(ProxiedFilterChain.class);

    //原来的过滤链对象
    <font color="red">private FilterChain orig;
    private List<filter> filters;</filter></font>
    private int index = 0;

    public ProxiedFilterChain(FilterChain orig, List<filter> filters) {
        if (orig == null) {
            throw new NullPointerException("original FilterChain cannot be null.");
        }
        this.orig = orig;
        this.filters = filters;
        this.index = 0;
    }

    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
        //如果执行完Shiro的权限过滤器，则继续执行Servlet中的过滤器
        if (this.filters == null || this.filters.size() == this.index) {
            //we've reached the end of the wrapped chain, so invoke the original one:
            if (log.isTraceEnabled()) {
                log.trace("Invoking original filter chain.");
            }
            <font color="red">this.orig.doFilter(request, response);</font>
        } else {
            if (log.isTraceEnabled()) {
                log.trace("Invoking wrapped filter at index [" + this.index + "]");
            }
            <font color="red">this.filters.get(this.index++).doFilter(request, response, this);</font>
        }
    }
}
</filter></pre>

<p><strong>代理过滤链的产生流程</strong></p>
<p>1、AbstractShiroFilter中的getExecutionChain方法，通过FilterChainResolver的getChain方法，获得过滤链</p>
<pre>
protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) {
    FilterChain chain = origChain;

    <font color="red">FilterChainResolver resolver = getFilterChainResolver();</font>
    if (resolver == null) {
        log.debug("No FilterChainResolver configured.  Returning original FilterChain.");
        return origChain;
    }

    <font color="red">FilterChain resolved = resolver.getChain(request, response, origChain);</font>
    if (resolved != null) {
        log.trace("Resolved a configured FilterChain for the current request.");
        chain = resolved;
    } else {
        log.trace("No FilterChain configured for the current request.  Using the default.");
    }

    return chain;
}
</pre>

<p>2、FilterChainResolver接口的默认实现是PathMatchingFilterChainResolver，必须实现getChain方法。DefaultFilterChainManager 实现 FilterChainManager 接口，维护着 url 模式与拦截器链的关系，遍历url模式，如果与访问的url匹配，则根据匹配的 url 模式找到相应的过滤器，用来生成过滤器链；</p>
<pre>
public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
    FilterChainManager filterChainManager = getFilterChainManager();
    if (!filterChainManager.hasChains()) {
        return null;
    }

    String requestURI = getPathWithinApplication(request);

    for (String pathPattern : filterChainManager.getChainNames()) {

        if (pathMatches(pathPattern, requestURI)) {
            if (log.isTraceEnabled()) {
                log.trace("Matched path pattern [" + pathPattern + "] for requestURI [" + requestURI + "].  " +
                        "Utilizing corresponding filter chain...");
            }
            return filterChainManager.proxy(originalChain, pathPattern);
        }
    }

    return null;
}
</pre>

<p><strong>PathMatchingFilterChainResolver维护着FilterChainManager和PatternMatcher两个成员变量</strong>，FilterChainManager维护着url 模式与拦截器链的关系，默认是DefaultFilterChainManager；PatternMatcher为请求url与url 模式的匹配方式，默认是AntPathMatcher（PathMatchingFilterChainResolver中构造器时赋值）</p>
<p><strong>Shiro Filter初始化时，ShiroFilterFactoryBean调用getObject时，createInstance中创建了一些重要的组件，包括SecurityManager、FilterChainResolver（FilterChainManager为其成员变量）。</strong></p>
<pre>
protected AbstractShiroFilter createInstance() throws Exception {

    log.debug("Creating Shiro Filter instance.");

    SecurityManager securityManager = getSecurityManager();
    if (securityManager == null) {
        String msg = "SecurityManager property must be set.";
        throw new BeanInitializationException(msg);
    }

    if (!(securityManager instanceof WebSecurityManager)) {
        String msg = "The security manager does not implement the WebSecurityManager interface.";
        throw new BeanInitializationException(msg);
    }

    //创建DefaultFilterChainManager
    <font color="red">FilterChainManager manager = createFilterChainManager();</font>

    //Expose the constructed FilterChainManager by first wrapping it in a
    // FilterChainResolver implementation. The AbstractShiroFilter implementations
    // do not know about FilterChainManagers - only resolvers:
    PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();
    <font color="red">chainResolver.setFilterChainManager(manager);</font>

    //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built
    //FilterChainResolver.  It doesn't matter that the instance is an anonymous inner class
    //here - we're just using it because it is a concrete AbstractShiroFilter instance that accepts
    //injection of the SecurityManager and FilterChainResolver:
    return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);
}
</pre>

<h4 id="拦截器链总结"><a href="#拦截器链总结" class="headerlink" title="拦截器链总结"></a>拦截器链总结</h4><p>1、当用户发送请求时，被Shiro Filter拦截，利用FilterChainResolver的getChain方法，获得代理的过滤链，这样可以先执行Shiro 中的一些过滤器，再执行Servlet的其他过滤器<br>2、获得过滤链代理的主要流程是：FilterChainResolver的实现类PathMatchingFilterChainResolver维护着FilterChainManager和PatternMatcher两个成员变量，FilterChainManager维护着url 模式与拦截器链的关系，PatternMatcher为请求url与url 模式的匹配方式，遍历url模式并与请求url进行匹配，获取配置的过滤器，组成代理的过滤器链，并返回</p>
<h4 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h4><pre><code>public enum DefaultFilter {

    anon(AnonymousFilter.class),
    authc(FormAuthenticationFilter.class),
    authcBasic(BasicHttpAuthenticationFilter.class),
    logout(LogoutFilter.class),
    noSessionCreation(NoSessionCreationFilter.class),
    perms(PermissionsAuthorizationFilter.class),
    port(PortFilter.class),
    rest(HttpMethodPermissionFilter.class),
    roles(RolesAuthorizationFilter.class),
    ssl(SslFilter.class),
    user(UserFilter.class);
    ...
}
</code></pre><p><img src="http://i.imgur.com/rde5CK6.png" alt=""></p>
<h4 id="自己提出的问题★★★★★"><a href="#自己提出的问题★★★★★" class="headerlink" title="自己提出的问题★★★★★"></a>自己提出的问题★★★★★</h4><p><strong>1、</strong>Shiro Filter中SecurityManager是否需要绑定到内存的问题</p>
<p>详见AbstractShiroFilter.java</p>
<ul>
<li>如果在Shiro过滤器初始化参数中设置了staticSecurityManagerEnabled的值为true，则SecurityManager与线程绑定</li>
<li>默认是false，即SecurityManager不与线程绑定，设置在WebEnvironment中</li>
</ul>
<p><strong>2、</strong>Shiro Filter中SecurityManager变量依赖注入的方式</p>
<p>Shiro Filter中成员变量SecurityManager实例化的方式有两种：</p>
<ul>
<li>第一种方式是 SecurityManager 在 Spring 中创建，可以自定义设置SecurityManager的属性，然后依赖注入到Shiro Filter中（单例）</li>
<li>如果没有通过依赖注入的方式得到SecurityManager的实例，Shiro将自动创建默认的SecurityManager（每次调用过滤器都会创建一个默认SecurityManager，不推荐）</li>
</ul>
<p>详见AbstractShiroFilter.java</p>
<p><strong>3、</strong>★★★★在Web.xml中配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt;
        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;!--使用[/*]匹配所有请求,保证所有的可控请求都经过Shiro的过滤--&gt;
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><p>在applicationContext-shiro.xml中配置</p>
<pre><code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;
...
&lt;/bean&gt;
</code></pre><p>则DelegatingFilterProxy类与ShiroFilterFactoryBean的关系是什么？</p>
<p>答：DelegatingFilterProxy是一个代理类，具体的操作交给内部的Filter对象delegate去处理，这个delegate通过Spring容器的中的ShiroFilterFactoryBean的工厂方法getBean获取，返回对象类型是SpringShiroFilter，即代理的Filter对象为SpringShiroFilter</p>
<p>处理流程：<br>1、Tomcat扫描web.xml文件，到过滤器节点，遇到DelegatingFilterProxy的配置，生成一个DelegatingFilterProxy的实例，并调用其init方法</p>
<pre><code>&lt;filter&gt;   
    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;  
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;  
    &lt;init-param&gt;  
         &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;   
         &lt;param-value&gt;true&lt;/param-value&gt;   
    &lt;/init-param&gt;   
&lt;/filter&gt; 
</code></pre><p>2、init方法在其父类GenericFilterBean中实现，init方法中调用initFilterBean方法，其在子类DelegatingFilterProxy中改写，代理对象通过语句 this.delegate = initDelegate(wac) 获得<br>3、查看initDelegate方法，有如下语句：Filter delegate = wac.getBean(getTargetBeanName(), Filter.class)，代理对象是从Spring容器中根据id获得，id即为过滤器的名称shiroFilter，你就知道为什么web.xml中过滤器的名称和application-shiro.xml中的bean id要一致了</p>
<pre><code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;
...
&lt;/bean&gt;
</code></pre><p>4、在Spring容器中查找id为shiroFilter，类型为Filter的对象，即为ShiroFilterFactoryBean。但ShiroFilterFactoryBean实现了工厂类，上面的delegate真正的对象是通过它的getObject()获取的</p>
<pre><code>public Object getObject() throws Exception {
    if (instance == null) {
        instance = createInstance();
    }
    return instance;
}
</code></pre><p>5、真正创建对象的方法在createInstance中，<strong>可见代理的过滤器是SpringShiroFilter</strong></p>
<pre><code>protected AbstractShiroFilter createInstance() throws Exception {
    ...
    return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);
}
</code></pre><p>6、SpringShiroFilter: ShiroFilterFactoryBean的内部类，继承AbstractShiroFilter</p>
<pre><code>private static final class SpringShiroFilter extends AbstractShiroFilter {

    protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) {
        super();
        if (webSecurityManager == null) {
            throw new IllegalArgumentException(&quot;WebSecurityManager property cannot be null.&quot;);
        }
        setSecurityManager(webSecurityManager);
        if (resolver != null) {
            setFilterChainResolver(resolver);
        }
    }
}
</code></pre><p>7、每次URL请求，经过代理过滤器DelegatingFilterProxy时，调用SpringShiroFilter实例的doFilter方法</p>
<p>DelegatingFilterProxy.java</p>
<pre>
public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    // Lazily initialize the delegate if necessary.
    <font color="red">Filter delegateToUse = this.delegate;</font>
    if (delegateToUse == null) {
        synchronized (this.delegateMonitor) {
            if (this.delegate == null) {
                WebApplicationContext wac = findWebApplicationContext();
                if (wac == null) {
                    throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener registered?");
                }
                this.delegate = initDelegate(wac);
            }
            delegateToUse = this.delegate;
        }
    }

    // Let the delegate perform the actual doFilter operation.
    <font color="red">invokeDelegate(delegateToUse, request, response, filterChain);</font>
}
</pre>    

<p><strong>总结：</strong></p>
<p>1、Tomcat创建代理对象，初始化代理对象的时候，代理对象通过bean工厂获得被代理对象，并做成其成员对象；每当来一个客户端请求，代理对象的doFilter方法，代理对象调用被代理对象的doFilter方法</p>
<p>2、DelegatingFilterProxy的主要作用就是一个代理模式的应用,可以把 servlet 容器中的filter同spring容器中的bean关联起来[既可以代理Spring Security的过滤器，也可以代理Shiro中的过滤器]</p>
<p><strong>4、</strong> 路径匹配规则</p>
<p>1、路径为空，不进行匹配默认全部通过<br>2、请求url与资源权限路径列表从上到下进行匹配，如果某一个路径匹配，进行权限验证，根据返回结果通过还是拒绝</p>
<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>所谓会话，即用户访问应用时保持的连接关系，<strong>在多次交互中应用能够识别出当前访问的用户是谁</strong>，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。</p>
<pre><code>public interface Session {

    /**
     * 获取当前会话的唯一标识。
     */
    Serializable getId();

    /* 获得属性
     */
    Object getAttribute(Object key) throws InvalidSessionException;

    /* 设置属性
     */
    void setAttribute(Object key, Object value) throws InvalidSessionException;

    /* 删除属性
     */
    Object removeAttribute(Object key) throws InvalidSessionException;

    ...
}
</code></pre><h4 id="会话存储-持久化★★★★★"><a href="#会话存储-持久化★★★★★" class="headerlink" title="会话存储/持久化★★★★★"></a>会话存储/持久化★★★★★</h4><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现：</p>
<pre><code>//如 DefaultSessionManager 在创建完 session 后会调用该方法；如保存到关系数据库/文件
系统/NoSQL 数据库；即可以实现会话的持久化；返回会话 ID ；主要此处返回的
ID.equals(session.getId())；
Serializable create(Session session); 
//根据会话 ID 获取会话
Session readSession(Serializable sessionId) throws UnknownSessionException; 
//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用
void update(Session session) throws UnknownSessionException; 
//删除会话；当会话过期/会话停止（如用户退出时）会调用
void delete(Session session); 
//获取当前所有活跃用户，如果用户量多此方法影响性能
</code></pre><p>Shiro 内嵌了如下 SessionDAO 实现：</p>
<p><img src="http://i.imgur.com/GCOP4Bg.png" alt=""></p>
<p>AbstractSessionDAO 提供了 SessionDAO 的基础实现， 如生成会话 ID 等； CachingSessionDAO<br>提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护； 而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，<strong>默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话</strong>。</p>
<p>可以通过如下配置设置 SessionDAO：</p>
<pre><code>sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO 
sessionManager.sessionDAO=$sessionDAO 
</code></pre><p>Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分<br>布式集群——98页</p>
<h4 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h4><ul>
<li>会话管理器管理着应用中所有 Subject 的会话的创建、维护、删除、失效、验证等工作。是Shiro 的核心组件</li>
<li>顶层组件 SecurityManager 直接继承了 SessionManager，且提供了SessionsSecurityManager 实 现直接把会话管理<strong>委托</strong>给相应的 SessionManager </li>
</ul>
<pre><code>public abstract class SessionsSecurityManager extends AuthorizingSecurityManager {
    private SessionManager sessionManager;
    public Session start(SessionContext context) throws AuthorizationException {
           return this.sessionManager.start(context);
    }

    public Session getSession(SessionKey key) throws SessionException {
        return this.sessionManager.getSession(key);
    }
    ...
}
</code></pre><p><img src="http://i.imgur.com/WT5FGEk.png" alt=""></p>
<p>Shiro 提供了三个默认实现：</p>
<ul>
<li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li>ServletContainerSessionManager： DefaultWebSecurityManager 使用的默认实现，用于 Web环境，其直接使用 Servlet 容器的会话；</li>
<li><font color="red"><strong>DefaultWebSessionManager</strong></font>： 用于 Web 环境的实现 ， 可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ul>
<p><strong>替换默认的会话管理器</strong></p>
<p><strong>在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话</strong>，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制，此时我们可以使用 DefaultWebSessionManager来维护会话：</p>
<pre><code>#sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板
sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookie 
sessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager 
#sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID
sessionIdCookie.name=sid 
#sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名
#sessionIdCookie.domain=sishuok.com 
#sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下
#sessionIdCookie.path= 
#sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认-1 表示关闭浏览器时过期 Cookie
sessionIdCookie.maxAge=1800 
#sessionIdCookie.httpOnly如果设置为 true，则客户端不会暴露给客户端脚本代码，使用HttpOnlycookie 有助于减少某些类型的跨站点脚本攻击； 此特性需要实现了 Servlet2.5 MR6及以上版本的规范的 Servlet 容器支持
sessionIdCookie.httpOnly=true 
sessionManager.sessionIdCookie=$sessionIdCookie 
#sessionManager.sessionIdCookieEnabled：是否启用/禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie， 即默认使用了 Servlet 容器的 JSESSIONID， 且通过 URL 重写（URL 中的“;JSESSIONID=id”部分）保存 Session Id。
sessionManager.sessionIdCookieEnabled=true 
securityManager.sessionManager=$sessionManager 
</code></pre><h4 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h4><p>会话监听器用于监听会话创建、过期及停止事件</p>
<h4 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h4><p>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；<strong>出于性能考虑， 一般情况下都是获取会话时来验证会话是否过期并停止会话的</strong>； 但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。</p>
<h4 id="Session源代码"><a href="#Session源代码" class="headerlink" title="Session源代码"></a>Session源代码</h4><p><img src="http://i.imgur.com/oU7r8WX.png" alt=""></p>
<p>Session是个状态性的数据上下文，可以理解为每个用户都有一个特定数据库，该数据库存储着每个用户自己的数据，在shiro里，它是和Subject绑定在一起的，通常用户通过Subject.getSession来获取使用。它在系统内会存活一段时间为用户提供客户端浏览器和应用服务器通讯的一些功能。以下是一些关于Session的使用场景。 </p>
<p>1、用户登陆成功后，应用服务器产生个Session，且返回该Session的唯一标识符ID给客户端保存（可通过cookie，或者uri参数等形式）。这样用户访问需要验证后的URL时，应用服务器就能识别。</p>
<p><strong>注意：shiro在用户第一次通过浏览器第一次访问应用服务器时，就会产生Session了，且返回SessionID，后面如果用户再登陆的话，则会在Session里存储该用户已经登陆的。 </strong></p>
<p>2、像网上商城，用户通常都会浏览自己喜欢商品，满意后则添加到购物车，由于Session相当于个人的小数据库，此时可以利用Session存储用户添加到购物车的商品，等用户选择完去付款时，此时从Session中获取该用户购物车的商品进行计费、生成订单付费即可。</p>
<p>Shiro实现了自己的Session，即由shiro来管理Session的生命周期。可以为任意的应用提供Session支持。</p>
<p><strong>具体：</strong><a href="http://blog.csdn.net/wojiaolinaaa/article/details/48312299" target="_blank" rel="external">http://blog.csdn.net/wojiaolinaaa/article/details/48312299</a></p>
<p>1、Session</p>
<pre><code>public interface Session {
    //返回Session的标识符
    Serializable getId();

    //根据key获取Session存储的值
    Object getAttribute(Object key) throws InvalidSessionException;

    //设置值和key到session中
    void setAttribute(Object key, Object value) throws InvalidSessionException;

    //根据key删除值
    Object removeAttribute(Object key) throws InvalidSessionException;

    ...
}
</code></pre><p>2、SimpleSession</p>
<pre><code>//SimpleSession实现了ValidatingSession和Serializable接口，支持验证session操作和序列化
public class SimpleSession implements ValidatingSession, Serializable {

    private transient Map&lt;Object, Object&gt; attributes;
    //sessonID，用于保持客户端浏览器和服务端Session存储容器之间的标识
    private transient Serializable id;

    public Serializable getId() {
        return this.id;
    }

    public Object getAttribute(Object key) {
        Map&lt;Object, Object&gt; attributes = getAttributes();
        if (attributes == null) {
            return null;
        }
        return attributes.get(key);
    }

    public void setAttribute(Object key, Object value) {
        if (value == null) {
            removeAttribute(key);
        } else {
            getAttributesLazy().put(key, value);
        }
    }

    public Object removeAttribute(Object key) {
        Map&lt;Object, Object&gt; attributes = getAttributes();
        if (attributes == null) {
            return null;
        } else {
            return attributes.remove(key);
        }
    }
}
</code></pre><p>3、DelegatingSession</p>
<p>服务端的代理的Session，<strong>该DelegatingSession 只是保存了真正的底层Session（SimpleSession）的key，然后根据该key来查找到SimpleSession再代理它的操作</strong>。Subject.getSession()获取的就是该DelegatingSession，也许是为了不让用户破坏底层Session的一些特性吧</p>
<pre><code>public class DelegatingSession implements Session, Serializable {
    private final SessionKey key;
    //用于根据SessionKey来操作真正的底层Session
    private final transient NativeSessionManager sessionManager;

    public Serializable getId() {
        return key.getSessionId();
    }

    public Object getAttribute(Object attributeKey) throws InvalidSessionException {
        return sessionManager.getAttribute(this.key, attributeKey);
    }

    public void setAttribute(Object attributeKey, Object value) throws InvalidSessionException {
        if (value == null) {
            removeAttribute(attributeKey);
        } else {
            sessionManager.setAttribute(this.key, attributeKey, value);
        }
    }

    public Object removeAttribute(Object attributeKey) throws InvalidSessionException {
        return sessionManager.removeAttribute(this.key, attributeKey);
    }
}
</code></pre><p>4、ProxiedSession</p>
<p><strong>该类主要作用是代理真正的Session</strong>，为子类提供可重写方法。如：不可调用代理某个方法，如果调用则抛出异常</p>
<pre><code>public class ProxiedSession implements Session {

    //真正的Session
    protected final Session delegate;

    public Object getAttribute(Object key) throws InvalidSessionException {
        return delegate.getAttribute(key);
    }


    public void setAttribute(Object key, Object value) throws InvalidSessionException {
        delegate.setAttribute(key, value);
    }


    public Object removeAttribute(Object key) throws InvalidSessionException {
        return delegate.removeAttribute(key);
    }
}
</code></pre><p>5、ImmutableSession</p>
<p>ImmutableProxiedSession 继承与ProxiedSession ，该类主要作用是返回一个不可修改Session的代理Session,对于修改的方法都重写抛异常</p>
<pre><code>public class ImmutableProxiedSession extends ProxiedSession {

}
</code></pre><p>6、StoppingAwareProxiedSession</p>
<p>StoppingAwareProxiedSession 主要是增强代理Session的方法</p>
<pre><code>private class StoppingAwareProxiedSession extends ProxiedSession {

}
</code></pre><p>7、HttpServletSession </p>
<p><strong>该Session仅仅只是代理了servlet的HttpSession</strong>。方便与ServletContainerSessionManager和shiro实现可易配置。把session交由servlet Container来控制生命周期。</p>
<h4 id="SessionFactory源码分析"><a href="#SessionFactory源码分析" class="headerlink" title="SessionFactory源码分析"></a>SessionFactory源码分析</h4><p>SessionManager根据SessionContext来创建出一个Session，默认是实现是SimpleSessionFactory</p>
<p><img src="http://i.imgur.com/obPr9zS.png" alt=""></p>
<p>默认的SessionFactory SimpleSessionFactory的创建过程：</p>
<pre><code>public Session createSession(SessionContext initData) {
    if (initData != null) {
        String host = initData.getHost();
        if (host != null) {
            return new SimpleSession(host);
        }
    }
    return new SimpleSession();
}
</code></pre><p>如果SessionContext有host信息，就传递给Session，然后就是直接new一个Session接口的实现SimpleSession</p>
<h4 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h4><p>SessionDAO接口，即对Session进行增删改查</p>
<pre><code>public interface SessionDAO {
    Serializable create(Session session);
    Session readSession(Serializable sessionId) throws UnknownSessionException;
    void update(Session session) throws UnknownSessionException;
    void delete(Session session);
    Collection&lt;Session&gt; getActiveSessions();
}
</code></pre><ul>
<li>create:为Session分配Session-ID，并保存Session</li>
<li>readSession:提供Session-ID取出Session</li>
</ul>
<p><strong>SessionDAO 接口继承关系如下：</strong></p>
<p><img src="http://i.imgur.com/OJePhsn.png" alt=""></p>
<p><strong>AbstractSessionDAO</strong>：有一个重要的属性SessionIdGenerator，它负责给Session创建sessionId，SessionIdGenerator接口如下：</p>
<pre><code>public interface SessionIdGenerator {
    Serializable generateId(Session session);
}
</code></pre><p>很简单，参数为Session，返回sessionId。SessionIdGenerator 的实现有两个JavaUuidSessionIdGenerator、RandomSessionIdGenerator。而AbstractSessionDAO默认采用的是JavaUuidSessionIdGenerator，如下：</p>
<pre><code>public AbstractSessionDAO() {
    this.sessionIdGenerator = new JavaUuidSessionIdGenerator();
}
</code></pre><p>AbstractSessionDAO实现了接口create方法，具体创建Session，存储，传回Session-ID方法由子类实现：</p>
<pre><code>public Serializable create(Session session) {
    Serializable sessionId = doCreate(session);
    verifySessionId(sessionId);
    return sessionId;
}

abstract Serializable doCreate(Session session)；
</code></pre><p>AbstractSessionDAO实现了接口readSession方法，具体根据Session-ID从缓存中获取Session的方法由子类实现：</p>
<pre><code>public Session readSession(Serializable sessionId) throws UnknownSessionException {
    Session s = doReadSession(sessionId);
    if (s == null) {
        throw new UnknownSessionException(&quot;There is no session with id [&quot; + sessionId + &quot;]&quot;);
    }
    return s;
}

protected abstract Session doReadSession(Serializable sessionId);
</code></pre><p><strong>MemorySessionDAO</strong>：继承了AbstractSessionDAO，它把Session存储在一个ConcurrentMap<serializable, session=""> sessions集合中，key为sessionId，value为Session</serializable,></p>
<pre><code>//Session存储在ConcurrentMap集合中
private ConcurrentMap&lt;Serializable, Session&gt; sessions;
public MemorySessionDAO() {
    this.sessions = new ConcurrentHashMap&lt;Serializable, Session&gt;();
}

//重写父类创建Session的方法
protected Serializable doCreate(Session session) {
    //调用父类的获取Session-ID
    Serializable sessionId = generateSessionId(session);
    //为Session设置Session-ID
    assignSessionId(session, sessionId);
    //存储Session
    storeSession(sessionId, session);
    return sessionId;
}

protected Session storeSession(Serializable id, Session session) {
    if (id == null) {
        throw new NullPointerException(&quot;id argument cannot be null.&quot;);
    }
    return sessions.putIfAbsent(id, session);
}

//重写父类读取Session的方法，从Map中根据键值取出Session
protected Session doReadSession(Serializable sessionId) {
    return sessions.get(sessionId);
}
</code></pre><p><strong>CachingSessionDAO</strong>：主要配合在别的地方存储session，维护了一个成员变量cacheManager，默认的activeSessionsCacheName名为shiro-activeSessionCache</p>
<pre><code>private CacheManager cacheManager;
</code></pre><p>扩展了AbstractSessionDAO的create方法，在创建Session后，放入缓存</p>
<pre><code>public Serializable create(Session session) {
        Serializable sessionId = super.create(session);
        cache(session, sessionId);
        return sessionId;
    }
</code></pre><p>扩展了AbstractSessionDAO的readSession方法，先从缓存中获取，如果不行，再去数据库获取</p>
<pre><code>public Session readSession(Serializable sessionId) throws UnknownSessionException {
    Session s = getCachedSession(sessionId);
    if (s == null) {
        s = super.readSession(sessionId);
    }
    return s;
}
</code></pre><p><strong>EnterpriseCacheSessionDAO</strong>：doCreate操作完成了为Session分配Session-ID</p>
<pre><code>protected Serializable doCreate(Session session) {
    Serializable sessionId = generateSessionId(session);
    assignSessionId(session, sessionId);
    return sessionId;
}
</code></pre><p>doReadSession操作不执行任何功能</p>
<pre><code>protected Session doReadSession(Serializable sessionId) {
    return null; //should never execute because this implementation relies on parent class to access cache, which
    //is where all sessions reside - it is the cache implementation that determines if the
    //cache is memory only or disk-persistent, etc.
}
</code></pre><p>如果使用默认的EnterpriseCacheSessionDAO，那么设置的缓存管理器就是内存，与MemorySessionDAO无任何差异，如果使用了外部的缓存管理器，如Ehcache，则将缓存保存到指定的缓存中</p>
<pre><code>public EnterpriseCacheSessionDAO() {
    setCacheManager(new AbstractCacheManager() {
        @Override
        protected Cache&lt;Serializable, Session&gt; createCache(String name) throws CacheException {
            return new MapCache&lt;Serializable, Session&gt;(name, new ConcurrentHashMap&lt;Serializable, Session&gt;());
        }
    });
}
</code></pre><p>注意：这些缓存不支持持久化，如果要保存缓存进入数据库，需要自定义SessionDAO的doCreate()和doReadSession()方法，见张开涛的跟我学Shiro</p>
<h4 id="SessionManager源代码解析"><a href="#SessionManager源代码解析" class="headerlink" title="SessionManager源代码解析"></a>SessionManager源代码解析</h4><p><a href="http://www.cnblogs.com/Kavlez/p/4135857.html" target="_blank" rel="external">http://www.cnblogs.com/Kavlez/p/4135857.html</a></p>
<p>正如其名，sessionManager用于为应用中的Subject管理session，比如创建、删除、失效或者验证等，和Shiro中的其他核心组件一样，他由SecurityManager维护。</p>
<p>Shiro为SessionManager提供了3个实现类(顺便也整理一下与SecurityManager实现类的关系)。</p>
<ul>
<li>DefaultSessionManager</li>
<li>DefaultWebSessionManager</li>
<li>ServletContainerSessionManager</li>
</ul>
<p>其中ServletContainerSessionManager只适用于servlet容器中，如果需要支持多种客户端访问，则应该使用DefaultWebSessionManager。</p>
<p>SessionManager的接口关系：</p>
<p><img src="http://i.imgur.com/GfAv20z.png" alt=""></p>
<h4 id="ThreadContext、SubjectContext（类似）"><a href="#ThreadContext、SubjectContext（类似）" class="headerlink" title="ThreadContext、SubjectContext（类似）"></a>ThreadContext、SubjectContext（类似）</h4><p><a href="http://www.codeweblog.com/shiro%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-subject%E5%92%8Csession/" target="_blank" rel="external">http://www.codeweblog.com/shiro%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-subject%E5%92%8Csession/</a></p>
<h5 id="ThreadContext（类似于数据库，共享Subject、SecurityManager）"><a href="#ThreadContext（类似于数据库，共享Subject、SecurityManager）" class="headerlink" title="ThreadContext（类似于数据库，共享Subject、SecurityManager）"></a>ThreadContext（<strong>类似于数据库，共享Subject、SecurityManager</strong>）</h5><p>ThreadLocal模式线程内<strong>共享Subject、SecurityManager</strong>，ThreadLocal模式只能共享一个变量，由于需求要保存多个对象，保存这个变量类型为Map</p>
<pre><code>public abstract class ThreadContext {

    public static final String SECURITY_MANAGER_KEY = ThreadContext.class.getName() + &quot;_SECURITY_MANAGER_KEY&quot;;

    public static final String SUBJECT_KEY = ThreadContext.class.getName() + &quot;_SUBJECT_KEY&quot;;

    private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new InheritableThreadLocalMap&lt;Map&lt;Object, Object&gt;&gt;();
    .....
}
</code></pre><p>绑定SecurityManager：如果SecurityManager不为空，向线程局部变量的map中，以键存入SECURITY_MANAGER_KEY，值securityManager存入；</p>
<pre><code>public static void bind(SecurityManager securityManager) {
    if (securityManager != null) {
        put(SECURITY_MANAGER_KEY, securityManager);
    }
}

public static void put(Object key, Object value) {
    ensureResourcesInitialized();
    resources.get().put(key, value);
}

//如果map没有初始化，新建一个HashMap
private static void ensureResourcesInitialized(){
    if (resources.get() == null){
       resources.set(new HashMap&lt;Object, Object&gt;());
    }
}
</code></pre><p>取出SecurityManager：取出线程局部变量中的map，根据资源获得SecurityManager</p>
<pre><code>public static SecurityManager getSecurityManager() {
    return (SecurityManager) get(SECURITY_MANAGER_KEY);
}

public static Object get(Object key) {
    Object value = getValue(key);
    return value;
}

private static Object getValue(Object key) {
    Map&lt;Object, Object&gt; perThreadResources = resources.get();
    return perThreadResources != null ? perThreadResources.get(key) : null;
}
</code></pre><p>设置、取出Subject同理：</p>
<pre><code>public static void bind(Subject subject) {
    if (subject != null) {
        put(SUBJECT_KEY, subject);
    }
}

public static Subject getSubject() {
    return (Subject) get(SUBJECT_KEY);
}
</code></pre><h5 id="SubjectContext"><a href="#SubjectContext" class="headerlink" title="SubjectContext"></a>SubjectContext</h5><p>于ThreadContext的设计类似</p>
<h4 id="Subject-getSession-boolean-create"><a href="#Subject-getSession-boolean-create" class="headerlink" title="Subject.getSession(boolean create)"></a>Subject.getSession(boolean create)</h4><p>整体三大步骤，先创建一个SessionContext ，然后传递SessionContext给securityMa但我们可以看下如何创建Session的nager来创建Session，最后是装饰Session,由于创建Session过程内容比较多，先说说装饰Session。</p>
<pre><code>public class DelegatingSubject implements Subject {

    public Session getSession(boolean create) {        
        if (this.session == null &amp;&amp; create) {
            //①创建SessionContext
            SessionContext sessionContext = createSessionContext();
            //②SecurityManager调用SessionManager创建Session
            Session session = this.securityManager.start(sessionContext);
            //③装饰Session
            this.session = decorate(session);
        }
        return this.session;        
    }

    //创建SessionContext
    protected SessionContext createSessionContext() {
        SessionContext sessionContext = new DefaultSessionContext();
        if (StringUtils.hasText(host)) {
            sessionContext.setHost(host);
        }
        return sessionContext;
    }

    protected Session decorate(Session session) {
        if (session == null) {
            throw new IllegalArgumentException(&quot;session cannot be null&quot;);
        }
        return new StoppingAwareProxiedSession(session, this);
    }
}
</code></pre><p>装饰Session就是将Session和DelegatingSubject封装起来，返回的Session包含Subject和Session的实例，其中owner表示拥有该Session的Subject，delegate为代理的Session，类型为DelegatingSession</p>
<pre><code>private class StoppingAwareProxiedSession extends ProxiedSession {
    private final DelegatingSubject owner;

    private StoppingAwareProxiedSession(Session target, DelegatingSubject owningSubject) {
        super(target);
        owner = owningSubject;
    }
}
</code></pre><p>Subject调用SessionManager创建Session的具体过程可以参见上节：Session、SessionFactory、SessionDAO、SessionManager</p>
<h4 id="SecurityUtils创建Subject"><a href="#SecurityUtils创建Subject" class="headerlink" title="SecurityUtils创建Subject"></a>SecurityUtils创建Subject</h4><p>SecurityUtils总体如下，SecurityUtils类中维护一个securityManager变量，它需要由用户自己创建SecurityManager，然后set进入SecurityUtils中进行存储，在应用程序中共享SecurityManager</p>
<pre><code>public abstract class SecurityUtils {

    private static SecurityManager securityManager;

    public static Subject getSubject() {
        Subject subject = ThreadContext.getSubject();
        if (subject == null) {
            subject = (new Subject.Builder()).buildSubject();
            ThreadContext.bind(subject);
        }
        return subject;
    }

    public static void setSecurityManager(SecurityManager securityManager) {
        SecurityUtils.securityManager = securityManager;
    }

    public static SecurityManager getSecurityManager() throws UnavailableSecurityManagerException {
        SecurityManager securityManager = ThreadContext.getSecurityManager();
        if (securityManager == null) {
            securityManager = SecurityUtils.securityManager;
        }
        return securityManager;
    }
}
</code></pre><p>第一次使用SecurityUtils.getSubject()来获取Subject：</p>
<pre><code>public static Subject getSubject() {
    Subject subject = ThreadContext.getSubject();
    if (subject == null) {
        subject = (new Subject.Builder()).buildSubject();
        ThreadContext.bind(subject);
    }
    return subject;
}
</code></pre><p>首先使用ThreadLocal模式来获取，若没有则使用</p>
<pre><code>Subject subject = (new Subject.Builder()).buildSubject();
</code></pre><p>创建一个并绑定到当前线程（<font color="red"><strong>Subject与线程绑定</strong></font>）</p>
<p>此时创建使用的是Subject内部类Builder来创建的，Builder会创建一个SubjectContext接口的实例DefaultSubjectContext，最终会委托securityManager来根据SubjectContext信息来创建一个Subject</p>
<pre><code>public interface Subject {

    .....

    public static class Builder {

        private final SubjectContext subjectContext;
        private final SecurityManager securityManager;

        public Builder() {
            this(SecurityUtils.getSecurityManager());
        }

        //Builder会创建一个SubjectContext接口的实例DefaultSubjectContext
        public Builder(SecurityManager securityManager) {
            if (securityManager == null) {
                throw new NullPointerException(&quot;SecurityManager method argument cannot be null.&quot;);
            }
            this.securityManager = securityManager;
            this.subjectContext = newSubjectContextInstance();
            if (this.subjectContext == null) {
                throw new IllegalStateException(&quot;Subject instance returned from &apos;newSubjectContextInstance&apos; &quot; +
                        &quot;cannot be null.&quot;);
            }
            this.subjectContext.setSecurityManager(securityManager);
        }

        protected SubjectContext newSubjectContextInstance() {
            return new DefaultSubjectContext();
        }

        //委托securityManager来根据SubjectContext信息来创建一个Subject
        public Subject buildSubject() {
            return this.securityManager.createSubject(this.subjectContext);
        }

    }

}
</code></pre><h5 id="★★★★★在DefaultSecurityManager的createSubject"><a href="#★★★★★在DefaultSecurityManager的createSubject" class="headerlink" title="★★★★★在DefaultSecurityManager的createSubject"></a>★★★★★在DefaultSecurityManager的createSubject</h5><p>下面详细说下该过程，<strong>在DefaultSecurityManager的createSubject</strong>方法中：</p>
<pre><code>public Subject createSubject(SubjectContext subjectContext) {
        SubjectContext context = copy(subjectContext);

        context = ensureSecurityManager(context);

        context = resolveSession(context);

        context = resolvePrincipals(context);

        Subject subject = doCreateSubject(context);

        save(subject);

        return subject;
    }
</code></pre><p>首先就是复制SubjectContext，即新建一个SubjectContext实例，与原来的对象具有相同的属性值，SubjectContext的详细介绍见下一节</p>
<p>对于context，把能获取到的参数都凑齐，SecurityManager、Session、Principal，以Session为例，整个过程如下;</p>
<pre><code>public class DefaultSecurityManager extends SessionsSecurityManager {

    //①以获取Session为例
    protected SubjectContext resolveSession(SubjectContext context) {
        //②尝试获取context的map中获取Session
        if (context.resolveSession() != null) {
            log.debug(&quot;Context already contains a session.  Returning.&quot;);
            return context;
        }
        try {
            //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to
            //the session manager:

            //③若没有再尝试获取sessionId
            Session session = resolveContextSession(context);
            if (session != null) {
                context.setSession(session);
            }
        } catch (InvalidSessionException e) {
            log.debug(&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot; +
                    &quot;(session-less) Subject instance.&quot;, e);
        }
        return context;
    }

    protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException {
        SessionKey key = getSessionKey(context);
        if (key != null) {
            return getSession(key);
        }
        return null;
    }

    protected SessionKey getSessionKey(SubjectContext context) {
        Serializable sessionId = context.getSessionId();
        if (sessionId != null) {
            return new DefaultSessionKey(sessionId);
        }
        return null;
    }

}
</code></pre><p>首先调用SubjectContext的resolveSession方法，尝试获取context的map中获取Session：</p>
<pre><code>1、首先获取与SubjectContext中Session
2、如果没找到，尝试获取SubjectContext存储的Subject，如果存在的话，调用Subject的getSession方法获取Session（不新建Session，没有返回null）
</code></pre><p>若没有再尝试获取sessionId,若果有了sessionId则构建成一个DefaultSessionKey来获取对应的Session。</p>
<p>注意：第一次调用SecurityUtil.getSubject()创建Subject的时候不新建Session</p>
<p>SubjectContext的参数填充完整后，进行实际的Subject创建工作，调用DefaultSecurityManager的doCreateSubject方法：请按照1，2，3，4的顺序查看</p>
<pre>
public class DefaultSecurityManager extends SessionsSecurityManager {

    <font color="red">protected SubjectDAO subjectDAO;</font>
    <font color="red">protected SubjectFactory subjectFactory;</font>

    //④SubjectDAO、SubjectFactory默认值
    public DefaultSecurityManager() {
        super();
        <font color="red">this.subjectFactory = new DefaultSubjectFactory();</font>
        <font color="red">this.subjectDAO = new DefaultSubjectDAO();</font>
    }

    //①创建Subject
    public Subject createSubject(SubjectContext subjectContext) {
        //SubjectContext参数的获取
        SubjectContext context = copy(subjectContext);
        context = ensureSecurityManager(context);
        context = resolveSession(context);
        context = resolvePrincipals(context);
        //②具体创建Subject
        <font color="red">Subject subject = doCreateSubject(context);</font>
        save(subject);
        return subject;
    }

    //③
    //通过SubjectFactory工厂接口来创建Subject的，而DefaultSecurityManager默认使用的SubjectFactory是DefaultSubjectFactory：
    protected Subject doCreateSubject(SubjectContext context) {
        return getSubjectFactory().createSubject(context);
    }
}
</pre>

<p>继续看DefaultSubjectFactory是怎么创建Subject的：</p>
<pre><code>public Subject createSubject(SubjectContext context) {
    SecurityManager securityManager = context.resolveSecurityManager();
    Session session = context.resolveSession();
    boolean sessionCreationEnabled = context.isSessionCreationEnabled();
    PrincipalCollection principals = context.resolvePrincipals();
    boolean authenticated = context.resolveAuthenticated();
    String host = context.resolveHost();

    return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);
}
</code></pre><p>仍然就是从SubjectContext获取这些属性，传递给新建的Subject实例：DelegatingSubject，也没什么好说的，到此为止创建一个Subject实例DelegatingSubject，维护了Principal、authenticated、host、session，此时除了host全为空，并返回；</p>
<pre><code>public class DelegatingSubject implements Subject {

    private static final Logger log = LoggerFactory.getLogger(DelegatingSubject.class);

    private static final String RUN_AS_PRINCIPALS_SESSION_KEY =
            DelegatingSubject.class.getName() + &quot;.RUN_AS_PRINCIPALS_SESSION_KEY&quot;;

    protected PrincipalCollection principals;
    protected boolean authenticated;
    protected String host;
    protected Session session;

}
</code></pre><p>创建完成之后，就需要将刚创建的Subject保存起来</p>
<p>来看下save方法：</p>
<pre><code>protected void save(Subject subject) {
    this.subjectDAO.save(subject);
}
</code></pre><p>可以看到又是使用另一个模块来完成的即SubjectDAO，SubjectDAO接口的默认实现为DefaultSubjectDAO()，具体的实现类DefaultSubjectDAO是如何来保存的：</p>
<pre><code>public Subject save(Subject subject) {
    if (isSessionStorageEnabled(subject)) {
        saveToSession(subject);
    } else {
        log.trace(&quot;Session storage of subject state for Subject [{}] has been disabled: identity and &quot; +
                &quot;authentication state are expected to be initialized on every request or invocation.&quot;, subject);
    }

    return subject;
}
</code></pre><p>首先就是判断isSessionStorageEnabled，是否要存储该Subject的session到<br>DefaultSubjectDAO：有一个重要属性SessionStorageEvaluator，它是用来决定一个Subject的Session来记录Subject的状态，接口如下</p>
<pre><code>public interface SessionStorageEvaluator {
    boolean isSessionStorageEnabled(Subject subject);
}
</code></pre><p>其实现为DefaultSessionStorageEvaluator：</p>
<pre><code>public class DefaultSessionStorageEvaluator implements SessionStorageEvaluator {

    private boolean sessionStorageEnabled = true;

    public boolean isSessionStorageEnabled(Subject subject) {
        return (subject != null &amp;&amp; subject.getSession(false) != null) || isSessionStorageEnabled();
    }
}
</code></pre><p>决定策略就是通过DefaultSessionStorageEvaluator 的sessionStorageEnabled的true或false 和subject是否有Session对象来决定的。如果允许存储Subject的Session的话，下面就说 <strong>具体的存储过程</strong>：</p>
<pre><code>protected void saveToSession(Subject subject) {
    mergePrincipals(subject);
    mergeAuthenticationState(subject);
}

protected void mergePrincipals(Subject subject) {
    //merge PrincipalCollection state:

    PrincipalCollection currentPrincipals = null;

    //SHIRO-380: added if/else block - need to retain original (source) principals
    //This technique (reflection) is only temporary - a proper long term solution needs to be found,
    //but this technique allowed an immediate fix that is API point-version forwards and backwards compatible
    //
    //A more comprehensive review / cleaning of runAs should be performed for Shiro 1.3 / 2.0 +
    if (subject.isRunAs() &amp;&amp; subject instanceof DelegatingSubject) {
        try {
            Field field = DelegatingSubject.class.getDeclaredField(&quot;principals&quot;);
            field.setAccessible(true);
            currentPrincipals = (PrincipalCollection)field.get(subject);
        } catch (Exception e) {
            throw new IllegalStateException(&quot;Unable to access DelegatingSubject principals property.&quot;, e);
        }
    }
    if (currentPrincipals == null || currentPrincipals.isEmpty()) {
        currentPrincipals = subject.getPrincipals();
    }

    Session session = subject.getSession(false);

    if (session == null) {
       //只有当Session为空，并且currentPrincipals不为空的时候才会去创建Session
       //Subject subject = SecurityUtils.getSubject()此时两者都是为空的，
       //不会去创建Session
        if (!CollectionUtils.isEmpty(currentPrincipals)) {
            session = subject.getSession();
            session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
        }
        //otherwise no session and no principals - nothing to save
    } else {
        PrincipalCollection existingPrincipals =
                (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);

        if (CollectionUtils.isEmpty(currentPrincipals)) {
            if (!CollectionUtils.isEmpty(existingPrincipals)) {
                session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
            }
            //otherwise both are null or empty - no need to update the session
        } else {
            if (!currentPrincipals.equals(existingPrincipals)) {
                session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
            }
            //otherwise they&apos;re the same - no need to update the session
        }
    }
}
</code></pre><p>上面有我们关心的重点，当subject.getSession(false)获取的Session为空时（它不会去创建Session），此时就需要去创建Session，subject.getSession()则默认调用的是subject.getSession(true),则会进行Session的创建，创建过程上文已详细说明了。</p>
<p>在第一次创建Subject的时候</p>
<pre><code>Subject subject = SecurityUtils.getSubject();
</code></pre><p>虽然Session为空，但此时还没有用户身份信息，也不会去创建Session</p>
<p><strong>所以创建的DelegatingSubject实例，成员变量Principal、Session全是空</strong></p>
<h4 id="Subject-login-token"><a href="#Subject-login-token" class="headerlink" title="Subject.login(token)"></a>Subject.login(token)</h4><p>案例中的<strong>subject.login(token)</strong>该过程则会去创建Session，具体看下过程：</p>
<p>首先DelegatingSubject调用login方法会委托给SecurityManager的securityManager.login(this, token)方法</p>
<pre><code>public void login(AuthenticationToken token) throws AuthenticationException {
    clearRunAsIdentitiesInternal();

    //SecurityManager完成实际的登录操作
    Subject subject = securityManager.login(this, token);

    PrincipalCollection principals;

    String host = null;

    if (subject instanceof DelegatingSubject) {
        DelegatingSubject delegating = (DelegatingSubject) subject;
        principals = delegating.principals;
        host = delegating.host;
    } else {
        principals = subject.getPrincipals();
    }

    if (principals == null || principals.isEmpty()) {
        String msg = &quot;Principals returned from securityManager.login( token ) returned a null or &quot; +
                &quot;empty value.  This value must be non null and populated with one or more elements.&quot;;
        throw new IllegalStateException(msg);
    }
    this.principals = principals;
    this.authenticated = true;
    if (token instanceof HostAuthenticationToken) {
        host = ((HostAuthenticationToken) token).getHost();
    }
    if (host != null) {
        this.host = host;
    }
    Session session = subject.getSession(false);
    if (session != null) {
        this.session = decorate(session);
    } else {
        this.session = null;
    }
}
</code></pre><p>SecurityManager的login方法分为两步：1、对用户名、密码验证 2、创建Subject</p>
<pre><code>public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException {
    //对用户名、密码验证
    AuthenticationInfo info;
    try {
        info = authenticate(token);
    } catch (AuthenticationException ae) {
        try {
            onFailedLogin(token, ae, subject);
        } catch (Exception e) {
            if (log.isInfoEnabled()) {
                log.info(&quot;onFailedLogin method threw an &quot; +
                        &quot;exception.  Logging and propagating original AuthenticationException.&quot;, e);
            }
        }
        throw ae; //propagate
    }
     //在该过程会进行Session的创建
    Subject loggedIn = createSubject(token, info, subject);

    onSuccessfulLogin(token, info, loggedIn);

    return loggedIn;
}
</code></pre><p>对于验证过程这里不再说明，重点还是在验证通过后，<font color="red"><strong>会创建一个新的Subject，同时Subject中包含认证信息和Session；</strong></font></p>
<p>新建SubjectContext，并设置了认证信息</p>
<pre><code>protected Subject createSubject(AuthenticationToken token, AuthenticationInfo info, Subject existing) {
        SubjectContext context = createSubjectContext();
        context.setAuthenticated(true);
        context.setAuthenticationToken(token);
        context.setAuthenticationInfo(info);
        if (existing != null) {
            context.setSubject(existing);
        }
        //根据SubjectContext创建Subject，之前详细讲解过
        return createSubject(context);
    }

protected SubjectContext createSubjectContext() {
    return new DefaultSubjectContext();
}
</code></pre><font color="red"><strong>在系统刚启动时，创建Subject时，参数SubjectContext中的Session、Principal都为空，不创建Session；但在调用Subject.login有了认证成功的AuthenticationInfo信息，调用SubjectContext在resolvePrincipals便可以获取用户信息</strong></font>

<p>再次调用createSubject(context）创建Subject，此时resolvePrincipals(context)中，可以获取到刚才认证传入的AuthenticationInfo，并取出Principal。<strong>在SubjectContext中Principal不为空，但Session为空</strong></p>
<pre><code>public Subject createSubject(SubjectContext subjectContext) {

    SubjectContext context = copy(subjectContext);
    context = ensureSecurityManager(context);
    context = resolveSession(context);
    context = resolvePrincipals(context);
    Subject subject = doCreateSubject(context);
    save(subject);

    return subject;
}
</code></pre><font color="red"><strong>PrincipalCollection不为空了，在<font color="blue">save(subject)</font>的时候会得到session为空，同时PrincipalCollection不为空，则会执行Session的创建。</strong></font>也就是说在认证通过后，会执行Session的创建，返回的Session为Subject和Session的封装体，并在Session中存入Principal<br><br><font color="blue"><strong>调用subject.getSession()，回返回一个Subject和Session的封装体，并且设置该Session为Subject的成员变量</strong></font>

<pre><code>protected void mergePrincipals(Subject subject) {
    PrincipalCollection currentPrincipals = null;
    if (subject.isRunAs() &amp;&amp; subject instanceof DelegatingSubject) {
        try {
            Field field = DelegatingSubject.class.getDeclaredField(&quot;principals&quot;);
            field.setAccessible(true);
            currentPrincipals = (PrincipalCollection)field.get(subject);
        } catch (Exception e) {
            throw new IllegalStateException(&quot;Unable to access DelegatingSubject principals property.&quot;, e);
        }
    }
    if (currentPrincipals == null || currentPrincipals.isEmpty()) {
        currentPrincipals = subject.getPrincipals();
    }

    Session session = subject.getSession(false);

    if (session == null) {
        if (!CollectionUtils.isEmpty(currentPrincipals)) {
            //【此处会执行！！！】Principal不为空会创建一个Session
            //调用subject.getSession()，回返回一个Subject和Session的共同体，并且设置该Session为Subject的成员变量
            session = subject.getSession();

            //Session中存入Principal
            session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
        }
        //otherwise no session and no principals - nothing to save
    } else {
        PrincipalCollection existingPrincipals =
                (PrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);

        if (CollectionUtils.isEmpty(currentPrincipals)) {
            if (!CollectionUtils.isEmpty(existingPrincipals)) {
                session.removeAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);
            }
            //otherwise both are null or empty - no need to update the session
        } else {
            if (!currentPrincipals.equals(existingPrincipals)) {
                session.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, currentPrincipals);
            }
            //otherwise they&apos;re the same - no need to update the session
        }
    }
}
</code></pre><p>委托SecurityManager执行登录操作完毕，回到DelegatingSubject的login函数，<strong>返回了新建的Subject</strong></p>
<p>Session创建完成之后会进行一次装饰，即用新建一个StoppingAwareProxiedSession对象，其中的delegate为session（也为StoppingAwareProxiedSession类型），owner为Subject，然后又进行如下操作：</p>
<pre>    
public class DelegatingSubject implements Subject {

    public void login(AuthenticationToken token) throws AuthenticationException {
        clearRunAsIdentitiesInternal();
        //★★★★★这里的Subject则是经过认证后创建的并且也含有刚才创建的session
        <font color="red">Subject subject = securityManager.login(this, token);</font>

        PrincipalCollection principals;

        String host = null;

        if (subject instanceof DelegatingSubject) {
            DelegatingSubject delegating = (DelegatingSubject) subject;
            //we have to do this in case there are assumed identities - we don't want to lose the 'real' principals:
            principals = delegating.principals;
            host = delegating.host;
        } else {
            principals = subject.getPrincipals();
        }

        if (principals == null || principals.isEmpty()) {
            String msg = "Principals returned from securityManager.login( token ) returned a null or " +
                    "empty value.  This value must be non null and populated with one or more elements.";
            throw new IllegalStateException(msg);
        }
        <font color="red">//内部Subject的principal、session、authenticated复制到外部的Subject</font>
        this.principals = principals;
        this.authenticated = true;
        if (token instanceof HostAuthenticationToken) {
            host = ((HostAuthenticationToken) token).getHost();
        }
        if (host != null) {
            this.host = host;
        }
        Session session = subject.getSession(false);
        if (session != null) {
            //在这里可以看到又进行了一次装饰
            this.session = decorate(session);
        } else {
            this.session = null;
        }
    }
}
</pre>

<p>subject 创建出来之后，暂且叫内部subject，就是<strong>把认证通过的内部subject的信息和session复制给我们外界使用的subject.login(token)的subject中（principals、host、authenticated、Session）</strong>，这个subject暂且叫外部subject，看下session的赋值，又进行了一次装饰，这次装饰则把session(类型为StoppingAwareProxiedSession，<strong>即是内部subject和session的合体)和外部subject绑定到一起</strong></p>
<h4 id="从Cookie、URL、request中根据Token获取Session"><a href="#从Cookie、URL、request中根据Token获取Session" class="headerlink" title="从Cookie、URL、request中根据Token获取Session"></a>从Cookie、URL、request中根据Token获取Session</h4><p>1、客户端请求到来，调用AbstractShiroFilter中的doFilterInternal方法，创建Subject</p>
<pre><code>final Subject subject = createSubject(request, response);
</code></pre><p>2、调用WebSubject.Builder().buildWebSubject方法</p>
<pre><code>protected WebSubject createSubject(ServletRequest request, ServletResponse response) {
    return new WebSubject.Builder(getSecurityManager(), request, response).buildWebSubject();
}
</code></pre><p>3、创建WebSubject与默认的Subject稍微有差别，但还是调用父类（即Subject接口的Builder中的BuildSubject方法）</p>
<pre><code>public WebSubject buildWebSubject() {
        Subject subject = super.buildSubject();
        if (!(subject instanceof WebSubject)) {
            String msg = &quot;Subject implementation returned from the SecurityManager was not a &quot; +
                    WebSubject.class.getName() + &quot; implementation.  Please ensure a Web-enabled SecurityManager &quot; +
                    &quot;has been configured and made available to this builder.&quot;;
            throw new IllegalStateException(msg);
        }
        return (WebSubject) subject;
    }
</code></pre><p>4、父类的buildSubject方法，将创建Subject的方法委托为SecurityManager</p>
<pre><code>public Subject buildSubject() {
    return this.securityManager.createSubject(this.subjectContext);
}
</code></pre><p>5、DefaultSecurityManager的createSubject</p>
<pre><code>public Subject createSubject(SubjectContext subjectContext) {
    SubjectContext context = copy(subjectContext);
    context = ensureSecurityManager(context);
    context = resolveSession(context);
    context = resolvePrincipals(context);
    Subject subject = doCreateSubject(context);
    save(subject);
    return subject;
}
</code></pre><p>6、resolveSession(context)解析Session，context.resolveSession()返回的是null，调用Session session = resolveContextSession(context)尝试获取Session</p>
<pre><code>protected SubjectContext resolveSession(SubjectContext context) {
    //①
    if (context.resolveSession() != null) {
        log.debug(&quot;Context already contains a session.  Returning.&quot;);
        return context;
    }
    try {
        //Context couldn&apos;t resolve it directly, let&apos;s see if we can since we have direct access to 
        //the session manager:
        //②
        Session session = resolveContextSession(context);
        if (session != null) {
            context.setSession(session);
        }
    } catch (InvalidSessionException e) {
        log.debug(&quot;Resolved SubjectContext context session is invalid.  Ignoring and creating an anonymous &quot; +
                &quot;(session-less) Subject instance.&quot;, e);
    }
    return context;
}
</code></pre><p>7、具体看resolveContextSession，调用getSessionKey(context)</p>
<pre><code>protected Session resolveContextSession(SubjectContext context) throws InvalidSessionException {
    SessionKey key = getSessionKey(context);
    if (key != null) {
        return getSession(key);
    }
    return null;
}
</code></pre><p>8、DefaultWebSecurityManager重写getSessionKey(SubjectContext context)方法</p>
<pre><code>protected SessionKey getSessionKey(SubjectContext context) {
    if (WebUtils.isWeb(context)) {
        Serializable sessionId = context.getSessionId();
        ServletRequest request = WebUtils.getRequest(context);
        ServletResponse response = WebUtils.getResponse(context);
        return new WebSessionKey(sessionId, request, response);
    } else {
        return super.getSessionKey(context);

    }
}
</code></pre><p>返回WebSessionKey实例，但WebSessionKey中的sessionId为null</p>
<p>9、回到第7步SessionKey key = getSessionKey(context)，此时key不为空，调用SessionSecurityManager的getSession方法（接口方法）</p>
<pre><code>public Session getSession(SessionKey key) throws SessionException {
    return this.sessionManager.getSession(key);
}
</code></pre><p>10、调用AbstractNativeSessionManager中的getSession</p>
<pre><code>public Session getSession(SessionKey key) throws SessionException {
    Session session = lookupSession(key);
    return session != null ? createExposedSession(session, key) : null;
}
</code></pre><p>11、进入到lookupSession</p>
<pre><code>private Session lookupSession(SessionKey key) throws SessionException {
    if (key == null) {
        throw new NullPointerException(&quot;SessionKey argument cannot be null.&quot;);
    }
    return doGetSession(key);
}
</code></pre><p>12、doGetSession被子类AbstractValidatingSessionManager重写</p>
<pre><code>protected final Session doGetSession(final SessionKey key) throws InvalidSessionException {
    enableSessionValidationIfNecessary();

    log.trace(&quot;Attempting to retrieve session with key {}&quot;, key);

    Session s = retrieveSession(key);
    if (s != null) {
        validate(s, key);
    }
    return s;
}
</code></pre><p>13、retrieveSession也是个抽象方法，被子类DefaultSessionManager重写，</p>
<pre><code>protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {
    Serializable sessionId = getSessionId(sessionKey);
    if (sessionId == null) {
        log.debug(&quot;Unable to resolve session ID from SessionKey [{}].  Returning null to indicate a &quot; +
                &quot;session could not be found.&quot;, sessionKey);
        return null;
    }
    Session s = retrieveSessionFromDataSource(sessionId);
    if (s == null) {
        //session ID was provided, meaning one is expected to be found, but we couldn&apos;t find one:
        String msg = &quot;Could not find session with ID [&quot; + sessionId + &quot;]&quot;;
        throw new UnknownSessionException(msg);
    }
    return s;
}
</code></pre><p>14、getSessionId被子类DefaultWebSessionManager重写</p>
<pre><code>public Serializable getSessionId(SessionKey key) {
    Serializable id = super.getSessionId(key);
    if (id == null &amp;&amp; WebUtils.isWeb(key)) {
        ServletRequest request = WebUtils.getRequest(key);
        ServletResponse response = WebUtils.getResponse(key);
        id = getSessionId(request, response);
    }
    return id;
}
</code></pre><p>由于父类的getSessionId返回null，执行getSessionId(request,response)</p>
<pre><code>protected Serializable getSessionId(SessionKey sessionKey) {
    return sessionKey.getSessionId();
}
</code></pre><p>15、DefaultWebSessionManager的getSessionId</p>
<pre><code>protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
    return getReferencedSessionId(request, response);
}
</code></pre><p>16、★★★★★★★getReferencedSessionId先解析cookie，在解析URL，最后解析</p>
<pre><code>private Serializable getReferencedSessionId(ServletRequest request, ServletResponse response) {

    String id = getSessionIdCookieValue(request, response);
    if (id != null) {
        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,
                ShiroHttpServletRequest.COOKIE_SESSION_ID_SOURCE);
    } else {
        //not in a cookie, or cookie is disabled - try the request URI as a fallback (i.e. due to URL rewriting):

        //try the URI path segment parameters first:
        id = getUriPathSegmentParamValue(request, ShiroHttpSession.DEFAULT_SESSION_ID_NAME);

        if (id == null) {
            //not a URI path segment parameter, try the query parameters:
            String name = getSessionIdName();
            id = request.getParameter(name);
            if (id == null) {
                //try lowercase:
                id = request.getParameter(name.toLowerCase());
            }
        }
        if (id != null) {
            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,
                    ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);
        }
    }
    if (id != null) {
        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);
        //automatically mark it valid here.  If it is invalid, the
        //onUnknownSession method below will be invoked and we&apos;ll remove the attribute at that time.
        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);
    }

    // always set rewrite flag - SHIRO-361
    request.setAttribute(ShiroHttpServletRequest.SESSION_ID_URL_REWRITING_ENABLED, isSessionIdUrlRewritingEnabled());

    return id;
}
</code></pre><h4 id="SubjectContext、MapContext、Map"><a href="#SubjectContext、MapContext、Map" class="headerlink" title="SubjectContext、MapContext、Map"></a>SubjectContext、MapContext、Map</h4><p>接口设计:</p>
<p><img src="http://i.imgur.com/5BjziW0.png" alt=""></p>
<p><strong>MapContext</strong>：实现了Map接口，<strong>内部拥有一个类型为HashMap的backingMap属性，大部分方法都由HashMap来实现，然后仅仅更改某些行为</strong>，<strong>MapContext没有选择去继承HashMap，而是使用了组合的方式，更加容易去扩展</strong>，如backingMap的类型不一定非要选择HashMap，可以换成其他的Map实现，一旦MapContext选择继承HashMap，如果想对其他的Map类型进行同样的功能增强的话，就需要另写一个类来继承它然后改变一些方法实现，这样的话就会有很多重复代码。这也是设计模式所强调的少用继承多用组合</p>
<pre><code>public class MapContext implements Map&lt;String, Object&gt;, Serializable {

    private static final long serialVersionUID = 5373399119017820322L;

    private final Map&lt;String, Object&gt; backingMap;

    public MapContext() {
        this.backingMap = new HashMap&lt;String, Object&gt;();
    }

    public MapContext(Map&lt;String, Object&gt; map) {
        this();
        if (!CollectionUtils.isEmpty(map)) {
            this.backingMap.putAll(map);
        }
    }
  //略
}
</code></pre><p><strong>SubjectContext</strong>接口继承了Map<string, object="">，然后加入了几个重要的SecurityManager、SessionId、Subject、PrincipalCollection、Session、boolean authenticated、boolean sessionCreationEnabled、Host、AuthenticationToken、AuthenticationInfo等众多信息。</string,></p>
<p>MapContext中增加了getTypedValue方法，便于获得参数化的类型：</p>
<pre><code>protected &lt;E&gt; E getTypedValue(String key, Class&lt;E&gt; type) {
        E found = null;
        Object o = backingMap.get(key);
        if (o != null) {
            if (!type.isAssignableFrom(o.getClass())) {
                String msg = &quot;Invalid object found in SubjectContext Map under key [&quot; + key + &quot;].  Expected type &quot; +
                        &quot;was [&quot; + type.getName() + &quot;], but the object under that key is of type &quot; +
                        &quot;[&quot; + o.getClass().getName() + &quot;].&quot;;
                throw new IllegalArgumentException(msg);
            }
            found = (E) o;
        }
        return found;
    }
</code></pre><p>可以把Map当做公有基本类，然后SubjectContext在此基础上扩展，类似于公有方法和新添加的方法；Map定义了这个类的功能是存储，SubjectContext在此基础上增加了SecurityManager、Subject、Session的存储</p>
<p>讨论1：首先是SubjectContext为什么要去实现Map<string, object="">？</string,></p>
<p>实现对数据的存储有设计方式有两种方式：<br>1、继承数据结构，如map，自然就可以调用Map的put/get方法对数据进行存储<br>2、组合方式，即类中存放一个存储型数据结构，如map，调用成员变量的put/get方法实现存储</p>
<p>ThreadContext采用采用的是组合方式，SubjectContext采用的是继承方式</p>
<p>讨论2：SubjectContext接口的作用？</p>
<p>SubjectContext提供了常用的get、set方法，还提供了一个resolve方法，以SecurityManager为例：</p>
<pre><code>SecurityManager getSecurityManager();
void setSecurityManager(SecurityManager securityManager);
SecurityManager resolveSecurityManager();
</code></pre><p>这些get、set方法则用于常用的设置和获取，而resolve则表示先调用getSecurityManager，如果获取不到，则使用其他途径来获取，如DefaultSubjectContext的实现：</p>
<pre><code>public SecurityManager resolveSecurityManager() {
    SecurityManager securityManager = getSecurityManager();
    if (securityManager == null) {
        if (log.isDebugEnabled()) {
            log.debug(&quot;No SecurityManager available in subject context map.  &quot; +
                    &quot;Falling back to SecurityUtils.getSecurityManager() lookup.&quot;);
        }
        try {
            securityManager = SecurityUtils.getSecurityManager();
        } catch (UnavailableSecurityManagerException e) {
            if (log.isDebugEnabled()) {
                log.debug(&quot;No SecurityManager available via SecurityUtils.  Heuristics exhausted.&quot;, e);
            }
        }
    }
    return securityManager;
}
</code></pre><p>如果getSecurityManager获取不到，则使用SecurityUtils工具来获取。<br>再如resolvePrincipals</p>
<pre><code>public PrincipalCollection resolvePrincipals() {
    PrincipalCollection principals = getPrincipals();

    if (CollectionUtils.isEmpty(principals)) {
        //check to see if they were just authenticated:
        AuthenticationInfo info = getAuthenticationInfo();
        if (info != null) {
            principals = info.getPrincipals();
        }
    }

    if (CollectionUtils.isEmpty(principals)) {
        Subject subject = getSubject();
        if (subject != null) {
            principals = subject.getPrincipals();
        }
    }

    if (CollectionUtils.isEmpty(principals)) {
        //try the session:
        Session session = resolveSession();
        if (session != null) {
            principals = (PrincipalCollection) session.getAttribute(PRINCIPALS_SESSION_KEY);
        }
    }

    return principals;
}
</code></pre><p>普通的getPrincipals()获取不到，尝试使用其他属性来获取。</p>
<h4 id="SubjectFactory"><a href="#SubjectFactory" class="headerlink" title="SubjectFactory"></a>SubjectFactory</h4><p><img src="http://i.imgur.com/i1mAQCJ.png" alt=""></p>
<p>DefaultSubjectFactory: 根据SubjectContext，解析出ecurityManager、Session、PrincipalCollection等信息，生成一个代理Subject：DelegatingSubject</p>
<pre><code>public Subject createSubject(SubjectContext context) {
    SecurityManager securityManager = context.resolveSecurityManager();
    Session session = context.resolveSession();
    boolean sessionCreationEnabled = context.isSessionCreationEnabled();
    PrincipalCollection principals = context.resolvePrincipals();
    boolean authenticated = context.resolveAuthenticated();
    String host = context.resolveHost();

    return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);
}
</code></pre><h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p><img src="http://i.imgur.com/Tdbme0T.png" alt=""></p>
<h4 id="★★★会话管理总结"><a href="#★★★会话管理总结" class="headerlink" title="★★★会话管理总结"></a>★★★会话管理总结</h4><p>1、服务器刚启动时，创建Subject，其Principal、Session为空<br>2、用户登录，调用Subject.login获取用户信息，创建Session，在Session中存入Principal信息，更新Subject中的Session、Principal<br>3、下次用户携带Token登录，恢复Session，取出Principal，建立带状态信息的Subject</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>导入依赖</p>
<pre><code>&lt;!--shiro与ehcache整合--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;
    &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;!--1.3.2--&gt;
&lt;/dependency&gt;
&lt;!--ehcache,纯Java开源缓存框架--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
    &lt;version&gt;2.10.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>ehcache.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
         updateCheck=&quot;false&quot;&gt;

    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;

    &lt;!--
    Mandatory Default Cache configuration. These settings will be applied to caches
    created programmtically using CacheManager.add(String cacheName)
    --&gt;
    &lt;!--
       name:缓存名称。
       maxElementsInMemory：缓存最大个数。
       eternal:对象是否永久有效，一但设置了，timeout将不起作用。
       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。
       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
       maxElementsOnDisk：硬盘最大缓存个数。
       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
       clearOnFlush：内存数量最大时是否清除。
    --&gt;
    &lt;defaultCache
            maxElementsInMemory=&quot;10000&quot;
            eternal=&quot;false&quot;
            timeToIdleSeconds=&quot;120&quot;
            timeToLiveSeconds=&quot;120&quot;
            overflowToDisk=&quot;true&quot;
            maxElementsOnDisk=&quot;10000000&quot;
            diskPersistent=&quot;false&quot;
            diskExpiryThreadIntervalSeconds=&quot;120&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;
    /&gt;

    &lt;cache name=&quot;shiro&quot;
           maxEntriesLocalHeap=&quot;2000&quot;
           eternal=&quot;false&quot;
           timeToIdleSeconds=&quot;600&quot;
           timeToLiveSeconds=&quot;600&quot;
           overflowToDisk=&quot;false&quot;
           statistics=&quot;true&quot;&gt;
    &lt;/cache&gt;
&lt;/ehcache&gt;
</code></pre><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>根据应用场景的不同，目前实现开放授权的方法分为两种：一种是使用OAuth协议；另一种是使用IAM服务</p>
<ul>
<li>OAuth协议主要适用于针对个人用户对资源的开放授权，比如Google的用户Alice允许别的应用程序（如Facebook）访问他的联系人列表</li>
<li>IAM它的特点是”预先授权”或”离线授权”，客户端通过REST API去访问资源，资源所有者可以预先知道第三方应用所需的资源请求，一次授权之后，很少会更改。<strong>IAM服务一般在云计算服务中使用</strong>，如阿里云计算服务</li>
</ul>
<h4 id="OAuth-角色"><a href="#OAuth-角色" class="headerlink" title="OAuth 角色"></a>OAuth 角色</h4><p>资源拥有者（resource owner）：能 <strong>授权</strong> 访问受保护资源的一个实体，可以是一个人，我们称之为最终用户，如新浪微博用户、zhangsan</p>
<p>资源服务器（resource server）：存储受保护资源，客户端通过 access token 请求资源，资源服务器响应受保护资源给客户端，存储着用户 zhangsan 的微博等信息</p>
<p>授权服务器（authorization server）：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（Access Token）给客户端</p>
<p>客户端（client）：如新浪微博客户端、微格等第三方应用，也可以是它自己的官方应用，其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来/提交到服务器。”客户端”术语不代表任何特定实现（如应用运行在一台服务器、桌面、手机或其他设备）</p>
<h4 id="OAuth2-协议流程"><a href="#OAuth2-协议流程" class="headerlink" title="OAuth2 协议流程"></a>OAuth2 协议流程</h4><p><img src="http://i.imgur.com/z8GVJj9.png" alt=""></p>
<p>1、客户端从 <strong>资源拥有者</strong> 那请求授权。授权请求可以直接发给资源拥有者，或间接的通过授<br>权服务器这种中介，后者更可取。（我们常会看到跳出弹框，是否允许第三方授权，需要用户决定是否同意）<br>2、客户端收到一个 <strong>授权许可</strong>，代表资源服务器提供的授权<br>3、客户端使用它自己的私有证书及授权许可到 <strong>授权服务器</strong> 验证<br>4、如果验证成功，则下发一个 <strong>访问令牌</strong><br>5、客户端使用访问令牌向 <strong>资源服务器</strong> 请求受保护资源<br>6、资源服务器会验证访问令牌的有效性，如果成功则下发受保护资源</p>
<h4 id="无状态-Web-应用集成"><a href="#无状态-Web-应用集成" class="headerlink" title="无状态 Web 应用集成"></a>无状态 Web 应用集成</h4><p>在一些环境中，可能需要把 Web 应用做成无状态的，即服务器端无状态，就是说 <strong>服务器端不会存储像会话这种东西，而是每次请求时带上相应的用户名进行登录</strong>。如一些 REST 风格的 API，如果不使用 OAuth2 协议，就可以使用如 REST+HMAC 认证进行访问。</p>
<p>HMAC（Hash-based  Message  Authentication  Code）：基于散列的消息认证码，使用一个密钥和一个消息作为输入，生成它们的消息摘要。注意该密钥只有客户端和服务端知道，其他第三方是不知道的。</p>
<p>访问时使用该消息摘要进行传播，服务端然后对该消息摘要进行验证。如果只传递用户名+密码的消息摘要， 一旦被别人捕获可能会重复使用该摘要进行认证。解决办法如：</p>
<p>1、每次客户端申请一个 Token，然后使用该 Token 进行加密，而该 Token 是一次性的，即<br>只能用一次；有点类似于 OAuth2 的 Token 机制，但是简单些；<br>2、客户端每次生成一个唯一的 Token，然后使用该 Token 加密，这样服务器端记录下这些<br>Token，如果之前用过就认为是非法请求</p>
<h2 id="权限实例"><a href="#权限实例" class="headerlink" title="权限实例"></a>权限实例</h2><p><a href="http://www.360doc.com/content/14/0529/10/11298474_381933566.shtml#" target="_blank" rel="external">http://www.360doc.com/content/14/0529/10/11298474_381933566.shtml#</a></p>
<h3 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h3><p>有一个用户管理系统，注册的用户分为<strong>normal用户，manager用户，admin用户</strong>，有<strong>系统管理、用户管理、角色管理</strong>三类操作，我们规定：</p>
<ul>
<li>admin 可以访问 <code>/admin/**</code></li>
<li>manager 可以访问 <code>/admin/user/**</code></li>
<li>normal 可以访问 <code>/admin/role/**</code></li>
</ul>
<p>用户 admin 拥有 admin、manager、normal 三种角色，可以访问<code>/admin/**</code>，<code>/admin/user/**</code>,<code>/admin/role/**</code>的资源</p>
<p>用户 zhangsan 拥有 manager、normal 两种角色，可以访问 <code>/admin/user/**</code>，<code>/admin/role/**</code></p>
<p>用户 lisi 拥有 normal 角色，可以访问 <code>/admin/role/**</code></p>
<p><strong>权限是应用程序的一些基本操作，角色是权限的集合</strong></p>
<p>我们采用下面的逻辑创建权限表结构（不是绝对的，根据需要修改）</p>
<p><strong><em>用户与角色关系：多对多</em></strong><br>一个用户可以有多种角色（normal,manager,admin等等）<br>一个角色可以有多个用户（user1,user2,user3等等）</p>
<p><strong><em>角色与权限关系：多对多</em></strong><br>一个角色可以有多个权限（save,update,delete,query等等）<br>一个权限可以属于多个角色</p>
<p><img src="http://i.imgur.com/O5fa7S2.png" alt=""></p>
<h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>我们创建五张表：</p>
<p>tb_user用户表：设置了3个用户</p>
<pre><code>+----+-----------+----------------------------------
| id | user_name | password     
+----+-----------+----------------------------------      
|  1 | admin     | 086bad3456e2653dc05e32a77000ce87   
|  2 | zhangsan  | 39dd5dcf4b69e917f7a32233462c55d4    
|  3 | lisi      | a259a0625727a416130cdb03e6e9dfb6
+----+-----------+----------------------------------  
</code></pre><p>tb_role角色表：设置3个角色</p>
<pre><code>+----+-----------+-------------+
| id | role_name | description |
+----+-----------+-------------+
|  1 | admin     | 系统管理员  |
|  2 | manager   | 系统顾问    |
|  3 | normal    | 系统用户    |
+----+-----------+-------------+-
</code></pre><p><strong>tb_user_role用户角色表</strong>：</p>
<pre><code>+----+---------+---------+
| id | user_id | role_id |
+----+---------+---------+
|  1 | 1       | 1       |
|  2 | 1       | 2       |
|  3 | 1       | 3       |
|  4 | 2       | 2       |
|  5 | 2       | 3       |
|  6 | 3       | 3       |
+----+---------+---------+
</code></pre><p>tb_resources权限表：</p>
<pre><code>+----+---------------+------------+----------------+
| id | resource_name | permission | url            |
+----+---------------+------------+----------------+
|  1 | 系统管理      | NULL       | /admin/**      |
|  2 | 用户管理      | NULL       | /admin/user/** |
|  3 | 角色管理      | NULL       | /admin/role/** |
+----+---------------+------------+----------------+   
</code></pre><p>select * from tb_role_resource角色权限表：</p>
<pre><code>+----+---------+-------------+
| id | role_id | resource_id |
+----+---------+-------------+
|  1 |       1 |           1 |
|  2 |       2 |           2 |
|  3 |       3 |           3 |
+----+---------+-------------+
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/13/[JDK源码阅读]JDK源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/13/[JDK源码阅读]JDK源码阅读/" itemprop="url">JDK源码阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-13T09:00:00+08:00">
                2016-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JDK源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">JDK源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>//类加载根目录<br>String parent = getClass().getClassLoader().getResource(“”).getPath();</p>
<h3 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h3><p>要介绍BufferedOutputStream，我们先了解一下OutputStream类<br>抽象类OutputStream类有三个write方法</p>
<pre><code>public abstract void write(int b)
public void write(byte b[])
public void write(byte b[], int off, int len)
</code></pre><p>由上面我们可以看出第一个write方法是让子类覆盖的，而第二个人write（byte b[]）方法源代码如下</p>
<pre><code>public void write(byte b[]) throws IOException {
    write(b, 0, b.length);
}
</code></pre><p>所以可见最后处理还是调用第三个方法write(byte b[],int off,int len)，该方法源码如下：</p>
<pre><code>public void write(byte b[], int off, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||
               ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    for (int i = 0 ; i &lt; len ; i++) {
    //注意这儿，这儿其实调用前面的抽象方法write（int b）,同时还发生了自动转型
        write(b[off + i]);
    }
}
</code></pre><p>我们先不看抽象方法是如何实现的，<strong>也就是说OutputStream也具有缓存器功能，我们可以将要写入到流中的数据写到一个byte[] buf数组中，然后调用write(byte b[])或者write(byte b[], int off, int len)也可以</strong>，那为什么还要BufferedInputStream类干什么呢，他们有什么区别呢。同时我们知道BufferedInputStream类中还有一个flush()方法，在OutputStream流中没有flush()方法，这又是为什么呢？flush()是不是必须的呢，接下来看一下BufferedOutputStream类；</p>
<p>首先，BufferedOutput将OutputStream类对象作为一个构造方法的参数的。<br>首先看一下 BufferedOutputStream 类源代码</p>
<pre><code>public class BufferedOutputStream extends FilterOutputStream {

    //这儿定义了一个byte[]数组，用来充当缓存器  
    protected byte buf[]; 
    //这个变量是重点，他就是用来记录当前缓存器中的字节数量的
    protected int count; 
    //我们初始化创建一个对象的时候给了这个buf这个数组8192个字节.
    public BufferedOutputStream(OutputStream out) {
        this(out, 8192);
    }

    public BufferedOutputStream(OutputStream out, int size) {
        super(out);
        if (size &lt;= 0) {
            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
        }
      // 这儿创建一个给定大小的数组对象来充当缓存器
        buf = new byte[size];
    }

    public synchronized void write(int b) throws IOException {
        if (count &gt;= buf.length) {
            flushBuffer();
        }
        buf[count++] = (byte)b;
    }

    //该方法是重点    
    public synchronized void write(byte b[], int off, int len) throws IOException {
        //如果传进来的数组长度大于buf 数组的长度，则直接调用OutputStream对象的write方法。
        if (len &gt;= buf.length) {

            flushBuffer();
            out.write(b, off, len);
            return;
        }
        //验证BufferedOutputStream 类中buf剩下的空间能否装得下传进来的数组。如果不能则先将当前buf数组中数据写入底层io流中
        if (len &gt; buf.length - count) {
            flushBuffer();
        }
        //该处是重点，如果在当前BufferedOutputStream 类中buf数组没有满，则将传进来的数组复制到当前类对象buf数组中，同时更新count的值。
        System.arraycopy(b, off, buf, count, len);
        count += len;
   //调用flushBuffer方法也就是将不满8192个字节数组中的数据发送出去。同时将count置零。
    private void flushBuffer() throws IOException {
        if (count &gt; 0) {
            out.write(buf, 0, count);
            count = 0;
        }
    }

    //强制将buf数据中未满8192个字节的数据写入底层io中。
    public synchronized void flush() throws IOException {
        flushBuffer();
        out.flush();
    }
}
</code></pre><p>结论： </p>
<p>OutputStream的缓存器（数组）与BufferedOutputStream中类的缓存器（数组）本质是一样的，只是BufferedOutputStream类中将要写入到底层io流中的数据先 <strong>凑个整</strong>，然后再一起写入底层io流中，这样就大大<strong>节省了io操作</strong>，大大提高了io利用率，写一次io是很费资源的。这样也出现了一个问题，假设向硬盘中写入一个文件，文件最后数据比默认值8192个字节小，则BufferOutputStream就不会将这些数据写入底层io流中，造成文件缺失，因此就<strong>需要在close()前调用flush（）方法，强制将还没有装满buf数组的数据写入底层io中</strong>。同时也可以看出节点流是不用flush()方法的，而一般的处理流都会采用固定buf这种方式的，比如常用的PrintWriter里面其实操作的就是一个BufferedWriter对象，因此也需要调用flush（）方法来刷新，因为默认是不刷新的。</p>
<p>引用：<a href="http://m.blog.csdn.net/article/details?id=51355523" target="_blank" rel="external">http://m.blog.csdn.net/article/details?id=51355523</a></p>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h3><pre>
<font color="red">//复制原来的数组，长度为newLength</font>
public static <t> T[] copyOf(T[] original, int newLength) {
    return (T[]) copyOf(original, newLength, original.getClass());
}

public static <t,u> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    <font color="red">//将original复制到copy中，从originnal的0开始，copy的0开始，长度为newLength</font>
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
</t,u></t></pre>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><pre>
<font color="red">//from包括，toIndex不包括</font>
public static void sort(int[] a, int fromIndex, int toIndex) {
    rangeCheck(a.length, fromIndex, toIndex);
    sort1(a, fromIndex, toIndex-fromIndex);
}
</pre>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><pre>
public static boolean equals(int[] a, int[] a2) {
    if (a==a2)
        return true;
    if (a==null || a2==null)
        return false;

    int length = a.length;
    if (a2.length != length)
        return false;

    for (int i=0; i<length; i++)="" if="" (a[i]="" !="a2[i])" return="" false;="" true;="" }="" <="" pre="">

<h3 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h3><pre>
public static <t> List<t> asList(T... a) {
<font color="red">//生成的是内部类的ArrayList</font>
return new ArrayList<t>(a);
}

<font color="red">//内部类，add、remove没有重写（改动了数组的长度），get、set重写了（不改动数组的长度）</font>
private static class ArrayList<e> extends AbstractList<e>
implements RandomAccess, java.io.Serializable
{
    private static final long serialVersionUID = -2764017481108945198L;
    private final E[] a;

    ArrayList(E[] array) {
        if (array==null)
            throw new NullPointerException();
        a = array;
    }

    public int size() {
        return a.length;
    }

    public Object[] toArray() {
        return a.clone();
    }

    public <t> T[] toArray(T[] a) {
        int size = size();
        if (a.length < size)
            return Arrays.copyOf(this.a, size,
                     (Class<? extends T[]>) a.getClass());
        System.arraycopy(this.a, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    public E get(int index) {
        return a[index];
    }

    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        return oldValue;
    }

    public int indexOf(Object o) {
        if (o==null) {
            for (int i=0; i<a.length; i++)="" if="" (a[i]="=null)" return="" i;="" }="" else="" {="" for="" (int="" i="0;" i<a.length;="" (o.equals(a[i]))="" -1;="" public="" boolean="" contains(object="" o)="" indexof(o)="" !="-1;" <="" pre="">

<h2 id="判断两个对象是否相等"><a href="#判断两个对象是否相等" class="headerlink" title="判断两个对象是否相等"></a>判断两个对象是否相等</h2><h3 id="判断两个对象是否相等代码"><a href="#判断两个对象是否相等代码" class="headerlink" title="判断两个对象是否相等代码"></a>判断两个对象是否相等代码</h3><pre><code>public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Employee employee = (Employee) o;

    if (id != null ? !id.equals(employee.id) : employee.id != null) return false;
    if (name != null ? !name.equals(employee.name) : employee.name != null) return false;
    if (email != null ? !email.equals(employee.email) : employee.email != null) return false;
    if (hiredate != null ? !hiredate.equals(employee.hiredate) : employee.hiredate != null) return false;

    return true;
}
</code></pre><p>其中Employee有如下属性：</p>
<pre><code>public class Employee {
    private Integer id;
    private String name;
    private String email;
    private Date hiredate;
}
</code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>判断两个对象是否相等的原则：<strong><em>对象类型相同</em></strong>，而且<strong><em>属性值全部相等</em></strong></p>
<p>1、如果两个对象地址相等，两个对象一定相等</p>
<pre><code>if( this == o ) return true;
</code></pre><p>2、两个对象类型不相等，两个一定不相等</p>
<pre><code>if( getClass() != o.getClass() ) return false;
养成一个好习惯，在使用对象前判断对象o是否为空
考虑到如果比较对象o为空null，但当前对象this必然不为null，不相等，可以结合起来：
if( o == null || getClass() != o.getClass() ) return false;
</code></pre><p>3、如果两个对象所有属性相等，两个对象才相等，否则判定为不相等</p>
<pre><code>类型强转:Employee employee = (Employee) o;
如果属性不相等，return false
if( !id.equals(employee.id) ) return false;
同样，需要判断id是否为空。如果id为空，不能使用equals作为判断方法，如下
if( id == null &amp;&amp; employee.id != null || id != null &amp;&amp; !id.equals(employee.id) ) return false;
使用三目运算符让代码更加优雅：
if( id != null ? !id.equals(employee.id) : employee.id != null) return false
</code></pre><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="http://i.imgur.com/nYCSoQg.png" alt=""></p>
<p>从图中可以看出 HashMap 的底层就是一个数组结构，数组中的每一项又是一个链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">transient Entry&lt;K,V&gt;[] table;  </div><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;  </div><div class="line">	final K key;     //键</div><div class="line">	V value;         //值</div><div class="line">	Entry&lt;K,V&gt; next; //指向下一个节点  </div><div class="line">	int hash;        //散列值</div><div class="line">	</div><div class="line">	Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </div><div class="line">		value = v;  </div><div class="line">		next = n;  </div><div class="line">		key = k;  </div><div class="line">		hash = h;  </div><div class="line">	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap有一个属性是Entry的数组table。Entry就是table数组中的元素，Map.Entry保存一个键值对<br>和这个键值对持有指向下一个键值对的引用，如此就构成了链表了</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>一些属性：</p>
<ul>
<li>capacity：数组的长度，默认是16</li>
<li>loadFactor：HashMap元素的个数除以数组的长度，当元素个数大于threshold时，需要扩容。默认负载因子是0.75</li>
<li>threashold：数组的长度乘以负载因子，当元素大于threshold时，需要扩容。默认threshold = 16*0.75 = 12</li>
<li>size：HashMap中元素的个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**根据指定容量和负载因子构造HashMap*/   </div><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    if (initialCapacity &lt; 0)  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +  </div><div class="line">                                           initialCapacity);  </div><div class="line">	/**</div><div class="line">	 * 数组最大容量是 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30，即32位最大2的整数次</div><div class="line">	 * 如果传入初始容量太大，真实设置的的最大</div><div class="line">	 */</div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)  </div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;  </div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +  </div><div class="line">                                           loadFactor);  </div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 找到大于给出的初始容量的2的乘方</div><div class="line">	 */</div><div class="line">    // Find a power of 2 &gt;= initialCapacity  </div><div class="line">    int capacity = 1;  </div><div class="line">    while (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= 1;  </div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 负载因子是链表的长度除以数组的长度，当链表的长度大于threshold时，需要扩容</div><div class="line">	 */</div><div class="line">    this.loadFactor = loadFactor;  </div><div class="line">    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);  </div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 初始化 Entry 数组</div><div class="line">	 */</div><div class="line">    table = new Entry[capacity];  </div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 空函数，子类可扩展</div><div class="line">	 */</div><div class="line">    init();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/**根据指定的容量和默认的负载因子构造HashMap*/  </div><div class="line">public HashMap(int initialCapacity) &#123;  </div><div class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">//默认的空的构造器  </div><div class="line">public HashMap() &#123;  </div><div class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);  </div><div class="line">&#125;  </div><div class="line">/**通过指定一个Map对象进行构造*/  </div><div class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;  </div><div class="line">    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,  </div><div class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);  </div><div class="line">    putAllForCreate(m);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p>当存入的key是null的时候将调用putForNUllKey方法，暂时将这段逻辑放一边，看key不为null的情况。先调用了hash(int h)方法获取了一个hash值。<br><br></p>
<font color="red"><strong>遍历table[i]上的元素，如果存在键相等，则替换它的值。否则以头插法的方式插入链表</strong></font>

<p>之后判断size是否到达了需要扩充table数组容量的界限并让size自增1，如果达到了则调用resize(int capacity)方法将数组容量拓展为原来的两倍。</p>
<pre>
public V put(K key, V value) {  
    // HashMap允许存放null键和null值。  
    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  
    if (key == null)  
        return putForNullKey(value);  
    <font color="red">// 根据key的keyCode重新计算hash值。 </font> 
    int hash = hash(key);//注意这里的实现是jdk1.7和以前的版本有区别的  
    <font color="red">// 搜索指定hash值在对应table中的索引。</font>  
    int i = indexFor(hash, table.length);  
    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。如果键的Hash值一样，而且equal相等  
    for (Entry<k,v> e = table[i]; e != null; e = e.next) {  
        Object k;  
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  
            V oldValue = e.value;  
            e.value = value;  
            e.recordAccess(this);  
            return oldValue;  
        }  
    }  
    // 如果i索引处的Entry为null，表明此处还没有Entry。  
    modCount++;  
    // 将key、value添加到i索引处。  
    addEntry(hash, key, value, i);  
    return null;  
}  

/**
 * <font color="red">采用头插法，即使头结点是空也没有关系！！</font>
 * 数组上的元素为刚插入的节点
 */
void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry<k,v> e = table[bucketIndex];
    table[bucketIndex] = new Entry<k,v>(hash, key, value, e);
    if (size++ >= threshold)
        resize(2 * table.length);
}
</k,v></k,v></k,v></pre>

<p><strong>为什么要进行两次Hash？</strong></p>
<p>防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占4个字节，即32位。根据这32位值进行移位、异或运算得到一个值。</p>
<p><strong>如何确定元素在数组的位置？</strong></p>
<pre><code>static int indexFor(int h, int length) {
    return h &amp; (length-1);     
}
</code></pre><p>这样可以保证结果的最大值是length-1，而且均匀分布在数组中，异或的操作效率比取余的效率高</p>
<p><strong>HashMap中如何判断两个键相等？</strong></p>
<p>两个对象的HashCode相等， 而且equals相等。所以如果使用对象的作为键，需要重写HashCode和equals方法</p>
<p>String已经重写了HashCode，String中的数据结构是char[] s，Hash 值的计算方法是 s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + ….. + s[0]*31^0</p>
<p>可以采用迭代的方法计算：h = h * 31 + s[i]</p>
<pre><code>int h = 0;
for(int i = 0; i &lt; n; i++){
    h = h * 31 + s[i];
}
</code></pre><p><strong>链表扩容</strong></p>
<p>当链表内元素大于threashold时，新建一个新的数组，数组长度变成原来的两倍，并将原来的元素复制到新数组上</p>
<pre>
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    // 这个if块表明，如果容量已经到达允许的最大值，即MAXIMUN_CAPACITY，则不再拓展容量，而将装载拓展的界限值设为计算机允许的最大值。
    // 不会再触发resize方法，而是不断的向map中添加内容，即table数组中的链表可以不断变长，但数组长度不再改变
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    // 创建新数组，容量为指定的容量
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    // 设置下一次需要调整数组大小的界限
    threshold = (int)(newCapacity * loadFactor);
}
</pre>

<p>将old数组上的元素复制到新数组上的操作在transfer上完成，主要步骤是：</p>
<ul>
<li>遍历原来的Entry数组</li>
<li>遍历链表</li>
<li>将链表元素依次按照插入到新的数组中(头插法)，<font color="red"><strong>链表反置</strong></font></li>
</ul>
<pre>
void transfer(Entry[] newTable) {
    // 保留原数组的引用到src中，
    Entry[] src = table;
    // 新容量使新数组的长度
    int newCapacity = newTable.length;
    // 遍历原数组
    for (int j = 0; j < src.length; j++) {
        // 获取元素e
        Entry<k,v> e = src[j];
        if (e != null) {
            // 将原数组中的元素置为null
            src[j] = null;
            // 遍历原数组中j位置指向的链表
            do {
                Entry<k,v> next = e.next;
                // 根据新的容量计算e在新数组中的位置
                int i = indexFor(e.hash, newCapacity);
                // 将e插入到newTable[i]指向的链表的头部
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
</k,v></k,v></pre>

<p><strong>HashMap允许键null、值null，怎么处理？</strong></p>
<p>从源码可以看到，key为null的对象放在数组<strong>索引0的位置</strong>。<strong>put的方式和put普通元素一样</strong>，首先遍历链表，是否有相同key的元素，如果有则替换并返回原来的值。否则头插入的方式将元素插入链表</p>
<pre>
private V putForNullKey(V value) {
    for (Entry<k,v> e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
</k,v></pre>

<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">	/**</div><div class="line">	 * 如果key为null，从table[0]所在的链表进行搜索，如果存在元素且元素的key为null，返回元素的值；如果之前没有传入key为null的元素，那么返回null</div><div class="line">	 */</div><div class="line">    if (key == null)</div><div class="line">        return getForNullKey();</div><div class="line">    int hash = hash(key.hashCode());</div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != null;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">            return e.value;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法分为key为null和不为null两块。先看不为null的情况。先获取key的hash值，之后通过hash值及table.length获取key对应的table数组的索引，遍历索引的链表，所找到key相同的元素，则返回元素的value，否者返回null。不为null的情况调用了getForNullKey()方法。</p>
<pre><code>private V getForNullKey() {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null)
            return e.value;
    }
    return null;
}
</code></pre><p>参考：<a href="http://www.cnblogs.com/hzmark/archive/2012/12/24/HashMap.html" target="_blank" rel="external">http://www.cnblogs.com/hzmark/archive/2012/12/24/HashMap.html</a></p>
<h3 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h3><p>containsKey(Object key)方法很简单，只是判断getEntry(key)的结果是否为null，是则返回false，否返回true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean containsKey(Object key) &#123;</div><div class="line">    return getEntry(key) != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getEntry(Object key)也没什么内容，只是根据key对应的hash值计算在table数组中的索引位置，然后遍历该链表判断是否存在相同的key值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</div><div class="line">    int hash = (key == null) ? 0 : hash(key.hashCode());</div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != null;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            return e;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h3><p>判断一个value是否存在比判断key是否存在还要简单，就是遍历所有元素判断是否有相等的值。这里分为两种情况处理，value为null何不为null的情况，但内容差不多，只是判断相等的方式不同。</p>
<pre>
public boolean containsValue(Object value) {
    if (value == null)
            return containsNullValue();

    Entry[] tab = table;
    for (int i = 0; i < tab.length ; i++)
        for (Entry e = tab[i] ; e != null ; e = e.next)
            <font color="red">if (value.equals(e.value))</font>
                return true;
    return false;
}

private boolean containsNullValue() {
    Entry[] tab = table;
    for (int i = 0; i < tab.length ; i++)
        for (Entry e = tab[i] ; e != null ; e = e.next)
            <font color="red">if (e.value == null)</font>
                return true;
    return false;
}
</pre>

<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><pre><code>public V remove(Object key) {
    Entry&lt;K,V&gt; e = removeEntryForKey(key);
    return (e == null ? null : e.value);
}
</code></pre><p>看这个方法，removeEntryKey(key)的返回结果应该是被移除的元素，如果不存在这个元素则返回为null。remove方法根据removeEntryKey返回的结果e是否为null返回null或e.value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</div><div class="line">    int hash = (key == null) ? 0 : hash(key.hashCode());</div><div class="line">    int i = indexFor(hash, table.length);</div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">    while (e != null) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            if (prev == e)</div><div class="line">                table[i] = next;</div><div class="line">            else</div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(this);</div><div class="line">            return e;</div><div class="line">        &#125;</div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</a.length;></t></e></e></t></t></t></pre></length;></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/11/[Java]基于Token的身份验证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/[Java]基于Token的身份验证/" itemprop="url">基于 Token 的身份验证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T10:50:00+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么要身份验证"><a href="#为什么要身份验证" class="headerlink" title="为什么要身份验证"></a>为什么要身份验证</h2><p>可能你会说，不是有登录接口吗，输入用户名、密码，身份验证通过就可以跳到下一个页面，很简单啊！</p>
<p>但是，HTTP 是一种没有状态的协议，也就是它并不知道用户是否已经登录验证过。这里我们把用户看成是客户端（可以是浏览器、Android、IOS等），客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求访问其他服务器接口的时候，还得再验证一下，<font color="red"><strong>否则的话用户就可以跳过登录页面，直接访问其他服务器接口，登录就失去了意义</strong></font></p>
<h2 id="传统身份验证方法"><a href="#传统身份验证方法" class="headerlink" title="传统身份验证方法"></a>传统身份验证方法</h2><p>Cookie+Session的存在主要是为了解决HTTP这一无状态协议下服务器如何识别用户的问题。当用户请求登录的时候，如果验证通过，<font color="red"><strong>在服务端创建一个session</strong></font>，session中记录一下登录的用户信息，<font color="red"><strong>然后把这个session的 sessionid 号发送给客户端</strong></font>，客户端收到以后把这个 sessionid 号存储在 Cookie 里，<font color="red"><strong>下次这个用户再向服务端发送请求的时候带着这个 Cookie</strong></font> ，这样服务端会根据 Cookie 里的sessionid恢复session，<font color="red"><strong>看看session中是否存有用户信息</strong></font>，如果是，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端</p>
<p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端创建一个守护程序定期的去清理过期的 Session</p>
<h2 id="基于-Token-的身份验证方法"><a href="#基于-Token-的身份验证方法" class="headerlink" title="基于 Token 的身份验证方法"></a>基于 Token 的身份验证方法</h2><p>使用基于 Token 的身份验证方法，<strong>在服务端不需要存储用户的登录记录</strong>。大概的流程是这样的：</p>
<p>1、客户端使用用户名和密码请求登录<br>2、服务端收到请求，去验证用户名与密码<br>3、验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端<br>4、客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br>5、客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br>6、服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
<p>比起传统的身份验证方法，Token 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：</p>
<ul>
<li>header</li>
<li>payload</li>
<li>signature</li>
</ul>
<p><strong>中间用点分隔开</strong>，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：</p>
<pre>
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<font color="red" style="font-weight:bold">.</font>eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ<font color="red" style="font-weight:bold">.</font>SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</pre>

<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><strong>header</strong> 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。</p>
<pre><code>{
    &quot;typ&quot;: &quot;JWT&quot;,
    &quot;alg&quot;: &quot;HS256&quot;
}
</code></pre><p>上面的内容要用 Base64 的形式编码一下，所以就变成这样：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
</code></pre><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：</p>
<ul>
<li>iss：Issuer，发行者</li>
<li>sub：Subject，主题</li>
<li>aud：Audience，观众</li>
<li>exp：Expiration time，过期时间</li>
<li>nbf：Not before</li>
<li>iat：Issued at，发行时间</li>
<li>jti：JWT ID</li>
</ul>
<p>比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。</p>
<pre><code>{
    &quot;iss&quot;: &quot;ninghao.net&quot;,
    &quot;exp&quot;: &quot;1438955445&quot;,
    &quot;name&quot;: &quot;wanghao&quot;,
    &quot;admin&quot;: true
}
</code></pre><p>使用 Base64 编码以后就变成了这个样子：</p>
<pre><code>eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ
</code></pre><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，<strong>这个密码秘密地存储在服务端</strong>。</p>
<ul>
<li>header</li>
<li>payload</li>
<li>secret</li>
</ul>
<pre><code>var encodedString = base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload); 
HMACSHA256(encodedString, &apos;secret&apos;);
</code></pre><p>处理完成以后看起来像这样：</p>
<pre><code>SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</code></pre><p>最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc
</code></pre><p>客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源</p>
<h2 id="JWT库下载"><a href="#JWT库下载" class="headerlink" title="JWT库下载"></a>JWT库下载</h2><p>官网下载<br><a href="https://jwt.io/#libraries-io" target="_blank" rel="external">https://jwt.io/#libraries-io</a></p>
<h3 id="JJWT"><a href="#JJWT" class="headerlink" title="JJWT"></a>JJWT</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h4><pre><code>import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.impl.crypto.MacProvider;
import java.security.Key;

// We need a signing key, so we&apos;ll create one just for this example. Usually the key would be read from your application configuration instead.
Key key = MacProvider.generateKey();

String compactJws = Jwts.builder()
  .setSubject(&quot;Joe&quot;)
  .signWith(SignatureAlgorithm.HS512, key)
  .compact();
</code></pre><h4 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h4><p>1、判断JWT是否有效<br>2、JWT中个数据是否正确，比如判断Subject是否为Joe</p>
<pre><code>try {

    Jwts.parser().setSigningKey(key).parseClaimsJws(compactJws);    
    //OK, we can trust this JWT

} catch (SignatureException e) {

    //don&apos;t trust the JWT!
}
</code></pre><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p>基于 Token 的身份验证(<a href="http://ninghao.net/blog/2834" target="_blank" rel="external">http://ninghao.net/blog/2834</a>)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/11/[网络安全]运输层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/[网络安全]运输层/" itemprop="url">运输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T00:00:00+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h3><pre><code>计算机网络最基本的问题:
● 两个实体怎样才能在一种会丢失或损坏数据的介质上可靠得通信
● 控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复出来

运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（Logic Communication）。通过逻辑，运行不同进程的主机好像直接相连一样，实际上这些主机也许位于地球的两侧，通过很多路由器及都中不同类型的链路相连

运输层协议实在端系统中而不是在网络路由器中实现的。
    1、在发送方，运输层将接收到的来自发送应用程序的报文分成较小的块，并为每块加上一个运输层首部。在发送方端系统中，运输层将这些报文段传递给网络层，网络层再将其分装成网络层分组，并向目的地发送。
    2、在接收方，网络层从数据报中提取出运输层报文段，并将该报文段向上交给运输层。运输层则处理接受到的报文段，使得接受方应用程序可应用该报文段中的数据

运输层TCP和UDP的分组称为报文段，网络层分组称为数据报

网络层协议叫ip，全程是网际协议，IP为主机之间提供了逻辑通信，IP的服务模型是尽力而为交付服务。他不确保报文段的交付，不保证报文段的按序交付，更不保证报文段中的数据完整性。所以IP成为不可靠服务。

★★★
UDP提供的服务：进程间数据交付、差错检测（运输层最低限度的两个服务，也是UDP仅有的两个服务）
TCP提供附加服务：提供可靠数据传输（流量控制，序号，确认，定时器等技术）、拥塞控制
</code></pre><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><pre><code>接收主机中的运输层并没有直接将数据交付给进程，而是通过一个中间的套接字来传递。接收主机上可能有多个套接字，每个套接字都有唯一的标识符。在运输层报文段设置几个字段，接收端检查这些字段并标识出接收套接字。

1、从源主机发送报文段
    ● 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解
    ● 从源主机的不同套接字中收集数据块，并为每个数据块分装上首部信息从而生成报文段，然后将报文段传递到网络的工作称为多路复用

2、目的主机接受报文段
    ● 报文段达到目的主机，根据报文段上的端口号定位到相应进程的套接字（多路分解）
    ● 运输层收集套接字输出的数据形成运输层报文段（多路复用）

运输层多路复用的要求：
    ❶ 套接字有唯一标识符
    ❷ 每个报文段有特殊字段（源端口、目的端口）来指示该报文段要交付的套接字

● UDP套接字由一个包含目的IP地址和目的端口号的二元组来标识，如果两个UDP报文段有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字定向到相同的目的进程

● TCP套接字由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识，两个不同源IP地址或或源端口号的TCP报文会被定向到两个不同的套接字
</code></pre><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>UDP只是做了运输协议能够做的最少工作，除了多路复用/多路分解功能及一些轻型差错检测，它几乎没有对IP增加别的东西

问题：有些应用程序更适合用UDP，而不是提供可靠数据传输服务的TCP？
答：
    ● 应用层能更好地控制要发送的数据和发送时间。应用层将数据交给UDP，UDP就会在数据上附上多路复用/多路分解所需的源端口号和目的端口号，及两个其他字段，并立即将其传递给网络层。而TCP有一个拥塞控制机制，当链路非常拥塞时，遏制运输层TCP发送方，同时TCP会重新发送报文段知道目的主机收到此报文并加以确认，而不管可靠交付时间需要多长。实时应用通常要求最快的发送速率，能容忍一些数据丢失
    ● 无需连接确立。TCP在数据传输之前需要经过三次握手，UDP却不需要任何准备即可进行数据传输
    ● 无连接状态。TCP需要在端系统中维护连接状态，连接状态包括接受和发送缓存、拥塞控制参数、序号与确认好的参数。UDP不维护连接状态
    ● 分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8个字节的开销

★★★
UDP应用可以实现可靠数据传输，通过在应用程序自身中建立可靠性机制（例如增加确认和重传机制来实现）。这会增加开发人员的工作，但应用程序可以进行可靠通信，而无需受制于TCP拥塞控制机制引起的传输速率约束。
</code></pre><h3 id="UDP报文结构"><a href="#UDP报文结构" class="headerlink" title="UDP报文结构"></a>UDP报文结构</h3><p><img src="http://img.blog.csdn.net/20160406154258808" alt="UDP报文结构"></p>
<pre><code>UDP首部只有四个字段，每个字段由两个字节组成[源端口号、目的端口号、长度、校验和]，共8个字节，应用层数据占用UDP报文段的数据字段。
    ● 源端口和目的端口是执行多路复用/多路分解的必备条件
    ● 接受主机使用校验和来检查报文段是否存在差错
    ● 长度字段包括首部在内的UDP报文长度，字节为单位
</code></pre><h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><h3 id="构建可靠数据传输协议"><a href="#构建可靠数据传输协议" class="headerlink" title="构建可靠数据传输协议"></a>构建可靠数据传输协议</h3><p><img src="http://img.blog.csdn.net/20160406161249976" alt="这里写图片描述"></p>
<pre><code>1、完全可靠信道上的可靠数据传输：rdt1.0
    最简单的情况，底层信道是完全可靠的。
    图3.9显示了rdt1.0发送方和接收方的有限状态机。初始状态用虚线表示。
    ● rdt的发送方通过rdt_send(data)从高层接收数据，产生一个包含该数据的分组（make_pkt(data)）,并且将数据发送到信道中。状态回到等待状态。
    ● 接收方，rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中取出数据(经extract(packet,data)动作)，并将数据上传给高层（通过deliver_data(data)动作）
</code></pre><p><img src="http://img.blog.csdn.net/20160407072723981" alt="这里写图片描述"></p>
<pre><code>2、具有比特差错信道上的可靠数据传输：rdt2.0
    考虑你自己是怎样通过电话口述一条长消息：报文接受者听到、明白每句话都会说OK；如果听到依据含糊不清的话，他可能要求你重复那句话。这种口述消息协议使用了肯定确认（OK），否定确认（请重复一遍）。这些控制报文使得接收方可以让发送方知道哪些内容被正确接受，哪些内容有误需要重传。计算机网络中，基于这种重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议。
    ARQ协议处理比特差错：
        ● 差错检测
        ● 接收方反馈：肯定确认（ACK），否定确认（NAK）
        ● 重传
    当rdt_send(data)事件发生时，发送方将产生一个包含待发送数据的分组(sndpkt)，然后经由udp_send(pkt)发送该分组，状态跳转到等待接收方的ACK或NAK分组。如果收到数据包且收到一个ACK，则发送方知道最近传输的分组已被正确接收，状态跳转到等待上层数据状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方的响应。
    如果发送一个数据包出现差错，则发送方将会一直重传该数据包，直到接收到ACK。这种行为也成为停等协议
    接收方当分组到达时，接收方根据分组是否受损回答ACK或NAK

    缺陷：如果ACK或NAK分组受损，发送方无法知道是否正确接收了上一块发送的数据（如果发送数据包后没收到ACK或NAK，则状态一直停留在等待ACK或NAK中）
    解决方法：当发送方收到含糊不清的ACK或NAK分组时，只需重新发送当前数据分组即可。但这会引入冗余分组，会造成接收方无法判断接收到的分组是新的还是一次重传。
</code></pre><p><img src="http://img.blog.csdn.net/20160407105631251" alt="这里写图片描述">   <img src="http://img.blog.csdn.net/20160407105648095" alt="这里写图片描述"> </p>
<pre><code>rdt2.1解决了这个问题，在数据分组中添加一个序号字段，对于停等协议，1比特序号就足够了，前后接受的序号相同则代表是重传分组。
发送方初始状态处于等待来自上层的调用0状态。当事件rdt_send(data)发生时，生成一个序号为0的数据包，向信道发送数据，状态跳转到等待序号为0的数据的ACK或NAK。如果正确接收到一个数据包，但数据包受损或是NAK，则继续等待，直到接收到的数据包没有损坏而且是ACK，说明0号数据包已经被正常接收，状态跳转到等待发送数据包1的状态。之后同理。
在接收方，初始状态为等待数据包0的状态。如果收到的数据包破损，则向发送方发送一个NAK。或者你现在想收到序号为0的数据包，但发送过来一个序号为1的数据包，说明发送方重发了数据包1，则发送一个ACK。因为是重发，所以不需要提取数据包中的数据。如果正确接收到序号为0的分组，则提取出数据，传送给上层，并想发送方发送一个ACK，告知已经成功接收数据包0，状态跳转到等待接收序号为1的数据包。之后同理。
</code></pre><p><img src="http://img.blog.csdn.net/20160407110607754" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160407110946553" alt="这里写图片描述">   </p>
<pre><code>rdt2.2接收到受损的分组，发送一个对上次正确接受的分组的ACK。发送方接收到对同一个分组的两个ACK（冗余ACK），就知道接收方没有正确接收到跟在被确人两次的分组后面的分组。
当发送方处于等待来自上层的调用0的状态时，rdt_send(data)事件发生，生成一个序号为0的数据包，通过udt_send(sndpkt)将数据发送到信道。状态跳转到等待序号为0的数据包的ACK。如果接收到为受损的ACK数据包，状态跳转到等待发送序号为1的数据包的状态。如果收到受损的数据包，或数据包的序号不为0（确认的是之前的序号，则当前发送的数据包接收方没有正确被接收），则继续处于等待序号为0的数据包的ACK。之后同理。
在接收方，注意到初始化时oncethru = 0，如果发送方第一个数据包出现错误，则接收方一直将处于等待来自下层的0这个状态，不用发累计确认ACK。当接收到的数据包没有受损，而且刚好是等待的序号为0的分组，接收方提取出分组的数据，传递给上层，然后向发送方发送序号为0的ACK，通知发送方已经成功接受序号为0的分组，状态跳转到等待序号为1的数据包这个状态。如果之前的情况，向发送方发送序号为0的ACK出现损坏，则发送方会再次发送一个序号为0的数据包。这种情况下接收方会重新发送之前的确认包，告知发送方数据包已经接受，防止重复接受，接收方也就不需要提取数据包的消息。除了重发的情况，如果接受到破损数据，也将重新发送之前的确认包，接收方就知道确认包之后的数据没有被正确接受。之后又同理。
</code></pre><p> <img src="http://img.blog.csdn.net/20160407224831968" alt="这里写图片描述"> </p>
<pre><code>3.具有比特差错的丢包信道上的可靠数据传输：rdt 3.0 
    rdt2.2已经解决了发生丢包后该做些什么，通过检验和、序号、ACK分组和重传等方式。现在需要解决的问题是怎样检测丢包。
    我们让发送方负责检测和恢复丢包。假定发送方传输一个数据分组，该分组丢失或该分组的ACK丢失，这样发送方收不到来自接收方的响应。如果发送方愿意等待足够长的时间以便确认分组已丢失，则只需重传该数据分组即可。
    从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失、一个ACK丢失，还是该分组或ACK只是过度时延，所有的情况采取的动作都是同样的：重传。为了实现基于时间的重传机制，需要一个倒计数定时器，在一个给定的时间过期后，可中断发送方。
    状态图：初始状态为等待来自上层的调用0状态，当事件rdt_send(data)发生时，生成一个序号为0的数据包，发送到信道，同时启动定时器，状态跳转到等待数据包0的ACK。如果正确无差错的ACK，则数据包0成功被接收，停止计时器，状态跳转到等待上次调用发送序号为1的数据包。若在等待ACK 0的时候，收到受损数据包，或者收到序列为1的ACK（说明当前发送的数据包没有成功接收），需要重传数据包，但先不发送，等到计数器超时后再发送（因为是基于定时器的重发机制），并且重新开启定时器，状态仍为等待ACK 0.在等待来自上层的调用1的时候，此时已经完成数据的接收，但为什么会收到回复？因为如果超时时间过短，会出现过早超时的情形，发送方间隔发送两个相同的数据包，同时连个数据包都得到了回应ACK，会选择接收第一个ACK，第二个则忽略。
</code></pre><p><img src="http://img.blog.csdn.net/20160407231948479" alt="这里写图片描述"></p>
<h3 id="流水线可靠数据传输"><a href="#流水线可靠数据传输" class="headerlink" title="流水线可靠数据传输"></a>流水线可靠数据传输</h3><pre><code>允许发送方发送多个分组而无需等待确认，这种技术称为流水线。
● 必须增加序号范围，每个传输的分组必须有一个唯一的序号
● 协议的发送方和接收方必须缓存多个分组
● 所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式，解决流水线的差错恢复有两种基本的方法：回退N步和选择重传
</code></pre><h3 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h3><p><img src="http://img.blog.csdn.net/20160408103441813" alt="这里写图片描述"></p>
<pre><code>[0，base-1]内的序号对应于已经发送并确认过的分组，[base，nextseqnum-1]内的序号对应于已经发送，但未被确认的分组。[nextseqnum，base+N-1]内的序号可用于那些要被立即发送的分组，其数据来自上层。
那些已经被发送但还未被确认的分组的序号范围可以看成是一个在序号范围内长度为N的窗口，并且随着协议的运行，该窗口在序好空间向前滑动，因此N常被称为窗口长度，GBN协议被称为滑动窗口协议
</code></pre><p><img src="http://img.blog.csdn.net/20160408110239599" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160408110310178" alt="这里写图片描述"></p>
<pre><code>GBN发送方必须响应以下三种类型的事件：
● 上层的调用。当上层调用rdt_send()，发送方首先检查发送窗口是否已满。如果未满则创建一个分组将其发送，变量也响应的更新。如果窗口已满，发送方将数据返回给上层，通知上次该窗口已满，然后上层可能会过一会再试 
●
●
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/08/[数据结构与算法]算法4笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/08/[数据结构与算法]算法4笔记/" itemprop="url">算法4笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-08T19:07:00+08:00">
                2016-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>Scanner in = new Scanner(System.in);
Scanner cin = new Scanner(new BufferedInputStream(System.in)); //加Buffer可能会快一些 
</code></pre><p>Scanner类提供了非常丰富的成员函数来负责读取各种数据类型:</p>
<pre>
构造函数
                <font color="red">BigInteger(String val)</font>
                将 BigInteger 的十进制字符串表示形式转换为 BigInteger。
返回值              成员函数
<font color="red">String          next(String pattern)</font>
                    如果下一个标记与从指定字符串构造的模式匹配，则返回下一个标记,
                    如果参数为空,就是读取一个字符串
BigDecimal      nextBigDecimal()
                    将输入信息的下一个标记    +扫描为一个 BigDecimal。
BigInteger      nextBigInteger()
                    将输入信息的下一个标记扫描为一个 BigInteger。
boolean         nextBoolean()
                    扫描解释为一个布尔值的输入标记并返回该值。
byte            nextByte()
                    将输入信息的下一个标记扫描为一个 byte。
double          nextDouble()
                    将输入信息的下一个标记扫描为一个 double。
float           nextFloat()
                    将输入信息的下一个标记扫描为一个 float。
<font color="red">int             nextInt()</font>
                    将输入信息的下一个标记扫描为一个 int。
<font color="red">String          nextLine()</font>
                    此扫描器执行当前行，并返回跳过的输入信息。
long            nextLong()
                    将输入信息的下一个标记扫描为一个 long。
short           nextShort()
</pre>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>System.out.print(); // cout &lt;&lt; …;
System.out.println(); // cout &lt;&lt; … &lt;&lt; endl;
System.out.printf(); // 与C中的printf用法类似.
</code></pre><pre>
例：
System.out.printf("%d%10.5f\n", a, b); // 输入b为字宽为10，右对齐，保留小数点后5位，<font color="red">四舍五入</font>.
</pre>


<p>规格化的输出：</p>
<pre><code>函数：
// 这里0指一位数字，#指除0以外的数字(如果是0，则不显示),四舍五入.
DecimalFormat fd = new DecimalFormat(&quot;#.00#&quot;);
DecimalFormat gd = new DecimalFormat(&quot;0.000&quot;);
System.out.println(&quot;x =&quot; + fd.format(x));
System.out.println(&quot;x =&quot; + gd.format(x))
</code></pre><p>DecimalFormat详细：</p>
<p>符号含义：</p>
<pre><code>0 一个数字
# 一个数字，不包括 0
. 小数的分隔符的占位符
, 分组分隔符的占位符
; 分隔格式。
- 缺省负数前缀。
% 乘以 100 和作为百分比显示
? 乘以 1000 和作为千进制货币符显示；用货币符号代替；如果双写，用
国际货币符号代替。如果出现在一个模式中，用货币十进制分隔符代
替十进制分隔符。
X 前缀或后缀中使用的任何其它字符，用来引用前缀或后缀中的特殊字符。
</code></pre><p>例子：    </p>
<pre><code>public class TestNumberFormat {
    public static void main(String[] args) {

        double pi = 3.1415926;

        // 取一位整数:3
        System.out.println(new DecimalFormat(&quot;0&quot;).format(pi));

        // 取一位整数和两位小数:3.14
        System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi));

        // 取两位整数和三位小数，整数不足部分以0填补:03.142
        System.out.println(new DecimalFormat(&quot;00.000&quot;).format(pi));

        // 取所有整数部分:3
        System.out.println(new DecimalFormat(&quot;#&quot;).format(pi));

        // 以百分比方式计数，并取两位小数:314.16%
        System.out.println(new DecimalFormat(&quot;#.##%&quot;).format(pi));

        long c = 299792458;

        //显示为科学计数法，并取五位小数:2.99792E8
        System.out.println(new DecimalFormat(&quot;#.#####E0&quot;).format(c));

        //显示为两位整数的科学计数法，并取四位小数:29.9792E7 
        System.out.println(new DecimalFormat(&quot;00.####E0&quot;).format(c));

        //每三位以逗号进行分隔:299,792,458
        System.out.println(new DecimalFormat(&quot;,###&quot;).format(c));

        //将格式嵌入文本
        System.out.println(new DecimalFormat(&quot;光速大小为每秒,###米。&quot;).format(c));

        System.out.println(&quot;**************************************************&quot;);

        double d = 299792458.546;

        System.out.println(new DecimalFormat(&quot;#.00&quot;).format(d));
    }
}
</code></pre><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><pre><code>String st = Integer.toString(num, base); // 把num当做10进制的数转成base进制的st(base &lt;= 35).
Integer.toHexString(255)//ff，16进制
int num = Integer.parseInt(st, base); // 把st当做base进制，转成10进制的int(parseInt有两个参数,第一个为要转的字符串,第二个为说明是什么进制). 
BigInterget m = new BigInteger(st, base); // st是字符串，base是st的进制.
</code></pre><p>1、如果要将一个大数以2进制形式读入 可以使用 <code>cin.nextBigInteger(2);</code><br>当然也可以使用其他进制方式读入；<br>2、如果要将一个大数转换成其他进制形式的字符串 使用 <code>cin.toString(2);</code> //将它转换成2进制表示的字符串</p>
<h2 id="Arrays-sort-Collections-sort"><a href="#Arrays-sort-Collections-sort" class="headerlink" title="Arrays.sort / Collections.sort"></a>Arrays.sort / Collections.sort</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>在 JDK 类库中，有一部分类实现了 Comparable 接口，如 Integer、Double 和 String 等。<br>Comparable 接口有一个 <code>comparTo(Object o)</code> 方法，它返回整数类型</p>
<ul>
<li>如果返回值为0，则表示 x 和 y 相等</li>
<li>如果返回值大于0，则表示 x 大于 y</li>
<li>如果返回值小于0，则表示 x 小于 y</li>
</ul>
<p>TreeSet 集合调用对象的 compareTo() 方法比较集合中的大小，注意了不是 TreeSet 调用它自己的 comparTo() 方法而是<strong>它调用集合中对象的 comparTo() 方法</strong>。TreeSet类本身并没有实现 Comparable 接口，然后<font color="red"><strong>进行升序排列</strong></font>，这种方式称为自然排序。</p>
<p>JDK类库中实现了Comparable接口的一些类的排序方式 </p>
<ul>
<li>BigDecimal、BigInteger、Byte、Double、Float、Integer、Long、Short排序方式按数字大小排序</li>
<li>Character 按字符的 Unicode 值的数字大小排序</li>
<li>String 按字符中字符的 Unicode 值排序</li>
</ul>
<p>这里一定要灰常注意:使用自然排序时只能向集合中加入同类型的对象，并且这些对象的类必须实现<strong>Comparable</strong>接口</p>
<pre>
public class Solution {

    public static void main(String[] args) {
        Set<customer> set = new TreeSet<customer>();
        Customer customer1 = new Customer("Tom", 17);
        Customer customer2 = new Customer("Tom", 16);
        Customer customer3 = new Customer("Som", 16);
        set.add(customer1);
        set.add(customer2);
        set.add(customer3);
        System.out.println(set);
    }

    public static class Customer implements Comparable {
        private String name;
        private int age;

        public Customer(String name, int age) {
            this.age = age;
            this.name = name;
        }

<font color="red">
        @Override
        public int compareTo(Object o) {
            if(o == null || !(o instanceof Customer)){
                throw new IllegalArgumentException("对象必须是Customer");
            }
            Customer other = (Customer) o;
            //先按姓名升序排序，如果姓名相等跳过
            if (!this.name.equals(other.name)) {
                return name.compareTo(other.name);
            }
            //再按年龄升序排序，如果年龄相等跳过
            if (this.age != other.age) {
                return age - other.age;
            }
            //相等
            return 0;
        }
</font>
        @Override
        public String toString() {
            return "Customer{" +
                    "age=" + age +
                    ", name='" + name + '\'' +
                    '}';
        }
    }
}

</customer></customer></pre>

<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>TreeSet 按照 Customer 对象的 name 属性进行降序排列，然后按照 age 降序，可以先创建一个实现Comparator接口的类 </p>
<pre>
public class Solution {

    public static void main(String[] args) {
        <font color="red">Set<customer> set = new TreeSet<customer>(new CustomerComparator());</customer></customer></font>
        Customer customer1 = new Customer("Tom", 17);
        Customer customer2 = new Customer("Tom", 16);
        Customer customer3 = new Customer("Som", 16);
        set.add(customer1);
        set.add(customer2);
        set.add(customer3);
        System.out.println(set);
        //结果：[Customer{age=17, name='Tom'}, Customer{age=16, name='Tom'}, Customer{age=16, name='Som'}]
    }

<font color="red">
    public static class CustomerComparator implements Comparator<customer> {

        @Override
        public int compare(Customer c1, Customer c2) {
            /*1、如果Customer实现了Comparable接口，直接调用compareTo方法
            return c1.compareTo(c2);*/

            //2、自定义比较方法，降序
            if (!c1.name.equals(c2.name)) {
                return -c1.name.compareTo(c2.name);
            }
            if (c1.age != c2.age) {
                return -(c1.age - c2.age);
            }

            return 0;
        }
    }
</customer></font>
}
</pre>

<h3 id="升序、逆序理解★★★★★"><a href="#升序、逆序理解★★★★★" class="headerlink" title="升序、逆序理解★★★★★"></a>升序、逆序理解★★★★★</h3><p>如果给定两个数A、B，按照<strong>数字大小</strong>进行排序，并且<strong>以A为基准与B比较</strong>，得到以下表达式：</p>
<ul>
<li>if ( A &gt; B ) return 1</li>
<li>if ( A &lt; B ) return -1</li>
<li>if ( A = B ) return 0</li>
</ul>
<p>三个表达式可以总结为：return A - B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] a = &#123;1, 4, 2, 3, 5&#125;;</div><div class="line">        Arrays.sort(a, new Comparator&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(Integer o1, Integer o2) &#123;</div><div class="line">                return o1 - o2;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(Arrays.toString(a));//[1, 2, 3, 4, 5]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样会按照升序排序</strong></p>
<p>如果是逆序，直接在升序的基础上<strong>加上负号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] a = &#123;1, 4, 2, 3, 5&#125;;</div><div class="line">        Arrays.sort(a, new Comparator&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(Integer o1, Integer o2) &#123;</div><div class="line">                return -(o1 - o2);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(Arrays.toString(a));//[5, 4, 3, 2, 1]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样会按照逆序排序</strong></p>
<p><strong>进一步抽象：</strong></p>
<p>如果给定两个元素A、B，<strong>按照一定规则</strong>进行排序，并且<strong>以A为基准与B比较</strong>，得到以下表达式：</p>
<ul>
<li>A在什么情况下大于B return 1</li>
<li>A在什么情况下小于B return -1</li>
<li>A在什么情况下等于B return 0</li>
</ul>
<p>之后会按照定义A、B之间的关系，得到升序的结果</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、如果 Java 类重新定义了 equals 方法,那么这个类也必须重新定义 hashCode() 方法,并且保证当两个对象用 equals 方法比较结果为 true 时,这两个对象的 hashCode() 方法的返回值相等</p>
<p>2、如果 Java 类实现了 Comparable 接口，那么这个类应该从新定义 compareTo()、equals()和hashCode()方法，保证 compareTo() 和 equals() 方法采用相同的比较规则来比较两个对象是否相等，并且保证当两个对象用 equals() 方法比较的结果为 true 时,这两个对象的 hashCode() 方法的返回值相等.</p>
<p>3、HashSet 和 HashMap 具有较好的性能，是 Set 和 Map 首选实现类，只有在需要<strong>排序</strong>的场合，才考虑使用 TreeSet 和 TreeMap。LinkedList 和 ArrayList各有优缺点，如果经常对元素执行插入和删除操作，那么可以用 LinkedList，如果经常随机访问元素，那么可以用ArrayList</p>
<p>Arrays.fill()<br>Arrays.sort()<br>Arrays.binarySearch()  </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>先按第一列升序排序，再按第二列降序排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[][] a = &#123;&#123;3,3&#125;,&#123;2,2&#125;,&#123;1,1&#125;,&#123;4,1&#125;,&#123;4,2&#125;,&#123;4,3&#125;&#125;;</div><div class="line">        int m = a.length;</div><div class="line">        int n = a[0].length;</div><div class="line"></div><div class="line">        System.out.println(&quot;排序前&quot;);</div><div class="line">        print(a);</div><div class="line">        Arrays.sort(a, new Comparator&lt;int[]&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(int[] o1, int[] o2) &#123;</div><div class="line">                /**</div><div class="line">                 * 先按第一列升序排序，再按第二列降序排序</div><div class="line">                 */</div><div class="line">                //第一列升序</div><div class="line">                if(o1[0] != o2[0])&#123;</div><div class="line">                    return o1[0] - o2[0];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //第二列降序</div><div class="line">                if(o1[1] != o2[1])&#123;</div><div class="line">                    return -(o1[1] - o2[1]);</div><div class="line">                &#125;</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(&quot;排序后&quot;);</div><div class="line">        print(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void print(int[][] a) &#123;</div><div class="line">        int m = a.length;</div><div class="line">        int n = a[0].length;</div><div class="line">        for (int i = 0; i &lt; m; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; n; j++) &#123;</div><div class="line">                System.out.print(a[i][j] + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>排序前
3 3 
2 2 
1 1 
4 1 
4 2 
4 3 
排序后
1 1 
2 2 
3 3 
4 3 
4 2 
4 1 
</code></pre><p>集合中元素实现Comparable进行<strong>升序排序</strong>，先按照姓名升序排序，再按照年龄顺序排序</p>
<pre><code>public class Solution {

    public static void main(String[] args) {
        List&lt;Customer&gt; lists = new ArrayList&lt;Customer&gt;();
        lists.add(new Customer(&quot;Tom&quot;, 17));
        lists.add(new Customer(&quot;Tom&quot;, 16));
        lists.add(new Customer(&quot;Som&quot;, 16));
        lists.add(new Customer(&quot;Rom&quot;, 17));
        //排序
        Collections.sort(lists);
        //输出
        System.out.println(lists);//[Customer{age=17, name=&apos;Rom&apos;}, Customer{age=16, name=&apos;Som&apos;}, Customer{age=16, name=&apos;Tom&apos;}, Customer{age=17, name=&apos;Tom&apos;}]
    }

    public static class Customer implements Comparable {
        private String name;
        private int age;

        public Customer(String name, int age) {
            this.age = age;
            this.name = name;
        }

        @Override
        public int compareTo(Object o) {
            if(o == null || !(o instanceof Customer)){
                throw new IllegalArgumentException(&quot;对象必须是Customer&quot;);
            }
            Customer other = (Customer) o;
            //先按姓名升序排序，如果姓名相等跳过
            if (!this.name.equals(other.name)) {
                return name.compareTo(other.name);
            }
            //再按年龄升序排序，如果年龄相等跳过
            if (this.age != other.age) {
                return age - other.age;
            }
            //相等
            return 0;
        }

        @Override
        public String toString() {
            return &quot;Customer{&quot; +
                    &quot;age=&quot; + age +
                    &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                    &apos;}&apos;;
        }
    }
}
</code></pre><p><strong>逆序排序</strong></p>
<pre><code>Collections.sort(lists,Collections.&lt;Customer&gt;reverseOrder());
</code></pre><p>原理：</p>
<pre><code>public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {
    return c2.compareTo(c1);
}
</code></pre><p><strong>自定义排序方法</strong></p>
<pre><code>Collections.sort(lists,new CustomerComparator());

public class CustomerComparator implements Comparator&lt;Customer&gt; {

    @Override
    public int compare(Customer c1, Customer c2) {
        //先按name升序，再按age降序
        if (!c1.name.equals(c2.name)) {
            return c1.name.compareTo(c2.name);
        }
        if (c1.age != c2.age) {
            return -(c1.age - c2.age);
        }

        return 0;
    }
}
</code></pre><h3 id="Map排序"><a href="#Map排序" class="headerlink" title="Map排序"></a>Map排序</h3><p>TreeMap传入Comparator，按键排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(</div><div class="line">	new Comparator&lt;String&gt;() &#123;</div><div class="line">	    public int compare(String obj1, String obj2) &#123;</div><div class="line">	        // 降序排序</div><div class="line">	        return obj2.compareTo(obj1);</div><div class="line">	    &#125;</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p><strong>还有一种通用的排序方法</strong>，调用Map.entrySet()得到Set<map.entry<k,v>&gt;集合，然后转化为ArrayList，调用Collection的Sort方法进行排序，可以自由选择根据Key还是根据Value进行排序</map.entry<k,v></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class HashMapTest &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">        map.put(&quot;c&quot;, &quot;ccccc&quot;);</div><div class="line">        map.put(&quot;a&quot;, &quot;aaaaa&quot;);</div><div class="line">        map.put(&quot;b&quot;, &quot;bbbbb&quot;);</div><div class="line">        map.put(&quot;d&quot;, &quot;ddddd&quot;);</div><div class="line">        </div><div class="line">        List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());</div><div class="line">        Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123;</div><div class="line">            //升序排序</div><div class="line">            public int compare(Entry&lt;String, String&gt; o1,</div><div class="line">                    Entry&lt;String, String&gt; o2) &#123;</div><div class="line">                return o1.getValue().compareTo(o2.getValue());</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        for(Map.Entry&lt;String,String&gt; mapping:list)&#123; </div><div class="line">               System.out.println(mapping.getKey()+&quot;:&quot;+mapping.getValue()); </div><div class="line">          &#125; </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="Bignteger"><a href="#Bignteger" class="headerlink" title="Bignteger"></a>Bignteger</h3><pre>
返回值                   成员函数
BigInteger              add(BigInteger val)
                        返回其值为 (this + val) 的 BigInteger。 

BigInteger              subtract(BigInteger val)
                        返回其值为 (this - val) 的 BigInteger。

BigInteger              multiply(BigInteger val)
                        返回其值为 (this * val) 的 BigInteger。

BigInteger              divide(BigInteger val)
                        返回其值为 (this / val) 的 BigInteger。

BigInteger              mod(BigInteger m)
                        返回其值为 (this mod m) 的 BigInteger。

int                     compareTo(BigInteger val)
                           将此 BigInteger 与指定的 BigInteger 进行比较。
                        如果和val相等返回0,小于返回-1,大于返回1

BigInteger              pow(int exponent)
                        返回其值为 (this exponent) 的 BigInteger。

String                  toString()
                        返回此 BigInteger 的十进制字符串表示形式。

String                  toString(int radix)
                        返回此 BigInteger 的给定基数的字符串表示形式。

static BigInteger       valueOf(long val)
                        返回其值等于指定 long 的值的 BigInteger。

BigInteger              gcd(BigInteger val)
                        返回一个 BigInteger，其值是 abs(this) 和 abs(val) 的最大公约数。

BigInteger              abs()
                        返回其值是此 BigInteger 的绝对值的 BigInteger。

int                     hashCode()
                        返回此 BigInteger 的哈希码。

boolean                 isProbablePrime(int certainty)
                        如果此 BigInteger 可能为素数，则返回 true，如果它一定为合数，则返回 false。

BigInteger              nextProbablePrime()
                        返回大于此 BigInteger 的可能为素数的第一个整数。

int                     signum()
                        返回此 BigInteger 的正负号函数。

除了以上成员函数,BigInteger还有几个非常常用的属性

BigInteger.ZERO             BigInteger 的常量 0。
BigInteger.ONE              BigInteger 的常量 1。
BigInteger.TEN              BigInteger 的常量 10。
</pre>

<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><pre><code>返回值                   成员函数
BigDecimal              add(BigDecimal augend)
                        返回一个 BigDecimal，其值为 (this + augend)。

BigDecimal              subtract(BigDecimal subtrahend)
                        返回一个 BigDecimal，其值为 (this - subtrahend)。

BigDecimal              multiply(BigDecimal multiplicand)
                        返回一个 BigDecimal，其值为 (this × multiplicand).

BigDecimal              divide(BigDecimal divisor)
                        返回一个 BigDecimal，其值为 (this / divisor).

BigDecimal              pow(int n)
                        返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。

int                     compareTo(BigDecimal val)
                        将此 BigDecimal 与指定的 BigDecimal 比较。

static BigDecimal       valueOf(double val)
                        使用 Double.toString(double) 方法提供的 double 规范的字符串
                        表示形式将 double 转换为 BigDecimal。

BigDecimal              stripTrailingZeros()
                        返回数值上等于此小数，但从该表示形式移除所有尾部零的 BigDecimal。

String                  toPlainString()
                        返回不带指数字段的此 BigDecimal 的字符串表示形式。

String                  toString()
                        返回此 BigDecimal 的字符串表示形式，如果需要指数，则使用科学记数法。

BigDecimal              abs()
                        返回 BigDecimal，其值为此 BigDecimal 的绝对值，其标度为 this.scale()。

int                     hashCode()
                        返回此 BigDecimal 的哈希码。

int                     signum()
                        返回此 BigDecimal 的正负号函数。
BigInteger的三个重要属性,BigDecimal同样也有,这里就不再复述了.
</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre>
返回值                   成员函数
char                    charAt(int index)
                        返回指定索引处的 char 值。

char[]                  <font color="red">toCharArray() </font>
                        将此字符串转换为一个新的字符数组。 

String                  substring(int beginIndex)
                        返回一个新的字符串，它是此字符串的一个子字符串。

String                  substring(int beginIndex, int endIndex)
                        返回一个新字符串，它是此字符串的一个子字符串。

int                     length()
                        返回此字符串的长度。

String                  toLowerCase()
                        使用默认语言环境的规则将此 String 中的所有字符都转换为小写。

String                  toUpperCase()
                        使用默认语言环境的规则将此 String 中的所有字符都转换为大写。

int                     compareTo(String anotherString)
                        按字典顺序比较两个字符串。

String                  concat(String str)
                        将指定字符串联到此字符串的结尾。

boolean                 contains(CharSequence s)
                        当且仅当此字符串包含 char 值的指定序列时，才返回 true。

int                     hashCode()
                        返回此字符串的哈希码。

boolean                 startsWith(String prefix)
                        测试此字符串是否以指定的前缀开始。

boolean                 endsWith(String suffix)
                        测试此字符串是否以指定的后缀结束。

String                  trim()
                        返回字符串的副本，忽略前导空白和尾部空白。
</pre>

<h2 id="书本源代码"><a href="#书本源代码" class="headerlink" title="书本源代码"></a>书本源代码</h2><p><a href="http://algs4.cs.princeton.edu/code/" target="_blank" rel="external">http://algs4.cs.princeton.edu/code/</a></p>
<h2 id="算法与数据结构课程介绍"><a href="#算法与数据结构课程介绍" class="headerlink" title="算法与数据结构课程介绍"></a>算法与数据结构课程介绍</h2><ul>
<li>算法是解决问题的方法</li>
<li>数据结构是存储数据的方法</li>
</ul>
<h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><p><img src="http://i.imgur.com/GDFtowZ.png" alt=""></p>
<p>第一部分内容：</p>
<ul>
<li>基本数据类型（栈stack、队列queue、背包bag、并查集union-find、优先队列priority queue）</li>
<li>排序方法（快排quicksort、归并mergesort、堆排序heapsort、基数排序radix sorts）</li>
<li>查找（二叉排序树BST、binary search trees，红黑二叉排序树，red-black BST、哈希表hash table）</li>
</ul>
<p>第二部分内容：</p>
<ul>
<li>图算法（BFS、DFS、Prim、Kruskal、Dijkstra）</li>
<li>字符串（KMP、regular expressions，TST、Huffman、LZW）</li>
<li>高级算法（B-tree、suffix array，maxflow）</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>算法4 1.1 1.2</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>递归总有一个最简单的情况——方法的第一条语句总是一个包含return的条件语句</li>
<li>递归调用总是去尝试解决一个<strong><em>规模更小的子问题</em></strong>，这样递归才能收敛到最简单的情况</li>
<li>递归调用的父问题和尝试解决的子问题之间<strong><em>不应该有交集</em></strong>，比如两个子问题各自操作的数组部分是不同的</li>
</ul>
<h2 id="欧几里德算法"><a href="#欧几里德算法" class="headerlink" title="欧几里德算法"></a>欧几里德算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>计算两个<strong><em>非负整数</em></strong> p和q的最大公约数：若q是0，则最大公约数是p；否则p除以q得到余数r，p和q的最大公约数即为q和r的最大公约数</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>保证p和q为非负，<strong><em>p和q的大小无要求</em></strong></p>
<pre><code>public static int gcd(int p, int q){
    if(q == 0) return p;
    return gcd(q, p%q);
}
</code></pre><h2 id="判断一个数是否是素数"><a href="#判断一个数是否是素数" class="headerlink" title="判断一个数是否是素数"></a>判断一个数是否是素数</h2><ul>
<li>如果一个数只能被除了1和本身的数整除，那个这个数就是素数</li>
<li>遍历从2开始，不大于N的平方根，<strong><em>注意是&lt;=</em></strong></li>
<li>2是最小的素数，小于2的数字肯定不是素数</li>
</ul>
<pre><code>public static boolean isPrime(int N){
    if(N &lt; 2) return false;
    for(int i = 2; i*i &lt;= N; i++)
        if(N % i == 0) return false;
    return true;
}
</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>固定长度栈</p>
<pre><code>public class FixedCapacityStack&lt;Item&gt;{

    private Item[] items;
    //top指向栈顶元素后一位，top = 0表示空栈，也表示栈中元素个数
    private Integer top;

    public FixedCapacityStack(Integer cap){
        items = (Item[]) new Object[cap];
        top = 0;
    }

    public void push(Item item){
        items[top++] = item;
    }

    public Item pop(){
        return items[--top];
    }

    public Integer size(){
        return top;
    }

    public boolean isEmpty(){
        return top == 0;
    }

    public void traverse(){
        for(int i = 0; i &lt; top; i++){
            System.out.print(items[i] + &quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><p>算法1.1 下压（LIFO）栈（能够动态调整数组大小的实现）</p>
<pre><code>public class ResizingArrayStack&lt;Item&gt;{

    private Item[] items = (Item[]) new Object[1];
    //top指向栈顶元素后一位，top = 0表示空栈，也表示栈中元素个数
    private Integer top = 0;

    public void push(Item item){
        //栈满了
        if(top == items.length){
            resize(2*items.length);
        }
        items[top++] = item;
    }

    public Item pop(){
        Item item = items[--top];
        //避免对象游离
        items[top] = null;
        //减少长度，使用率不会低于1/4
        if(top &gt; 0 &amp;&amp; top == items.length/4) resize(items.length/2);
        return item;
    }

    public void resize(Integer length){
        Item[] temp = (Item[]) new Object[length];
        //赋值
        for(int i = 0; i &lt; top; i++){
            temp[i] = items[i];
        }
        items = temp;
    }

    public Integer size(){
        return top;
    }

    public boolean isEmpty(){
        return top == 0;
    }

    public void traverse(){
        for(int i = 0; i &lt; top; i++){
            System.out.print(items[i] + &quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><p>算法1.2 下压堆栈（链表实现）</p>
<pre><code>public class Stack&lt;Item&gt; {
    private Node top = null;
    private Integer N = 0;

    private class Node{
        //定义了节点的嵌套类
        Item item;
        Node next;
    }

    public void push(Item item){
        Node old = top;
        top = new Node();
        top.item = item;
        top.next = old;
        N++;
    }

    public Item pop(){
        Item item = top.item;
        top = top.next;
        N--;
        return item;
    }

    public Integer size(){
        return N;
    }

    public boolean isEmpty(){
        return N == 0;//或top == null
    }

    public void traverse(){
        Node p = top;
        while(p != null){
            System.out.print(p.item + &quot; &quot;);
            p = p.next;
        }
        System.out.println();
    }
}
</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>算法1.3 先进先出队列</p>
<pre><code>public class Queue&lt;Item&gt; {
    //队头
    private Node first;
    //队尾
    private Node last;
    //元素个数
    private int N;

    private class Node{
        private Item item;
        private Node next;
    }

    public void enqueue(Item item){
        Node old = last;
        last = new Node();
        last.item = item;
        last.next = null;
        //队列为空时处理first指针
        if(isEmpty())
            first = last;
        else
            old.next = last;
        N++;
    }

    public Item dequeue(){
        Item item = first.item;
        first = first.next;
        //队列为空时处理last指针
        if(isEmpty())
            last = null;
        N--;
        return item;
    }

    public boolean isEmpty(){
        return first == null;
    }

    public Integer size(){
        return N;
    }

    public void traverse(){
        Node p = first;
        while(p != null){
            System.out.print(p.item + &quot; &quot;);
            p = p.next;
        }
        System.out.println();
    }
}
</code></pre><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>选择排序</p>
<pre><code>int[] a = {5, 4, 3, 2, 1};
int n = a.length;
for (int i = 0; i &lt; n - 1; i++) {
    int min = i;
    for (int j = i + 1; j &lt; n; j++) {
        //min为下标，不要搞错
        if (a[j] &lt; a[min]) {
            min = j;
        }
    }
    if (min != i) {
        int t = a[min];
        a[min] = a[i];
        a[i] = t;
    }
}
System.out.println(Arrays.toString(a));
</code></pre><p>插入排序</p>
<pre><code>int[] a = {5, 4, 3, 2, 1};
int n = a.length;
//1 ~ n-1，执行n-1次
for (int i = 1; i &lt; n; i++) {
    int j = i - 1;
    int t = a[i];
    //j &gt;=0 要放在前面
    while (j &gt;= 0 &amp;&amp; t &lt; a[j]) {
        a[j + 1] = a[j];
        j--;
    }
    a[j + 1] = t;
}
System.out.println(Arrays.toString(a));
</code></pre><p>冒泡排序</p>
<pre><code>int[] a = {5, 4, 3, 2, 1};
int n = a.length;
for (int i = 0; i &lt; n - 1; i++) {
    //j的范围为从n-2 ~ 0
    for (int j = 0; j &lt; n - 1 - i; j++) {
        if (a[j] &gt; a[j + 1]) {
            int t = a[j];
            a[j] = a[j + 1];
            a[j + 1] = t;
        }
    }
}
System.out.println(Arrays.toString(a));
</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种基于分治技术的排序算法，思想核心是选择一个基准元素X将待排序元素分成两个子序列，使得一个子序列中的元素均小于等于X,而另一个子序列中的元素均大于X,处于其终端所处在的位置上。</p>
<p>或者你也可以打个比喻，想象一下，假设r为主元素，J元素为前方开路元素,和主元素进行比较，如果大于主元素则继续开路 ，如果小于主元素则I元素加1之后和J元素交换之后，J元素继续开路直到最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class QUICKSORT &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] a = &#123;10,9,8,7,6,5,4,4,3,2,1,0,-1,-2,-3&#125;;</div><div class="line">        quicksort(a, 0, a.length - 1);</div><div class="line">        System.out.println(Arrays.toString(a));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void quicksort(int[] a, int p, int q) &#123;</div><div class="line">        if (p &lt; q) &#123;</div><div class="line">            int r = partition(a, p, q);</div><div class="line">            quicksort(a, p, r - 1);</div><div class="line">            quicksort(a, r + 1, q);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static int partition(int[] a, int p, int q) &#123;</div><div class="line">        int i = p - 1;</div><div class="line">        for (int j = p; j &lt; q; j++) &#123;</div><div class="line">            //注意是&lt;=</div><div class="line">            if (a[j] &lt;= a[q]) &#123;</div><div class="line">                swap(a, ++i, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap(a, ++i, q);</div><div class="line">        return i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void swap(int[] a, int i, int j) &#123;</div><div class="line">        int temp = a[i];</div><div class="line">        a[i] = a[j];</div><div class="line">        a[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>public class MergeSort extends SortTemplate {

    Comparable[] copy = new Comparable[50];

    @Override
    public void sort() {
        doMergeSort(a, 0, a.length-1);
    }

    private void doMergeSort(Comparable[] a, int low, int high) {
        if (low &lt; high) {
            int mid = low + (high - low) / 2;
            doMergeSort(a, low, mid);
            doMergeSort(a, mid + 1, high);
            merge(a, low, mid, high);
        }
    }

    private void merge(Comparable[] a, int low, int mid, int high) {
        int i = low, j = mid + 1;
        for(int t = low; t &lt;= high;t++){
            copy[t] = a[t];
        }
        for (int k = low; k &lt;= high; k++) {
            if (i &gt; mid) {
                a[k] = copy[j++];
            } else if (j &gt; high) {
                a[k] = copy[i++];
            } else if (copy[i].compareTo(copy[j]) &lt; 0) {
                a[k] = copy[i++];
            } else {
                a[k] = copy[j++];
            }
        }
    }

    public static void main(String[] args) {
        Comparable[] a = new Integer[]{1, 2, 3, 1, 2, 3, 4};
        MergeSort s = new MergeSort();
        s.merge(a, 0, 2, a.length - 1);
    }
}
</code></pre><h2 id="全排序"><a href="#全排序" class="headerlink" title="全排序"></a>全排序</h2><h3 id="不去重递归"><a href="#不去重递归" class="headerlink" title="不去重递归"></a>不去重递归</h3><p>全排列可以看做固定前i位，对第i+1位之后的再进行全排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution&lt;T&gt; &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Solution&lt;Character&gt; s = new Solution&lt;Character&gt;();</div><div class="line">        Character[] a = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125;;</div><div class="line">        s.permutation(a, 0, a.length - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void permutation(T[] a, int l, int r) &#123;</div><div class="line">        if (l == r) &#123;</div><div class="line">            for (int i = 0; i &lt; a.length; i++) &#123;</div><div class="line">                System.out.print(a[i]);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = l; i &lt;= r; i++) &#123;</div><div class="line">                swap(a, i, l);//把第i个和第l进行交换  </div><div class="line">                permutation(a, l + 1, r);</div><div class="line">                swap(a, i, l);//交换回来</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void swap(T[] a, int i, int l) &#123;</div><div class="line">        T t = a[i];</div><div class="line">        a[i] = a[l];</div><div class="line">        a[l] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="全排列的去重递归算法"><a href="#全排列的去重递归算法" class="headerlink" title="全排列的去重递归算法"></a>全排列的去重递归算法</h3><p>序列有时候可能有重复的字符，当需要输出去重全排列时，就可以采取以下方法：<br>当第i位与i+n位交换时，i到i+n位中不能有与i+n位相同的字符<br>比如说23560678,当第三位5与第六位6交换时，中间不能有6，这里有6所以不进行交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Solution&lt;T&gt; &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Solution&lt;Character&gt; s = new Solution&lt;Character&gt;();</div><div class="line">        Character[] a = &#123;&apos;a&apos;, &apos;a&apos;, &apos;c&apos;, &apos;d&apos;&#125;;</div><div class="line">        s.permutation(a, 0, a.length - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void permutation(T[] a, int l, int r) &#123;</div><div class="line">        if (l == r) &#123;</div><div class="line">            for (int i = 0; i &lt; a.length; i++) &#123;</div><div class="line">                System.out.print(a[i]);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = l; i &lt;= r; i++) &#123;</div><div class="line">                if (comparesub(a, l, i)) &#123;</div><div class="line">                    swap(a, i, l);</div><div class="line">                    permutation(a, l + 1, r);</div><div class="line">                    swap(a, i, l);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //比较函数,[l,i)中是否有与i的值相等得数</div><div class="line">    private boolean comparesub(T[] a, int l, int i) &#123;</div><div class="line">        for (int k = l; k &lt; i; k++) &#123;</div><div class="line">            if(a[k] == a[i])&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void swap(T[] a, int i, int l) &#123;</div><div class="line">        T t = a[i];</div><div class="line">        a[i] = a[l];</div><div class="line">        a[l] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="二维动态规划（未编程实现，下次看的时候弄）"><a href="#二维动态规划（未编程实现，下次看的时候弄）" class="headerlink" title="二维动态规划（未编程实现，下次看的时候弄）"></a>二维动态规划（未编程实现，下次看的时候弄）</h3><pre><code>度度熊最近对全排列特别感兴趣,对于1到n的一个排列,度度熊发现可以在中间根据大小关系插入合适的大于和小于符号(即 &apos;&gt;&apos; 和 &apos;&lt;&apos; )使其成为一个合法的不等式数列。但是现在度度熊手中只有k个小于符号即(&apos;&lt;&apos;&apos;)和n-k-1个大于符号(即&apos;&gt;&apos;),度度熊想知道对于1至n任意的排列中有多少个排列可以使用这些符号使其为合法的不等式数列。 
输入描述:
输入包括一行,包含两个整数n和k(k &lt; n ≤ 1000)
输出描述:
输出满足条件的排列数,答案对2017取模。
</code></pre><p>解析：</p>
<p>当有1～n-1个数字的全排列，增加数字n后，进行全排列，全排列的过程可以看做将数字n插入到1~n-1数字中间</p>
<p>插入一个数字n后可能会使小于号的个数发生变化，比如数字1，2，增加数字3。如果是312，小于号数字没有变化；如果是123，小于号数字增加1</p>
<p>所以满足条件的个数的变化与 长度和小于号的个数相关</p>
<p><strong>先考虑长度：</strong><br>当长度增加1时，长度的变化但是结果的变化可以用dp[i]、dp[i-1]的变化表示，其中i表示当前长度，dp[i]表示满足条件的结果。即下标是状态，数组值是结果</p>
<p><strong>再考虑小于号个数：</strong><br>只考虑长度是一维动态规划，再考虑小于号的个数就是二维动态规划，并在一维的基础上修改，求 dp[i][?] 与 dp[i-1][?] 之间的关系</p>
<p>当长度增加1时，小于号的个数可能不变，也可能增加1，所以上述公式可以转化为dp[i][j]与dp[i-1][j]、dp[i-1][j-1]之间的关系  </p>
<p>dp[i][j]表示长度为i，小于号为j时，满足条件的个数</p>
<p><strong>公式解释</strong>，用的来说是比较长度为i和长度i-1之间的关系，即dp[i]与dp[i-1]之间的关系，还需增加小于号的变化，添加状态值j，长度加1后j可能不变，也可能增加，最终结果为求dp[i][j]与dp[i-1][j]、dp[i-1][j-1]之间的关系 </p>
<p>比如1<3>2<br>✔ 将数字4放在最左边，因为4比所有数字都大，会引入一个大于号，小于号不变<br>✔将数字4放在最右边，因为4比所有数字都大会引入一个小于号<br>✔放在中间<br>☞ 如果放在小于号的位置，1<4>3&gt;2，小于号不变，会新增一个大于号<br>☞ 如果放在大于号的位置1<3<4>2，大于号不变，会增加一个小于号</3<4></4></3></p>
<p>dp[i][j]与dp[i-1][j]数量的变化，对应上述小于号数量不变的情况，即放在最左边和放在小于号的位置，即dp[i][j]=(j+1)*dp[i-1][j]</p>
<p>dp[i][j]与dp[i-1][j-1]数量的变化，对应上述小于号增加1的情况，即放在最右边和放在大于号的位置。有i-1个数有i-2个符号，有i-2-(j-1)个大于号，即i-j-1个大于号，再加上放在最右边的1个，有i-j种放法，即dp[i][j]=(i-j)*dp[i-1][j-1]</p>
<p>两种情况汇总</p>
<ul>
<li>dp[i][j]=(j+1)*dp[i-1][j]</li>
<li>dp[i][j]=(i-j)*dp[i-1][j-1]</li>
</ul>
<p>合并为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j]=(j+1)*dp[i-1][j] + (i-j)*dp[i-1][j-1]</div></pre></td></tr></table></figure>
<p>编程：<br>新建一个dp[n+1][n]数组，数组长度可以是1~n，小于号个数可以是0~n-1</p>
<p>初始值，长度为2<br>dp[2][1]=1，dp[2][0]=1，注意数组每一行的和为长度为n的全排列数</p>
<p>那么求dp[3][0]，dp[3][1]，dp[3][2]<br>按照公式分别是2，1+2 ，1</p>
<p>dp[4][0] dp[4][1] dp[4][2] dp[4][3]<br>按公式分别是2 6+6 =12 3+6 = 9 1</p>
<p>最终结果是dp[n][k]</p>
<p>我做的结果是列举了全部状态，复杂度n<em>n，可以降为n</em>k</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h2 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h2><p>参考：<a href="http://www.cnblogs.com/nullzx/p/6624731.html" target="_blank" rel="external">http://www.cnblogs.com/nullzx/p/6624731.html</a></p>
<p>索引优先队列三个数组的引出：</p>
<p>优先队列只能取队头元素，不能直接访问队列中的对象。索引优先队列可以通过<strong>索引快速访问</strong>列表中的对象，并保持整个元素还是以<strong>最小堆</strong>的方式存储。</p>
<p>每个操作对应pq、qp和element数组的变化</p>
<p>代码：</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/08/[SSM]IDEA在编辑时提示could not autowire/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/08/[SSM]IDEA在编辑时提示could not autowire/" itemprop="url">IDEA在编辑时提示could not autowire</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-08T10:28:00+08:00">
                2016-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开发中我在applicationContext-dao.xml中加入了mapper扫描器</p>
<pre><code>&lt;!--mapper扫描器--&gt;  
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  
    &lt;!--扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开--&gt;  
    &lt;property name=&quot;basePackage&quot; value=&quot;com.qianlv.ssmdemo.mapper&quot; /&gt;  
    &lt;!--这里不用sqlSessionFactory是因为如果用会导致上面配置的dataSource失效--&gt;  
    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;  
&lt;/bean&gt;  
</code></pre><p>但是在编辑一个Service中注入mapper会提示could not autowire，但是可以正常执行的。</p>
<pre><code>public class ItemsServiceImpl implements com.qianlv.ssmdemo.service.ItemsService{  

    @Autowired  
    ItemsMapperCustom itemsMapperCustom;  

    public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {  
        return itemsMapperCustom.findItemsList(itemsQueryVo);  
    }  

}  
</code></pre><p>我们需要改一下IDEA的设置</p>
<p><img src="http://i.imgur.com/lATPEQG.png" alt=""></p>
<p>将最右边的Serverity改为Warning</p>
<p>参考：<a href="http://blog.csdn.net/xlxxybz1314/article/details/51404700" target="_blank" rel="external">http://blog.csdn.net/xlxxybz1314/article/details/51404700</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/10/07/[SSM]SpringMVC-Spring-Mybatis整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/[SSM]SpringMVC-Spring-Mybatis整合/" itemprop="url">SpringMVC-Spring-Mybatis整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T12:52:00+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;cn.apeius&lt;/groupId&gt;
    &lt;artifactId&gt;Demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;!--集中管理依赖版本号--&gt;
    &lt;properties&gt;
        &lt;junit.version&gt;4.10&lt;/junit.version&gt;
        &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt;
        &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt;
        &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt;
        &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt;
        &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt;
        &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt;
        &lt;jackson.version&gt;2.4.2&lt;/jackson.version&gt;
        &lt;druid.version&gt;1.0.9&lt;/druid.version&gt;
        &lt;httpclient.version&gt;4.3.5&lt;/httpclient.version&gt;
        &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;
        &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt;
        &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt;
        &lt;joda-time.version&gt;2.5&lt;/joda-time.version&gt;
        &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt;
        &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;

        &lt;!--单元测试--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;${junit.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--分页插件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;3.7.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
            &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;c3p0&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Mysql--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;${mysql.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--日志--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Jackson Json处理工具包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;${jackson.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;${druid.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--httpclient--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;${httpclient.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--JSP相关--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;${jstl.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;${servlet-api.version}&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;${jsp-api.version}&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--时间操作组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;joda-time&lt;/groupId&gt;
            &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
            &lt;version&gt;${joda-time.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Apache工具组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
            &lt;version&gt;${commons-lang3.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;${commons-io.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--文件上传--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/rhapsody1290/SSM" target="_blank" rel="external">https://github.com/rhapsody1290/SSM</a></p>
<h2 id="查询用户列表"><a href="#查询用户列表" class="headerlink" title="查询用户列表"></a>查询用户列表</h2><h3 id="定义EasyUIPage"><a href="#定义EasyUIPage" class="headerlink" title="定义EasyUIPage"></a>定义EasyUIPage</h3><p>封装对应的easyUi需要的数据</p>
<pre><code>public class EasyUIPage {
    private Long total;
    private List&lt;?&gt; rows;

    public Long getTotal() {
        return total;
    }

    public void setTotal(Long total) {
        this.total = total;
    }

    public List&lt;?&gt; getRows() {
        return rows;
    }

    public void setRows(List&lt;?&gt; rows) {
        this.rows = rows;
    }

}
</code></pre><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><pre><code>@RequestMapping(value = &quot;list&quot;)
@ResponseBody
public EasyUIPage queryAll(
        @RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer pageNum,
        @RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;) Integer pageSize) {
    EasyUIPage esayUIPage = userService.queryAllUser(pageNum,pageSize);
    return esayUIPage;
}
</code></pre><h3 id="编写userservice"><a href="#编写userservice" class="headerlink" title="编写userservice"></a>编写userservice</h3><pre><code>@Override
public EasyUIPage queryAllUser(Integer pageNum, Integer pageSize) {
    PageHelper.startPage(pageNum, pageSize);
    List&lt;User&gt; users = userMapper.queryAllUser();

    PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(users);

    EasyUIPage easyUIPage = new EasyUIPage();
    //easyUIPage.setRows(users);
    easyUIPage.setRows(pageInfo.getList());
    easyUIPage.setTotal(pageInfo.getTotal());
    return easyUIPage;
}
</code></pre><h3 id="编写userMapper"><a href="#编写userMapper" class="headerlink" title="编写userMapper"></a>编写userMapper</h3><pre><code>public List&lt;User&gt; queryAllUser();
</code></pre><h3 id="userMapper对应的xml"><a href="#userMapper对应的xml" class="headerlink" title="userMapper对应的xml"></a>userMapper对应的xml</h3><pre><code>&lt;select id=&quot;queryAllUser&quot; resultType=&quot;User&quot;&gt;
    select * from tb_user
&lt;/select&gt;
</code></pre><h2 id="页面跳转合并★★★★★★"><a href="#页面跳转合并★★★★★★" class="headerlink" title="页面跳转合并★★★★★★"></a>页面跳转合并★★★★★★</h2><pre><code>//页面跳转合并
@RequestMapping(value = &quot;/page/{pageName}&quot;)
public String toPage(@PathVariable(&quot;pageName&quot;) String pageName){
    return pageName;
}
</code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><h3 id="日期格式转换"><a href="#日期格式转换" class="headerlink" title="日期格式转换"></a>日期格式转换</h3><p>SpringMVC默认不支持字符串转换成Date格式，可以采用SpringMVC自带的转换器，还有一种简单的方法：</p>
<pre><code>@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date birthday;
</code></pre><p>需要导入依赖：</p>
<pre><code>&lt;!--时间操作组件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;joda-time&lt;/groupId&gt;
    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
    &lt;version&gt;${joda-time.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="添加失败"><a href="#添加失败" class="headerlink" title="添加失败"></a>添加失败</h3><p>使用try-catch</p>
<pre><code>@RequestMapping(value = &quot;/save&quot;)
@ResponseBody
public Map&lt;String, String&gt; save(User user){
    Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();
    try{
        Integer num = userService.addUser(user);
        if(num &gt; 0){
            map.put(&quot;status&quot;,&quot;200&quot;);
        }else{
            map.put(&quot;status&quot;,&quot;500&quot;);
        }
    }catch (Exception e){
        map.put(&quot;status&quot;,&quot;500&quot;);
    }
    return map;
}
</code></pre><h2 id="导出excel"><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h2><p>视图除了可以是html、jsp、json等常见视图之外，还可以是excel，其他</p>
<h3 id="poi依赖"><a href="#poi依赖" class="headerlink" title="poi依赖"></a>poi依赖</h3><pre><code>&lt;!--操作excel--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
    &lt;artifactId&gt;poi&lt;/artifactId&gt;
    &lt;version&gt;3.10.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="导入编写好的Excel视图"><a href="#导入编写好的Excel视图" class="headerlink" title="导入编写好的Excel视图"></a>导入编写好的Excel视图</h3><p>UserExcelView、Constants两个Java文件</p>
<h3 id="声明excel视图"><a href="#声明excel视图" class="headerlink" title="声明excel视图"></a>声明excel视图</h3><pre><code>&lt;bean name=&quot;userExcel&quot; class=&quot;cn.apeius.usermanage.view.UserExcelView&quot;/&gt;
</code></pre><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><pre><code>@RequestMapping(value = &quot;export/excel&quot;)
public ModelAndView export(@RequestParam(value = &quot;page&quot;, defaultValue = &quot;1&quot;) Integer pageNow,
                           @RequestParam(value = &quot;rows&quot;, defaultValue = &quot;5&quot;) Integer pageSize){
    //1、查询需要导出的数据
    EasyUIPage page = this.userService.queryAllUsers(pageNow,pageSize);
    //2、传递数据
    ModelAndView mv = new ModelAndView();
    mv.addObject(&quot;userList&quot;,page.getRows());
    mv.setViewName(&quot;userExcel&quot;);//定义到自定义的excel视图
    return mv;
}
</code></pre><h3 id="bean视图解析器"><a href="#bean视图解析器" class="headerlink" title="bean视图解析器"></a>bean视图解析器</h3><p>数字越小优先级越高</p>
<pre><code>&lt;!--定义视图解析器--&gt;
&lt;bean class = &quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><h3 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h3><pre><code>@ResponseBody
@RequestMapping(value = &quot;/delete&quot;)
//springmvc会自动把逗号切割，变成一个数组
public Map&lt;String,String&gt; deleteById(@RequestParam(value = &quot;ids&quot;) Long[] ids){
    Integer num = this.userService.deleteUserByIds(ids);
    Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();
    if(num &gt; 0){
        map.put(&quot;status&quot;,&quot;200&quot;);
    }else{
        map.put(&quot;status&quot;,&quot;208&quot;);
    }
    return map;
}
</code></pre><h3 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h3><pre><code>&lt;delete id=&quot;deleteUserByIds&quot;&gt;
    delete from tb_user where id in
    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
        #{id}
    &lt;/foreach&gt;
&lt;/delete&gt;
</code></pre><h2 id="通用mapper"><a href="#通用mapper" class="headerlink" title="通用mapper"></a>通用mapper</h2><p>通用的增删改查操作</p>
<h3 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.abel533&lt;/groupId&gt;
    &lt;artifactId&gt;mapper&lt;/artifactId&gt;
    &lt;version&gt;2.3.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="Mybatis配置文件方式"><a href="#Mybatis配置文件方式" class="headerlink" title="Mybatis配置文件方式"></a>Mybatis配置文件方式</h3><p>在mybatis-config.xml中添加如下配置:</p>
<pre><code>&lt;plugin interceptor=&quot;com.github.abel533.mapperhelper.MapperInterceptor&quot;&gt;
    &lt;!--主键自增方法，默认值为MYSQL，详细说明请看文档--&gt;
    &lt;property name=&quot;IDENTITY&quot; value=&quot;MYSQL&quot;/&gt;
    &lt;!--通用mapper接口，多个通用接口用逗号隔开--&gt;
    &lt;property name=&quot;mappers&quot; value=&quot;com.github.abel533.mapper.Mapper&quot;/&gt;
&lt;/plugin&gt;
</code></pre><h3 id="通用mapper使用"><a href="#通用mapper使用" class="headerlink" title="通用mapper使用"></a>通用mapper使用</h3><h4 id="继承通用的Mapper-必须指定泛型"><a href="#继承通用的Mapper-必须指定泛型" class="headerlink" title="继承通用的Mapper,必须指定泛型"></a>继承通用的Mapper<t>,必须指定泛型<t></t></t></h4><pre><code>public interface UserInfoMapper extends Mapper&lt;UserInfo&gt; {
  //其他必须手写的接口...

}
</code></pre><h4 id="泛型-实体类-的类型必须符合要求★★★★★"><a href="#泛型-实体类-的类型必须符合要求★★★★★" class="headerlink" title="泛型(实体类)的类型必须符合要求★★★★★"></a>泛型(实体类)<t>的类型必须符合要求★★★★★</t></h4><ol>
<li>表名默认使用类名,驼峰转下划线(只对大写字母进行处理),如UserInfo默认对应的表名为user_info。</li>
<li>表名可以使用<strong><em>@Table(name = “tableName”)</em></strong>进行指定,对不符合第一条默认规则的可以通过这种方式指定表名.</li>
<li>字段默认和@Column一样,都会作为表字段,表字段默认为Java对象的Field名字驼峰转下划线形式.</li>
<li>可以使用<strong><em>@Column(name = “fieldName”)</em></strong>指定不符合第3条规则的字段名</li>
<li><strong><em>使用@Transient注解可以忽略字段,添加该注解的字段不会作为表字段使用（关联查询）</em></strong></li>
<li><strong><em>建议一定是有一个@Id注解作为主键的字段,可以有多个@Id注解的字段作为联合主键.</em></strong></li>
</ol>
<h4 id="通用mapper使用-1"><a href="#通用mapper使用-1" class="headerlink" title="通用mapper使用"></a>通用mapper使用</h4><pre><code>public class UserMapperTest {

    private UserMapper mapper;

    @Before
    public void setUp() throws Exception {
        ApplicationContext ac = new ClassPathXmlApplicationContext(
                new String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext-mybatis.xml&quot;,&quot;applicationContext-tx.xml&quot;});
        mapper = ac.getBean(UserMapper.class);
    }

    @After
    public void tearDown() throws Exception {

    }

    @Test
    public void testSelectOne() throws Exception {
        //创建User对象，设置的属性作为查询的约束
        User user = new User();
        user.setId(1L);
        //使用selectOne必须保证结果唯一，如果结果太多则会报错
        System.out.println(mapper.selectOne(user));
    }

    @Test
    public void testSelect() throws Exception {
        User record = new User();
        //可以设置属性增加约束

        List&lt;User&gt; users = mapper.select(record);
        for(User user : users)
            System.out.println(user);
    }

    @Test
    public void testSelectCount() throws Exception {
        User record = new User();
        int count = mapper.selectCount(record);
        System.out.println(count);
    }

    @Test
    public void testSelectByPrimaryKey() throws Exception {
        //参数表示主键的值
        System.out.println(mapper.selectByPrimaryKey(1L));
    }

    @Test
    public void testInsert() throws Exception {
        User record = new User();
        record.setUserName(&quot;踩雷&quot;);
        record.setName(&quot;bajie&quot;);
        record.setPassword(&quot;123456&quot;);
        record.setBirthday(new Date());
        mapper.insert(record);
    }

    @Test
    public void testInsertSelective() throws Exception {
        //与testInsert的区别：只添加设置值得字段，其余让数据库默认，推荐！！！
        User record = new User();
        record.setUserName(&quot;李璇&quot;);
        record.setName(&quot;bajie&quot;);
        record.setPassword(&quot;123456&quot;);
        record.setBirthday(new Date());
        mapper.insert(record);
    }

    @Test
    public void testDelete() throws Exception {
        User record = new User();
        record.setName(&quot;xxxx&quot;);
        mapper.delete(record);
    }

    @Test
    public void testDeleteByPrimaryKey() throws Exception {
        mapper.deleteByPrimaryKey(66L);
    }

    @Test
    public void testUpdateByPrimaryKey() throws Exception {
        User record = new User();
        record.setId(66L);
        record.setName(&quot;踩雷&quot;);
        mapper.updateByPrimaryKey(record);
    }

    @Test
    public void testUpdateByPrimaryKeySelective() throws Exception {
        //只更新设置的值，推荐！！！！！！！
        User record = new User();
        record.setId(66L);
        record.setName(&quot;踩雷&quot;);
        mapper.updateByPrimaryKeySelective(record);
    }


    @Test
    public void testExampleBasic(){
        //进行复杂查询
        Example example = new Example(User.class);
        Example.Criteria criteria = example.createCriteria();
        criteria.andGreaterThanOrEqualTo(&quot;age&quot;,30);
        //添加and条件，密码为123456
        criteria.andEqualTo(&quot;password&quot;,&quot;123456&quot;);
        List&lt;User&gt; users = mapper.selectByExample(example);
        for(User u : users)
            System.out.println(u);
    }

    @Test
    //SELECT AGE,NAME,UPDATED,USER_NAME USERNAME,BIRTHDAY,ID,CREATED,SEX,PASSWORD FROM tb_user
    // WHERE ( AGE &gt;= ? and NAME like ? ) or ( PASSWORD = ? and ID in(?,?) )
    public void testExampleOr(){
        //进行复杂查询，or
        Example example = new Example(User.class);
        Example.Criteria criteria = example.createCriteria();
        criteria.andGreaterThanOrEqualTo(&quot;age&quot;,30);
        criteria.andLike(&quot;name&quot;,&quot;%xx%&quot;);

        Example.Criteria criteria12 = example.createCriteria();
        //添加and条件，密码为123456
        criteria12.andEqualTo(&quot;password&quot;,&quot;123456&quot;);
        List&lt;Object&gt; ids = new ArrayList&lt;Object&gt;();
        ids.add(&quot;1&quot;);
        ids.add(&quot;2&quot;);
        criteria12.andIn(&quot;id&quot;,ids);

        //多个criteria之间是or的关系
        example.or(criteria12);

        List&lt;User&gt; users = mapper.selectByExample(example);
        for(User u : users)
            System.out.println(u);
    }

    @Test
    public void testExampleSort(){
        Example example = new Example(User.class);
        example.setOrderByClause(&quot;age desc,id desc&quot;);
        List&lt;User&gt; users = mapper.selectByExample(example);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/09/30/[Java]list转string[]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/30/[Java]list转string[]/" itemprop="url">list转string[]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-30T00:00:00+08:00">
                2016-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方法一：单个元素转换"><a href="#方法一：单个元素转换" class="headerlink" title="方法一：单个元素转换"></a>方法一：单个元素转换</h2><pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);
//转化成Object数组
Object[] objs = array.toArray();
//新建数组
String[] strings = new String[array.size()];
//每个元素类型转换
int i = 0;
for(Object obj : objs){
    if(obj instanceof String){
        strings[i++] = (String)obj;
    }
}
for(String s : strings){
    System.out.println(s);
}
</code></pre><h2 id="方法二：整个转"><a href="#方法二：整个转" class="headerlink" title="方法二：整个转"></a>方法二：整个转</h2><p>使用List的toArray(T[])方法，传入一个与list容量相等的字符串数组</p>
<pre><code>//ArrayList
ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();
array.add(&quot;aaa&quot;);
array.add(&quot;bbb&quot;);
array.add(&quot;ccc&quot;);

String[] strings = new String[array.size()];
array.toArray(strings);
for(String s : strings){
    System.out.println(s);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/09/30/[Java]Java泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/30/[Java]Java泛型/" itemprop="url">Java泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-30T00:00:00+08:00">
                2016-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型本质是<strong>参数化类型</strong>，也就是说把操作的<strong>数据类型</strong>指定为一个<strong>参数</strong>。这种参数类型可以用在<strong>类、接口和方法</strong>的创建中，分别称为泛型类、泛型接口、泛型方法。 </p>
<p>Java语言引入泛型的好处是：<br>1、<strong>安全简单</strong>，在<strong>编译的时候检查类型安全</strong>，并且所有的<strong>强制转换都是自动和隐式</strong>。比如<strong>在定义集合的时候指定具体的参数类型，这样无法加入指定类型以外的数据，避免了强制类型转换时出现对转换错误的问题</strong><br>2、能够复用算法，防止重复代码的编写</p>
<h2 id="泛型的基本应用"><a href="#泛型的基本应用" class="headerlink" title="泛型的基本应用"></a>泛型的基本应用</h2><ul>
<li>Jdk1.5的集合类希望你在定义集合时，<strong><em>明确表示你要向集合中装哪种类型的数据</em></strong>，无法加入指定类型以外的数据</li>
<li>如下例子，如果不给定参数类型，可以在集合类中加入任意类型的数据，但在取元素时必须由程序员强行转换数据类型，编译器不会报错，出现问题由程序员负责</li>
</ul>
<pre><code>ArrayList collection1 = new ArrayList();
collection1.add(1);
collection1.add(1L);
collection1.add(&quot;abc&quot;);
</code></pre><ul>
<li>在指定参数后，泛型的基本用法如下，<strong>对不是给定类型的数据，编译会报错</strong>。另一个好处是取出数据后，<strong>不用对数据进行强制转换</strong>。</li>
</ul>
<pre><code>ArrayList&lt;String&gt; collection2 = new ArrayList&lt;String&gt;();
//collection2.add(1);
//collection2.add(1L);
collection2.add(&quot;abc&quot;);
String string = collection2.get(0);
</code></pre><ul>
<li><strong>泛型是提供给javac编译器使用的</strong>，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带类型说明的集合时会<strong>去除掉”类型”信息</strong>，使程序运行效率不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样</li>
</ul>
<pre><code>ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;();
System.out.println(collection1.getClass() == collection2.getClass());//True
System.out.println(collection2.getClass() == collection3.getClass());//True
</code></pre><ul>
<li>由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用<strong>反射</strong>得到集合，再调用其add方法即可</li>
</ul>
<pre><code>ArrayList&lt;Integer&gt; collection3 = new ArrayList&lt;Integer&gt;();
collection3.getClass().getMethod(&quot;add&quot;,Object.class).invoke(collection3, &quot;abc&quot;);
System.out.println(collection3.get(0));//abc
</code></pre><p>collection3的参数类型是Integer，但用反射的方法跳过编译器，还是能够加入String类型的数据</p>
<h2 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h2><ol>
<li>提高了我们程序的使用性，不需要在自己去做强转</li>
<li>将原来在运行阶段处理的问题，放到了编译阶段</li>
<li>提高安全性</li>
</ol>
<h2 id="泛型的术语"><a href="#泛型的术语" class="headerlink" title="泛型的术语"></a>泛型的术语</h2><p>ArrayList<e>类定义和ArrayList<integer>类引用中涉及如下术语：</integer></e></p>
<ul>
<li>整个称为 ArrayList<e>泛型类型</e></li>
<li>ArrayList<e>中的E称为类型变量或<strong>类型参数</strong></e></li>
<li>整个ArrayList<integer>称为<strong>参数化的类型</strong></integer></li>
<li>ArrayList<integer>中的Integer称为类型参数的实际类型参数或实际类型参数</integer></li>
<li>ArrayList<integer>中的&lt;&gt;念typeof</integer></li>
<li>ArrayList称为<strong>原始类型</strong></li>
</ul>
<h3 id="参数化类型与原始类型的兼容性"><a href="#参数化类型与原始类型的兼容性" class="headerlink" title="参数化类型与原始类型的兼容性"></a>参数化类型与原始类型的兼容性</h3><ul>
<li><p>参数化类型可以引用一个原始类型，编译报告警告，例如</p>
<pre><code>Collection&lt;String&gt; c = new Vector();
</code></pre></li>
<li><p>原始类型可以引用一个参数化类型的对象，编译报告警告，例如</p>
<pre><code>Collection c = new Vector&lt;String&gt;();
</code></pre></li>
</ul>
<h3 id="参数化类型不考虑类型参数的继承关系"><a href="#参数化类型不考虑类型参数的继承关系" class="headerlink" title="参数化类型不考虑类型参数的继承关系"></a>参数化类型不考虑类型参数的继承关系</h3><p>不要认为String和Object有继承关系就不会报错</p>
<ul>
<li>Vector<string> v = new Vector<object>();//错误</object></string></li>
<li>Vector<object> v = new Vector<string>();//错误</string></object></li>
</ul>
<p><strong>思考</strong>，下面的代码会报错误吗？</p>
<pre><code>Vector v1 = new Vector&lt;String&gt;();
Vector&lt;Object&gt; v = v1;
</code></pre><p>答：不会，第一个语句，原始类型可以引用一个参数化类型的对象，第二个语句，参数化类型可以引用一个原始类型的对象，所以不会报错。</p>
<h2 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h2><p><strong>泛型可以声明在类上，可以声明在方法上，可以声明在接口上</strong>。声明在类上的泛型，在整个类的范围内都可以使用。声明在方法上的泛型，只能在方法上使用。</p>
<p><strong><em>什么时候在方法上声明泛型？</em></strong></p>
<p>类上已经声明了泛型，但是在方法上我们不使用类上的泛型，而是自定义的一个，那么就可以在方法上声明，注意：在方法上声明时，<strong>泛型要定义在方法的返回值前面。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class APP &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">		//sayHello的参数列表中使用了泛型，可以传入不同的数据类型</div><div class="line">        String hello = sayHello(&quot;Hello&quot;);</div><div class="line">        Integer integer = sayHello(1);</div><div class="line">        Float aFloat = sayHello(1F);</div><div class="line">        Double aDouble = sayHello(1D);</div><div class="line">    &#125;</div><div class="line">	//泛型定义在返回值前面</div><div class="line">    private static &lt;T&gt; T sayHello(T parameter) &#123;</div><div class="line">        System.out.println(parameter);</div><div class="line">        return parameter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="泛型中使用？通配符"><a href="#泛型中使用？通配符" class="headerlink" title="泛型中使用？通配符"></a>泛型中使用？通配符</h2><p>定义一个printCollection函数，参数是一个集合，类型参数是？通配符，这样可以将任何类型参数的集合作为参数传入，如ArrayList<integer></integer></p>
<pre><code>public static void printCollection(Collection&lt;?&gt; collection){
    //System.out.println(collection.add(&quot;abc&quot;));//错误，因为它不知道自己未来匹配就一定是String
    System.out.println(collection.size());//没错，此方法与类型参数无关
    for(Object object : collection){
        System.out.println(object);
    }
}
</code></pre><p>总结：<strong>使用<code>？</code>通配符可以引用其它各种参数化的类型</strong>，<code>？</code>通配符定义的变量主要用作引用，<strong>只可以调用与参数化无关的方法</strong>，不能调用与参数化有关的方法</p>
<h2 id="泛型中的-通配符的扩展"><a href="#泛型中的-通配符的扩展" class="headerlink" title="泛型中的 ? 通配符的扩展"></a>泛型中的 ? 通配符的扩展</h2><ul>
<li>&lt;? extends E&gt; 它是用来限定是E类型或是E的子类型.</li>
<li>&lt;? super E&gt;  只能是E类型或E的父类型.</li>
</ul>
<h3 id="限定通配符的上边界"><a href="#限定通配符的上边界" class="headerlink" title="限定通配符的上边界"></a>限定通配符的上边界</h3><ul>
<li>正确：Vector&lt;? extends Number&gt; x = new Vector<integer>(); </integer></li>
<li>错误：Vector&lt;? extends Number&gt; x = new Vector<string>();</string></li>
</ul>
<h3 id="限定通配符的下边界"><a href="#限定通配符的下边界" class="headerlink" title="限定通配符的下边界"></a>限定通配符的下边界</h3><ul>
<li>正确：Vector&lt;? super Number&gt; x = new Vector<number>();</number></li>
<li>错误：Vector&lt;? super Number&gt; x = new Vector<byte>();</byte></li>
</ul>
<h2 id="泛型方法（自定义泛型）"><a href="#泛型方法（自定义泛型）" class="headerlink" title="泛型方法（自定义泛型）"></a>泛型方法（自定义泛型）</h2><p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。</strong></p>
<p><font color="red">在返回值前加上&lt;T&gt;表示新定义一个类型</font>，返回<code>x+y</code>有错误，因为不确定T类型是否有<code>+</code>这个方法，<font color="red"><strong>返回类型为传入类型的最大公共类型</strong></font>，比如传入Integer和Float，返回Numberic，传入Integer和String，返回Object</p>
<p><img src="http://i.imgur.com/hZFc0o8.png" alt=""></p>
<p><strong>泛型的实际类型只能是引用类型，不能是基本类型</strong>。<code>T</code>不能被基本类型替换。在案例<code>add(1，2)</code>中会自动装箱，而在swap案例中，<strong>数组本身就是Object，不会装箱</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span></span>&#123;</div><div class="line">		T tmp = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swap(<span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>,<span class="string">"xyz"</span>,<span class="string">"asd"</span>&#125;,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//正确</span></div><div class="line"><span class="comment">//swap(new int[]&#123;1,2,3,4,5&#125;,1,2);//报错</span></div></pre></td></tr></table></figure>
<p>除了在应用泛型时可以使用extends限定符，在定义泛型时也可以使用extends限定符,可以用来指定多个边界，如 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//必须实现Serializable 和cloneable两个接口</div><div class="line">&lt;V extends Serializable &amp; cloneable &gt; void method()&#123;&#125;</div></pre></td></tr></table></figure>
<p>普通方法、构造方法和静态方法中都可以使用泛型</p>
<p>也可以用类型变量表示异常，称为参数化的异常，可以用于方法的throws列表中，但是不能用于catch子句中。<br>例：用下面的代码说明对异常如何采用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Exception&gt; sayHello() <span class="keyword">throws</span> T</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line"> </div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        <span class="keyword">throw</span> (T)e;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">在泛型中可以同时**有多个类型参数**，在定义它们的尖括号中用逗号分，例如：</div><div class="line"></div><div class="line">```Java</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">V <span class="title">getValue</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> map.get(key); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在开发中，如果在类上已经声明了泛型，但是我们在方法上不使用类上声明的泛型，我们可以自己在方法上声明泛型。</p>
<ul>
<li>这个在方法上声明的泛型，只能在方法内使用。如果声明在方法上，必须声明在方法的返回值前面。 </li>
<li>泛型声明在类上，那么这个泛型可以在整个类内使用.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo9</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line">    &#123;</div><div class="line">        Student&lt;String&gt; s=<span class="keyword">new</span> Student&lt;String&gt;();</div><div class="line">        s.a=<span class="string">"hello"</span>;</div><div class="line">        System.out.println(s.print());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在类上定义泛型</span></div><div class="line"><span class="comment">//如果将泛型定义在类上，那么这个泛型可以在整个类内使用.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt;  </span></div><div class="line">&#123;</div><div class="line">    T a;  <span class="comment">//泛型做为成员属性</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123; <span class="comment">//泛型作用在方法.</span></div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>泛型练习题</strong></p>
<p>自动将Object类型的对象转换成其他类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Generic &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Object o = &quot;123&quot;;</div><div class="line">        String s = convert(o);</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; T convert(Object o)&#123;</div><div class="line">        return (T) o;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：这里的T由返回类型决定!!!</strong></p>
<h2 id="通过反射获取泛型的实际参数类型"><a href="#通过反射获取泛型的实际参数类型" class="headerlink" title="通过反射获取泛型的实际参数类型"></a>通过反射获取泛型的实际参数类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vector&lt;Date&gt; v1 = new Vector&lt;Date&gt;();</div></pre></td></tr></table></figure>
<p>通过获取v1的字节码来获取Vector的实际参数类型是<strong>不可能</strong>，因为编译器在编译后会去掉类型信息。但在已知框架中的确有这个应用，它是怎么实现的呢？</p>
<p>通过变量是无法知道它的参数类型的，但是当把这个变量交给一个方法去使用的时候，方法可以获得它的参数列表，并且是泛型的形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="comment">//Vector&lt;Date&gt; v1 = new Vector&lt;Date&gt;();</span></div><div class="line">		Method applyMethod = GenericTest.class.getMethod(<span class="string">"applyVector"</span>, Vector.class);</div><div class="line">		Type[] types = applyMethod.getGenericParameterTypes();</div><div class="line">		ParameterizedType pType = (ParameterizedType)types[<span class="number">0</span>];</div><div class="line">		System.out.println(pType.getRawType());</div><div class="line">		System.out.println(pType.getActualTypeArguments()[<span class="number">0</span>]);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyVector</span><span class="params">(Vector&lt;Date&gt; v1)</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br>    class java.util.Vector<br>    class java.util.Date</p>
<h2 id="泛型DAO"><a href="#泛型DAO" class="headerlink" title="泛型DAO"></a>泛型DAO</h2><p>1、编写BaseDAO类，类中封装常用的DAO方法，如selectById</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseDAO&lt;T&gt; &#123;</div><div class="line">    private Class&lt;T&gt; entityClass;</div><div class="line"></div><div class="line">    protected BaseDAO() &#123;</div><div class="line">        //得到子类的泛型父类</div><div class="line">        Type type = getClass().getGenericSuperclass();</div><div class="line">        //转化为泛型类型，返回此泛型类型的实际类型参数的Type对象的数组,数组里放的都是对应类型的Class</div><div class="line">        Type[] trueType = ((ParameterizedType) type).getActualTypeArguments();</div><div class="line">        this.entityClass = (Class&lt;T&gt;) trueType[0];</div><div class="line">        System.out.println(&quot;传入泛型类型：&quot; + entityClass.getCanonicalName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected T findById(Serializable id)&#123;</div><div class="line">        //从数据库中查询，并返回</div><div class="line">        T t = null;</div><div class="line">        try &#123;</div><div class="line">            t = entityClass.newInstance();</div><div class="line">            Field field_id = entityClass.getDeclaredField(&quot;id&quot;);</div><div class="line">            field_id.setAccessible(true);</div><div class="line">            field_id.set(t,id);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用getClass()方法，<strong>隐含的this指针是子类对象</strong>（因为new的是子类，this对象指的是子类对象。虽然会执行父类的构造方法，但并没有构造一个父类的对象），获得父类</p>
<p>2、对于每一个用户自定义的DAO类，继承BaseDAO，并且传入Domain类作为类型参数。这样可以从父类BaseDAO中获得常用的单表增、删、改、查方法。如果用户需要一些复杂查询，需要自行添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class UserDAO extends BaseDAO&lt;User&gt; &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、Domain对象对应数据库中的一张表，从数据库中查出的一条记录需要转变成一个Domain对象，方便Service中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    private long id;</div><div class="line">    private String name;</div><div class="line">    private String password;</div><div class="line"></div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(long id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getPassword() &#123;</div><div class="line">        return password;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPassword(String password) &#123;</div><div class="line">        this.password = password;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;User&#123;&quot; +</div><div class="line">                &quot;id=&quot; + id +</div><div class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</div><div class="line">                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、测试具体DAO的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class APP &#123;</div><div class="line">	UserDAO userDAO = new UserDAO();</div><div class="line">	User user = userDAO.findById(2);</div><div class="line">	System.out.println(user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
