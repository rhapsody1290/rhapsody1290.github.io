<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://qianmingxs.com/page/13/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/page/13/"/>





  <title>Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/08/09/[Java]命令行编译Java程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/09/[Java]命令行编译Java程序/" itemprop="url">命令行编译Java程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-09T00:00:00+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先说下.java和.class文件，.java文件可以放在任何位置，只要运行javac时，指定你要编译的源文件位置就好，然后javac还有另一个参数是指定.class文件输出到哪个目录。另外javac还有一个option叫 -d，表示编译出来的.class文件，按照包名放进相应层级的目录中去。<br>所以，假设你的.java文件在D:\code\src\com\company\Hello.java，（因为Java要求源文件中的public类与源文件名要相同，类名通常首字母大写，所以源文件通常是Hello.java这样的），并且假如你的Hello.java里写明package com.company;<br>假如你当前置身于D:\code\目录下，执行javac .\src\com\company\Hello.java -d .\bin\<br>表示编译.\src\com\company\Hello.java，将编译好的.class文件按包名层级结构放到.\bin\目录下。<br>于是在D:\code\bin\com\company\下会出现一个Hello.class文件。这时，运行Hello时，跟.java文件就没有关系了。<br>这时如果你置身于D:\code\bin\目录下，最好了，因为我们通常配置环境变量时，CLASSPATH会配置.，也就是当前路径，那你就在D:\code\bin\下执行java，那class也就在当前路径找了：<br>java com.company.Hello，这里java是启动虚拟机的命令，启动时运行哪个类呢？com.company.Hello，这是类名，带着包名，叫全限定名，也就是类的全名，这跟它在哪个目录下没关系，是类名，虚拟机会在CLASSPATH下，也就是当前目录下，去找com.company.Hello这个类，并加载运行。<br>至于它怎么找，你就不用管了。<br>如果你当前正置身于D:\code\下，那你执行java com.company.Hello就失败了，因为虚拟机在CLASSPATH下找不到这个类。那怎么办呢，就要告诉虚拟机，去哪找，也就是要指定CLASSPATH，可以执行：java -classpath .\bin com.company.Hello<br>不知道你能不能理解，你要运行的是com.company.Hello这个类，这是类名，不是目录名，去哪找这个类？用-classpath告诉虚拟机，所以，不能java .\bin\com.company.Hello，这就不伦不类了。</p>
<p>参考<br><a href="http://bbs.csdn.net/topics/390865848" target="_blank" rel="external">http://bbs.csdn.net/topics/390865848</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/08/08/[Java]Log4j笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/[Java]Log4j笔记/" itemprop="url">Log4j笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-08T00:00:00+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1、新建一个JAva工程，导入包log4j-1.2.17.jar，整个工程最终目录如下</p>
<p><img src="http://i.imgur.com/8ZkEHMI.png" alt=""></p>
<p>2、src同级创建并设置log4j.properties</p>
<pre><code>### 设置###
log4j.rootLogger = debug,stdout,D,E

### 输出信息到控制抬 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss,SSS} [%p] method:%l%n%m%n

### 输出DEBUG级别以上的日志到=E://logs/error.log ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = E://logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG 
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 输出ERROR级别以上的日志到=E://logs/error.log ###
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File =E://logs/error.log 
log4j.appender.E.Append = true
log4j.appender.E.Threshold = ERROR 
log4j.appender.E.layout = org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><p>3、设置日志内容</p>
<pre><code>package com.mucfc;
import org.apache.log4j.Logger;
/**
 *@author linbingwen
 *@2015年5月18日9:14:21
 */
public class Test {
    private static Logger logger = Logger.getLogger(Test.class);  

    /** 
     * @param args 
     */  
    public static void main(String[] args) {  
        // System.out.println(&quot;This is println message.&quot;);  

        // 记录debug级别的信息  
        logger.debug(&quot;This is debug message.&quot;);  
        // 记录info级别的信息  
        logger.info(&quot;This is info message.&quot;);  
        // 记录error级别的信息  
        logger.error(&quot;This is error message.&quot;);  
    }  

}
</code></pre><h2 id="Log4j的架构"><a href="#Log4j的架构" class="headerlink" title="Log4j的架构"></a>Log4j的架构</h2><p>Log4j由三个重要的组件构成：</p>
<ul>
<li>日志写入器：控制日志信息的优先级，日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG</li>
<li>日志输出终端：指定了日志将打印到控制台还是文件中</li>
<li>日志布局模式：控制日志信息的输出格式</li>
</ul>
<p><img src="http://i.imgur.com/5z0m4oX.png" alt=""></p>
<p>Logger类是日志包的核心，Logger的名称是大小写敏感的，并且名称之间有继承关系。子名由父名做前缀，用点号”.”分隔，如x.y是x.y.z的父亲Logger。</p>
<h2 id="Log4j基本使用方法"><a href="#Log4j基本使用方法" class="headerlink" title="Log4j基本使用方法"></a>Log4j基本使用方法</h2><h3 id="定义配置文件"><a href="#定义配置文件" class="headerlink" title="定义配置文件"></a>定义配置文件</h3><p><strong><em>1、配置根Logger，其语法为：</em></strong></p>
<pre><code>log4j.rootLogger = [ level ] , appenderName, appenderName, …
</code></pre><ul>
<li>level是日志记录的优先级，Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来</li>
<li>appenderName就是指日志信息输出到哪个地方。您可以同时指定多个输出目的地</li>
</ul>
<p><strong><em>2.配置日志信息输出目的地Appender，其语法为：</em></strong></p>
<pre><code>log4j.appender.appenderName = org.apache.log4j.DailyRollingFileAppender
</code></pre><p>其中，Log4j提供的appender有以下几种：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台），  </li>
<li>org.apache.log4j.FileAppender（文件），  </li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），  </li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  </li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<p><strong><em>3.配置日志信息的格式（布局），其语法为：</em></strong></p>
<pre><code>log4j.appender.appenderName.layout = org.apache.log4j.PatternLayout
</code></pre><p>其中，Log4j提供的layout有以e几种：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局），  </li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式），  </li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），  </li>
<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<h3 id="在代码中使用Log4j"><a href="#在代码中使用Log4j" class="headerlink" title="在代码中使用Log4j"></a>在代码中使用Log4j</h3><p><strong><em>1.得到记录器</em></strong></p>
<pre><code>static Logger logger = Logger.getLogger(Class clazz)；//在某对象中，用该对象所属的类作为参数
</code></pre><p><strong><em>2.读取配置文件()</em></strong></p>
<pre><code>PropertyConfigurator.configure ( String configFilename) ：读取使用Java的特性文件编写的配置文件
</code></pre><p>例如：</p>
<pre><code>PropertyConfigurator.configure(&quot;config/properties/log4j.properties&quot;);
</code></pre><p>在项目下面建立一个文件夹名为config即可，这是标准写法。注意log4j默认的相对路径是工程下面，非src或者bin</p>
<p><strong><em>3.插入记录信息（格式化日志信息）</em></strong></p>
<pre><code>Logger.debug ( Object message ) ;  
Logger.info ( Object message ) ;  
Logger.warn ( Object message ) ;  
Logger.error ( Object message ) ;
</code></pre><h3 id="配置文件相对路径"><a href="#配置文件相对路径" class="headerlink" title="配置文件相对路径"></a>配置文件相对路径</h3><pre><code>log4j.appender.R.File=${user.dir}/logs/log.log
</code></pre><h2 id="commons-logging-和-log4j-之间的关系"><a href="#commons-logging-和-log4j-之间的关系" class="headerlink" title="commons-logging 和 log4j 之间的关系"></a>commons-logging 和 log4j 之间的关系</h2><h3 id="Log4j与通用日志包commons-logging的结合使用"><a href="#Log4j与通用日志包commons-logging的结合使用" class="headerlink" title="Log4j与通用日志包commons-logging的结合使用"></a>Log4j与通用日志包commons-logging的结合使用</h3><p>其实commons-logging中<strong><em>默认都支持</em></strong> Log4j，因此只要同时加载commons-logging包和log4j包，可以不用配置即可用在应用中使用commons-logging的接口方法。    </p>
<p>当然，标准的应用的是需要的配置，如果你log4j则这个配置是可选的。下面我说明如何通过配置文件来组合commons-logging和log4j。</p>
<p>配置文件内容很简单，就指定一个日志实现类即可，下面是个示例文件commons-logging.properties：</p>
<pre><code>org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger
org.apache.commons.logging.LogFactory=org.apache.commons.logging.impl.LogFactoryImpl
</code></pre><h3 id="commons-logging-和-log4j-之间的关系-1"><a href="#commons-logging-和-log4j-之间的关系-1" class="headerlink" title="commons-logging 和 log4j 之间的关系"></a>commons-logging 和 log4j 之间的关系</h3><p>我们在做项目时，日志的记录是必不可少的一项任务，而我们通常是使用 apache 的 log4j 日志管理工具。然而，在项目中，我们经常会看到两个 jar 包：commons-logging.jar 和 log4j.jar。为什么我们在使用 log4j 的同时还要引入 commons-logging.jar 呢，或者说不用 commons-logging.jar 可不可以，这两者之间到底是怎么的一种关系呢？ </p>
<p>作为记录日志的工具，它至少应该包含如下几个组成部分(组件)： </p>
<ol>
<li>Logger<br> 记录器组件负责产生日志，并能够对日志信息进行分类筛选，控制什么样的日志应该被输出，什么样的日志应该被忽略。它还有一个重要的属性 － 日志级别。不管何种日志记录工具，大概包含了如下几种日志级别：DEBUG, INFO, WARN, ERROR 和 FATAL。 </li>
<li>Level<br> 日志级别组件。 </li>
<li>Appender<br> 日志记录工具基本上通过 Appender 组件来输出到目的地的，一个 Appender 实例就表示了一个输出的目的地。 </li>
<li>Layout<br> Layout 组件负责格式化输出的日志信息，一个 Appender 只能有一个 Layout。 </li>
</ol>
<p>我们再来看看 log4j.jar，打开 jar 包，我们可以看到 Logger.class(Logger)，Level.class(Level), FileAppender.class(Appender)， HTMLLayout.class(Layout)。其它的我们先忽略不看，这几个字节码文件正好是记录日志必不可少的几个组件。 </p>
<p>接下来看看 commons-logging 中的 org.apache.commons.logging.Log.java 源码： </p>
<pre><code>package org.apache.commons.logging;  
public interface Log {  
    public boolean isDebugEnabled();  
    public boolean isErrorEnabled();  
    public boolean isFatalEnabled();  
    public boolean isInfoEnabled();  
    public boolean isTraceEnabled();  
    public boolean isWarnEnabled();  
    public void trace(Object message);  
    public void trace(Object message, Throwable t);  
    public void debug(Object message);  
    public void debug(Object message, Throwable t);  
    public void info(Object message);  
    public void info(Object message, Throwable t);  
    public void warn(Object message);  
    public void warn(Object message, Throwable t);  
    public void error(Object message);  
    public void error(Object message, Throwable t);  
    public void fatal(Object message);  
    public void fatal(Object message, Throwable t);  
}  
</code></pre><p>很显然，只要实现了 Log 接口，它就是一个名副其实的 Logger 组件，也验证了 Logger 组件具有日志级别的属性。继续看 commons-logging org.apache.commons.logging.impl 包下的几个类的源码片段： </p>
<pre><code>package org.apache.commons.logging.impl;  

import org.apache.commons.logging.Log;  
import org.apache.log4j.Logger;  
import org.apache.log4j.Priority;  
import org.apache.log4j.Level;  
import ......  

public class Log4JLogger implements Log, Serializable {  
    // 对 org.apache.commons.logging.Log 的实现  
    ......  
}  

------------------------------------------------------------------  

package org.apache.commons.logging.impl;  

import org.apache.commons.logging.Log;  
import java.io.Serializable;  
import java.util.logging.Level;  
import java.util.logging.Logger;  

public class Jdk14Logger implements Log, Serializable {  
     // 对 org.apache.commons.logging.Log 的实现  
    ......  
}  
</code></pre><p>好了，分析到这里，我们应该知道，<font color="red">真正的记录日志的工具是 log4j 和 sun 公司提供的日志工具。而 commons-logging 把这两个(实际上，在 org.apache.commons.logging.impl 包下，commons-logging 仅仅为我们封装了 log4j 和 sun logger)记录日志的工具重新封装了一遍(Log4JLogger.java 和 Jdk14Logger.java)，可以认为 org.apache.commons.logging.Log 是个傀儡，它只是提供了对外的统一接口。因此我们只要能拿到 org.apache.commons.logging.Log，而不用关注到底使用的是 log4j 还是 sun logger。</font>正如我们经常在项目中这样写： </p>
<pre><code>// Run 是我们自己写的类，LogFactory 是一个专为提供 Log 的工厂(abstract class)  
private static final Log logger = LogFactory.getLog(Run.class);  
</code></pre><p>既然如此，我们向构建路径加了 commons-logging.jar 和 log4j.jar 两个 jar 包，那我们的应用程序到底使用的 log4j 还是 sun logger 呢？我们能不能认为由于加了 log4j.jar 包，就认为系统使用的就是 log4j 呢？事实上当然不是这样的，那我还认为我正在使用 jdk 而认为系统使用的是 sun logger 呢。使用 Spring 的朋友可以在 web.xml 中看到如下 listener 片段： </p>
<pre><code>&lt;listener&gt;  
    &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;  
&lt;/listener&gt;  
</code></pre><p>这是由 Spring 为我们提供的实现了标准的 servlet api 中的 javax.servlet.ServletContextListener 接口，用于在 web 容器启动时做一些初始化操作。我们逐层进入 Spring 的源码，可以看到如下代码： </p>
<pre><code>Log4jConfigurer.initLogging(location, refreshInterval);  
</code></pre><p>终于找到了 org.springframework.util.Log4jConfigurer，这正是 log4j 提供给我们的初始化日志的类。至此，我们终于明白了我们系统的的确确使用的是 log4j 的日志工具。 </p>
<p>可是问题又来了，org.apache.commons.logging.Log 和 org.apache.log4j.Logger 这两个类，通过包名我们可以发现它们都是 apache 的项目，既然如下，为何要动如此大的动作搞两个东西(指的是 commons-logging 和 log4j)出来呢？事实上，在 sun 开发 logger 前，apache 项目已经开发了功能强大的 log4j 日志工具，并向 sun 推荐将其纳入到 jdk 的一部分，可是 sun 拒绝了 apache 的提议，sun 后来自己开发了一套记录日志的工具。可是现在的开源项目都使用的是 <font color="red"><strong><em>log4j</em></strong></font>，log4j 已经成了事实上的标准，但由于又有一部分开发者在使用 <font color="red"><strong><em>sun logger</em></strong></font>，因此 apache 才推出 commons-logging，<font color="red"><strong><em>使得我们不必关注我们正在使用何种日志工具</em></strong></font>。</p>
<h2 id="slf4j-api、slf4j-log4j12以及log4j之间的关系"><a href="#slf4j-api、slf4j-log4j12以及log4j之间的关系" class="headerlink" title="slf4j-api、slf4j-log4j12以及log4j之间的关系"></a>slf4j-api、slf4j-log4j12以及log4j之间的关系</h2><p>几乎在每个jar包里都可以看到log4j的身影，在多个子工程构成项目中，slf4j相关的冲突时不时就跳出来让你不爽，那么slf4j-api、slf4j-log4j12还有log4j是什么关系？ </p>
<p><strong><em>slf4j:Simple Logging Facade for Java，为java提供的简单日志Facade。</em></strong>Facade门面，更底层一点说就是<strong>接口</strong>。<font color="red"><strong><em>它允许用户以自己的喜好，在工程中通过slf4j接入不同的日志系统</em></strong></font>。更直观一点，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。</p>
<p>因此slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。查看slf4j-api源码就可以发现，里面除了public final class LoggerFactory类之外，都是接口定义。因此slf4j-api本质就是一个接口定义。</p>
<p>下图比较清晰的描述了它们之间的关系，例子为当系统采用log4j作为日志框架实现的调用关系：</p>
<p><img src="http://i.imgur.com/0GvNDWm.png" alt=""></p>
<p>①首先系统包含slf4j-api作为日志接入的接口。<font color="red">compile时slf4j-api中public final class LoggerFactor类中private final static void bind()方法会寻找具体的日志实现类绑定，主要通过StaticLoggerBinder.getSingleton()的语句调用。</font></p>
<p>②slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法。</p>
<p>③log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codeceo.com/article/log4j-usage.html" target="_blank" rel="external">http://www.codeceo.com/article/log4j-usage.html</a><br><a href="http://blog.csdn.net/hpf911/article/details/5852127" target="_blank" rel="external">http://blog.csdn.net/hpf911/article/details/5852127</a><br><a href="http://www.tuicool.com/articles/U7ZjUni" target="_blank" rel="external">http://www.tuicool.com/articles/U7ZjUni</a><br><a href="http://zachary-guo.iteye.com/blog/361177" target="_blank" rel="external">http://zachary-guo.iteye.com/blog/361177</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/08/04/[网络安全]Dos攻击原理及防御/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/04/[网络安全]Dos攻击原理及防御/" itemprop="url">Dos攻击原理及防御</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-04T00:00:00+08:00">
                2016-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Dos攻击简介"><a href="#Dos攻击简介" class="headerlink" title="Dos攻击简介"></a>Dos攻击简介</h2><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，<strong><em>其目的是使计算机或网络无法提供正常的服务</em></strong>。最常见的DoS攻击有计算机网络 <strong><em>带宽攻击</em></strong>和 <strong><em>连通性攻击</em></strong>。</p>
<ul>
<li><strong><em>带宽攻击</em></strong> 指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。</li>
<li><strong><em>连通性攻击</em></strong> 指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。</li>
</ul>
<h2 id="DDos攻击简介"><a href="#DDos攻击简介" class="headerlink" title="DDos攻击简介"></a>DDos攻击简介</h2><p>传统上，攻击者所面临的主要问题是网络带宽，由于较小的网络规模和较慢的网络速度的限制，攻击者无法发出过多的请求。但大多数的DoS攻击还是需要相当大的带宽的，而以个人为单位的黑客们很难使用高带宽的资源。为了克服这个缺点，DoS攻击者开发了分布式的攻击。攻击者简单利用工具集合许多的网络带宽来同时对同一个目标发动大量的攻击请求，这就是DDoS(Distributed Denial of Service)攻击。</p>
<h2 id="攻击表现方式★★★"><a href="#攻击表现方式★★★" class="headerlink" title="攻击表现方式★★★"></a>攻击表现方式★★★</h2><p>无论是DoS攻击还是DDoS攻击，简单的看，都只是一种破坏网络服务的黑客方式，虽然具体的实现方式千变万化，但都有一个共同点，就是其根本目的是使受害主机或网络无法及时接收并处理外界请求，或无法及时回应外界请求。其具体表现方式有以下几种：</p>
<p>　1. 制造大流量<strong><em>无用数据</em></strong>，造成通往被攻击主机的网络拥塞，使被攻击主机无法正常和外界通信。<br>　2. 利用被攻击主机提供服务或传输协议上处理重复连接的缺陷，反复高频的发出攻击性的 <strong><em>重复服务请求</em></strong>，使被攻击主机无法及时处理其它正常的请求。<br>　3. 利用被攻击主机所提供服务程序或传输协议的本身实现缺陷，反复发送 <strong><em>畸形的攻击数据</em></strong> 引发系统错误的分配大量系统资源，使主机处于挂起状态甚至死机。</p>
<h2 id="TCP三次连接及重要概念"><a href="#TCP三次连接及重要概念" class="headerlink" title="TCP三次连接及重要概念"></a>TCP三次连接及重要概念</h2><h3 id="TCP连接三次握手"><a href="#TCP连接三次握手" class="headerlink" title="TCP连接三次握手"></a>TCP连接三次握手</h3><p>要理解dos攻击，首先要理解TCP连接的三次握手过程(Three-way handshake)。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<div align="center"><br><img src="http://i.imgur.com/sSu5DYG.jpg" alt=""><br></div>

<ul>
<li>第一次握手:建立连接时，客户端发送 <strong><em>SYN</em></strong> 包((SYN=i)到服务器，并进入 <strong><em>SYN_SEND</em></strong> 状态，等待服务器确认;</li>
<li>第二次握手:服务器收到SYN包，必须确认客户的SYN (ACK=i+1 )，同时自己也发送一个SYN包((SYN=j)}即 <strong><em>SYN+ACK</em></strong> 包，此时服务器进入 <strong><em>SYN_RECV</em></strong> 状态;</li>
<li>第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包 <strong><em>ACK</em></strong> (ACK=j+1)，此包发送完毕，客户端和服务器进入 <strong><em>ESTABLISHED</em></strong> 状态，完成三次握手，客户端与服务器开始传送数据。</li>
</ul>
<h3 id="一些重要概念"><a href="#一些重要概念" class="headerlink" title="一些重要概念"></a>一些重要概念</h3><ul>
<li>半连接：<strong><em>收到SYN包而还未收到ACK包时的连接状态</em></strong> 称为半连接，即尚未完全完成三次握手的TCP连接。</li>
<li>半连接队列：在三次握手协议中，服务器维护一个半连接队列，<strong><em>该队列为每个客户端的SYN包(SYN=i)开设一个条目</em></strong>，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</li>
<li>Backlog参数：表示半连接队列的<strong><em>最大容纳数目</em></strong>。</li>
<li>SYN-ACK重传次数：<strong><em>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传</em></strong>，等待一段时间仍未收到客户确认包，进行第二次重传，<strong><em>如果重传次数超过系统规定的最大重传次数，系统将该连接信息、从半连接队列中删除</em></strong>。注意，每次重传等待的时间不一定相同。</li>
<li>半连接存活时间：是指半连接队列的条目存活的最长时间，也即<strong><em>服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和</em></strong>。有时也称半连接存活时间为Timeout时间、SYN_RECV存活时间。</li>
<li>上面 <strong><em>三个参数</em></strong> 对系统的TCP连接状况有很大影响</li>
</ul>
<h2 id="常见攻击与防范参考"><a href="#常见攻击与防范参考" class="headerlink" title="常见攻击与防范参考"></a>常见攻击与防范参考</h2><h3 id="SYN-Flood攻击（SYN洪水攻击）"><a href="#SYN-Flood攻击（SYN洪水攻击）" class="headerlink" title="SYN Flood攻击（SYN洪水攻击）"></a>SYN Flood攻击（SYN洪水攻击）</h3><p><strong><em>大纲：</em></strong><br><img src="http://i.imgur.com/SKds3zZ.png" alt=""></p>
<div style="display:none;"><br>    <table cellspacing="0px"><br>        <tr><th>Dos攻击形式</th><th>解决方法</th></tr><br>        <tr><td>1、固定源地址发起攻击</td><td>检测到某个IP地址发起较多报文，加入黑名单</td></tr><br>        <tr><td>2、伪造IP地址进行攻击</td><td rowspan="2">方法1失效，原因：<br>    1、单个IP发送的SYN报文不会很多，达不到被拒绝的阈值<br>    2、伪装的IP若被拒绝到，正常用户使用该IP将会无法获得服务<br>    3、可以用三种解决方法方法，如下表</td></tr><br>        <tr><td>3、僵尸网络固定源地址发起攻击</td></tr><br>    </table><br><br>    <table cellspacing="0px"><br>        <tr><th>解决方法</th><th>问题</th></tr><br>        <tr><td>方法一：不断监视系统中连接队列，达到阈值就释放系统连接</td><td>入门级防御SYN Flood方法，正常连接也会淹没在其中而被释放</td></tr><br>        <tr><td>方法二：延缓TCB分配</td><td>1、SYS Cache：cache（哈希表）中保存半连接信息，收到正确回应ACK后再分配TCB<br>    2、SYN cookie：根据SYN包按照一定的规则计算SYN+ACK包的初始序列。客户端返回ACK再次校验，若正确才分配TCB</td></tr><br>        <tr><td>方法三：使用SYN Proxy防火墙</td><td>防火墙提供SYN代理，验证成功后才放行</td></tr><br>    </table><br></div>

<p><strong><em>原理：</em></strong></p>
<ul>
<li>问题就出在TCP连接的三次握手中，假设一个用户<strong><em>向服务器发送了SYN报文后突然死机或掉线</em></strong>，那么服务器在发出SYN+ACK应答报文后是<strong><em>无法收到客户端的ACK报文</em></strong>的(第三次握手无法完成)，这种情况下服务器端一般会重试(<strong><em>再次发送SYN+ACK给客户端</em></strong>)，并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为<strong><em>SYN Timeout</em></strong>，一般来说这个时间是分钟的数量级(<strong><em>大约为30秒 - 2分钟</em></strong>);</li>
<li>一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源<ul>
<li><strong><em>数以万计的半连接</em></strong>，即使是简单的<strong><em>保存并遍历也会消耗非常多的CPU时间和内存</em></strong>，何况还要不断对这个列表中的IP进行<strong><em>SYN+ACK的重试</em></strong>。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃</li>
<li>即使服务器端的<strong><em>系统足够强大</em></strong>，服务器端也将忙于处理攻击者伪造的TCP连接请求而<strong><em>无暇理睬客户的正常请求</em></strong>(毕竟客户端的正常请求比率非常之小)，此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击(SYN洪水攻击)。</li>
</ul>
</li>
</ul>
<p><strong><em>SYN Flood种类：</em></strong></p>
<p><img src="http://i.imgur.com/jLdacJD.jpg" alt=""></p>
<ol>
<li>Direct Attack 攻击方使用 <strong><em>固定的源地址</em></strong> 发起攻击，这种方法对攻击方的消耗最小</li>
<li>Spoofing Attack 攻击方使用变化的源地址发起攻击，这种方法需要攻击方 <strong><em>不停地修改源地址</em></strong>，实际上消耗也不大</li>
<li>Distributed Direct Attack 这种攻击主要是使用<strong><em>僵尸网络</em></strong>进行<strong><em>固定源地址</em></strong>的攻击</li>
</ol>
<p><strong><em>防范：</em></strong></p>
<p>对于第一种攻击的防范可以使用比较简单的方法，即对SYN包进行监视，如果发现某个IP发起了较多的攻击报文，直接将这个<strong><em>IP列入黑名单</em></strong>即可。当然下述的方法也可以对其进行防范。<br>对于源地址不停变化的攻击使用上述方法则不行，首先从某一个被伪装的IP过来的Syn报文可能不会太多，<strong><em>达不到被拒绝的阈值</em></strong>，其次从这个<strong><em>被伪装的IP（真实的）的请求会被拒绝掉</em></strong>，即导致正常用户使用该IP将会无法访问服务。因此必须使用其他的方法进行处理。</p>
<p><strong>1． 无效连接监视释放</strong><br>　　这种方法不停<strong><em>监视系统的半开连接和不活动连接</em></strong>，当<strong><em>达到一定阈值时拆除这些连接</em></strong>，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级防御SYN Flood方法。</p>
<p><strong>2． 延缓TCB分配方法</strong><br>　　从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，<font color="red">当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗</font>。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<p>　　<strong>Syn Cache技术：</strong><br>　　这种技术是在收到SYN数据报文时<strong><em>不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB</em></strong>。在FreeBSD系统中这种Cache每个半开连接只需使用160字节，远小于TCB所需的736个字节。在发送的SYN ACK中需要使用一个己方的Sequence Number，这个数字不能被对方猜到，否则对于某些稍微智能一点的Syn Flood攻击软件来说，它们在发送Syn报文后会发送一个ACK报文，如果己方的Sequence Number被对方猜测到，则会被其建立起真正的连接。因此一般采用一些加密算法生成难于预测的Sequence Number。</p>
<p>　　<strong>Syn Cookie技术：</strong><br>　　对于SYN攻击，Syn Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，<strong><em>还是需要使用一些空间去保存己方生成的Sequence Number等信息</em></strong>，也造成了一些资源的浪费。<br>　　<strong><em>Syn Cookie技术则完全不使用任何存储资源</em></strong>，这种方法比较巧妙，它<strong><em>使用一种特殊的算法生成Sequence Number</em></strong>，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，<strong><em>重新计算一遍</em></strong>，看其是否与<strong><em>对方回应报文中的（Sequence Number-1）相同</em></strong>，从而决定是否分配TCB资源。(<font color="red">在接收到syn包后不分配TCB资源，而是根据SYN包计算出一个cookie，这个cookie作为将要返回syn+ack包的序号列，服务器中不存储序列号。下次客户端返回ack包时，再根据包头信息计算cookie，与ack包的序号加一进行对比，如果相等，则说明是正常的连接，分配资源建立连接</font>)</p>
<p><strong>3． 使用SYN Proxy防火墙</strong><br>　　Syn Cache技术和Syn Cookie技术总的来说是一种<strong><em>主机保护技术</em></strong>，需要系统的<strong><em>TCP/IP协议栈的支持</em></strong>，而目前<strong><em>并非所有的操作系统支持这些技术</em></strong>。因此很多防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p>
<p><img src="http://i.imgur.com/dR07Uvz.jpg" alt=""></p>
<p>　　从上图（左图）中可以看出，防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，在右图中，所有的无效连接均无法到达内部的服务器。而<strong><em>防火墙采用的验证连接有效性的方法则可以是Syn Cookie或Syn Flood等其他技术</em></strong>。<br>　　采用这种方式进行防范需要注意的一点就是防火墙需要对整个有效连接的过程发生的数据包<strong><em>进行代理</em></strong>，如下图所示：</p>
<div align="center"><br><img src="http://i.imgur.com/pM1a1P3.gif" alt=""><br></div>

<p>　　因为防火墙代替发出的SYN ACK包中使用的序列号为c，而服务器真正的回应包中序列号为c’，这其中有一个差值<strong><em>|c-c’|</em></strong>，在每个相关数据报文经过防火墙的时候进行序列号的修改。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>什么是Dos攻击？<br><a href="http://blog.csdn.net/justdoitflyer/article/details/12870907" target="_blank" rel="external">http://blog.csdn.net/justdoitflyer/article/details/12870907</a><br>SYN Flood攻击及防御方法<br><a href="http://blog.csdn.net/bill_lee_sh_cn/article/details/6065704" target="_blank" rel="external">http://blog.csdn.net/bill_lee_sh_cn/article/details/6065704</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/08/01/[Linux]磁盘分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/01/[Linux]磁盘分区/" itemprop="url">磁盘分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-01T00:00:00+08:00">
                2016-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="磁盘连接方式与设备文件名的关系"><a href="#磁盘连接方式与设备文件名的关系" class="headerlink" title="磁盘连接方式与设备文件名的关系"></a>磁盘连接方式与设备文件名的关系</h2><ul>
<li>计算机常用的磁盘接口有两种，分别是IDE与SATA接口，目前主流是SATA接口</li>
<li>一个IDE电缆可以连接两个IDE设备，通常主机提供两个IDE接口，因此最多可以接四个IDE设备。IDE设备分为主设备（Master）与从设备（Slave），四个IDE设备的文件名分别是<strong>/dev/hda、/dev/hdb、/dev/hdc/、/dev/hdd</strong>，对应IDE1的主设备、IDE1的从设备、IDE2的主设备、IDE2的从设备</li>
<li>SATA/USB/SCSI接口的磁盘设备文件名都是<strong>/dev/sd[a-p]</strong>，与IDE接口不同的是，SATA/USB接口没有一定的顺序，根据<strong>Linux内核检测到的磁盘顺序决定</strong>，即设备文件名与插槽号无关，Linux内核根据SATA插槽顺序进行检测磁盘，USB在开机候才被系统识别<br><img src="http://i.imgur.com/WXsDx1n.jpg" alt=""></li>
</ul>
<h2 id="磁盘组成"><a href="#磁盘组成" class="headerlink" title="磁盘组成"></a>磁盘组成</h2><ul>
<li>磁盘由盘片、机械手臂、磁头与主轴马达组成，数据的写入是在盘片上</li>
<li>盘片上可以细分为扇区与柱面两种单位</li>
<li>磁道：盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道</li>
<li>柱面：硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面。磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用</li>
<li>扇区：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，每个扇区可以存放512个字节的信息，磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位</li>
</ul>
<p><img src="http://img.mydigit.net/Mon_1111/84_493179_8d87dfa7e9d372c.jpg?26" alt=""></p>
<p><strong><em>问题1：不同磁道的扇区数是否相同？</em></strong></p>
<ul>
<li><p><strong>在旧的记录方式</strong>，的确每个磁道所拥有的扇区数量都是一样的。因为每个扇区所能容纳的数据量是相同的，都是512字节，而数据量需要平均分配在扇区面积的每个角落，所以外面扇区的数据密度低，里面扇区的速度密度高<br><img src="http://i.imgur.com/zHHLPEj.png" alt=""></p>
</li>
<li><p><strong>新的解决方式</strong>认为，既然磁盘越往外面积越大，那就应该划分出更多的扇区，每个扇区的面积都是一样的，容纳的数据量也是一样的<br><img src="http://i.imgur.com/0kRy8Wz.png" alt=""></p>
</li>
</ul>
<p><strong><em>问题2：如果有一块空硬盘，写入一个文件，是不是先写满同一个磁道的所有扇区，然后再换一个磁道写入？</em></strong></p>
<p>　　是的，而且<strong>写入的方式是从外到内</strong>，先写满最外的磁道，接着再写里面的磁道。为什么硬盘用久了读写速度会变慢？因为外面的磁道使用完了，开始用里面的磁道，越是里面的磁道读写速度越慢，同样的时间，读写头在外面磁道可以扫过10个扇区的面积，读写10个扇区的数据，但在里面的磁道只能扫过1个扇区的面积，读写1个扇区的数据，所以这时该做磁盘整理或者格式化，这会使外面的磁道得到使用</p>
<h2 id="磁盘的第一扇区（主引导分区、分区表）"><a href="#磁盘的第一扇区（主引导分区、分区表）" class="headerlink" title="磁盘的第一扇区（主引导分区、分区表）"></a>磁盘的第一扇区（主引导分区、分区表）</h2><p>磁盘的第一个扇区记录了两个重要信息，分别是：</p>
<ul>
<li>主引导分区（MBR），可以安装引导加载程序的地方，有446bytes。MBR是很重要的，系统在<strong>开机的时候会主动去读取这个区块的内容，这样系统才知道你的程序放在哪里且如何进行开机。</strong>如果你要安装多重引导的系统，MBR这个区块的管理就非常重要了</li>
<li>分区表，记录整块硬盘分区的状态，有64bytes </li>
</ul>
<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p><img src="http://i.imgur.com/Y8b8nPX.png" alt=""></p>
<ul>
<li>柱面是分割磁盘的最小单位，以开始柱面与结束柱面来标识一个分区</li>
<li>假设上面硬盘的设备文件名为/dev/hda，四个分区的设备文件名会在文件名后再加上一个数字，分别是/dev/hda1，/dev/hda2，/dev/hda3，/dev/hda4</li>
<li>上述硬盘被分为四个分区，第四个分区为301~400柱面的范围，在windows系统中，四个分区分别是C、D、E、F。当你把数据写入F盘时，你的数据会被写入这块磁盘的301~400号柱面之间</li>
<li><p><strong>分区表总结</strong></p>
<ul>
<li><strong>所谓的分区就是对64bytes的分区表进行设置而已</strong></li>
<li>分区的最小单位是柱面</li>
<li><strong>分区表默认只能写入四组分区信息，即主分区与扩展分区不超过四个</strong></li>
<li>系统要写入磁盘时，必须参考分区表，才能对某个分区进行数据处理</li>
<li>分区的好处：数据安全，系统性能</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/U8YbelW.png" alt=""></p>
<ul>
<li><p>分区继续深入</p>
<ul>
<li>上图中四个分区记录区仅用到两个，P1为主分区，P2为扩展分区</li>
<li>图中这5个由扩展分区切出来的分区叫做逻辑分区</li>
<li>上述分区在Linux下的设备文件名分别是P1：hda1，P2：hda2，L1：hda5，L2：hda6，L3：hda7，L4：hda8，L5：hda9</li>
<li><strong>发现少了hda3，hda4，因为前面四个号码都是保留给主分区和扩展分区用的，所以逻辑分区的设备号从5开始</strong></li>
</ul>
</li>
<li><p><strong>分区总结</strong></p>
<ul>
<li>主分区和扩展分区最多有四个</li>
<li>扩展分区最多只有一个（操作系统的限制）</li>
<li>逻辑分区是由扩展分区切割出来的分区</li>
<li>能够被格式化的是主分区和逻辑分区，扩展分区无法格式化 </li>
</ul>
</li>
</ul>
<h2 id="MBR（Master-boot-Record）主引导分区"><a href="#MBR（Master-boot-Record）主引导分区" class="headerlink" title="MBR（Master boot Record）主引导分区"></a>MBR（Master boot Record）主引导分区</h2><h3 id="开机流程"><a href="#开机流程" class="headerlink" title="开机流程"></a>开机流程</h3><ul>
<li>操作系统的作用是控制计算机硬件资源的合理分配，但操作系统也是一个软件，从开机到执行操作系统软件的过程如下：</li>
<li>CMOS是记录各项硬件参数且嵌在主板上的存储器，BIOS是写入到主板的一个软件程序，<strong>是计算机开机主动执行的第一个的程序</strong></li>
<li><strong><em>BIOS</em></strong> 会根据用户的设置取得能够开机的硬盘，并读取该硬盘第一个扇区的 <strong><em>MBR</em></strong> 位置，MBR中会放置 <font color="red"><strong><em>引导加载程序</em></strong></font>，引导加载程序的目的是加载内核文件，<strong><em>内核文件</em></strong> 开始操作系统的功能</li>
</ul>
<h3 id="多系统"><a href="#多系统" class="headerlink" title="多系统"></a>多系统</h3><ul>
<li>引导加载程序的主要功能是读取内核文件，开始操作系统。在多系统中，引导加载程序能提供用户不同的开机选项，并将加载功能转交给其他引导加载程序</li>
<li>引导加载程序不但可以放置在MBR中，还可以安装在每个分区的引导扇区</li>
<li>如下图是windows和Linux双系统，开机时MBR的引导加载程序提供两个菜单，菜单一（M1）可以直接加载Windows内核文件来开机，菜单二（M2）则将引导加载工作移交给第二个分区的引导加载程序，加载Linux的内核文件来开机<br><img src="http://i.imgur.com/XFSpuWG.png" alt=""></li>
</ul>
<p><strong><em>为什么装双系统，最好先装windows再装Linux？</em></strong></p>
<ul>
<li>因为Linux在安装时，可以选择将<font color="red"> <strong><em>引导加载加载程序</em></strong> </font>安装在MBR还是个别分区的引导扇区</li>
<li>Windows安装时，它的安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/29/[Java]JAVA深复制(深克隆)与浅复制(浅克隆)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/29/[Java]JAVA深复制(深克隆)与浅复制(浅克隆)/" itemprop="url">JAVA深复制(深克隆)与浅复制(浅克隆)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-29T00:00:00+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html" target="_blank" rel="external">http://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html</a></p>
<h2 id="浅复制与深复制概念"><a href="#浅复制与深复制概念" class="headerlink" title="浅复制与深复制概念"></a>浅复制与深复制概念</h2><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a><em>浅复制</em></h3><p>　　被复制的对象的成员变量与原来的对象都有相同的值，但引用其他对象的成员变量仍指向原来的对象，修改引用对象的值，会同时影响原对象与复制对象。换言之，<strong>浅复制仅仅复制所考虑的对象，不复制它引用的对象</strong>。</p>
<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a><em>深复制</em></h3><p>　　被复制的对象的所有成员变量与原来对象都有相同的值，而且引用其他对象的成员变量将指向被复制过的新对象。换言之，<strong>深复制把要复制的对象及所引用的对象都复制了一遍。</strong></p>
<h2 id="java-lang-Object类的clone-方法是浅复制"><a href="#java-lang-Object类的clone-方法是浅复制" class="headerlink" title="java.lang.Object类的clone()方法是浅复制"></a>java.lang.Object类的clone()方法是浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.clone();</div><div class="line">		</div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class student implements Cloneable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null;</div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code>student 18
student 18
</code></pre><p>因为复制对象中成员变量引用的对象professor不变，当改变新复制对象的成员变量引用值，对原对象也会有影响。<br><img src="http://img.blog.csdn.net/20160504171513907" alt="这里写图片描述"></p>
<h2 id="实现深层次克隆方法1"><a href="#实现深层次克隆方法1" class="headerlink" title="实现深层次克隆方法1"></a>实现深层次克隆方法1</h2><p>　　在复制对象时，对引用的对象也进行复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.clone();</div><div class="line">		</div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class student implements Cloneable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null;</div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">			((student)o).p = (professor)this.p.clone();//核心</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor implements Cloneable&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public Object clone()&#123;</div><div class="line">		Object o = null; </div><div class="line">		try&#123;</div><div class="line">			o = super.clone();</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实现深层次克隆方法2"><a href="#实现深层次克隆方法2" class="headerlink" title="实现深层次克隆方法2"></a>实现深层次克隆方法2</h2><p>　　利用串行化来做深复制，在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line">public class test&#123;</div><div class="line">	public static void main(String[] args) throws Exception&#123;</div><div class="line">		professor p = new professor(40);</div><div class="line">		student s = new student(&quot;student&quot;, p);</div><div class="line">		student new_s = (student)s.deepClone();</div><div class="line"></div><div class="line">		new_s.p.age = 18;</div><div class="line">		System.out.println(s);</div><div class="line">		System.out.println(new_s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class student implements Serializable&#123;</div><div class="line">	String name;</div><div class="line">	professor p;</div><div class="line">	public student(String name, professor p)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.p = p;</div><div class="line">	&#125;</div><div class="line">	public Object deepClone() throws Exception&#123;</div><div class="line">		//将对象写到流里</div><div class="line">		ByteArrayOutputStream bo = new ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream oo = new ObjectOutputStream(bo);</div><div class="line">		oo.writeObject(this);</div><div class="line">		//从流里读出来</div><div class="line">		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());</div><div class="line">		ObjectInputStream oi = new ObjectInputStream(bi);</div><div class="line">		return oi.readObject();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public String toString()&#123;</div><div class="line">		return name + &quot; &quot; + p.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class professor implements Serializable&#123;</div><div class="line">	int age;</div><div class="line">	public professor(int age)&#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<pre><code>student 40
student 18
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/29/[Java]Java集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java集合/" itemprop="url">Java集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-29T00:00:00+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集合框架–使用"><a href="#集合框架–使用" class="headerlink" title="集合框架–使用"></a>集合框架–使用</h2><p><img src="http://img.blog.csdn.net/20160416165357245" alt="这里写图片描述"></p>
<h3 id="开发常用"><a href="#开发常用" class="headerlink" title="开发常用"></a><em>开发常用</em></h3><p>　　●　在实际开发过程中，比较常用的是Vector、Stack、ArrayList、LinkedList、HashMap、HashTable<br>　　●　集合类基本上在util包中</p>
<h3 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a><em>集合分类</em></h3><p>　　Java集合类主要有以下几种<br>　 　●　List结构的集合类：ArrayList、LinkedList、Vector、Stack<br>　 　●　Map结构的集合类：HashMap、HashTable<br>　 　●　Set结构的集合类：HashSet、TreeSet<br>　 　●　Queue结构的集合：Queue接口</p>
<h2 id="List结构的集合类"><a href="#List结构的集合类" class="headerlink" title="List结构的集合类"></a>List结构的集合类</h2><h3 id="ArrayList类的使用-无同步性，线程不安全"><a href="#ArrayList类的使用-无同步性，线程不安全" class="headerlink" title="ArrayList类的使用(无同步性，线程不安全)"></a><em>ArrayList类的使用(无同步性，线程不安全)</em></h3><ul>
<li>基于动态数组的数据结构，随机访问优于LinkedList<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ArrayList</div><div class="line"></div><div class="line">1. 往list中插入元素 </div><div class="line">    ● boolean add(E e) 元素添加到列表的尾部 </div><div class="line">    ● void    add(int index, E element) 元素插入到列表的指定位置</div><div class="line">2. 返回列表中的元素数 </div><div class="line">    ● int size() 返回列表中的元素数 </div><div class="line">3. 如果此列表中没有元素，则返回 true </div><div class="line">    ● boolean isEmpty() </div><div class="line">4. 返回此列表中指定位置上的元素 </div><div class="line">    ● E get(int index) </div><div class="line">5. 用指定的元素替代此列表中指定位置上的元素,返回值是以前位于该位上的元素 </div><div class="line">    ● E set(int index, E element) </div><div class="line">6. 移除列表上的元素 </div><div class="line">    ● E remove(int index) 移除此列表中指定位置上的元素 </div><div class="line">    ● boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在） </div><div class="line">    ● protected void removeRange(int fromIndex, int toIndex) 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 </div><div class="line">    ● void clear() 移除列表中所有元素</div><div class="line">7. 查找元素 </div><div class="line">    ● contains(Object o) 判断list中是否含有指定元素 </div><div class="line">    ● int indexOf(Object o) 返回list中元素第一次出现的位置,若没有则返回-1 </div><div class="line">    ● int lastIndexOf(Object o) 返回arraylist中元素最后一次出现的位置,若没有则返回-1</div><div class="line">8. 返回包含此列表中所有元素的数组（按顺序），相当于数组API和collection API的桥梁,返回一个object的数组 </div><div class="line">    ● Object[] toArray()</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="LinkedList类的使用"><a href="#LinkedList类的使用" class="headerlink" title="LinkedList类的使用"></a><em>LinkedList类的使用</em></h3><ul>
<li>基于链表的数据结构，新增add和删除remove操作优于ArrayList<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 将指定元素插入此列表的开头</div><div class="line">    ● void addFirst(E e) </div><div class="line">2. 将指定元素添加到此列表的结尾</div><div class="line">    ● void addLast(E e)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Vector同理-线程安全具有同步性"><a href="#Vector同理-线程安全具有同步性" class="headerlink" title="Vector同理(线程安全具有同步性)"></a><em>Vector同理(线程安全具有同步性)</em></h3><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><em>Stack</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1. 测试堆栈是否为空 </div><div class="line">    boolean empty() </div><div class="line">2. 查看堆栈顶部的对象，但不从堆栈中移除它 </div><div class="line">    E peek() </div><div class="line">3. 移除堆栈顶部的对象，并作为此函数的值返回该对象</div><div class="line">    E pop() </div><div class="line">4. 把项压入堆栈顶部</div><div class="line">    E push(E item) </div><div class="line">5. 返回对象在堆栈中的位置，以 1 为基数  </div><div class="line">    int search(Object o)</div></pre></td></tr></table></figure>
<h3 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList和Vector的区别</div><div class="line">    ArrayList与Vector都是java的集合类，都可以用来存放java对象，这是他们的相同点，但是他们也有区别：</div><div class="line">1、同步性</div><div class="line">    Vector是线程同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是线程异步的，因此ArrayList中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销。</div><div class="line">2、数据增长</div><div class="line">    从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。</div></pre></td></tr></table></figure>
<h2 id="Map结构的集合类"><a href="#Map结构的集合类" class="headerlink" title="Map结构的集合类"></a>Map结构的集合类</h2><h3 id="HashMap（线程不同步），HashTable（线程同步）集合类"><a href="#HashMap（线程不同步），HashTable（线程同步）集合类" class="headerlink" title="HashMap（线程不同步），HashTable（线程同步）集合类"></a><em>HashMap（线程不同步），HashTable（线程同步）集合类</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void clear() </div><div class="line">      从此映射中移除所有映射关系。 </div><div class="line">V get(Object key) </div><div class="line">      返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null。 </div><div class="line">boolean isEmpty() </div><div class="line">      如果此映射不包含键-值映射关系，则返回 true。 </div><div class="line">V put(K key, V value) </div><div class="line">      在此映射中关联指定值与指定键。 </div><div class="line">V remove(Object key) </div><div class="line">      从此映射中移除指定键的映射关系（如果存在）。 </div><div class="line">int size() </div><div class="line">      返回此映射中的键-值映射关系数。</div></pre></td></tr></table></figure>
<h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a><em>Map遍历</em></h3><pre><code>1. Map.Entry&lt;String, String&gt;的数据类型为键值对。

2. map.entrySet(),返回类型为Set&lt;Entry&lt;String, String&gt;&gt; ，即map中非空元素组成的键值对Set集合，可以用图例（key1,value1）,(key2,value2)...(keyn,valuen)表示。

3. Map.Entry&lt;String, String&gt;类型分别通过getKey()、getValue()方法取出键和值。

4. 可以通过map.keySet()方法取出全部键的Set集合，从而通过map.get(Object key)方法取出值，即方法一。

5. 可以通过map.value()得到Collection&lt;String&gt;集合，得到所有值。即方法四

6、方法二中使用迭代器对数据遍历，类型是Map.Entry&lt;String, String&gt;，即仍旧是键值对，集合是map.entrySet().iterator()，比方法三麻烦。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">  map.put(<span class="string">"1"</span>, <span class="string">"value1"</span>);</div><div class="line">  map.put(<span class="string">"2"</span>, <span class="string">"value2"</span>);</div><div class="line">  map.put(<span class="string">"3"</span>, <span class="string">"value3"</span>);</div><div class="line">  </div><div class="line">  <span class="comment">//第一种：普遍使用，二次取值</span></div><div class="line">  System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</div><div class="line">  <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">   System.out.println(<span class="string">"key= "</span>+ key + <span class="string">" and value= "</span> + map.get(key));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//第二种</span></div><div class="line">  System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</div><div class="line">  Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</div><div class="line">  <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">   Map.Entry&lt;String, String&gt; entry = it.next();</div><div class="line">   System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//第三种：推荐，尤其是容量大时</span></div><div class="line">  System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);</div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">   System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//第四种</span></div><div class="line">  System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key"</span>);</div><div class="line">  <span class="keyword">for</span> (String v : map.values()) &#123;</div><div class="line">   System.out.println(<span class="string">"value= "</span> + v);</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="HashMap和Hashtable集合类的区别"><a href="#HashMap和Hashtable集合类的区别" class="headerlink" title="HashMap和Hashtable集合类的区别"></a><em>HashMap和Hashtable集合类的区别</em></h3><pre><code>HashMap与Hashtable都是java的集合类，都可以用来存放java对象，这是他们的相同点，但是他们也有区别。
1、历史原因
    Hashtable是基于陈旧的Dictionary类的，HashMap是java 1.2引进的Map接口的一个实现。
2、同步性
    Hashtable是线程同步的。这个类中的一些方法保证了Hashtable中的对象是线程安全的。而HashMap则是线程异步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。
3、值
    HashMap可以让你将空值作为一个表的条目的key或value但是Hashtable是不能放入空值的(null)
</code></pre><h2 id="List、Map集合框架的选择★（常用）★★★★"><a href="#List、Map集合框架的选择★（常用）★★★★" class="headerlink" title="List、Map集合框架的选择★（常用）★★★★"></a>List、Map集合框架的选择★（常用）★★★★</h2><pre><code>如何选用集合类？
1、要求线程安全，使用Vector、Hashtable
2、不要求线程安全，使用ArrayList,LinkedList,HashMap
3、要求key和value键值，则使用HashMap,Hashtable
4、数据量很大，又要线程安全，则使用Vector
</code></pre><h2 id="Set结构的集合类"><a href="#Set结构的集合类" class="headerlink" title="Set结构的集合类"></a>Set结构的集合类</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><em>用法</em></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#添加</div><div class="line">add(Object)</div><div class="line"></div><div class="line">#遍历</div><div class="line">Iterator&lt;String&gt; iterator = hashSet.iterator();</div><div class="line">while(iterator.hasNext())&#123;</div><div class="line">	System.out.println(iterator.next());</div><div class="line">&#125;</div><div class="line"></div><div class="line">#删除元素</div><div class="line">删除一个元素 remove(Object)</div><div class="line">删除所有元素 clear()</div><div class="line"></div><div class="line">#包含</div><div class="line">contain(Object)</div></pre></td></tr></table></figure>
<h3 id="HashSet与TreeSet区别"><a href="#HashSet与TreeSet区别" class="headerlink" title="HashSet与TreeSet区别"></a><em>HashSet与TreeSet区别</em></h3><ul>
<li>HashSet随机存储对象，不能保证先插入的元素出现在前面；TreeSet中元素默认按照元素自然序进行排列，使用compareTo()方法自定义排序</li>
<li>HashSet内部依靠HashMap，而TreeSet依靠TreeMap</li>
<li>HashSet可以存储空对象，但TreeSet不允许</li>
<li>性能，HashSet对基本操作add，remove，size有常数的时间复杂度，TreeSet有log(n)的时间复杂度</li>
<li>TreeSet比起HashSet具有更多丰富的功能，例如pollFirst(),pollLast(),first(),last(),celling(),lower()等</li>
<li>比较，HashSet使用equals()方法进行比较，而TreeSet使用compareTo()方法获得排列顺序</li>
</ul>
<h3 id="HashSet与TreeSet相同点"><a href="#HashSet与TreeSet相同点" class="headerlink" title="HashSet与TreeSet相同点"></a><em>HashSet与TreeSet相同点</em></h3><ul>
<li>只能存储独一无二的元素，不允许任何重复的元素</li>
<li>不是线程安全</li>
<li>Clone方法有相同的实现技术</li>
</ul>
<h2 id="Queue结构的集合"><a href="#Queue结构的集合" class="headerlink" title="Queue结构的集合"></a>Queue结构的集合</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/29/[Java]Java类加载器深入讲解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java类加载器深入讲解/" itemprop="url">Java类加载器深入讲解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-29T00:00:00+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器?"></a>什么是类加载器?</h2><p>　　加载类的工具，把硬盘上.class文件加载到内存，并进行一些处理，得到字节码</p>
<h2 id="类加载器有什么作用"><a href="#类加载器有什么作用" class="headerlink" title="类加载器有什么作用?"></a>类加载器有什么作用?</h2><p>　　当程序需要的某个类，那么需要通过类加载器把类的二进制加载到内存中，类加载器也是Java类</p>
<h2 id="类加载器之间的父子关系和管辖范围。"><a href="#类加载器之间的父子关系和管辖范围。" class="headerlink" title="类加载器之间的父子关系和管辖范围。"></a>类加载器之间的父子关系和管辖范围。</h2><p><img src="http://my.csdn.net/uploads/201207/12/1342057661_9458.png" alt="类加载器之间的父子关系和管辖范围图"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#获得类加载器的名字</div><div class="line">ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</div><div class="line">while (classLoader != null) &#123;</div><div class="line">    System.out.println(classLoader.getClass().getName());</div><div class="line">    classLoader = classLoader.getParent();</div><div class="line">&#125;</div><div class="line">System.out.println(classLoader);</div></pre></td></tr></table></figure>
<p><img src="http://my.csdn.net/uploads/201207/12/1342057738_7123.png" alt="此处输入图片的描述"></p>
<p>##4. 类加载器的委托机制:</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a><strong>类的加载</strong></h3><ol>
<li>当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢?<br>　　①首先 <strong>当前线程的类加载器</strong> 去加载线程中的第一个类.<br>　　②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B<br>　　③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类.</li>
<li>每个类加载器加载类时，又<strong>先委托给其上级类加载器</strong><br>　　<strong>当所有祖宗类加载器没有加载到类，回到发起者类加载器</strong>，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。</li>
</ol>
<h3 id="委托机制有什么好处"><a href="#委托机制有什么好处" class="headerlink" title="委托机制有什么好处?"></a><strong>委托机制有什么好处?</strong></h3><ul>
<li>集中管理，如果我们写了几个类加载器，都去加载某个类，那么内存中就有多份这个类的字节码</li>
<li>安全。系统类由系统的类加载器加载</li>
</ul>
<h3 id="能不能自己写一个类叫java-lang-System"><a href="#能不能自己写一个类叫java-lang-System" class="headerlink" title="能不能自己写一个类叫java.lang.System?"></a><strong>能不能自己写一个类叫java.lang.System?</strong></h3><p>　　为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸优先，也就是使用的永远是爸爸的(系统的)System类，而不是我们写的System类.</p>
<h2 id="编写自己的类加载器"><a href="#编写自己的类加载器" class="headerlink" title="编写自己的类加载器"></a>编写自己的类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>　　然后在新建一个类，通过上面的方法将新建的类的字节码进行加密:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderAttachment</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123; <span class="comment">//为什么要继承Date待会再说?</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello，itcast"</span>;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　并在工程里新建一个文件夹，用来保存加密后的class文件.<br>　　<img src="http://my.csdn.net/uploads/201207/12/1342057789_4367.png" alt="此处输入图片的描述"><br>　　那么这就需要使用我们自己的类加载器来进行解密了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String srcPath = args[<span class="number">0</span>];</div><div class="line">        String destDir = args[<span class="number">1</span>];</div><div class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcPath);</div><div class="line">        String destFileName = srcPath.substring(srcPath.lastIndexOf(<span class="string">'\\'</span>)+<span class="number">1</span>);</div><div class="line">        String destPath = destDir + <span class="string">"\\"</span> + destFileName;</div><div class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destPath);</div><div class="line">        cypher(fis，fos);</div><div class="line">        fis.close();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加密方法，同时也是解密方法</div><div class="line">     * <span class="doctag">@param</span> ips</div><div class="line">     * <span class="doctag">@param</span> ops</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cypher</span><span class="params">(InputStream ips ，OutputStream ops)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> b = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((b=ips.read())!=-<span class="number">1</span>)&#123;</div><div class="line">            ops.write(b ^ <span class="number">0xff</span>);<span class="comment">//如果是1就变成0，如果是0就变成1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> String classDir;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        String classFileName = classDir + <span class="string">"\\"</span> + name.substring(name.lastIndexOf(<span class="string">'.'</span>)+<span class="number">1</span>) + <span class="string">".class"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(classFileName);</div><div class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            cypher(fis，bos);</div><div class="line">            fis.close();</div><div class="line">            System.out.println(<span class="string">"aaa"</span>);</div><div class="line">            <span class="keyword">byte</span>[] bytes = bos.toByteArray();</div><div class="line">            <span class="keyword">return</span> defineClass(bytes， <span class="number">0</span>， bytes.length);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.classDir = classDir;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试运行代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class clazz = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClass"</span>).loadClass(<span class="string">"ClassLoaderAttachment"</span>);</div><div class="line"><span class="comment">//此处不能在使用ClassLoaderAttachment因为一旦用了之后，</span></div><div class="line"><span class="comment">//系统的类加载器就会去加载，导致失败，所以该类就继承了Date类了.</span></div><div class="line">Date date = (Date)clazz.newInstance();</div><div class="line">System.out.println(date);</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://my.csdn.net/uploads/201207/12/1342057844_5083.jpg" alt="此处输入图片的描述"></p>
<h2 id="一个类加载器的高级问题"><a href="#一个类加载器的高级问题" class="headerlink" title="一个类加载器的高级问题:"></a>一个类加载器的高级问题:</h2><p>　　我们知道tomcat服务器，是一个大大的java程序，那么它就必须在JVM上运行.这个大大的java程序内部也写了很多类加载器，它用这些类加载器去加载一些特定的类.注入servlet类.<br>下面我们新建一个javaweb工程，新建一个servlet程序.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request， HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException， IOException &#123;</div><div class="line">    response.setContentType(<span class="string">"text/html"</span>);</div><div class="line">    PrintWriter out = response.getWriter();</div><div class="line">    ClassLoader classload = <span class="keyword">this</span>.getClass().getClassLoader();</div><div class="line">    <span class="keyword">while</span> (classload != <span class="keyword">null</span>) &#123;</div><div class="line">        out.println(classload.getClass().getName()+<span class="string">"&lt;br&gt;"</span>);</div><div class="line">        classload = classload.getParent();</div><div class="line">    &#125;</div><div class="line">    out.println();</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　然后配置服务器，部署应用程序，启动tomcat服务器.在页面访问我们这个servlet，在页面打印的<br>结果如下图所示:<br><img src="http://my.csdn.net/uploads/201207/12/1342057884_8748.png" alt="此处输入图片的描述"><br>这是从小到大排序的.<br>现在呢?我想把该servlet打成jar包，放在ExtClassLoad类加载器加载的路径.<br>通过Eclipse即可完成<br><img src="http://my.csdn.net/uploads/201207/12/1342057935_6368.png" alt="此处输入图片的描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/29/[Java]Java面向对象编程的四大特征/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/29/[Java]Java面向对象编程的四大特征/" itemprop="url">Java面向对象编程的四大特征</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-29T00:00:00+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>　　我们在前面去定义一个类时候，实际上就是把一类事物的共有的属性和行为提取出来，形成一个物理模型(模版)。这种研究问题的方法称为抽象。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>　　封装就是把抽象出来的数据和对数据的操作封装在一起。数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作。</p>
<p>###<em>访问控制修饰符</em><br><img src="http://img.blog.csdn.net/20160416152720709" alt="这里写图片描述"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>　　继承可以解决代码复用，让我们的编程更加靠近人类思维。(变量)和方法时，可以从这些类中抽象出父类(比如刚才的Student)，在父类中定义这些相同的当多个类存在相同的属性属性和方法，所有的子类不需要重新定义这些属性和方法，只需要继承父类,这样子类就会自动拥有父类定义的某些属性和方法。
　　</p>
<h3 id="父类哪些属性、方法被子类继承"><a href="#父类哪些属性、方法被子类继承" class="headerlink" title="父类哪些属性、方法被子类继承"></a><em>父类哪些属性、方法被子类继承</em></h3><p>　　父类的public修饰符的属性和方法；protected修饰符的属性和方法；默认修饰符属性和方法被子类继承了，父类的private修饰符的属性和方法不能被子类继承。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><em>注意事项</em></h3><p>　　1. 子类最多只能继承一个父类(指直接继承)<br>　　2. java所有类都是Object类的子类 </p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a><em>方法重载（overload）</em></h3><p>　　简单的说：方法重载就是在类的同一种功能的多种实现方式，具有相同的方法名，但方法的参数类型、个数、顺序不同。<strong>到底采用哪种方式，取决于调用者给出的参数</strong>。<br>　　<br>注意事项</p>
<p>　　1. 方法返回类型可以不同(只是返回类型不一样，不能构成重载)<br>　　2. 方法的修饰符可以不同(只是控制访问修饰符不同，不能构成重载)</p>
<h3 id="方法覆盖（override）"><a href="#方法覆盖（override）" class="headerlink" title="方法覆盖（override）"></a><em>方法覆盖（override）</em></h3><p>　简单的说：方法覆盖就是<strong>子类</strong>有一个方法，和<strong>父类</strong>的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。</p>
<p>注意事项：</p>
<p>　　1、子类的方法的返回类型，参数，方法名称，要和父类的返回类型，参数，方法名称完全一样，否则编译出错。<br>　　2、子类方法不能缩小父类方法的访问权限，可以放大访问权限。★★★★</p>
<h3 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a><em>多态概念</em></h3><p>　　所谓多态，就是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的指针，来调用在不同子类中实现的方法。<br>　　实现多态有两种方式：1、继承；2、接口</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/29/[Java]java中的事件监听是怎样实现随时监听的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/29/[Java]java中的事件监听是怎样实现随时监听的/" itemprop="url">java中的事件监听是怎样实现随时监听的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-29T00:00:00+08:00">
                2016-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/monitor" target="_blank" rel="external">https://github.com/rhapsody1290/monitor</a></p>
<h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p><img src="http://img.blog.csdn.net/20160420164724788" alt="这里写图片描述"><br>　　Java中的事件监听是整个Java消息传递的基础和关键。牵涉到三类对象：事件源（Event Source）、事件（Event）、事件监听器（Event Listener）。<br>　　● 事件源是事件发生的场所，通常就是各个组件，它可以是一个按钮，编辑框等。<br>　　● 事件监听者负责监听事件源所发生的事件，并对各种事件做出相应的响应。<br>　　● 事件是描述事件源状态改变的对象。<br>　　具体实现呢，可以看看Button的源码。可能不好看得懂。那好我们仿照侯捷先生的作法，来模拟一个这样的事件传递： </p>
<h3 id="定义一个自己的事件"><a href="#定义一个自己的事件" class="headerlink" title="定义一个自己的事件"></a>定义一个自己的事件</h3><p>将事件源中value的最新值告知监听器</p>
<pre><code>public class MyEvent {
    private int value;

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
}
</code></pre><h3 id="做一个监听器接口-Listener"><a href="#做一个监听器接口-Listener" class="headerlink" title="做一个监听器接口 Listener"></a>做一个监听器接口 Listener</h3><p>当外部响应触发事件源上的事件时，产生一个事件对象，该事件对象会作为参数传递给监听器的事件处理方法</p>
<pre><code>public interface Listener {
    public void valueChanged(MyEvent e);
}
</code></pre><h3 id="做一个事件发生者"><a href="#做一个事件发生者" class="headerlink" title="做一个事件发生者"></a>做一个事件发生者</h3><ul>
<li>当事件源中的value值发生改变时，会促发事件</li>
<li>监听器在事件源上注册，事件源会保存该监听器，在事件触发时调用监听器的事件处理方法</li>
</ul>
<pre><code>public class MySource {
    private int value;
    private Vector&lt;Listener&gt; listeners = new Vector&lt;Listener&gt;();
    /**
     * 添加监听器
     * @param listener
     */
    public void addListener(Listener listener){
        listeners.add(listener);
    }

    public void setValue(int value){
        this.value = value;
        //发送消息
        MyEvent e = new MyEvent();
        e.setValue(value);
        for(int i = 0; i &lt; listeners.size(); i++){
            listeners.get(i).valueChanged(e);
        }
    }

}
</code></pre><h3 id="注册监听器"><a href="#注册监听器" class="headerlink" title="注册监听器"></a>注册监听器</h3><ul>
<li>如果想监听事件源中value值改变，就在事件源那儿注册一下监听器，然后写消息处理代码就可以了，一般使用匿名内部类的方式定义监听器</li>
<li>这样，当MySource的value真的改变时，就会触发响应</li>
</ul>
<pre><code>public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        MySource mySource = new MySource();
        mySource.addListener(new Listener() {
            public void valueChange(MyEvent e) {
                System.out.println(&quot;值改变了：&quot; + e.getValue());
            }
        });
        mySource.setValue(1);
    }

}

#结果
value changed to:10
</code></pre><p>Java中AWT/Swing的事件传递的实现，现在版本于上述有所不同，但应该都是这个原理。</p>
<h3 id="总结-图解-★★★★★★"><a href="#总结-图解-★★★★★★" class="headerlink" title="总结[图解]★★★★★★"></a>总结[图解]★★★★★★</h3><p><img src="http://i.imgur.com/JU0I5Nn.png" alt=""></p>
<h4 id="建议开发顺序："><a href="#建议开发顺序：" class="headerlink" title="建议开发顺序："></a>建议开发顺序：</h4><ul>
<li>先编写事件源，事件源中有监听器集合Vector<listener> listeners和增加监听器方法addListener</listener></li>
<li>在触发事件源的方法上如setValue，产生事件、并调用监听器方法，将事件以参数传入监听器方法</li>
<li>创建事件类和监听器类</li>
<li>测试，创建事件源——添加监听器——触发事件</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><strong><em>监听器本质</em></strong></p>
<ul>
<li>当调用setValue时，使得value属性的值发生变化，产生事件并调用监听器中对应该属性值改变时做出的处理；而事件不触发时不会产生这个响应，这就起到<strong><em>对一个属性值监控</em></strong> 的作用</li>
<li>使用监听器有什么好处呢？我们可以直接在setValue这个函数中做出响应啊！但是如果直接在serValue中写，这个响应处理不能由程序员自己控制，这是写死的。而采用监听器方法时，通过重写Listener中的事件处理函数，<strong><em>程序员可以自己编写事件处理函数</em></strong></li>
<li><font color="red">函数调用顺序是：外界动作调用setValue方法，在这个而方法中去调用监听器中对应的事件处理函数</font>

</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]. <a href="http://www.jcodecraeer.com/a/chengxusheji/java/2012/0822/371.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/chengxusheji/java/2012/0822/371.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/15/[Spring]Spring笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/15/[Spring]Spring笔记/" itemprop="url">Spring笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-15T08:51:00+08:00">
                2016-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><ul>
<li>struts是web框架 (jsp/action/actionfrom)</li>
<li>hibernate是orm框架，处于持久层</li>
<li>spring是<strong><em>容器框架</em></strong>，用于配置各个层的bean（action/service/domain/dao），并维护bean之间关系的框架 </li>
</ul>
<p>面试回答：<strong>Spring就是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</strong></p>
<h2 id="spring中重要概念★★★★★"><a href="#spring中重要概念★★★★★" class="headerlink" title="spring中重要概念★★★★★"></a>spring中重要概念★★★★★</h2><h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><ul>
<li><strong>Spring管理的对象为bean</strong></li>
<li>bean是java中的任何一种对象（javabean/service/action/数据源/dao），spring作用是配置各个层中的组件（bean），并维持组件（bean）之间的关系</li>
<li>JavaBean必须拥有一个无参的构造器，通过get/set方法访问参数，同时支持持久化</li>
</ul>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul>
<li>ioc(inverse of control，控制反转)，控制反转就是把<font color="red">创建对象（bean）和维护对象（bean）的关系的权利</font>从程序中转移到spring容器中（applicationContext.xml），只需配置一下就能完成</li>
<li>使用Spring，程序中几乎所有重要的组件的创建工作和维护组件之间的依赖关系都移交给Spring</li>
</ul>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul>
<li>di(dependency injection，依赖注入)，<strong><em>实际上di和ioc是同一概念</em></strong>，spring设计者认为di更准确表示spring核心技术</li>
<li>依赖注入接管对象的创建工作，并将该对象的引用注入需要该对象的组件</li>
</ul>
<pre>
/*
<font color="red">有两个组件A和B，A依赖于B，且A中的importantMethod方法调用了B的方法，
使用B前，类A必须先获得组件B的实例（具体类可以new一个B实例，但如果B是接口，使用B的一个实现类，会降低A的可重用性）
使用依赖注入，框架会接管对象B的创建工作，并将B对象的引用注入到A中，具体是类A中的setB方法会被框架调用，注入一个B的实例，
这样类A的importantMethod方法在使用B的userfulMethod方法前不再需要创建一个B的实例</font>
*/
public class A {
    private B b;

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    public void importantMethod(){
        b.userfulMethod();
    }
}
</pre>

<h2 id="Spring在程序中的位置"><a href="#Spring在程序中的位置" class="headerlink" title="Spring在程序中的位置"></a>Spring在程序中的位置</h2><p>　　Spring层次图如下图所示</p>
<p><img src="http://i.imgur.com/xPyY3mN.png" alt=""></p>
<ul>
<li>Login.jsp与用户交互，将数据传递给Action.java处理器，Action.java一般与表单ActionForm关联，验证成功跳转到ok.jsp。这一层是web层，Struts位于web层</li>
<li>验证过程中，会调用UserService.java，这是业务层。业务层会有一个domain对象，Users.java[或者叫javabean，pojo]</li>
<li>业务层下是DAO层，它是对数据的操作</li>
<li>下面就是数据持久层，hibernate就位于持久层，它是一个orm框架</li>
<li>最底层的就是数据库</li>
<li>model层分为业务层（Service），DAO层和数据持久层，在开发过程中，可以根据实际情况进行选择组合，并不是必须把model层分得这么细</li>
<li>Spring横跨web层、业务层、DAO层、持久层，可以配置各个层的组件（JavaBean），并且维护各个bean之间的关系</li>
<li>具体的来说，spring可以配置web层的action[解决actin单例问题]，业务层的domain/service/dao以及数据持久层配置数据源</li>
<li>在配置文件中，体现出Spring创建各种组件及维持组件之间的关系<pre>
&lt;bean id = "bean1" class = "">配置bean
  &lt;property name = "" value = "">&lt;/property>
&lt;/bean>
&lt;bean id = "bean2" class = "">维护bean之间的关系(bean2依赖bean1)
  &lt;property name = "" ref="">&lt;/property>
&lt;/bean>
</pre>

</li>
</ul>
<h2 id="Spring快速入门"><a href="#Spring快速入门" class="headerlink" title="Spring快速入门"></a>Spring快速入门</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/rhapsody1290/Spring_Study" target="_blank" rel="external">https://github.com/rhapsody1290/Spring_Study</a></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>&lt;properties&gt;
    &lt;!-- spring版本号 --&gt;
    &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;
    &lt;!-- log4j日志文件管理包版本 --&gt;
    &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;
    &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- 导入Mysql数据库链接jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- spring核心包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--spring事务--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 格式化对象，方便输出日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.1.41&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;${slf4j.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>创建组件A、B，其中A组件依赖B</p>
<p>类A</p>
<pre><code>public class A {
    private B b;

    public void importantMethod(){
        System.out.println(&quot;A:importantMethod&quot;);
        b.usefulMethod();
    }
    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }
}
</code></pre><p>类B </p>
<pre><code>public class B {

    public void usefulMethod() {
        System.out.println(&quot;B:usefulMethod&quot;);
    }
}
</code></pre><h3 id="applicationContext-xml中配置bean"><a href="#applicationContext-xml中配置bean" class="headerlink" title="applicationContext.xml中配置bean"></a>applicationContext.xml中配置bean</h3><p>applicationContext.xml是spring的一个核心配置文件, [hibernate有核心文件hibernate.cfg.xml struts核心文件 struts-config.xml]</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 在容器文件中配置bean(service/dao/domain/action/数据源) --&gt;
    &lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象,并放入内存--&gt;
    &lt;bean id = &quot;A&quot; class=&quot;hello.A&quot;&gt;
        &lt;!-- 这里就体现出注入的概念，将B对象的引用注入到A中的b属性--&gt;
        &lt;property name=&quot;b&quot; ref=&quot;B&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt;

&lt;/beans&gt;
</code></pre><h3 id="获得bean并调用方法"><a href="#获得bean并调用方法" class="headerlink" title="获得bean并调用方法"></a>获得bean并调用方法</h3><pre><code>public class testSpringAPI {

    private ApplicationContext context;

    @Before
    public void setUp() throws Exception {
        //1.得到spring 的applicationContext对象(容器对象)
        context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    }

    @Test
    public void testName() throws Exception {
        //2、利用java反射机制获取bean对象
        A a  = (A) context.getBean(&quot;A&quot;);
        a.importantMethod();
    }
}
</code></pre><h2 id="Spring运行原理图"><a href="#Spring运行原理图" class="headerlink" title="Spring运行原理图"></a>Spring运行原理图</h2><p><img src="http://i.imgur.com/IYAnjQ8.png" alt=""></p>
<ul>
<li>当ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);执行的时候，Spring容器对象将被创建，同时applicationContext.xml中配置的bean就会被创建</li>
<li>UserService us = (UserService)ac.getBean(‘UserService’);调用后取出bean，取出的bean对象是单例</li>
<li>bean的存储结构类似HashMap/HashTable，分为id和bean对象。id对应配置文件中bean元素的id，对象在Spring容器对象创建时创建并存放。若有引用关系，则指向引用对象的id</li>
<li>Spring框架扫描XML文件，利用Java反射机制，创建一个个bean对象</li>
<li><p>可以利用dom4j+java反射机制模拟Spring运行流程。扫描xml文件，检测到bean元素，利用Java反射机制创建对象，并设置属性值，存入HashMap</p>
  <pre>
  userService = Class.forName("com.service.UserService");
  userService.setName("韩顺平");

  applicationContext = new HashMap();
  applicationContext.put("userService",userService);
  </pre>

</li>
</ul>
<h2 id="Spring接口编程"><a href="#Spring接口编程" class="headerlink" title="Spring接口编程"></a>Spring接口编程</h2><p>spring开发提倡接口编程,配合di技术可以层与层的解耦</p>
<p>举例说明:<br>现在我们体验一下spring的di配合接口编程的，完成一个字母大小写转换的案例:<br>思路:</p>
<ol>
<li>创建一个接口 ChangeLetter<pre>
public interface ChangeLetter {
　　public String change();
}
</pre></li>
<li><p>两个类实现接口</p>
<pre>
public class LowerLetter implements ChangeLetter {
      private String str;

      public String getStr() {
          return str;
      }

      public void setStr(String str) {
          this.str = str;
      }

      @Override
      public String change() {
          return str.toLowerCase();
      }
}</pre><pre>
public class UpperLeter implements ChangeLetter {
      private String str;

      public String getStr() {
          return str;
      }

      public void setStr(String str) {
          this.str = str;
      }
      @Override
      public String change() {
          return str.toUpperCase();
      }
}
</pre></li>
<li>把对象配置到spring容器中<pre>
&lt;bean id="changeLetter" class="cn.apeius.inter.UpperLeter">
  &lt;property name="str" value="abc">&lt;/property>
&lt;/bean>
&lt;!--    &lt;bean id="changeLetter" class="cn.apeius.inter.LowerLetter">
  &lt;property name="str" value="ABC">&lt;/property>
&lt;/bean>-->
</pre></li>
<li>使用<pre>
ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");
ChangeLetter us= (ChangeLetter) ac.getBean("changeLetter");
System.out.println(us.change());
</pre>

</li>
</ol>
<p>通过上面的案例，我们可以初步体会到di配合接口编程，的确可以减少层(web层) 和 业务层的耦合度.</p>
<h2 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h2><ul>
<li><p>配置文件的根元素通常为</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre></li>
<li>如果需要更强的Spring配置能力，可以在<strong><em>schemaLocation</em></strong>属性中添加相应地schema</li>
<li><p><strong><em>配置文件可以是一份，也可以是多份</em></strong>，ApplicationContext的实现类支持读取多份配置文件</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(new  String[]{&quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;});
</code></pre></li>
</ul>
<h2 id="三种获取ApplicationContext对象引用的方法"><a href="#三种获取ApplicationContext对象引用的方法" class="headerlink" title="三种获取ApplicationContext对象引用的方法"></a>三种获取ApplicationContext对象引用的方法</h2><p>ApplicationContext对象代表一个<strong><em>Spring控制反转容器</em></strong>，org.springframework.context.ApplicationContext接口有多个实现，包括：</p>
<p>1、ClassPathXmlApplicationContext -&gt; 通过类路径加载配置文件</p>
<pre><code>ApplicationContext context  = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre><p>2、FileSystemXmlApplicationContext -&gt; 通过文件路径加载配置文件</p>
<pre>
ApplicationContext context = new FileSystemXmlApplicationContext("配置文件绝对路径");
</pre>

<p>3、XmlWebApplicationContext 从web系统中加载</p>
<h2 id="两个获取bean的方式★★★"><a href="#两个获取bean的方式★★★" class="headerlink" title="两个获取bean的方式★★★"></a>两个获取bean的方式★★★</h2><h3 id="从ApplicationContex应用上下文容器中获取bean"><a href="#从ApplicationContex应用上下文容器中获取bean" class="headerlink" title="从ApplicationContex应用上下文容器中获取bean"></a>从ApplicationContex应用上下文容器中获取bean</h3><h4 id="基本模式创建一个bean实例★★★★★"><a href="#基本模式创建一个bean实例★★★★★" class="headerlink" title="基本模式创建一个bean实例★★★★★"></a>基本模式创建一个bean实例★★★★★</h4><p>Spring通过<strong><em>默认无参的构造器</em></strong>来创建一个bean实例</p>
<p>配置文件</p>
<pre><code>&lt;bean id=&quot;B&quot; class=&quot;hello.B&quot;/&gt;
</code></pre><p>获取bean</p>
<pre><code>//1.得到spring 的applicationContext对象(容器对象)
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
//从容器中取出一个bean的实例
B b = ac.getBean(&quot;B&quot;, B.class);
b.usefulMethod();
</code></pre><h4 id="工厂模式创建一个bean实例"><a href="#工厂模式创建一个bean实例" class="headerlink" title="工厂模式创建一个bean实例"></a>工厂模式创建一个bean实例</h4><p>1、定义一个接口</p>
<pre><code>public interface Animal {
    public void sayHello();
}
</code></pre><p>2、接口的两个实现类</p>
<p>Cat</p>
<pre><code>public class Cat implements Animal {
    public void sayHello() {
        System.out.println(&quot;Cat&quot;);
    }
}
</code></pre><p>Dog </p>
<pre><code>public class Dog implements Animal {    
    public void sayHello() {
        System.out.println(&quot;Dog&quot;);
    }
}
</code></pre><p>3、AnimalFactory工厂中包含了一个getAnimal的<strong><em>静态方法</em></strong>，该方法将根据传入的参数决定创建哪个对象。这是典型的静态工厂设计模式</p>
<pre><code>public class AnimalFactory {
    public static Animal getAnimal(String type){
        if(&quot;Cat&quot;.equals(type)){
            return new Cat();
        }else if(&quot;Dog&quot;.equals(type)){
            return new Dog();
        }
        return null;
    }
}
</code></pre><p>4、Spring配置文件中作如下配置</p>
<pre><code>&lt;bean id=&quot;cat&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt;
    &lt;constructor-arg value=&quot;Cat&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;dog&quot; class=&quot;Factory.AnimalFactory&quot; factory-method=&quot;getAnimal&quot;&gt;
    &lt;constructor-arg value=&quot;Dog&quot;/&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时<strong><em>class属性并不是指定Bean实例的实现类，而是静态工厂类</em></strong></li>
<li>需要使用factory-method来指定静态工厂方法名，Spring将调用静态工厂方法来返回一个Bean实例，使用<constructor-arg>元素来为静态工厂方法指定参数</constructor-arg></li>
<li>当使用静态工厂方法来创建Bean时，这个factory-method必须要是<strong><em>静态的</em></strong></li>
</ul>
<h3 id="从bean工厂容器中获取bean"><a href="#从bean工厂容器中获取bean" class="headerlink" title="从bean工厂容器中获取bean"></a>从bean工厂容器中获取bean</h3><pre><code>//如果我们使用beanfactory去获取bean，当你创建Spring容器时bean不被实例化,只有当你去使用getBean某个bean时，才会实时的创建    
BeanFactory factory = new XmlBeanFactory(
        new ClassPathResource(&quot;applicationContext.xml&quot;));
factory.getBean(&quot;A&quot;);
</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>如果使用ApplicationContext ，则配置的bean如果是singlton不管你用不用，都被实例化.(好处就是可以预先加载,缺点就是耗内存)</li>
<li>如果是 BeanFactory ,则当你获取beanfacotry时候，配置的bean不会被马上实例化，当你使用的时候，才被实例(好处节约内存,缺点就是速度)</li>
<li><strong>规定: 一般没有特殊要求，应当使用ApplicatioContext完成</strong>(实际项目中90%都采用这种方式)</li>
</ol>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p><strong><em>为什么总是一个生命周期当做一个重点?</em></strong></p>
<p>　　例如我们经常需要知道Servlet的生命周期，初始化init和销毁destroy，还有讨论java对象生命周期<br>　　不懂servlet的生命周期，你一样可以做开发。但是只有把一个新的技术对应的对象的生命周期弄清楚时，你才能真正的驾驭他。你知道Servlet创建的时候会调用init，才会把初始化工作放在init中，你知道Servlet销毁时会调用destroy，才会把文件备份的工作放在destroy中</p>
<p><strong><em>bean的生命周期</em></strong></p>
<p>bean被载入到容器中时，它的生命周期就开始了</p>
<p><img src="http://i.imgur.com/n6bHb14.png" alt=""></p>
<p>①    实例化★</p>
<ul>
<li>当我们的程序加载<code>beans.xml</code>文件，把我们的bean实例化到内存</li>
<li>默认调用无参的构造方法</li>
<li>以上我们考虑的是<code>scope=singleton</code>，单例模式最复杂</li>
</ul>
<p>②    调用set方法设置属性★<br>③    如果你实现了bean名字关注接口<code>BeanNameAware</code>则，可以通过<code>setBeanName</code>获取id号<br>④    如果你实现了bean工厂关注接口<code>BeanFactoryAware</code>,则可以获取<code>BeanFactory</code><br>⑤    如果你实现了<code>ApplicationContextAware</code>接口，则可以获得应用程序上下文</p>
<pre><code>//该方法传递ApplicationContext
public void setApplicationContext(ApplicationContext arg0)
        throws BeansException {
    // TODO Auto-generated method stub
    System.out.println(&quot;setApplicationContext&quot;+arg0);
}
</code></pre><p>⑥    如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。体现AOP（面向切片编程），放置一些公共方法，例如过滤ip，给对象添加属性等★</p>
<p><strong><em>自定义一个类myBeanPostProcessor，实现BeanPostProcessor接口，重写before和after两个方法</em></strong></p>
<pre>
# myBeanPostProcessor.java
public class myBeanPostProcessor <font color="red">implements BeanPostProcessor</font> {
    @Override
    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
        <font color="red">//对象o对实例化的bean对象，s为bean的id</font>
        System.out.println("postProcessBeforeInitialization");
        return o;
    }

    @Override
    public Object postProcessAfterInitialization(Object o, String s) throws BeansException {
        System.out.println("postProcessAfterInitialization");
        return o;
    }
}
</pre>

<p><strong><em>xml文件中配置</em></strong></p>
<pre><code>&lt;bean id = &quot;myBeanPostProcessor&quot; class=&quot;cn.apeius.beanlift.myBeanPostProcessor&quot;&gt;&lt;/bean&gt;
</code></pre><p><strong><em>运行</em></strong></p>
<pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
PersonService personService = (PersonService) ac.getBean(&quot;PersonService&quot;);
personService.sayHi();
</code></pre><p><strong><em>结果：bean对象创建后会自动调用before和after方法。类似JavaWeb中的过滤器</em></strong></p>
<pre><code>构造函数被调用
调用set方法
postProcessBeforeInitialization
postProcessAfterInitialization
你好啊 钱钱
</code></pre><p>⑦    如果你实现InitializingBean接口，则会调用afterPropertiesSet<br>⑧    如果自己配置<code>&lt;bean init-method=&quot;init&quot; /&gt;</code>，则可以在bean定义自己的初始化方法init。也可以通过注解的方式@PostConstruct<br>⑨    如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法<br>⑩    使用我们的bean<br>⑪ 容器关闭<br>⑫ 可以通过实现<code>DisposableBean</code>接口来调用方法<code>destory</code><br>⑬ 可以在<code>&lt;bean destory-method=&quot;fun1&quot;/&gt;</code>调用定制的销毁方法。可以通过注解的方式@PreDestroy</p>
<p><strong><em>小结: 我们实际开发中往往，没有用的这么的过程,常见的是:1-&gt;2-&gt;6-&gt;10-&gt;9-&gt;11 </em></strong></p>
<p>问题:通过BeanFactory来获取bean对象，bean的生命周期是否和 Applicationcontext 是一样吗?</p>
<pre><code>不是一样的，bean是工厂中创建的生命周期会简单一些:
比起ApplicationContext创建bean，通过BeanFactory少了一下步骤
⑤ 如果你实现了ApplicationContextAware接口，则可以获得应用程序上下文
⑥ 如果bean和一个后置处理器关联，则实例化一个bean时，会自动去调用before方法。
⑨ 如果bean和一个后置处理器关联,则会自动去调用Object postProcessAfterInitialization方法
</code></pre><p><img src="http://i.imgur.com/1KHveOv.png" alt=""></p>
<h2 id="bean装配的细节"><a href="#bean装配的细节" class="headerlink" title="bean装配的细节"></a>bean装配的细节</h2><h3 id="注入的写法★"><a href="#注入的写法★" class="headerlink" title="注入的写法★"></a>注入的写法★</h3><p>基础数据类型注入</p>
<pre>
一个标签
&lt;property name="name" <font color="red">value="财务部"</font>/>
两个标签
&lt;property name="name">
    <font color="red">&lt;value>财务部&lt;/value></font>
&lt;/property>
</pre>

<p>对象注入</p>
<pre>
# 方法一：利用property的ref属性，这是一种简写方式
&lt;bean id="Department"  class="cn.apeius.collections.Department">
    <font color="red">&lt;property name="emp" ref="Emp"/></font>
&lt;/bean>
&lt;bean id="Emp" class="cn.apeius.collections.Emp">
    &lt;property name="id" value="1"/>
    &lt;property name="name" value="qm"/>
&lt;/bean>

# 方法二：ref标签
&lt;bean id="Department"  class="cn.apeius.collections.Department">
    &lt;property name="emp">
        <font color="red">&lt;ref bean="Emp"/></font>
    &lt;/property>
&lt;/bean>
&lt;bean id="Emp" class="cn.apeius.collections.Emp">
    &lt;property name="id" value="1"/>
    &lt;property name="name" value="qm"/>
&lt;/bean>

# 方法三：内部配置

&lt;bean id="Department"  class="cn.apeius.collections.Department">
    &lt;property name="emp">
        <font color="red">&lt;bean class="cn.apeius.collections.Emp">
            &lt;property name="id" value="1"/>
            &lt;property name="name" value="qm"/>
        &lt;/bean></font>
    &lt;/property>
&lt;/bean>

</pre>

<h3 id="bean的作用域scope"><a href="#bean的作用域scope" class="headerlink" title="bean的作用域scope"></a>bean的作用域scope</h3><p><img src="http://i.imgur.com/1Dzlr62.png" alt=""></p>
<ul>
<li>singleton(默认)，单态，尽量使用scope=”singleton”,不要使用prototype,因为这样对我们的性能影响较大，除非有必要.<pre>
//获取两个student
Student s1=(Student) ac.getBean("student");
Student s2=(Student) ac.getBean("student");
System.out.println(s1 == s2);//一样
</pre></li>
<li>prototype<pre>
//获取两个student
Student s1=(Student) ac.getBean("student");
Student s2=(Student) ac.getBean("student");
System.out.println(s1 == s2);//不一样
</pre></li>
<li>request</li>
<li>session</li>
<li>global-session 是在web开发中才有意义</li>
</ul>
<h3 id="如何给集合类型注入值"><a href="#如何给集合类型注入值" class="headerlink" title="如何给集合类型注入值"></a>如何给集合类型注入值</h3><p>java中主要的集合有几种: map set list / 数组 </p>
<p><strong><em>给数组注入值</em></strong></p>
<pre><code>&lt;property name=&quot;empName&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;小明&lt;/value&gt;
        &lt;value&gt;小明小明&lt;/value&gt;
        &lt;value&gt;小明小明小明小明&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给list注入值 list 中可以有相同的对象</em></strong></p>
<pre><code>&lt;property name=&quot;empList&quot;&gt;
    &lt;list&gt;
        &lt;ref bean=&quot;emp2&quot; /&gt;
        &lt;ref bean=&quot;emp1&quot;/&gt;
        &lt;ref bean=&quot;emp1&quot;/&gt;
    &lt;/list&gt;
&lt;/property&gt;

&lt;bean id=&quot;emp1&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;北京&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;emp2&quot; class=&quot;com.hsp.collection.Employee&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;天津&quot;/&gt;
    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;
&lt;/bean&gt;
</code></pre><p><strong><em>给set注入值set不能有相同的对象</em></strong></p>
<pre><code>&lt;property name=&quot;empsets&quot;&gt;
    &lt;set&gt;
        &lt;ref bean=&quot;emp1&quot; /&gt;
        &lt;ref bean=&quot;emp2&quot;/&gt;
        &lt;ref bean=&quot;emp2&quot;/&gt;
    &lt;/set&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给map注入值，key为索引，value指定值，如果为Java对象，则使用ref指定，或者使用bean定义。如果key为对象，使用key-ref属性</em></strong></p>
<pre><code>&lt;property name=&quot;empMaps&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; 
        &lt;entry key = &quot;12&quot; value = &quot;emp2&quot; /&gt;
        &lt;entry key-ref=&quot;13&quot; value=&quot;emp3&quot; /&gt;
        &lt;entry key-ref=&quot;14&quot; value-ref=&quot;emp4&quot; /&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre><p><strong><em>给属性集合配置，即Property对象</em></strong></p>
<pre><code>&lt;property name=&quot;pp&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;pp1&quot;&gt;abcd&lt;/prop&gt;
        &lt;prop key=&quot;pp2&quot;&gt;hello&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre><h3 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h3><pre><code>&lt;bean id=&quot;foo&quot; class=&quot;....Foo&quot;&gt;
    &lt;property name=&quot;属性&quot;&gt;
        &lt;!—第一方法引用--&gt;
        &lt;ref bean=&quot;bean对象名&quot;/&gt;

        &lt;!—第二种方法，内部bean--&gt;
        &lt;bean&gt; 
            &lt;properyt name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h3 id="继承配置"><a href="#继承配置" class="headerlink" title="继承配置"></a>继承配置</h3><pre><code>public class Student 
public class Gradate extends Student

在beans.xml文件中体现配置 
&lt;!-- 配置一个学生对象 --&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.hsp.inherit.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;顺平&quot; /&gt;
    &lt;property name=&quot;age&quot; value=&quot;30&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 配置Grdate对象 --&gt;
&lt;bean id=&quot;grdate&quot; parent=&quot;student&quot; class=&quot;com.hsp.inherit.Gradate&quot;&gt;
    &lt;!-- 如果自己配置属性name,age,则会替换从父对象继承的数据  --&gt;
    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;
    &lt;property name=&quot;degree&quot; value=&quot;学士&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="通过构造函数注入值★★★"><a href="#通过构造函数注入值★★★" class="headerlink" title="通过构造函数注入值★★★"></a>通过构造函数注入值★★★</h3><ul>
<li>目前我们都是通过set方式给bean注入值，spring还提供其它的方式注入值，比如通过构造函数注入值!</li>
<li>set注入的缺点是无法清晰表达哪些属性是必须的，哪些是可选的；构造注入的优势是通过构造器<strong><em>强制依赖关系</em></strong></li>
<li>每个constructor-arg配置一个参数，参数有先后顺序，顺序要与构造函数相同</li>
</ul>
<h4 id="通过参数名传递参数"><a href="#通过参数名传递参数" class="headerlink" title="通过参数名传递参数"></a>通过参数名传递参数</h4><pre><code>&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;洗衣机&quot;/&gt;
    &lt;constructor-arg name=&quot;description&quot; value=&quot;家用洗衣服的工具&quot;/&gt;
&lt;/bean&gt;
</code></pre><h4 id="通过指数方式传递参数"><a href="#通过指数方式传递参数" class="headerlink" title="通过指数方式传递参数"></a>通过指数方式传递参数</h4><pre><code>&lt;bean id=&quot;product&quot; class=&quot;constructor.Product&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;洗衣机&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;家用洗衣服的工具&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="初始化bean和销毁bean的时候执行某个方法"><a href="#初始化bean和销毁bean的时候执行某个方法" class="headerlink" title="初始化bean和销毁bean的时候执行某个方法"></a>初始化bean和销毁bean的时候执行某个方法</h3><p>方法一：通过注解@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作</p>
<pre><code>public class DataInitializer{     
    @PostConstruct  
    public void initMethod() throws Exception {  
        System.out.println(&quot;initMethod 被执行&quot;);  
    }  
    @PreDestroy  
    public void destroyMethod() throws Exception {  
        System.out.println(&quot;destroyMethod 被执行&quot;);  
    }  
}  
</code></pre><p>方法二：通过 在xml中定义 init-method 和  destory-method 方法★★★★★</p>
<p>DataInitializer</p>
<pre><code>public class DataInitializer{  
    public void initMethod() throws Exception {  
        System.out.println(&quot;initMethod 被执行&quot;);  
    }  
    public void destroyMethod() throws Exception {  
        System.out.println(&quot;destroyMethod 被执行&quot;);  
    }  
}  
</code></pre><p>applicationContext.xml</p>
<pre><code>&lt;bean id=&quot;dataInitializer&quot; class=&quot;com.somnus.demo.DataInitializer&quot; init-method=&quot;initMethod&quot; destory-method=&quot;destroyMethod&quot;/&gt;  
</code></pre><p>方法三：通过bean实现InitializingBean和 DisposableBean接口</p>
<pre>
public class DataInitializer <font color="red">implements InitializingBean，DisposableBean</font>{  

    @Override  
    public void afterPropertiesSet() throws Exception {  
        System.out.println("afterPropertiesSet 被执行");  
    }  

    @Override  
    public void destroy() throws Exception {  
        System.out.println("destroy 被执行");  
    }  

}  
</pre>

<p>原理</p>
<pre>
<font color="red">//判断该bean是否实现了实现了InitializingBean接口，如果实现了InitializingBean接口，则只掉调用bean的afterPropertiesSet方法</font>  
<font color="blue">boolean isInitializingBean = (bean instanceof InitializingBean);  </font>
if(isInitializingBean)
    ((InitializingBean) bean).afterPropertiesSet();  
</pre>

<h2 id="注解装配Bean"><a href="#注解装配Bean" class="headerlink" title="注解装配Bean"></a>注解装配Bean</h2><h3 id="引入context名称空间，并配置扫描包"><a href="#引入context名称空间，并配置扫描包" class="headerlink" title="引入context名称空间，并配置扫描包"></a>引入context名称空间，并配置扫描包</h3><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;annotation&quot;/&gt;

&lt;/beans&gt;
</code></pre><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><pre><code>@Component(value = &quot;a&quot;)等价于&lt;bean id = &quot;a&quot; class = &quot;A&quot;&gt;

@Component(value = &quot;a&quot;)
public class A {

    public void say(){
        System.out.println(&quot;A&quot;);
    }

}
</code></pre><h3 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="简单类型数据注入"><a href="#简单类型数据注入" class="headerlink" title="简单类型数据注入"></a>简单类型数据注入</h4><p>spring3.0 提供 @Value 注解，可以注入简单数据类型</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Value(value = &quot;qm&quot;)
    private String name;

    public void say(){
        System.out.println(&quot;A&quot; + name);
    }

}
</code></pre><h4 id="复杂对象类型数据注入"><a href="#复杂对象类型数据注入" class="headerlink" title="复杂对象类型数据注入"></a>复杂对象类型数据注入</h4><p><strong>第一种：按类型注入，@Autowired</strong></p>
<p>A</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Autowired
    B b;

    public void say(){
        b.say();
    }

}
</code></pre><p>B</p>
<pre><code>@Component(value = &quot;b&quot;)
public class B {

    public void say(){
        System.out.println(&quot;B&quot;);
    }

}
</code></pre><p><strong>第二种：按名称注入，使用@Autowired 结合 @Qualifier 注解 (Spring 2.0 )</strong></p>
<p>A：</p>
<pre><code>@Component(value = &quot;a&quot;)
public class A {

    @Autowired
    @Qualifier(value = &quot;c_qualifier&quot;)
    B b;

    public void say(){
        b.say();
    }

}
</code></pre><p>B：</p>
<pre><code>@Component(value = &quot;c_qualifier&quot;)
public class B {

    public void say(){
        System.out.println(&quot;B&quot;);
    }

}
</code></pre><p><strong>第三种： 使用@Resouce注解 （JSR-250标准 ）</strong></p>
<pre><code>按照名称注入
</code></pre><p><strong>第四种： 使用 @Inject 注解 （JSR-330标准 ）</strong></p>
<pre><code>导入 javax.inject-1.jar 
</code></pre><h2 id="自动装配bean的属性值"><a href="#自动装配bean的属性值" class="headerlink" title="自动装配bean的属性值"></a>自动装配bean的属性值</h2><p>自动装配只有在属性没有设置时，才会进行</p>
<p><img src="http://i.imgur.com/wL8acDX.png" alt=""></p>
<h3 id="byName的用法"><a href="#byName的用法" class="headerlink" title="byName的用法:"></a>byName的用法:</h3><pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>原理图:</p>
<p>property中没有注入dog值，master中的dog为null。但当设置属性autowire=”byName”后，通过检测发现内存中有一个名字为dog的对象，则自动进行引用连接</p>
<p><img src="http://i.imgur.com/aYY9TE0.png" alt=""></p>
<h3 id="byType的用法"><a href="#byType的用法" class="headerlink" title="byType的用法"></a>byType的用法</h3><p>寻找和属性类型相同的bean，此时id为dog11也能够找到并进行装配；找不到、装不上、找到多个抛异常</p>
<pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog11&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="constructor的用法"><a href="#constructor的用法" class="headerlink" title="constructor的用法"></a>constructor的用法</h3><p>与byType类似， 查找和bean的构造参数一致的一个或多个bean，若找不到或找到多个，抛异常。按照参数的类型装配  </p>
<p><em>master写构造函数</em></p>
<pre><code>public master(Dog dog){
    this.dog = dog;
}
</code></pre><p><em>配置</em></p>
<pre><code>&lt;!-- 配置一个master对象 --&gt;
&lt;bean id=&quot;master&quot; class=&quot;com.hsp.autowire.Master&quot; autowire=&quot;constructor&quot;&gt;
    &lt;property name=&quot;name&quot;&gt;
        &lt;value&gt;顺平&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 配置dog对象 --&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.hsp.autowire.Dog&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;小黄&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;3&quot;/&gt;
&lt;/bean&gt;
</code></pre><h3 id="autodetect的用法"><a href="#autodetect的用法" class="headerlink" title="autodetect的用法"></a>autodetect的用法</h3><p><code>autowire=&quot;autodetect&quot;</code>(3)和(2)之间选一个方式。不确定性的处理与(3)和(2)一致</p>
<h3 id="defualt"><a href="#defualt" class="headerlink" title="defualt"></a>defualt</h3><p>这个需要在<code>&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;</code><br>当你在<code>&lt;beans&gt;</code>指定了default-atuowrite后，所有的bean的默认的autowire就是指定的装配方法;<br>如果没有在<code>&lt;beans defualt-autorwire=&quot;指定&quot; /&gt;</code>没有defualt-autorwire=”指定”，则默认是defualt-autorwire=”no”</p>
<h3 id="no-不自动装配"><a href="#no-不自动装配" class="headerlink" title="no: 不自动装配"></a>no: 不自动装配</h3><p>这是autowire的默认值</p>
<h2 id="使用spring的特殊bean-完成分散配置"><a href="#使用spring的特殊bean-完成分散配置" class="headerlink" title="使用spring的特殊bean,完成分散配置"></a>使用spring的特殊bean,完成分散配置</h2><p>将配置文件分成几个分散的配置文件，如一个项目中连接多个数据库，每个数据库各对应一个db.properties文件</p>
<ul>
<li>引入我们的db.properties文件，并在要注入值的地方用$占位符</li>
</ul>
<pre><code>&lt;context:property-placeholder location=&quot;classpath:com/hsp/dispatch/db.properties,classpath:com/hsp/dispatch/db2.properties&quot;/&gt;
&lt;!-- 配置一DBUtil对象 $占位符号 --&gt;
&lt;bean id=&quot;dbutil&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;${name}&quot; /&gt;
    &lt;property name=&quot;drivername&quot; value=&quot;${drivername}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
    &lt;property name=&quot;pwd&quot; value=&quot;${pwd}&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>注意：当通过<code>context:property-placeholder</code>引入属性文件的时候，有多个需要使用<code>,</code>间隔.</p>
<ul>
<li>db.properties</li>
</ul>
<pre><code>name=scott
drivername=oracle:jdbc:driver:OracleDirver
url=jdbc:oracle:thin:@127.0.0.1:1521:hsp
pwd=tiger
</code></pre><ul>
<li>测试</li>
</ul>
<pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
DBUtil dBUtil = (DBUtil) ac.getBean(&quot;dbutil&quot;);
System.out.println(dbUtil.getDrivername());
</code></pre><h2 id="AOP编程"><a href="#AOP编程" class="headerlink" title="AOP编程"></a>AOP编程</h2><ul>
<li><font color="red"><strong>AOP(Aspect Oriented Programming )，面向切面编程：AOP编程就是将共有的代码，如日志记录、权限控制、事务控制等全部抽取出来，放在某个地方集中管理，若需要使用这些功能，由容器动态织入这些共有代码</strong></font>，这样的好处：<br>1、程序员在编写业务逻辑时只需关心核心的业务逻辑处理方法，提高工作效率，使代码变得简洁<br>2、业务逻辑代码和共有代码分开存放，使维护工作变得轻松</li>
</ul>
<p><img src="http://i.imgur.com/CBjTgky.png" alt=""></p>
<ul>
<li><p>举个例子，在开发过程中，很多对象需要做同一类的操作，例如权限控制、日志记录、事务控制等，AOP编程就是把相同工作剥离出来，若对象需要使用其中的一个功能，则将其织入进去<br><img src="http://i.imgur.com/zNOHFYJ.png" alt=""></p>
</li>
<li><p>AOP编程，实际上在开发框架本身用的多，在实际项目中，用的不是很多，但是将来会越来越多，这是一个趋势</p>
</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/liujiahan629629/article/details/18864211" target="_blank" rel="external">http://blog.csdn.net/liujiahan629629/article/details/18864211</a></p>
<h3 id="AOP技术的实现原理"><a href="#AOP技术的实现原理" class="headerlink" title="AOP技术的实现原理"></a>AOP技术的实现原理</h3><ul>
<li>AOP技术是建立在 <strong>Java语言的反射机制</strong> 与 <strong>动态代理机制</strong> 之上的</li>
<li>业务逻辑组件在运行过程中，<font color="red"><strong>AOP容器</strong> 会动态创建一个 <strong>代理对象(Service的代理对象)</strong> 供使用者调用，该代理对象已经按Java EE程序员的意图将 <strong>切面</strong> 成功切入到 <strong>目标对象</strong> 的 <strong>连接点</strong> 上</font>，从而使 <strong>切面的功能</strong> 与 <strong>业务逻辑的功能</strong> 同时得以执行</li>
<li>从原理上讲，调用者直接调用的其实是AOP容器动态生成的代理对象，再由<strong>代理对象调用目标对象完成原始的业务逻辑处理</strong>，而代理对象则已经将切面与业务逻辑方法进行了合成</li>
</ul>
<p><img src="http://i.imgur.com/OJoBkfk.jpg" alt=""></p>
<p>现将图6-6中涉及到的一些概念解释如下：(<font color="red"><strong>切面包括通知和切入点，容器将切面切入到目标对象的连接点上，返回一个代理对象，这个过程叫做织入</strong></font>)</p>
<p><strong>切面（Aspect）：</strong>其实就是<font color="red"><strong>共有功能的实现，包括通知和切入点</strong></font>,如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。<br><strong>通知（Advice）：</strong> <strong><em>是切面的具体实现</em></strong>。以目标方法为参照点，根据 <strong><em>放置的地方不同</em></strong>，可分为前置通知（Before）、后置通知（AfterReturning）、环绕通知（Around）、异常通知（AfterThrowing）、最终通知（After）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。、<br><strong>切入点（Pointcut）：<em>*</em></strong>用于定义通知应该切入到哪些连接点上<strong><em>。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的 </em></strong>正则表达式<em>*</em> 来定义的</p>
<p><strong>连接点（Joinpoint）</strong>：就是程序在运行过程中能够<strong><em>插入切面的地点</em></strong>。例如，方法调用、异常抛出或字段修改等<br><strong>目标对象（Target）</strong>：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。<br><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。<br><strong>织入（Weaving）：</strong> <strong><em>将切面应用到目标对象从而创建一个新的代理对象的过程。</em></strong>这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。</p>
<p>举个例子解释术语：</p>
<p><img src="http://i.imgur.com/Snv0YKO.png" alt=""></p>
<p>AOP编程可以在不增加原来业务逻辑方法代码的情况下，<strong>扩展某个方法</strong>，传统的方法是采用 <strong>继承</strong> 的方式，现在可以采用<strong>动态代理技术</strong></p>
<p>连接点表示哪些方法 <strong>可以被扩展</strong>（拦截）；切入点表示哪些方法 <strong>需要被扩展</strong>（拦截）；织入是把通知应用到目标上，生成动态代理类的过程；切面表示公用的业务逻辑，包括多个切入点和多个通知</p>
<h3 id="AOP底层实现"><a href="#AOP底层实现" class="headerlink" title="AOP底层实现"></a>AOP底层实现</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>动态代理可以让一个类 代理多个不同的目标类，而且可以 代理不同的方法</p>
<p>详见Java——设计模式版块~<br><a href="http://qianmingxs.com/2016/07/06/[%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F]%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0/">http://qianmingxs.com/2016/07/06/[%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F]%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0/</a></p>
<p>1、必须针对接口进行代理<br>2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类<br>3、自己实现InvocationHandler 接口 </p>
<p><img src="http://i.imgur.com/fzfob6x.png" alt=""></p>
<p>说明：</p>
<h4 id="Cglib动态代理机制"><a href="#Cglib动态代理机制" class="headerlink" title="Cglib动态代理机制"></a>Cglib动态代理机制</h4><p>JDK只能对接口进行代理，如果目标对象没有接口，无法使用JDK动态代理，则可以使用cglib </p>
<p><strong>什么是CGLIB？</strong></p>
<p>CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。Cglib可以对接口或者类进行代理 ！</p>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>Spring AOP 就是基于JDKProxy 和 CglibProxy </p>
<p>1、如果目标对象有接口，优先使用JDK Proxy<br>2、如果目标对象没有接口， 使用CglibProxy </p>
<p>面试题：spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？<br>答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术.</p>
<h3 id="Spring-AOP三种配置详细介绍"><a href="#Spring-AOP三种配置详细介绍" class="headerlink" title="Spring AOP三种配置详细介绍"></a>Spring AOP三种配置详细介绍</h3><p><strong>AOP框架三足鼎立：</strong></p>
<ol>
<li>AspectJ</li>
<li>Jboss AOP</li>
<li>Spring  AOP</li>
</ol>
<p><strong>Spring提供4种AOP支持</strong></p>
<ol>
<li>基于代理的经典AOP</li>
<li>纯POJO切面（使用XML）</li>
<li>@AspcetJ注解驱动的切面</li>
<li>注入式AspcetJ切面</li>
</ol>
<h4 id="基于代理的经典AOP"><a href="#基于代理的经典AOP" class="headerlink" title="基于代理的经典AOP"></a>基于代理的经典AOP</h4><p><img src="http://i.imgur.com/eK3KdQ1.png" alt=""></p>
<p>现在有个需求，在调用sayHello()方法前写日志，思路如下：</p>
<p>1、面向接口编程，定义一个TestServiceInter接口，声明函数sayHello()<br>2、两个类Test1Service和Test2Service实现这两个接口<br>3、传统的方式很简单，在sayHello()方法前加入日志操作的代码，但如果有多个业务逻辑方法都需要写日志操作，是会有很多冗余代码。<strong>可以引入一个类，它的功能是写日志</strong>，</p>
<pre><code>Test1Service t1 = new Test1Service();
//采用传统方法，此处写日志操作
t1.sayHello();

Test2Service t2 = new Test2Service();
//采用传统方法，此处写日志操作
t2.sayHello();
</code></pre><p>4、Service类与日志类如何关联起来呢，需引入一个代理类，Spring提供一个代理对象类ProxyFactoryBean</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1、定义接口</p>
<pre><code>TestServiceInter.java
public interface TestServiceInter {
    public void sayHello();
}
</code></pre><p>2、编写对象(也称作被代理对象或目标对象)，实现接口</p>
<pre><code>Test1Service.java
public class Test1Service implements TestServiceInter {
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void sayHello() {
        System.out.println(&quot;Hi &quot; + name);
    }
}
</code></pre><p>3、编写通知（以前置通知为例，前置通知在目标方法调用前调用）</p>
<pre><code># MyMethodBeforeAdvice.java
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(&quot;记录日志：&quot; + method.getName());
    }
}
</code></pre><p>4、在beans.xml文件配置（分三部分：通知、被代理对象、代理对象）<br>　　4.1    配置目标对象<br>　　4.2    配置通知<br>　　4.3    配置代理对象 是 ProxyFactoryBean的对象实例<br>　　　　4.3.1 代理接口集<br>　　　　4.3.2 织入通知<br>　　　　4.3.3 配置目标对象</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--配置前置通知，比如日志--&gt;
    &lt;bean id=&quot;MyMethodBeforeAdvice&quot; class=&quot;cn.apeius.AOP.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;

    &lt;!--配置目标对象--&gt;
    &lt;bean id=&quot;Test1Service&quot; class=&quot;cn.apeius.AOP.Test1Service&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;钱明&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置代理对象,spring提供--&gt;
    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;!--配置代理接口集--&gt;
        &lt;property name=&quot;proxyInterfaces&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;cn.apeius.AOP.TestServiceInter&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--通知--&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;!--相当于包MyMethodBeforeAdvice前置通知和代理对象关联，我们也可以把通知看成拦截器--&gt;
            &lt;value&gt;MyMethodBeforeAdvice&lt;/value&gt;
        &lt;/property&gt;
        &lt;!--配置被代理对象--&gt;
        &lt;property name=&quot;target&quot; ref=&quot;Test1Service&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p><img src="http://i.imgur.com/DR0KqCg.png" alt=""><br>除了四种基本通知外，还有引入通知</p>
<p>前置通知</p>
<pre><code>public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(&quot;记录日志：&quot; + method.getName());
    }
}
</code></pre><p>后置通知</p>
<pre><code>public class MyAfterReturningAdvice implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable {
        System.out.println(&quot;关闭资源&quot;);
    }
}
</code></pre><p>环绕通知</p>
<pre><code>public class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;环绕前&quot;);
        Object o = methodInvocation.proceed();
        System.out.println(&quot;环绕后&quot;);
        return o;
    }
}
</code></pre><p>异常通知<br>　　ThrowsAdvice为标记接口，在接口中没有任何方法，因为方法被反射机制调用，实现类必须实现以下形式，见文档</p>
<pre><code>public class MyThrowsAdvice implements ThrowsAdvice {
    public void afterThrowing(Exception e){
        System.out.println(&quot;出大事了&quot; + e.getMessage());
    }
}
</code></pre><p>引入通知<br>　　引入通知不需要编写相应的类，只需要进行配置，目的是用来指定哪些方法需要执行相应的通知，如，我们想指定只有sayHello（）方法执行前置通知，</p>
<pre><code>&lt;bean id=&quot;myMethodBeforeAdviceFilter&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;  
    &lt;property name=&quot;advice&quot; ref=&quot;myMethodBeforeAdvice&quot;&gt;&lt;/property&gt;  
    &lt;property name=&quot;mappedNames&quot;&gt;  
        &lt;list&gt;  
            &lt;value&gt;sayHello&lt;/value&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;

拦截器名集中引入
 &lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt;
</code></pre><h4 id="传统AOP切面编程"><a href="#传统AOP切面编程" class="headerlink" title="传统AOP切面编程"></a>传统AOP切面编程</h4><p>极大简化了spring切面的配置工作，同时也让程序透明化，隐藏了切面的很多细节。上面所有内容都可以作为理解 <strong>spring配置AOP的基础</strong>，是最原始的配置方式，也体现了spring处理的过程。</p>
<p>使用ProxyFactoryBean配置有些欠优雅，在spring2.0里新的xml配置元素体现了改进。Spring2.0在aop命名空间里提供了一些配置元素，简化了把类转化为切面的操作。</p>
<p><strong>本质的使用同上，只是简化配置，隐藏细节</strong></p>
<h5 id="AspectJ切入点"><a href="#AspectJ切入点" class="headerlink" title="AspectJ切入点"></a>AspectJ切入点</h5><p>传统AOP切入点，使用正则表达式语法，不推荐使用。AspectJ切入点，是通过函数进行配置</p>
<p>常用语法说明简介:<br>execution 执行，语法：execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p>
<pre><code>execution(* *(..))  第一个* 任意返回类型 ， 第二个* 任意方法名 , .. 任意参数 

execution(* cn.itcast.service.UserService.*(..)) 匹配UserService所有方法 第一个星 任意返回类型

execution(* cn.itcast.service.UserService+.*(..)) 匹配UserService子类所有方法 + 子类

execution(* cn.itcast.service..*.*(..)) 第一个.. 任意子包 *.*任何类的任何方法 
</code></pre><p>within 根据包匹配</p>
<pre><code>语法：within(包名..*) 
within(cn.itcast.service..*) 拦截service下所有类的方法 
</code></pre><p>this根据目标类型匹配</p>
<pre><code>语法：this(类名) 
this(cn.itcast.service.UserService) 拦截 UserService所有方法 (包括代理对象)
</code></pre><p>target 根据目标类型匹配</p>
<pre><code>语法 ：target(类名)
target(cn.itcast.service.UserService) 拦截UserService所有方法 （不包括代理对象 ）
</code></pre><p>args 根据参数匹配</p>
<pre><code>args(java.lang.String) 拦截所有参数为String类的方法 
</code></pre><p>bean 根据bean name匹配 </p>
<pre><code>bean(userService) 拦截bean id/name为userService对象所有方法 
</code></pre><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><p>接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>实现</p>
<pre><code>public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>通知</p>
<pre><code>public class MyMethodInterceptor implements MethodInterceptor{
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        System.out.println(&quot;环绕前&quot;);
        Object o = methodInvocation.proceed();
        System.out.println(&quot;环绕后&quot;);
        return o;
    }
}
</code></pre><p>配置文件</p>
<pre><code>&lt;beans
        xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--1、目标--&gt;
    &lt;bean id=&quot;aopServiceImpl&quot; class=&quot;AOP.AopServiceImpl&quot;/&gt;
    &lt;!--2、通知--&gt;
    &lt;bean id=&quot;myMethodInterceptor&quot; class=&quot;AOP.MyMethodInterceptor&quot;/&gt;
    &lt;!--&lt;aop:config&gt; 配置切面=通知+切入点--&gt;
    &lt;aop:config&gt;
        &lt;!--aop:pointcut配置切入点--&gt;
        &lt;aop:pointcut id=&quot;service&quot; expression=&quot;execution(* AOP.*.*(..))&quot;/&gt;
        &lt;!--aop:advisor配置传统Spring AOP切面，只能有一个切入点和一个通知--&gt;
        &lt;aop:advisor advice-ref=&quot;myMethodInterceptor&quot; pointcut-ref=&quot;service&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre><p>测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService hello = (IAopService) context.getBean(&quot;aopServiceImpl&quot;);
        hello.withAop();
    }

}
</code></pre><h4 id="AspectJ-AOP切面编程"><a href="#AspectJ-AOP切面编程" class="headerlink" title="AspectJ AOP切面编程"></a>AspectJ AOP切面编程</h4><p>接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>实现</p>
<pre><code>public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>通知</p>
<pre><code>public class MyAspect {
    public void before1(JoinPoint jointPoint){
        System.out.println(&quot;before1&quot;);
    }
    public void before2(JoinPoint jointPoint){
        System.out.println(&quot;before2&quot;);
    }
}
</code></pre><p>配置</p>
<pre><code>&lt;!--1、目标--&gt;
&lt;bean id=&quot;aopServiceImplAspectJ&quot; class=&quot;AOP.AspectJ.AopServiceImpl&quot;/&gt;
&lt;!--2、通知--&gt;
&lt;bean id=&quot;myMethodInterceptorAspectJ&quot; class=&quot;AOP.AspectJ.MyAspect&quot;/&gt;
&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;aop:aspect ref=&quot;myMethodInterceptorAspectJ&quot;&gt;
        &lt;!--标签before决定前置通知--&gt;
        &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt;
        &lt;aop:before method=&quot;before2&quot; pointcut-ref=&quot;serviceAspectJ&quot;/&gt;
        &lt;!--切入点--&gt;
        &lt;aop:pointcut id=&quot;serviceAspectJ&quot; expression=&quot;execution(* AOP.AspectJ.*.*(..))&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService hello = (IAopService) context.getBean(&quot;aopServiceImplAspectJ&quot;);
        hello.withAop();
    }

}
</code></pre><h4 id="AspcetJ注解驱动的切面★★★★★★★★★"><a href="#AspcetJ注解驱动的切面★★★★★★★★★" class="headerlink" title="@AspcetJ注解驱动的切面★★★★★★★★★"></a>@AspcetJ注解驱动的切面★★★★★★★★★</h4><p>1、接口</p>
<pre><code>public interface IAopService {
    public void withAop() throws Exception;
}
</code></pre><p>2、实现</p>
<pre><code>@Service
public class AopServiceImpl implements IAopService {
    public void withAop() throws Exception {
        System.out.println(&quot;业务逻辑处理中&quot;);
    }
}
</code></pre><p>3、切面，包括切入点和通知</p>
<pre><code>@Aspect
//表示当前类是一个通知
public class MyAspect {

    private static final Logger logger = Logger.getLogger(MyAspect.class);

    //定义切入点方法一：定义在一个空方法上
    @Pointcut(&quot;execution(* *.*(..)))&quot;)
    private void myPointcut() {
    }

    //定义切点方法二：直接在通知上定义切入点
    @Before(&quot;execution(* *.*(..)))&quot;)
    public void before(JoinPoint joinPoint) {
        String className = joinPoint.getTarget().getClass().getName();
        String methodName = joinPoint.getSignature().getName();
        logger.warn(className + &quot;的&quot; + methodName + &quot;执行了&quot;);
        Object[] args = joinPoint.getArgs();
        StringBuilder log = new StringBuilder(&quot;参数为：&quot;);
        for (Object arg : args) {
            log.append(arg + &quot; &quot;);
        }
        logger.warn(log.toString());
    }

    @AfterReturning(value = &quot;execution(* *.*(..)))&quot;, returning = &quot;returnVal&quot;)
    public void afterReturin(Object returnVal) {
        logger.warn(&quot;方法正常结束了,方法的返回值:&quot; + returnVal);
    }

    @AfterThrowing(value = &quot;myPointcut()&quot;, throwing = &quot;e&quot;)
    public void afterThrowing(Throwable e) {
        logger.error(&quot;AfterThrowing&quot; + e.getMessage(),e);
    }

    @Around(value = &quot;myPointcut()&quot;)
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        logger.warn(&quot;Around:前置增强&quot;);
        Object result = null;
        try {
            result = proceedingJoinPoint.proceed();
        } catch (Exception e) {
            logger.error(&quot;Around:&quot; + e.getMessage(),e);
        }
        logger.warn(&quot;Around:后置增强&quot;);
        return result;
    }
}
</code></pre><p>4、配置</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;AOP&quot;/&gt;
&lt;!--1、开启AspectJ注解开发的配置--&gt;
&lt;aop:aspectj-autoproxy/&gt;
&lt;!--配置切面--&gt;
&lt;bean id = &quot;MyAspect&quot; class=&quot;AOP.AspectJAnnotation.MyAspect&quot;/&gt;
</code></pre><p></p>
<p>5、测试</p>
<pre><code>public class AopRun {

    public static void main(String[] args) throws Exception {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        IAopService aopService = (IAopService) context.getBean(IAopService.class);
        aopService.withAop();
    }

}
</code></pre><p>spring 的环绕通知和前置通知，后置通知有着很大的区别，主要有两个重要的区别：</p>
<ol>
<li><p>目标方法的调用由环绕通知决定，即你可以决定是否调用目标方法，而前置和后置通知   是不能决定的，他们只是在方法的调用前后执行通知而已，即目标方法肯定是要执行的。</p>
</li>
<li><p>环绕通知可以控制返回对象，即你可以返回一个与目标对象完全不同的返回值，虽然这很危险，但是你却可以办到。而后置方法是无法办到的，因为他是在目标方法返回值后调用</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
