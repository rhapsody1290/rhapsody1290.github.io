<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://qianmingxs.com/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/"/>





  <title>Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/07/22/[数据结构与算法]面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/[数据结构与算法]面试总结/" itemprop="url">面试总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T19:07:00+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><p>什么是Spring？<br>spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架</p>
<p>什么是IOC/AOP?<br>IOC是控制反转，就是将创建对象的工作从程序中转移出来，交由Spring框架完成对象的<strong>创建和装配</strong>工作<br>AOP是面向切面编程，将共有的代码抽离出来，放在一个地方进行维护，在程序运行的时候由框架将切面<strong>切入</strong>到目标对象上，程序员只需要专注业务逻辑的开发</p>
<p>什么是依赖注入？<br>在创建对象的时候，由框架将依赖的对象实例注入到当前对象中</p>
<p>什么是Bean？</p>
<ul>
<li>Spring管理的对象为Bean</li>
<li>Bean可以是任意对象，包括javabean、service、dao、数据源</li>
<li>Bean必须由一个无参的构造器，通过get/set方法访问参数，支持序列化</li>
</ul>
<p>原理：</p>
<p>1、配置文件中定义的 bean 可以全部都可以抽象为一个 Bean 对象，字段包括ID、类名、依赖属性</p>
<pre><code>&lt;bean id = &quot;person&quot; class = &quot;Person&quot;&gt;
    &lt;preperty name = &quot;name&quot; value = &quot;Alan&quot;/&gt;
&lt;/bean&gt;

=&gt; 抽象

Bean{
    /* Bean Id */
    private String id;
    /* Bean Class */
    private String type;
    /* Bean Property */
    private Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
}
</code></pre><p>2、接下来 Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个 <strong>HashMap</strong> 中，HashMap 的 key 就是 Bean 的 Id ，HasMap 的value是这个Bean，只有这样我们才能通过context.getBean(“user”)这个方法获得Animal这个类</p>
<p>3、依赖注入，在实例化一个类时，它通过<strong>反射</strong>调用类中 set 方法将事先保存在 HashMap 中的类属性注入到类中</p>
<p>如何启动Spring？</p>
<pre><code>ApplicationContext context = new ClasspathXMLApplicationContext(&quot;application.xml&quot;);
#在web.xml的监听器标签中配置ContextLoaderListener，并在全局参数中配置Spring配置文件
&lt;listener&gt;  
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  
&lt;/listener&gt; 
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre><p>注解依赖注入：</p>
<p>1、注解的方式引入bean：@Service(value = ‘a’)、@Component(value = ‘b’)<br>2、依赖注入：Autoware：按类型；Autoware+Qualifier(value=’b’)：按名称</p>
<p>AOP：AOP容器会将切面切入到目标对象的连接点上，动态创建一个代理对象供使用者调用</p>
<p>切面：共有功能的实现，包括通知和切入点，如日志切面、事务切面<br>通知：切面的具体实现，包括前置通知、后置通知、环绕通知、异常通知、最终通知<br>切入点：定义将通知切入到哪些连接点上</p>
<p>连接点：能够插入切面的地点<br>目标对象：需要被动态功能加强的对象<br>代理对象：将切面切入到目标对象后，动态创建的对象</p>
<p>织入：将切面切入到目标对象的连接点上，创建一个新的代理对象的过程</p>
<p>AOP底层实现？<br>1、JDK动态代理：必须针对接口进行代理，通过Proxy类，传入类加载器、接口和InvocationHandler类，返回代理对象<br>2、CGLIB：如果目标对象没有接口，无法使用JDK动态代理，则可以使用CGLIB</p>
<p>动态代理原理：</p>
<ul>
<li>使用：1、创建目标对象 2、自定义类实现InvocationHandler接口，构造函数中传入目标对象，在实现的接口方法Invoke中对根据选择对方法进行代理 3、调用Proxy.newProxyInstance方法中传入是三个参数，分别是类加载器，代理的接口和自定义InvocationHandler实例，返回代理对象</li>
<li>原理：1、调用ProxyGenerator的generateProxyClass方法产生ProxySubject.class的二进制数据，<strong>代理类实现接口中的方法，方法体中都是调用成员变量InvocationHandler的invoke方法</strong>，需要传入参数类名和实现接口，生成的代理类在调用接口方法时，会调用传入的InvocationHandler的invoke方法 2、利用反射创建代理对象的实例，并且传入InvocationHandler参数，返回代理对象实例 3、<strong>执行代理类的对象时都会执行InvocationHandler的invoke方法</strong></li>
</ul>
<p>基于注解的AOP：AspectJ</p>
<p>1、开启注解<code>&lt;aop:aspectj-autoproxy/&gt;</code><br>1、定义一个类作为切面，用@Aspect注解，并在配置文件中配置切面<br>2、定义切入点和通知</p>
<p>环绕通知和前置、后置区别：<br>spring 的环绕通知和前置通知，后置通知有着很大的区别，主要有两个重要的区别：</p>
<p>1） <strong>目标方法的调用由环绕通知决定</strong>，即你可以决定是否调用目标方法，而前置和后置通知是不能决定的，他们只是在方法的调用前后执行通知而已，即目标方法肯定是要执行的。</p>
<p>2）  环绕通知可以控制返回对象，即你可以返回一个与目标对象完全不同的返回值，虽然这很危险，但是你却可以办到。而后置方法是无法办到的，因为他是在目标方法返回值后调用</p>
<p><strong>总结</strong>：1、前置通知是在方法调用前执行，后置通知在方法调用后执行，但是方法都必须执行，但环绕通知可以决定是否调用该方法 2、环绕通知可以修改方法的返回值，但后置通知办不到，因为他是在目标方法返回值后调用</p>
<p>通知执行顺序：</p>
<pre><code>·环绕前置通知

前置通知

具体业务方法
异常通知

·环绕后置通知

后置通知
</code></pre><p>当目标方法抛出异常时，后置方法不再执行</p>
<h2 id="Spring-MVC："><a href="#Spring-MVC：" class="headerlink" title="Spring MVC："></a>Spring MVC：</h2><p>什么是Spring MVC？<br>Spring MVC是一个基于MVC设计理念的web框架</p>
<p>SpringMVC运行原理：<br>1、DispatcherServlet 拦截所有请求<br>2、从HandlerMapping 查找 Handler，返回执行链（Handler和拦截器集合）<br>3、DispatcherServlet 调用 HandlerAdapter，HandlerAdapter 调用 Handler，<strong>Handler处理具体的业务逻辑</strong>。Handler处理完业务逻辑后返回ModelAndView给HandlerAdapter，其中View是视图名称，Modal是数据模型。HandlerAdapter再返回给DispatcherServlet。<br>4、DispatcherServlet通过ModelView的<strong>视图名称</strong>在视图解析器中查找视图，视图解析器返回真正的View视图对象<br>5、渲染视图</p>
<p>HandlerMapping作用？</p>
<p>RequestMappingHandlerMapping处理<strong>请求映射</strong>的，根据用户的请求URL，查找@RequestMapping，找出匹配的Handler（<strong>URL-&gt;Handler</strong>）</p>
<p>HandlerAdapter作用？</p>
<p>HandlerAdapter的handler<strong>方法处理注解和准备handler方法中的参数</strong>（这就是SpringMVC如何将request中的参数编程输入参数的地方），最终<strong>调用实际的Handler method</strong></p>
<p>Restful风格API？</p>
<p>（1）每一个URI代表一种资源(只能有名词)<br>（2）客户端通过四个HTTP动词(get/post/put/delete)，对服务器端资源进行操作<br>（3）客户端和服务器之间，传递这种资源的某种表现层</p>
<p>url示例：</p>
<pre><code>get /board/xxxx.html  
post /board?title=xx
delete /board?id=xxx
put /board?id=xx&amp;title=xx
</code></pre><p>API:</p>
<pre><code>@Requestmapping(value = &quot;/board/{id}.html&quot; method = RequestMethod.GET)
public String getBoard(@Pathvariable(&quot;id&quot;) String id){
    server.get(id);
}
</code></pre><p>消息转换：</p>
<p>使用：<br>用@RequestBody标注，并在Domain对象中标注注解@XmlRootElement，将XML字符串转换为Domain对象<br>用@ResponseBody标注，将</p>
<p>原理：</p>
<p>HttpMessageConvert 自动将http消息转化为对象，将对象转化http消息</p>
<p>1、Spring MVC 配置了默认转换器，在类加载的时候尝试加载一些默认转换类，如jackson、jaxb，如果加载抛出异常说明没有引入类，否则来实例化响应的消息转换器类。当返回 HandlerAdapter时，为之设置<strong>转换器列表</strong><br>2、根据请求体的类型，如text/xml，遍历所有的消息转换器，看是否支持请求体类型；最终调用jaxb消息转换器，进行转换</p>
<p><strong>WebMvcConfigurationSupport：Spring MVC主要配置类</strong>，包括messageConverters、url匹配等</p>
<p>为什么转化为XML而不是JSON？</p>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><p><img src="http://i.imgur.com/JpGhPj9.jpg" alt=""></p>
<p>mybatis优势：</p>
<h2 id="什么是SOA？"><a href="#什么是SOA？" class="headerlink" title="什么是SOA？"></a>什么是SOA？</h2><p>面向服务的架构，强调的是一种架构思想，将系统划分为多个模块，各模块之间以标准服务的方式进行交互，强调组件化的灵活开发方式</p>
<p>（将系统划分为多个模块，也称为服务，这些服务之间通过接口和协议联系起来，接在一起以实现特定的功能。）</p>
<h2 id="什么是RPC框架？"><a href="#什么是RPC框架？" class="headerlink" title="什么是RPC框架？"></a>什么是RPC框架？</h2><p>RPC框架：远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</p>
<p><a href="http://www.jianshu.com/p/0f4113d6ec4b" target="_blank" rel="external">http://www.jianshu.com/p/0f4113d6ec4b</a></p>
<h2 id="什么是Thrifit："><a href="#什么是Thrifit：" class="headerlink" title="什么是Thrifit："></a>什么是Thrifit：</h2><p><strong>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，采用接口描述语言定义服务，支持跨语言，数据传输采用二进制，能够快速构建服务</strong></p>
<p>接口描述语言：<br>客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）。</p>
<p>基本数据类型：</p>
<ul>
<li>byte: 有符号字节 </li>
<li>i16: 16位有符号整数 </li>
<li>i32: 32位有符号整数 </li>
<li>i64: 64位有符号整数 </li>
<li>double: 64位浮点数 </li>
<li>string: 字符串</li>
</ul>
<p>容器类型：</p>
<ul>
<li>list<t>: 一系列由T类型的数据组成的有序列表，元素可以重复</t></li>
<li>set<t>: 一系列由T类型的数据组成的无序集合，元素不可重复</t></li>
<li>map<k, v="">: 一个字典结构，key为K类型，value为V类型，相当于Java中的HMap<k,v></k,v></k,></li>
</ul>
<p>结构体：（记得写参数编号）</p>
<pre><code>struct People {
     1: string name;
     2: i32 age;
     3: string sex;
}
</code></pre><p>枚举(enum)：</p>
<pre><code>enum Sex {
    MALE,
    FEMALE
}
</code></pre><p>异常(exception)：</p>
<pre><code>exception RequestException {
    1: i32 code;
    2: string reason;
}
</code></pre><p>服务(service):thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码</p>
<pre><code>service HelloWordService {
     // service中定义的函数，相当于Java interface中定义的函数
     string doAction(1: string name, 2: i32 age);
 }
</code></pre><p>注释：thrift注释方式支持shell风格的注释，支持C/C++风格的注释，即#和//开头的语句都单当做注释，/**/包裹的语句也是注释。</p>
<p>服务描述文件示例：</p>
<pre><code>namespace java com.winwill.thrift

enum RequestType {
    SAY_HELLO,   //问好
    QUERY_TIME,  //询问时间
}

struct Request {
    1: required RequestType type;  // 请求的类型，必选
    2: required string name;       // 发起请求的人的名字，必选
    3: optional i32 age;           // 发起请求的人的年龄，可选
}

exception RequestException {
    1: required i32 code;
    2: optional string reason;
}

// 服务名（类似于接口名）
service HelloWordService {
    string doAction(1: Request request) throws (1:RequestException qe); // 可能抛出异常。
}
</code></pre><p><strong>使用Thrift开发流程为</strong>：</p>
<ul>
<li>编写接口文件（IDL：Interface Description Language）</li>
<li>经过Thrift工具编译后，生成一个个Java类</li>
<li>实现Service类</li>
</ul>
<p><strong>Thrift框架原理</strong>;</p>
<ul>
<li>服务器启动后处于监听状态，当接收到客户端的消息后，服务器发起一个线程处理该消息请求，原线程再次进入阻塞状态</li>
<li>新线程根据协议读取消息，调用请求方法，并将结果写入到结果，传回客户端</li>
</ul>
<p><strong>Thrift传输协议</strong>：<br>协议类别总体上划分为：文本、二进制，但为节省带宽，提高传输效率，一般使用二进制类型的传输协议</p>
<p><strong>Thrift客户端、服务端</strong>：<br>有阻塞，非阻塞，线程池，半同步半异步，Selector多种服务端实现模式。</p>
<pre><code>TSimpleServer – 简单的单线程服务模型，常用于测试
TThreadedServer – 多线程服务模型，使用阻塞式IO，每个请求创建一个线程。(java 不支持)
TThreadPoolServer – 多线程服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。
TThreadedSelectorServer 允许你用多个线程来处理网络I/O。它维护了两个线程池，一个用来处理网络I/O，另一个用来进行请求的处理
TNonblockingServer – 多线程服务模型，使用非阻塞式IO（需使用TFramedTransport数据传输方式）,只有一个线程来处理消息
THsHaServer - 半同步半异步的服务模型，一个单独的线程用来处理网络I/O，一个worker线程池用来进行消息的处理
</code></pre><p>客户端包括同步，异步两种形式</p>
<p><strong>Thrifit优势</strong>：<br>使用二进制数据格式传输，</p>
<p>JSP：Java Servlet Page 动态生成网页的技术<br>在第一次访问JSP的时候，会将JSP文件翻译成一个Servlet文件，然后将Servlet编译成class文件，并加载进内存，创建一个Servlet实例，调用其init方法，其中init方法只有在第一次访问时调用，然后调用其service方法。第二次之后直接访问其service方法，所以第一次加载速度比较慢，之后就比较快了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;c:forEach items=&quot;$&#123;a&#125;&quot; var=&quot;fuwa&quot;&gt;</div><div class="line">     &lt;c:out value=&quot;$&#123;fuwa&#125;&quot;/&gt;&lt;br&gt;</div><div class="line">&lt;/c:forEach&gt;</div></pre></td></tr></table></figure>
<p>内置对象：request、response、session、application、page、out、config、exception、pageContext</p>
<p>装修计算器：主要有两大功能，装修规划及预算报价，</p>
<p>mybatis：</p>
<h2 id="园区网用户行为审计系统"><a href="#园区网用户行为审计系统" class="headerlink" title="园区网用户行为审计系统"></a>园区网用户行为审计系统</h2><p>项目介绍：本项目为解决园区网络内部的安全问题，对园区网络的内网用户访问外部网络的行为进行监控和审计，并将网络上发生的事件记录下来以便事后追查<br>主要负责：</p>
<p>1、利用华为二层、三层交换机组建园区网络：接入层采用二层交换机，骨干网采用高性能的三层交换机，在二层交换机中划分VLAN，隔离广播域（VLAN是虚拟的局域网）。在三层交换机配置SVI接口，在能够实现不同VLAN之间的通信（不同VLAN之间的通信相当于不同的广播域进行通信，要采用路由的方式，三层交换机一般处于骨干网络，能够记录下IP地址与交换机端口之间的映射关系，在园区网络内实现互联互通）</p>
<p>2、基于SNMP协议审计虚假路由攻击：实时监测园区网络中路由表的变化，SNMP是简单网络管理协议，可以获得设备的基本信息；使用UDP作为传输层；用161端口接收get/set报文，用162接收trap报文；当系统启动时主动获取路由器中的路由表，当路由表发生变化时，会向管理主机发送一个trap报文，查询路由表并与之间的对比，如果路由表发生变化则认为发生虚假路由攻击</p>
<p>3、利用Jpcap抓包对网络流量监控：Java语言对网络层以下的控制无能为力，Jpcap是一个中间件，JPCAP调用wincap，对数据链路层的控制；利用Java第三方类库Jpcap抓取网络数据包，统计单位时间网络传输的字节速率，具体方案是维护{bytes = 0，开始时间}，当时间小于一秒钟，累计字节数；如果超过1秒就记录下当时的字节数，得到的结果就是一秒内传输的字节速率</p>
<p>这是一个<strong>网络监控软件</strong>，解析各种常见的协议，如HTTP、SMTP、Telnet等，分析用户行为，能够知道用户在什么时候做了什么事情；</p>
<p>整个系统分为多个模块，每个模块是一个线程，各个模块间通过队列的方式协调运行<br>1、采集模块：因为 Java 程序没法操作链路层，所以采用 JPCAP 中间件从底层抓取数据包，放到队列中<br>2、分派模块：分派模块根据不同的数据包类型，将TCP数据包放到TCP队列，UDP数据包放到UDP队列，ARP数据包放到ARP队列<br>4、TCP重组模块：从TCP队列中取出数据包，根据TCP重组算法建立完整的TCP会话连接，并放入解析队列<br>4、解析模块：从解析队列中取出数据，根据使用的端口，进行协议解析：如果80端口解析HTTP报文，25端口是SMTP协议，110是POP3协议</p>
<p>TCP重组算法：根据源地址、目的地址、源端口、目的端口确定一条TCP连接，从TCP三次握手开始到TCP四次挥手，维护客户端和服务器的状态机，当出现SYN数据包时，客户端的状态由关闭状态变为SYN Send，当接收到 SYN+ACK，服务器端的状态由监听状态变为SYN Received；当接收到ACK，客户端的状态变为Established，服务器端的状态变为Established。之后接收到数据包，如果正式当前缓存队列中期待的数据包，则加入队列，否则放入乱序的队列；接下来到四次挥手，当接收到Fin数据包，客户端的状态变为Fin Wait1，接受都 Fin+ACK 服务器端的状态变为Close Wait;当接收到服务器端的Fin，服务器的状态变为Last ACK，当接收到ACK时，客户端的状态变为Fin Wait2</p>
<h3 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h3><p>1、jstat -gcutil 首先看存在占用100%或90以上的，增大堆3g -Xms -Xmx<br>2、可能会太大了，回缩，jstat -gc 设置堆为老年堆占用量的4倍<br>3、设置新生代和持久代为老年堆使用量的1.5倍<br>-Xmn<br>-XX:PermSize<br>-XX:MaxPermSize</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><strong>三次握手</strong></p>
<p><img src="http://i.imgur.com/vwU8xop.png" alt=""></p>
<p>首先客户端向服务端发送SYN报文（seq = client_isn），服务端收到后发送ACK（client_isn+1），和SYN报文（seq = server_isn），客户端再发送ACK（server_isn+1），TCP连接建立</p>
<p>当双方建立 TCP 连接以后，就可以传输数据了，传输过程中发送方每发送一个数据包 ，接收方都要给予一个应答。</p>
<p>TCP 断开连接<br>建立一个连接需要 3 次握手，而终止一个连接要经过 4 次握手（如图 2 ）。<strong>这是因为一个 TCP 连接是全双工（即数据在两个方向上能同时传递），每个方向必须单独地进行关闭</strong>。4 次握手实际上就是双方单独关闭的过程。</p>
<p><strong>为什么是三次握手，二次可以吗？</strong></p>
<p>三次握手的核心是什么？<font color="red"><strong>三次握手是为了交换客户端和服务器各自的初始序列号，这样双方都知道对方的初始序列，从而判断哪些TCP数据包是合法的，哪些不合法</strong></font></p>
<p>两次握手的时候，客户端向服务器端发送同步包。服务器接收到后，<strong>知道客户端的初始序列</strong>，分配资源建立连接，发送同步包和确认包，客户端接收到后，<strong>知道服务器的初始序列</strong>，于是分配资源连接建立，<strong>正常情况下是没有问题的</strong></p>
<p><strong>可能服务器发送的ACK丢失</strong>，客户端以为服务器没有接收到SYN，然后重新发送同步报，但是<strong>此时服务器已经打开连接了，会忽略客户端发送的同步包</strong>，这样客户端就永远不会获得服务器端的初始序列号，两者无法建立连接，但服务器端已经分配了资源，从而造成资源浪费</p>
<p>采用三次握手的时候，当接收到客户端的同步包的时候，建立半连接，当接收到客户端的响应时才打开连接<br><br></p>
<font color="red"><strong>此时如果客户端打开连接了，但是第三次ACK丢了，会造成客户端的资源浪费吗？</strong></font>

<p>服务器会重新发送SYN+ACK，直到接收到ACK，这样客户端和服务器都建立了连接，<strong>不会造成任何一方的资源浪费</strong></p>
<p><strong>为什么不是四次握手？</strong></p>
<p>三次握手已经能够建立可靠连接，第四次握手就多余了，<font color="red"><strong>在通信理论上，三次握手是不可靠信道上，进行建立可靠连接的最小次数</strong></font>，所以采用过三次握手可以提高连接的效率</p>
<p><strong>四次挥手</strong></p>
<p>FIN-ACK-FIN-ACK<br>客户端状态：Fin-Wait1，Fin-Wait2，Time-Wait，close<br>服务器状态：Clost-Wait，Last-ACK，close</p>
<p><img src="http://i.imgur.com/JnAoPIc.jpg" alt=""></p>
<p><strong>TCP细节：</strong></p>
<p>发送缓存：</p>
<p>[0，base-1]内的序号已经发送并确认过的序列，[base，nextSeqnum-1]对应已经发送但未被确认的分组，[nextSeqnum，base+N-1]内的序号为要被立刻发送的分组，数据来自上层，大于bast+N的序号不能使用，直到流水线中未被确认的分组得到确认为止</p>
<p><img src="http://i.imgur.com/CeJwtVf.png" alt=""></p>
<p>回退N步（GBN）：</p>
<ul>
<li>发送方如果出现超时事件，将重传所有<strong>已发送但未被确认的分组</strong></li>
<li>接收方需要维护下一个按需接收的分组序号，如果按序到达，将数据提交给上层；如果失序，直接丢弃，不进行任何缓存</li>
</ul>
<p>选择重传：</p>
<ul>
<li>每个分组发送后启动定时器，发送方会重传未被确认分组中序列号最小的的分组</li>
<li>在接受方失序的分组将被缓存</li>
</ul>
<p>TCP可靠数据传输：</p>
<p>发送方：1、从上层应用程序接收数据 2、定时器超时 3、收到ACK报文</p>
<p>发送数据包时启动定时器；定时器超时，重发未被确认分组中序列号最小的分组，并开启定时器；接收到ACK，而且ACK大于当前未被确认的序列，更新已经确认的序列，重启定时器；如果小于的话，直接忽略</p>
<p><img src="http://i.imgur.com/mGghHta.png" alt=""></p>
<h2 id="公众号开发"><a href="#公众号开发" class="headerlink" title="公众号开发"></a>公众号开发</h2><p>项目介绍：马可波罗瓷砖莞深销售中心公众号，用于解决分公司日常的<strong>销售业务中</strong>存在大量的信息沟通需要</p>
<h3 id="编码转换（已删）"><a href="#编码转换（已删）" class="headerlink" title="编码转换（已删）"></a>编码转换（已删）</h3><p>utf8-latin1-gbk</p>
<p>String content content = new String(temp.getBytes(“gbk”),”iso-8859-1”);</p>
<p>问题转换为如何将gbk编码的字节正确传输；<br>1、new String(temp.getBytes(“gbk”),”iso-8859-1”)：获得gbk编码的字节流，用lain1字节解码，获得字符串，任务转换为传输该字符串，只要发送方和接收方一致就行，<br>2、接收方接收到字节流，直接用gbk解码</p>
<h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>1、底层采用Jedis访问redis，包括一些set/get/expire命令<br>2、RedisTemplate 加上一层连接池<br>3、对于每次操作都是打开链接，执行操作；为了简洁，设计成execute（callback）的方式，不同的操作只是callback中的内容不一样<br>4、使用jdk序列化工作执行对象的序列化</p>
<h3 id="动态数据源切换"><a href="#动态数据源切换" class="headerlink" title="动态数据源切换"></a>动态数据源切换</h3><p>之前开发了一个微信公众号，后来提出了一个需求，需要开发5个分公司的微信公众号，有两种方案：</p>
<p>1、每个公众号设置不同的端口运行在服务器上，反向代理根据域名定位到个自己的服务器上<br>2、使用同一个应用，根据不同的公众号，动态切换数据源</p>
<p>由于每个公众号采用的操作都是一样的，就是数据不一样，于是采用方案二</p>
<p>如何分别不同的公众号？两种方案：</p>
<p>1、采用一级域名，二级域名的方式<br>/mk/bu1/o/get=&gt;相当于寻找/bu1/o/get，找不到<br>重定向带/o/get =&gt; 原来的不用改</p>
<p>2、采用标记</p>
<p>公众号1：flag = 1<br>公众号2：flag = 2</p>
<p>因为微信重定向时只能带一个参数，所以采用一级、二级域名的方式</p>
<p>具体方案：</p>
<p>1、重写DispatcherServlet的doDispatch方法，利用线程局部变量ThreadLocal记录前缀，然后重定向</p>
<p>2、继承AbstractRoutingDataSource，重写determineCurrentLookupKey的方法，这个方法在调用数据源的getConnection方法时需要选择数据源的名称，这是我们返回ThreadLocal的值就行了，完成了动态数据源</p>
<p>在Spring中配置数据源时，对应的class是咱么自己重写的数据源，然后改数据源管理了一些需要切换的数据源，用map保存</p>
<p>源码分析：<a href="http://www.cnblogs.com/davidwang456/p/4318303.html#top" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/4318303.html#top</a></p>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>单向链表头插法：</p>
<pre><code>t = first;
first = new Node();
first.next = t;
</code></pre><p>这种写法对first是否为null都不影响，但是对last指针有影响：当first为空时，last=first，否则last不变，完整写法：</p>
<pre><code>t = first;
first = new Node();
first.next = t;
if(t == null){
    last = first;
}else{
    //不操作
}
</code></pre><p>双向链表头插法：</p>
<p>不考虑特殊情况的写法：</p>
<pre><code>t = first;
first = new Node();
first.next = t;
first.pre = null;
t.pre = first;
</code></pre><p>但当first为null的时候，t.pre=first会报空指针异常，修正：</p>
<pre><code>t = first;
first = new Node();
first.next = t;
first.pre = null;
if(t == null){
    last = first;
}else{
    t.pre = first;
}
</code></pre><p>总结：头插法和尾插法思考方法<br>1、保存first或last的指针<br>2、first或last指向新new出来的对象，维护其与前后节点之间的关系<br>3、当first或last为空时，分别使last或first执行new的对象，如果是双向链表，还需维持new出来对象前后之间的关联</p>
<p>头插法双向链表：</p>
<pre><code>private void linkFirst(E e) {
    final Node&lt;E&gt; f = first;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
    first = newNode;
    //易错点
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}
</code></pre><p>尾插法双向链表：</p>
<pre><code>void linkLast(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    //易错点
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre><h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h2><p><a href="http://www.jianshu.com/p/0f4113d6ec4b#" target="_blank" rel="external">http://www.jianshu.com/p/0f4113d6ec4b#</a></p>
<p>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言</p>
<p>既然客户端和服务端能使用不同的语言开发，那么一定就要有一种<strong>中间语言</strong>来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）<strong>接口描述语言</strong></p>
<p>支持数据类型：</p>
<ul>
<li>byte: 有符号字节</li>
<li>i16: 16位有符号整数</li>
<li>i32: 32位有符号整数</li>
<li>i64: 64位有符号整数</li>
<li>double: 64位浮点数</li>
<li>string: 字符串</li>
</ul>
<p>结构体</p>
<pre><code>struct People {
     1: string name;
     2: i32 age;
     3: string sex;
}
</code></pre><p>异常</p>
<pre><code>exception RequestException {
    1: i32 code;
    2: string reason;
}
</code></pre><h2 id="OOP三大特性：继承，多态，封装，抽象"><a href="#OOP三大特性：继承，多态，封装，抽象" class="headerlink" title="OOP三大特性：继承，多态，封装，抽象"></a>OOP三大特性：继承，多态，封装，抽象</h2><p>记忆：jdcf<br>（京东程飞）</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><a href="http://yunnigu.dropsec.xyz/2016/09/25/Java%E4%B9%8B%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/#" target="_blank" rel="external">http://yunnigu.dropsec.xyz/2016/09/25/Java%E4%B9%8B%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/#</a></p>
<p>在父类中定义这些相同的当多个类存在相同的<strong>属性和方法</strong>，所有的子类不需要重新定义这些属性和方法，只需要继承父类,这样子类就会自动拥有父类定义的某些属性和方法</p>
<p>1、Java继承中的属性覆盖</p>
<p>父类哪些属性、方法被子类继？<strong>除了private修饰的属性和方法都能都能被子类继承</strong></p>
<p>继承中的属性覆盖结论：</p>
<ul>
<li>由于private变量受访问权限的限制，它不能被覆盖</li>
<li>属性的值取父类还是子类并不取决于我们创建对象的类型，而是取决于我们<strong>定义的变量的类型</strong></li>
<li>friendly、protected和public修饰符并不影响属性的覆盖</li>
<li><strong>静态变量和静态常量属于类，不属于对象，因此它们不能被覆盖</strong></li>
<li><strong>常量可以被覆盖</strong></li>
<li>对于基本类型和对象，它们适用同样的覆盖规律</li>
</ul>
<p>2、Java方法重写</p>
<ul>
<li>重载时只与<strong>方法特征</strong>有关，重写时会进一步检查两个方法的<strong>返回类型</strong>是否相同、<strong>访问修饰</strong>权限是否缩小和抛出的<strong>异常范围</strong>是否扩大</li>
<li>非私有非静态方法不能被任何静态方法覆写</li>
<li>非私有静态方法不能被任何非静态方法覆写</li>
<li>子类与父类中<strong>有方法特征相同的静态方法时</strong>，覆写规则与非静态方法覆写规则一样，但一般我们不把静态方法的覆写叫覆写，虽然语法规则上与非静态方法相同。<strong>不存在多态</strong></li>
<li>私有方法对子类同名方法不产生任何影响，也就是说私有方法不能被重写，即使试着在子类覆写了父类的私有方法，不管访问权限修饰符是什么，在编译时也不会报错。原因就是私有方法对子类也是不可见的。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>就是指一个引用(类型)在不同情况下的多种状态，实现多态有两种方式：<strong>1、继承；2、接口</strong></p>
<p>方法重写与方法重载：</p>
<ul>
<li><strong>方法重载</strong>：在一个类中有多个<font color="red"><strong>相同名字</strong></font>的方法，但具有<font color="red"><strong>不同的参数表</strong></font>（参数类型、个数、顺序），<strong>返回值类型、方法的修饰符可以不同，如果只是返回类型或方法的修饰符不一样，不能构成重载</strong>，，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</li>
<li><strong>方法重写</strong>： <strong>子类</strong>有一个方法，和<strong>父类</strong>的某个方法的<strong>返回类型、方法名、参数表一样</strong>，子类方法不能缩小父类方法的<font color="red"><strong>访问权限</strong></font>，可以放大访问权限；<strong>不能扩大异常范围，可以不抛异常</strong>                                                    </li>
</ul>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>定义一个类时候，实际上就是把一类事物的共有的属性和行为提取出来，形成一个类</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把抽象出来的<strong>数据</strong>和对数据的<strong>操作</strong>封装在一起。数据被保护在内部，程序的其它部分只有通过被授权的操作(<strong>成员方法</strong>)，才能对数据进行操作。</p>
<p>访问控制修饰符</p>
<p><img src="http://img.blog.csdn.net/20160416152720709" alt="这里写图片描述"></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><p>总的原则：可维护，复用，易扩展</p>
<p>SOLIDcl：（泥土 蔡磊）<br>s单一职责原则<br>o开闭原则：对扩展开放，对修改关闭<br>l里式替换：父类可以引用子类<br>i接口隔离原则：使用多个专门的接口，而不是用单一的总接口<br>d依赖倒转：面向接口编程<br>c合成复用：尽量使用对象组合，而不是继承达到复用的目的<br>l迪米特：一个软件实体尽可能少与其他实体耦合                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>
<h3 id="单例模式：确保一个类只有一个实例"><a href="#单例模式：确保一个类只有一个实例" class="headerlink" title="单例模式：确保一个类只有一个实例"></a>单例模式：确保一个类只有一个实例</h3><p>1、构造方法私有，外部不能通过new创建对象<br>2、静态变量保存唯一实例<br>3、静态的getInstance方法，是外部能够访问</p>
<p>饿汉模式:在类加载的时候已经创建了单例对象</p>
<pre><code>//staic final静态常量
private static final Singleton instance = new Singleton();
private Singleton(){}
public static Singleton getInstance(){return instance;}
</code></pre><p>懒汉模式：第一次调用的时候创建对象实例</p>
<pre><code>private static Singleton instatnce = null;
private Singleton(){}
//注意同步控制关键字 Synchronized
synchronized public Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre><p>方法二：synchronized同步控制代码块，双重检查锁定（单次判断实例不为空，如果一个线程正在创建对象但还未创建完成，另一个线程进入实例不为空的判断，最终产生两个实例，未被单一对象的原则）</p>
<pre><code>//使用volatile保证可见性
private volatile static Singleton instatnce = null;
private Singleton(){}
public static Singleton getInstance(){
    //第一重判断
    if(instance == null){
        synchronized(Singleton.class){
            //第二重判断
            if(instance == null){
                    instance = new Singleton();
            }
        }
    }
    return instance;
}
</code></pre><p>为什么需要使用volatile？不是同步快结束完之后，会将instance对象写入内存？</p>
<p>答：主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ul>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ul>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<font color="red"><strong>解析</strong>：</font>

<pre><code>线程1创建调用getInstance（）方法执行到instance=new Singleton()，但是这条语句不是原子性的，他分为三个步骤：1、分配内存 2、初始化 3、instance对象指向内存空间，执行完这步后instance为非空了。

但是jvm存在指令重排序的优化，如果指令按照1，3，2的执行方式，但是线程1在执行3之后，但未执行2之前，此时instance已经不为null了，这时候线程2调用getInstance（）方法（注意这时线程2可以调拥这个方法，因为只有进入一重检查锁之后才是临界区。）执行第一重判断if(instance == null){，此时instance不为null，直接调用return instance语句返回对象，但对象并没有真正得实例化完毕，调用就会出现错误
</code></pre><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<p>有些人认为使用 volatile 的原因是<strong>可见性</strong>，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：<strong>禁止指令重排序优化</strong>。也就是说，在 volatile 变量的<strong>赋值操作后面会有一个内存屏障</strong>（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，<strong>读操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</strong>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>方法三（最优）：静态内部类中保持对象的实例，在第一次调用的时候创建单例对象</p>
<pre><code>private static class Hold{
    private static final Singleton instance = new Singleton();
}
private Singleton(){}

public static Singleton getInstance(){
    return Hold.inistance;
}
</code></pre><p>饿汉式和懒汉式对比：饿汉式在类加载的时候创建，不管用不用，都占据内存；懒汉式在第一次使用的时候创建，必须加锁，多线程时性能受影响</p>
<h3 id="集中式工厂——简单工厂模式"><a href="#集中式工厂——简单工厂模式" class="headerlink" title="集中式工厂——简单工厂模式"></a>集中式工厂——简单工厂模式</h3><p>定义<strong>产品接口</strong>，<strong>抽象产品类</strong>实现接口，加入一些共有方法和抽象方法，<strong>具体产品</strong>类继承抽象产品类，实现方法</p>
<p>工厂类包括一个<strong>静态的getProduct方法，参数为具体产品名，返回值为产品接口</strong>，根据传入的产品名，返回不同的具体产品类</p>
<p>调用方法:</p>
<pre><code>Product a = Factory.getInstance(&quot;A&quot;);
Product b = Factory.getInstance(&quot;B&quot;);
</code></pre><p>缺点：增加一个新的产品时必须修改工厂类</p>
<h3 id="多台工厂——工厂方法模式"><a href="#多台工厂——工厂方法模式" class="headerlink" title="多台工厂——工厂方法模式"></a>多台工厂——工厂方法模式</h3><p>定义<strong>产品接口</strong>，<strong>抽象产品类</strong>实现接口，加入一些共有方法和抽象方法，<strong>具体产品</strong>类继承抽象产品类，实现方法</p>
<p>定义工厂接口，有个一getInstance方法。<strong>对于每一个具体的产品，都对应一个具体的工厂类</strong>，重新getInstance方法中实例化具体产品</p>
<p>调用方法：</p>
<pre><code>Factory factory = new AFactory();
ProductA = (ProductA)factory.getInstance();
</code></pre><p>缺点：每个工厂只生产一种产品，工厂类太多</p>
<h3 id="产品族的创建——抽象工厂"><a href="#产品族的创建——抽象工厂" class="headerlink" title="产品族的创建——抽象工厂"></a>产品族的创建——抽象工厂</h3><p>相关的产品组成一个”产品族”，由同一个工厂来统一生产</p>
<p>1、工厂方法中有多个方法，用来创建不同的产品</p>
<pre><code>public interfact Factory{
    ProductA createA();
    ProductB createB();
}
</code></pre><p>2、对于一个产品族，对应一个具体的工厂方法</p>
<pre><code>class SpringFactory implements Factory{
    ProductA createA(){return new SpringProductA();}
    ProductB createB(){return new SpringProductB();}
}

class SummerFactory implements Factory{
    ProductA createA(){return new SummerProductA();}
    ProductB createB(){return new SummerProductB();}
}
</code></pre><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>n客户端通过一个<strong>统一的外观角色</strong>与子系统进行通信，降低客户端的使用难度</p>
<p>外观类接收客户端的请求，并将请求委派到相应的子系统中处理，最终返回结果</p>
<p>具体实现：外观类中保持自己子系统的</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h2 id="Linux命令："><a href="#Linux命令：" class="headerlink" title="Linux命令："></a>Linux命令：</h2><p>wget  要下载文件的url<br>tail 查看日志<br>tar -zxvf 解压<br>zip xx 压缩</p>
<p>mount  挂载<br>unmount 卸载</p>
<p>make 根据makefile进行编译<br>make install 根据makefile进行安装</p>
<p>rpm 查看软件</p>
<p>yum install 安装软件</p>
<p>mkdir 建立文件夹<br>rmdir 删除空文件<br>rm -rf 删除文件夹</p>
<p>mv 移动<br>cp 复制</p>
<p>netstat -anp | grep 8080 查询端口</p>
<p>sudo 命令/ sudo su #管理员权限</p>
<p>service mysqld start 启动mysql数据库<br>service mysqld stop 停止</p>
<p>ps -aux 进程列表<br>kill -9 pid 杀进程</p>
<p>权限：<br>chmod 777 文件名 #！！！！！！！！！！<br>chown 用户名 文件名 #修改文件所有者<br>chgrp 组名 文件名 #修改文件所有组</p>
<p>/etc/profile #系统整体配置文件</p>
<p>df 系统分区情况</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库优化方案"><a href="#数据库优化方案" class="headerlink" title="数据库优化方案"></a>数据库优化方案</h3><p>单机：<br>（单从数据库本身）<br>Mysql换成Oracle，因为Oracle具有更大的存储空间，更安全，稳定<br>表优化：大表变小表，分库分表</p>
<p>（数据库之上）<br>读写分离：主从数据库</p>
<p>数据库连接池</p>
<p>（引入缓存）<br>缓存</p>
<p>分布式<br>集群+负载均衡：mysql集群、数据库操作中间件、redis集群</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>连接池的作用：</p>
<ul>
<li>用户请求一次查询的时候就会向数据库发起一次连接，执行完后就断开连接，而创建连接、释放连接都很耗费资源和时间，<strong>数据库的连接资源并没有得到很好的重复利用</strong>。使用连接池后直接从连接池中获取已经创建的连接，使用完之后放回连接池中</li>
<li>如果有很多用户同时在线，开发者不好控制数据库的连接数，很有可能因为分配的连接过多而导致内存耗尽。使用连接池可以控制最小连接数、最大连接数，可以根据连接的使用率进行增大或减少</li>
</ul>
<h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>Mysql中MyISAM引擎和InnoDB引擎的比较</p>
<ul>
<li>事务：InnoDB类型支持事务等高级处理，MyISAM不支持</li>
<li>并发：在执行数据库写入的操作（insert,update,delete）的时候，mysiam表会锁表，而innodb表会锁行</li>
<li>查询速度：MyISAM记录行数</li>
</ul>
<p>选择：</p>
<ul>
<li>MyISAM适合：(1)做很多count 的计算；(2)<strong>插入不频繁，查询非常频繁</strong>；(3)没有事务。</li>
<li>InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)<strong>表更新和查询都相当的频繁</strong>，并且表锁定的机会比较大的情况。</li>
</ul>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解作用：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li><strong>编译</strong>检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如<strong>动态生成代码</strong>。</li>
<li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如<strong>使用反射注入实例</strong>。</li>
</ul>
<p>元注释：</p>
<p>@Retention用于标明注解被保留的阶段</p>
<ul>
<li>SOURCE：被编译器丢弃 ——&gt; 编译检查、生成doc文档</li>
<li>CLASS：被编译器写入class文件中，但虚拟机无法获取到 ——&gt; 动态生成代码</li>
<li>RUNTIME：被编译器写入class文件中，运行时通过反射访问 ——&gt; 依赖注入</li>
</ul>
<p>@Target用于标明注解使用的范围</p>
<ul>
<li>TYPE：类、接口、枚举</li>
<li>FLED：成员变量</li>
<li>METHOD：方法</li>
<li>PARAMETER：方法参数</li>
<li>CONSTRUCTOR：构造器</li>
<li>LOCAL_VARIABLE：局部变量</li>
<li>ANNOTATION_TYPE：注解类型</li>
<li>PACKAGE：包</li>
</ul>
<p>@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</p>
<p>注解原理：</p>
<p>1、注解是在编译时由<strong>编译器</strong>进行处理，编译器会对注解符号处理并附加到<strong>class</strong>结构中<br>2、通过反射方法 Class.getAnnotation(Test.class) 获取到 Test 注解对象，进而再通过Test注解对象获取到Test里面的属性值</p>
<pre><code>Test.java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
    String value();
}

Main.java
@Test(value = &quot;qm&quot;)
public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&lt;?&gt; clazz = Class.forName(&quot;Annotation.Main&quot;);
        Test annotation = clazz.getAnnotation(Test.class);
        System.out.println(annotation.value());
    }
}
</code></pre><p>注解对象是什么？<br>其实注解被编译后的<strong>本质就是一个继承 Annotation 接口的接口</strong>，所以@Test其实就是”public interface Test extends Annotation”，当我们通过AnnotationTest.class.getAnnotation(Test.class)调用时，<strong>JDK会通过动态代理生成一个实现了Test接口的对象，并把将RuntimeVisibleAnnotations属性值设置进此对象中</strong>，此对象即为Test注解对象，通过它的value()方法就可以获取到注解值。</p>
<h3 id="Java中static作用"><a href="#Java中static作用" class="headerlink" title="Java中static作用"></a>Java中static作用</h3><p>static表示”全局”或者”静态”的意思，用来修饰<strong>成员变量</strong>和<strong>成员方法</strong>，也可以形成静态<strong>static代码块</strong>，但是Java语言中没有全局变量的概念</p>
<p>被static修饰的成员变量和成员方法<strong>独立于该类的任何对象，被类的所有实例共享</strong>。</p>
<p><strong>public修饰的static成员变量和成员方法本质是全局变量和全局方法</strong>，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>static变量前可以有<strong>private修饰</strong>，表示这个变量可以在<strong>类的静态代码块中，或者类的其他静态成员方法中使用</strong>（当然也可以在非静态成员方法中使用–废话），但是<strong>不能在其他类中通过类名来直接引用</strong>，这一点很重要</p>
<p>总结：</p>
<ul>
<li>static表示静态的，修饰变量、方法后叫做静态变量和静态方法，<strong>在加载类的过程中完成静态变量的内存分配</strong>，为所有对象所共有，通过类直接方法</li>
<li>static块在类加载的时候执行      </li>
</ul>
<h2 id="HashMap底层"><a href="#HashMap底层" class="headerlink" title="HashMap底层"></a>HashMap底层</h2><p><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p>
<p>定义：</p>
<pre><code>基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。
</code></pre><p>记忆：定义（Map接口）、特点（无序、null）、线程同步（非同步）</p>
<p>两个重要的参数：容量(Capacity)和负载因子(Load factor)</p>
<pre><code>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。
</code></pre><p>记忆：容量（桶的数量）、负载因子（衡量桶装满程度，当桶中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍）</p>
<p>put函数的实现：</p>
<pre><code>对key的hashCode()做hash，然后再计算index;
如果没碰撞（数组上的值为null）直接放到bucket里；
如果碰撞了，以链表的形式存在buckets后；
如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
如果节点已经存在就替换old value(保证key的唯一性)
如果bucket的容量超过阈值(超过capacity * loadFactor)，就要resize。
</code></pre><p>记忆：1、key做hash计算数组下标，2、是否碰撞（不碰撞，直接放入篮子；否则以链表形式放入篮子），3、如果碰撞导致链表长度过长，就把链表转成红黑树；4、如果节点存在则替换（key相等，替换值），5、如果bucket满了则resize</p>
<p>get函数的实现：</p>
<p>bucket里的第一个节点，直接命中；<br>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为<strong>树</strong>，则在树中通过key.equals(k)查找，O(logn)；<br>若为<strong>链表</strong>，则在链表中通过key.equals(k)查找，O(n)。</p>
<p>hash函数的实现：</p>
<p>高16bit不变，低16bit和高16bit做了一个异或</p>
<p>获取桶下标：<br>table长度n为2的幂，h&amp;(length - 1)相当于直接取模</p>
<p>如何解决频繁碰撞：<br>首先在获取HashMap的元素时，基本分两步：1、首先根据hashCode()做hash，然后确定bucket的index；2、如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</p>
<p>在Java 8之前的实现中是用链表解决冲突的，在Java 8中，利用红黑树替换链表</p>
<p>扩容：<br>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成”原索引+oldCap”</p>
<h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>1、<strong>Thread中有一个ThreadLocalMap属性，存放线程局部变量</strong>，是键值对的存储方式，以ThreadLocal对象为键，要保存的变量为值（ThreadLocalMap.Entry是保存键值对的对象）</p>
<p>2、<font color="red"><strong>ThreadLocal可以看做是ThreadLocalMap的操作类</strong></font>，在当前线程中通过ThreadLocal的set/get操作，对当前线程中的ThreadLocalMap进行操作</p>
<ul>
<li>set方法：首先获取当前线程的ThreadLocalMap的引用，然后以ThreadLocal实例作为key，保存的变量为value，保存到当前线程的ThreadLocalMap中</li>
<li>get方法：以当前ThreadLocal实例作为key，取出当前线程的ThreadLocalMap变量中该key的值</li>
</ul>
<p>3、<strong>每个线程都拥有自己的ThreadLocalMap属性，每个线程都是从自己的ThreadLocalMap中取值，所以互不影响</strong></p>
<p>4、作用：可以实现线程范围内的单例、线程范围内数据共享</p>
<h2 id="hashCode-和equals-区别和作用"><a href="#hashCode-和equals-区别和作用" class="headerlink" title="hashCode() 和equals() 区别和作用"></a>hashCode() 和equals() 区别和作用</h2><p>规范1：如果两个对象相同，那么他们的hashcode必须相等<br>规范2：如果两个对象不相同，他们的hashcode可能相同</p>
<p>这样我们就可以推断Java运行时环境是怎样判断HashSet和HastMap中的两个对象相同或不同了。我的推断是：<strong>先判断hashcode是否相等，再判断是否equals。 </strong></p>
<h2 id="数据库中char-varchar-nvarchar的差异"><a href="#数据库中char-varchar-nvarchar的差异" class="headerlink" title="数据库中char, varchar, nvarchar的差异"></a>数据库中char, varchar, nvarchar的差异</h2><p>char固定字符，varchar可变字符（根据实际所占的空间，char浪费空间，但效率略高）</p>
<p>varchar：按字节存储数据<br>nvarchar：按字符存储数据（如果用nvchar存储英文，会造成空间浪费）</p>
<ol>
<li>char和varchar的性能差距是很小的，可以考虑忽略不计。</li>
<li>在大数据量应用中，使用char和nvarchar有可能导致大量的存储空间的浪费。</li>
<li><strong>建议实际中用varvhar</strong></li>
</ol>
<h2 id="mysql中int、bigint、smallint-和-tinyint的区别与长度的含义"><a href="#mysql中int、bigint、smallint-和-tinyint的区别与长度的含义" class="headerlink" title="mysql中int、bigint、smallint 和 tinyint的区别与长度的含义"></a>mysql中int、bigint、smallint 和 tinyint的区别与长度的含义</h2><p>bigint<br>从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。</p>
<p>P.S. bigint已经有长度了，在mysql建表中的length，只是用于显示的位数</p>
<p>int<br>从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。</p>
<p>smallint<br>从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据。存储大小为 2 个字节。</p>
<p>tinyint<br>从 0 到 255 的整型数据。存储大小为 1 字节。</p>
<h2 id="分析MySQL数据类型的长度"><a href="#分析MySQL数据类型的长度" class="headerlink" title="分析MySQL数据类型的长度"></a>分析MySQL数据类型的长度</h2><p>（1）CHAR、VARCAHR的长度是指字符的长度，例如CHAR[3]则只能放字符串”123”，如果插入数据”1234”，则从高位截取，变为”123”。 VARCAHR同理。<br>（2）TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT的长度，其实和数据的大小无关！Length指的是显示宽度，举个例子：</p>
<h2 id="普通数组和ArrayList的差别"><a href="#普通数组和ArrayList的差别" class="headerlink" title="普通数组和ArrayList的差别"></a>普通数组和ArrayList的差别</h2><p>动态数组、get/set等一系列方法、基本类型/引用类型、泛型</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>Java的动态绑定又称为运行时绑定。意思就是说，<strong>程序会在运行的时候自动选择调用哪个方法。</strong>（重载）</p>
<h2 id="RESTFUL-API"><a href="#RESTFUL-API" class="headerlink" title="RESTFUL API"></a>RESTFUL API</h2><p>1、url代表一个资源<br>2、http的get/post/update/delete 表示对资源的操作，<strong>进行状态转换</strong><br>3、文本类型：xml、json进行数据传递</p>
<h2 id="StringBuilder，StringBuffer"><a href="#StringBuilder，StringBuffer" class="headerlink" title="StringBuilder，StringBuffer"></a>StringBuilder，StringBuffer</h2><p>都是字符串操作类，StringBuilder非线程安全，适合在单线程的情况下使用，效率比较高；StringBuffer是线程安全的，适合在多线程条件下使用，效率略低</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><h2 id="判断对象是否相等"><a href="#判断对象是否相等" class="headerlink" title="判断对象是否相等"></a>判断对象是否相等</h2><p>推荐使用java.util.Objects#equals （JDK7引入的工具类）</p>
<pre><code>public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null &amp;&amp; a.equals(b));
}
</code></pre><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器的作用是把类的字节码文件加载进内存中</p>
<p>类加载器的层次关系：Bootstrap、ExtClassLoader、AppClassLoader、用户自定义的类加载器</p>
<p>类加载器的委托机制：</p>
<p>1、当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢?<br>　　①首先 当前线程的类加载器 去加载线程中的第一个类.<br>　　②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B<br>　　③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类.</p>
<p>2、每个类加载器加载类时，又先<strong>委托给其上级类加载器</strong><br>　　当所有祖宗类加载器没有加载到类，回到发起者类加载器，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。</p>
<h3 id="ArrayList和LinkedList和Vector"><a href="#ArrayList和LinkedList和Vector" class="headerlink" title="ArrayList和LinkedList和Vector"></a>ArrayList和LinkedList和Vector</h3><p>1、ArrayList是实现了基于<strong>动态数组</strong>的数据结构，LinkedList基于<strong>链表</strong>的数据结构<br>2、对于<strong>随机访问</strong>get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针<br>3、对于<strong>新增和删除</strong>操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</p>
<p>Vector和ArrayList几乎是完全相同的，唯一的区别在于<strong>Vector是同步类</strong>(synchronized).因此,开销就比ArrayList要大.正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制</p>
<h3 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h3><p><img src="http://i.imgur.com/38sa06k.png" alt=""></p>
<p>1、历史原因</p>
<p>Hashtable是基于陈旧的<strong>Dictionary</strong>类的，HashMap是java 1.2引进的Map接口的一个实现</p>
<p>2、同步性</p>
<p>Hashtable是线程同步的。这个类中的一些方法保证了Hashtable中的对象是线程安全的（Synchronized）。而HashMap则是线程异步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率</p>
<p>3、值</p>
<p>HashMap可以让你将<strong>空值</strong>作为一个表的条目的key或value但是Hashtable是不能放入空值的(null)</p>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><p><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">http://zhangshixi.iteye.com/blog/672697</a></p>
<p>HashMap是基于哈希表的Map接口的<strong>非同步</strong>实现。此实现提供所有可选的映射操作，并允许<strong>使用null值和null键</strong>。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap的数据结构：</p>
<p>在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体。</p>
<p><img src="http://i.imgur.com/rdtyB5M.jpg" alt=""></p>
<p>从上图中可以看出，<strong>HashMap底层就是一个数组结构，数组中的每一项又是一个链表，链表的每一个元素是键-值对</strong>。当新建一个HashMap的时候，就会初始化一个数组。</p>
<pre><code>transient Entry[] table;  

static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {  
    final K key;  
    V value;  
    Entry&lt;K,V&gt; next;  
    final int hash;  
    ……  
}  
</code></pre><p>可以看出，Entry就是数组中的元素，<strong>每个 Map.Entry 其实就是一个key-value对</strong>，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<p>HashMap的存取实现：</p>
<p>1) 存储：</p>
<pre><code>public V put(K key, V value) {  
    // HashMap允许存放null键和null值。  
    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  
    if (key == null)  
        return putForNullKey(value);  
    // 根据key的keyCode重新计算hash值。  
    int hash = hash(key.hashCode());  
    // 搜索指定hash值在对应table中的索引。  
    int i = indexFor(hash, table.length);  
    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。  
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {  
        Object k;  
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  
            V oldValue = e.value;  
            e.value = value;  
            e.recordAccess(this);  
            return oldValue;  
        }  
    }  
    // 如果i索引处的Entry为null，表明此处还没有Entry。  
    modCount++;  
    // 将key、value添加到i索引处。  
    addEntry(hash, key, value, i);  
    return null;  
}  
</code></pre><p>从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>1、必须针对接口进行代理<br>2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类<br>3、自己实现InvocationHandler 接口</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>1、thread与runnable</p>
<p>如果改写thread的run方法和传入runnable类，使用的是那个run？</p>
<p>Thread的run方法，如果runnable对象不为空，去执行runnable中的run方法，但是如果Thread的run方法被重写，则使用改写的Thread中的run方法</p>
<pre><code>public void run() {
    if (target != null) {
        target.run();
    }
}
</code></pre><p>2、synchronized，使用的对象锁必须<strong>同一个对象</strong>，可以this或字符串常量</p>
<pre><code>Synchronized(){
    //保护一段代码
}
</code></pre><p>也可以修饰方法，来保护整个方法（默认对象锁是this）</p>
<p>如果修饰静态方法，静态对象对应的对象锁是<strong>类的字节码</strong></p>
<h3 id="Spring-MVC-和-Struts2的区别"><a href="#Spring-MVC-和-Struts2的区别" class="headerlink" title="Spring MVC 和 Struts2的区别"></a>Spring MVC 和 Struts2的区别</h3><ul>
<li>Struts2的入口是filter，Spring MVC的入口是Servlet，两者的实现机制不同</li>
<li>Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用；Spring MVC是基于方法设计的，参数绑定到方法的形参，并且只有一个方法可以使用</li>
<li>Struts2必须是多例的（Struts2传递到的参数绑定到类的属性，如果是单例会导致不同用户数据的冲突），Spring MVC默认是单例的，所以Spring MVC的性能比Struts2好</li>
</ul>
<h3 id="重定向与转发的区别"><a href="#重定向与转发的区别" class="headerlink" title="重定向与转发的区别"></a>重定向与转发的区别</h3><ul>
<li>浏览器中的url：转发仍是原来的url，重定向为新的url</li>
<li>重定向发生在浏览器，由浏览器重新发出http请求，转发发生web服务器，请求在web服务器转发</li>
<li>重定向可以到外部网站，重定向只能访问WEB应用个资源</li>
</ul>
<h3 id="Sesssion"><a href="#Sesssion" class="headerlink" title="Sesssion"></a>Sesssion</h3><p><strong>Session的生命周期</strong></p>
<p>Session存储在服务器端，一般为了防止在服务器的内存中（为了高速存取），<strong>Sessinon在用户访问第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session</strong>，只访问HTML、IMAGE等静态资源并不会创建Session，可调用<strong>request.getSession(true)强制生成Session</strong></p>
<p><strong>Session什么时候失效？</strong></p>
<p>1、服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为30分钟。<br>2、调用Session的invalidate方法。</p>
<h3 id="分布式Session同步"><a href="#分布式Session同步" class="headerlink" title="分布式Session同步"></a>分布式Session同步</h3><p>1、cookie存储方式。把session数据做加密，然后存储到cookie中。用户请求到了，就直接从cookie读取，然后做解密。这种方式真是把分布式思想发挥到了一个相当的高度。他把用户也当做分布式的一员，你要访问数据，那你就自己携带着他，每次到服务器的时候，我们的服务器就只负责解密……</p>
<p>对于session里只存放小数据，并且加密做的比较好（防止碰撞做暴力破解）的系统来讲，这是一个比较好的选择。他实现超级简单，而且不用考虑数据的同步。</p>
<p>不过如果要往session里存放大数据的情况就不是太好处理。或者安全性要求很高的系统，也不是太好的一个方式（数据有被破解的风险）</p>
<p>2、cache集群或者数据库做session管理。我们也可以采用另外一种架构来解决session同步问题，那就是引入统一session接入点。</p>
<p><img src="http://i.imgur.com/lcc3GzV.png" alt=""></p>
<p><strong>把session放入到cache集群或者数据库中，每次请求的时候，都从他们中来获取。</strong>这样，所有的机器都能获取到最新的session数据。<strong>这种方案也是很多中大型网站采用的解决方案</strong>。他实现起来相对简单（<strong>利用cache集群或者主从数据库自身的管理来实现多机的互备</strong>），而且效率很高，安全性也不错。</p>
<p>3、还有一种方式是从上面这种方式延展出来的，就是<strong>提供session服务</strong>。这个服务负责管理session，其他服务器每次从这个服务处获取session数据，从而达到数据的共享。</p>
<p><img src="http://i.imgur.com/XrcI3pE.png" alt=""></p>
<p>这种方式的好处就在于：</p>
<p>A、可以非常<strong>方便的扩展</strong>用户登录的数量以及存储数据的大小。当时在x度的时候，N亿用户的session都在这个系统里进行管理；</p>
<p>B、<strong>方便做性能优化</strong>。如果用cache集群的方案，如果cache有机器坏掉，那么就会造成一部分用户session失效；如果用数据库方案，如果量太大，有可能会出现性能问题。而这种方案在实现的时候，可以<strong>用cache和数据库结合的实现方式，保证高效和稳定</strong>。同时，针对一些接口，可以做性能的优化，提升查询效率；</p>
<p>C、<strong>对外封闭，保证数据安全</strong>。这种方式还有一个好处，就是可以将加密算法、密钥等封闭在系统内部，对外只暴露接口，使得数据安全性更有保障。（涉及到用户信息的，都是隐私！）</p>
<p>不过，这种方式也有自己的问题，就是运维相对更复杂，有可能需要专门的团队去管理这些系统。</p>
<p>参考：<a href="http://blog.csdn.net/zgwangbo/article/details/51636721" target="_blank" rel="external">http://blog.csdn.net/zgwangbo/article/details/51636721</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>DNS负载均衡<br>反向代理负载均衡<br>IP负载均衡</p>
<p><a href="http://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="external">http://www.cnblogs.com/itfly8/p/5043435.html</a><br><a href="http://lobert.iteye.com/blog/2159970" target="_blank" rel="external">http://lobert.iteye.com/blog/2159970</a></p>
<h3 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h3><p>详细见 Java - ConcurrentHashmap</p>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ul>
<li>用分离锁实现多个线程间的更深层次的共享访问。（Segment继承重入锁，并且管理一定范围的数组）</li>
<li><strong>用 HashEntery 对象的不变性</strong>来降低执行读操作的线程在遍历链表期间对加锁的需求。（就是说当需要对链表结构进行改变时，对链表进行复制，先不更改原来的链表，然后操作完成之后再把table切换过去，在put/remove中体现）</li>
<li>通过对同一个 <strong>Volatile</strong> 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ul>
<p>put/get：1、key存在：value是volatile保证可见，并且写在读之前 2、key不存在，需要插入：头插法，不影响读线程的遍历<br>remove/get：删除节点后面的不变，删除节点的前面节点头插法，复制完之后切换table，不影响读线程的遍历<br>clear/get：将table的置空，读线程仍可以访问原来的链表</p>
<font color="red"><strong>get：</strong></font>

<p>1、<font color="red"><strong>首先HashEntry对象必须用volatile修饰，否则可能会出现返回结果不为null，但是对象不可用</strong></font>；原因和双重检查锁定时必须将实例设为volatile一样，查看ConcurrentHashMap文章或设计模式的艺术之道笔记</p>
<p>2、如果的得到结果不为null，直接返回<br>3、如果得到的结果为null，1、可能对象不存在 2、对象刚被put线程放进去，写线程的确获取不到，读的是脏数据 =&gt; 这两种情况返回节点都指向table，如果查询的结果的确是刚插入的元素，释放锁后就能得到刚插入的结果，否则还是返回null</p>
<p>另一个考点：</p>
<p>ConcurrentHashMap的key和value不能为null</p>
<h3 id="happen-before"><a href="#happen-before" class="headerlink" title="happen before"></a>happen before</h3><p>① <strong>程序次序法则</strong>：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。<br>② <strong>监视器锁法则</strong>：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。<br>③ volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong><br>④ 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。<br>⑤ 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。<br>⑥ 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。<br>⑦ 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。<br>⑧ <strong>传递性</strong>：如果A happens-before于B，且B happens-before于C，则A happens-before于C</p>
<p><strong>我们重点关注的是②，③，这两条也是我们通常编程中常用的。</strong></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>作用：</p>
<p>1、可见性：共享变量直接在主存操作，保证可见性<br>2、禁止指令重排：对变量进行写操作后，会产生一个内存栅栏，保证读操作必须在写操作之后，且写操作对读操作可见</p>
<p>应用：</p>
<p>1、单线程写，多线程读<br>2、多线程写，但是写入的值不依赖于原值</p>
<p>为什么用volatile修饰，多线程i++的时候计数失败？</p>
<p>i++不是原子操作，分为三步：1、读取 2、修改 3、写入</p>
<p>volatile 操作保证读操作在写操作之后，如果按以下操作：</p>
<pre><code>1、读取  2、读取 1、修改 1、写入
</code></pre><p>即多线程会对共享变量进行多次读，造成脏读；如果多线程写入不依赖原值，那么volatile可以保持同步</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h3 id="wait和sleep的区别-释放锁"><a href="#wait和sleep的区别-释放锁" class="headerlink" title="wait和sleep的区别(释放锁)"></a>wait和sleep的区别(释放锁)</h3><h2 id="A类B类C类IP地址"><a href="#A类B类C类IP地址" class="headerlink" title="A类B类C类IP地址"></a>A类B类C类IP地址</h2><p><img src="http://img.blog.csdn.net/20151224190309198" alt="这里写图片描述"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/07/17/[Redis]Redis底层数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/17/[Redis]Redis底层数据结构/" itemprop="url">Redis底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T21:45:00+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis单进程单线程执行速度快的原因"><a href="#Redis单进程单线程执行速度快的原因" class="headerlink" title="Redis单进程单线程执行速度快的原因"></a>Redis单进程单线程执行速度快的原因</h2><p>总体来说快速的原因如下：</p>
<p>1）绝大部分请求是纯粹的内存操作（非常快速）<br>2）采用单线程,避免了不必要的上下文切换和竞争条件<br>3）非阻塞IO</p>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间    </p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p>首先，Redis没有MySQL那样的索引机制，因为其内建一个基于hash的字典，如下图：</p>
<p><img src="http://i.imgur.com/u4CAMEI.jpg" alt=""></p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<p># 使用字典设置的哈希函数，计算键 key 的哈希值<br>hash = dict-&gt;type-&gt;hashFunction(key);</p>
<p># 使用哈希表的 sizemask 属性和哈希值，计算出索引值<br># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]<br>index = hash &amp; dict-&gt;ht[x].sizemask;<br>插入数据时，根据以上算出index，然后根据index值放入table表中相应位置即可。</p>
<p><strong>QM注释：</strong><br>1、每个dictht为一个map结构，字典dict中有两个map<br>2、map为key、value的结构，value可以为各种数据类型，包括字符串、链表…</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>例如：Set hello world </p>
<p><img src="http://i.imgur.com/cb0jdYP.png" alt=""></p>
<p>字符串类似Java中的String对象，存储类似HashMap，key为字符串的名字，value为String对象</p>
<h3 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h3><p>例如：Lpush list aaaa bbb ccc</p>
<p><img src="http://i.imgur.com/kGPk6LE.png" alt=""></p>
<pre><code>// 双向链表
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

//数据结构 + 操作
typedef struct list {
    listNode *head;
    listNode *tail;
    ...
} list;
</code></pre><p>链表类似Java中的LinkedList，定义每个链表时取一个名称；存储类似HashMap，key为链表的名称，value为list对象</p>
<h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>例如：Hset test hello world</p>
<p><img src="http://i.imgur.com/udIIoGc.png" alt=""></p>
<p>存储类似HashMap，key为hash表的名称，value为hash表</p>
<p>注：新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现（一个key对应一个hash表）。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合，常用来存储不重复数据的数据结构，底层基于hashtable；在redis中为了优化存储，set的编码类型可以为：intset，hashtable。</p>
<h3 id="Sorted-Set-ZSet"><a href="#Sorted-Set-ZSet" class="headerlink" title="Sorted Set(ZSet)"></a>Sorted Set(ZSet)</h3><p>链表+跳跃表</p>
<p><a href="https://mp.weixin.qq.com/s/RDHebf6IfLWfw38dPvfiZQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/RDHebf6IfLWfw38dPvfiZQ</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/renzherushe/p/4779390.html" target="_blank" rel="external">http://www.cnblogs.com/renzherushe/p/4779390.html</a></p>
<h2 id="Redis过期检测"><a href="#Redis过期检测" class="headerlink" title="Redis过期检测"></a>Redis过期检测</h2><p>Redis对于过期检测，有2种方式，一个主动检测，一个是被动检测；在redis和client交互过程中，对于任何数据的操作，都会首先检测key是否已经过期，这是被动检测；主动检测是Redis启动的后台线程中，不间断的随机扫描一定量的key（randomKey），并对key进行过期检测</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/29/[JDK源码阅读]LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/[JDK源码阅读]LinkedHashMap/" itemprop="url">LinkedHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T14:00:00+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JDK源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">JDK源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>1、Entry节点增加了after、before两个指针，组成双向链表，记录节点插入顺序</p>
<pre><code>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
}
</code></pre><p>2、LinkedHashMap保存头节点指针，插入的方式都采用头插法，因为是双向链表，可以轻易插在头部和尾部</p>
<pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
{
    private transient Entry&lt;K,V&gt; header;
}
</code></pre><p>3、LinkHashMap有一个成员变量accessOrder，表示链表的保存顺序，默认是false，按照插入顺序保存。</p>
<pre><code>private final boolean accessOrder;
</code></pre><p><strong>注意：</strong>因为插入时采用的是头插法，所以链表的存储顺序是逆序的，<strong>即先插入的在尾部</strong>，但是迭代器在遍历的时候从尾到头的顺序，所以不影响</p>
<p>如果想实现LRU的方式，按照访问顺序的方式存储节点，构造LinkedHashMap的时候accessOrder设为true</p>
<pre><code>public LinkedHashMap(int initialCapacity,
         float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
</code></pre><h2 id="源码关键"><a href="#源码关键" class="headerlink" title="源码关键"></a>源码关键</h2><pre><code>//LinkedHashMap方法
public V get(Object key) {
    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);
    if (e == null)
        return null;
    e.recordAccess(this);
    return e.value;
}

//HashMap方法
public V put(K key, V value) {
    if (key == null)
    return putForNullKey(value);
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
</code></pre><p>1、<font color="red"><strong>当调用get或者put方法的时候，如果K-V已经存在，会回调Entry.recordAccess()方法</strong></font></p>
<p>当 accessOrder 为 true，即按LRU的策略存储，会先调用 remove 清除的当前首尾元素的指向关系，之后调用addBefore方法，<strong>将当前元素加入header之前。</strong></p>
<pre><code>/**
 * This method is invoked by the superclass whenever the value
 * of a pre-existing entry is read by Map.get or modified by Map.set.
 * If the enclosing Map is access-ordered, it moves the entry
 * to the end of the list; otherwise, it does nothing. 
 */
void recordAccess(HashMap&lt;K,V&gt; m) {
    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;
    if (lm.accessOrder) {
        lm.modCount++;
        remove();
        addBefore(lm.header);
    }
}

/**
 * Remove this entry from the linked list.
 */
private void remove() {
    before.after = after;
    after.before = before;
}

/**                                             
 * Insert this entry before the specified existing entry in the list.
 */
private void addBefore(Entry&lt;K,V&gt; existingEntry) {
    after  = existingEntry;
    before = existingEntry.before;
    before.after = this;
    after.before = this;
}
</code></pre><p>2、put操作时，如果key不存在，当有新元素加入 Ma p的时候会调用 Entry 的 addEntry 方法，<strong>会调用 removeEldestEntry 方法，这里就是实现LRU元素过期机制的地方</strong>，默认的情况下removeEldestEntry方法只返回false表示元素永远不过期。 </p>
<pre>
/**
 * This override alters behavior of superclass put method. It causes newly
 * allocated entry to get inserted at the end of the linked list and
 * removes the eldest entry if appropriate.
 */
void addEntry(int hash, K key, V value, int bucketIndex) {
    createEntry(hash, key, value, bucketIndex);

    // Remove eldest entry if instructed, else grow capacity if appropriate
    Entry<k,v> eldest = header.after;
    if (<font color="red">removeEldestEntry(eldest)</font>) {
        removeEntryForKey(eldest.key);
    } else {
        if (size >= threshold) 
            resize(2 * table.length);
    }
}

/**
 * This override differs from addEntry in that it doesn't resize the
 * table or remove the eldest entry.
 */
void createEntry(int hash, K key, V value, int bucketIndex) {
    HashMap.Entry<k,v> old = table[bucketIndex];
    Entry<k,v> e = new Entry<k,v>(hash, key, value, old);
    table[bucketIndex] = e;
    e.addBefore(header);
    size++;
}

protected boolean removeEldestEntry(Map.Entry<k,v> eldest) {
    <font color="red">return false;</font>
}
</k,v></k,v></k,v></k,v></k,v></pre>

<h2 id="实现LRU"><a href="#实现LRU" class="headerlink" title="实现LRU"></a>实现LRU</h2><p>LRU缓存LinkedHashMap(inheritance)实现</p>
<p>采用inheritance方式实现比较简单，而且实现了Map接口，在多线程环境使用时可以使用 <strong>Collections.synchronizedMap()</strong>方法实现线程安全操作</p>
<p>1、构造函数中调用父类的构造函数，accessOrder设置为true<br>2、重写removeEldestEntry，当元素数量大于缓存最大数量时，删除</p>
<pre>
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache2<k, v=""> extends LinkedHashMap<k, v=""> {

    private final int MAX_CACHE_SIZE;

    public LRUCache2(int cacheSize) {
        super ((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, <font color="red">true</font>);
        MAX_CACHE_SIZE = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        <font color="red">return size() > MAX_CACHE_SIZE;</font>
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<k, v=""> entry : entrySet()) {
            sb.append(String.format("%s:%s ", entry.getKey(), entry.getValue()));
        }       
        return sb.toString();
    }
}
</k,></k,></k,></pre>

<h2 id="实现FIFO"><a href="#实现FIFO" class="headerlink" title="实现FIFO"></a>实现FIFO</h2><p>1、只需重写removeEldestEntry就行，默认accessOrder就是false<br>2、重写removeEldestEntry方法，当缓存个数大于最大个数时，删除最先放进去的元素</p>
<pre><code>final int cacheSize = 5;
LinkedHashMap&lt;Integer, String&gt; lru = new LinkedHashMap&lt;Integer, String&gt;() {
    @Override   
    protected boolean removeEldestEntry(Map.Entry&lt;Integer, String&gt; eldest) {
        return size() &gt; cacheSize;
    }
};
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>LRU缓存实现(Java)</p>
<p><a href="http://transcoder.tradaquan.com/from=1086k/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%40320_1002%2Cta%40iphone_2_5.1_2_6.0/baiduid=99806F566512D4B5CD2F1444260EE0C9/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=7454783636244085594&amp;order=1&amp;fm=alop&amp;h5ad=1&amp;srd=1&amp;dict=32&amp;tj=www_normal_1_0_10_title&amp;url_mf_score=4&amp;vit=osres&amp;m=8&amp;cltj=cloud_title&amp;asres=1&amp;title=LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%28Java%29-%E6%87%92%E6%83%B0%E7%9A%84%E8%82%A5%E5%85%94-%E5%8D%9A%E5%AE%A2%E5%9B%AD&amp;w_qd=IlPT2AEptyoA_yitJU7mHiU5vhXPLqCyZhaDQ_&amp;sec=22108&amp;di=8c5570f1d6ae3a47&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAXinhMXmYGlGwdoSOxBt8w83c_79j7QwTaP1s&amp;clk_info=%7B%22srcid%22%3A%221599%22%2C%22tplname%22%3A%22www_normal%22%2C%22t%22%3A1498709801466%2C%22sig%22%3A%221646%22%2C%22xpath%22%3A%22div-a-h3%22%7D" target="_blank" rel="external">http://transcoder.tradaquan.com/from=1086k/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%40320_1002%2Cta%40iphone_2_5.1_2_6.0/baiduid=99806F566512D4B5CD2F1444260EE0C9/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=7454783636244085594&amp;order=1&amp;fm=alop&amp;h5ad=1&amp;srd=1&amp;dict=32&amp;tj=www_normal_1_0_10_title&amp;url_mf_score=4&amp;vit=osres&amp;m=8&amp;cltj=cloud_title&amp;asres=1&amp;title=LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%28Java%29-%E6%87%92%E6%83%B0%E7%9A%84%E8%82%A5%E5%85%94-%E5%8D%9A%E5%AE%A2%E5%9B%AD&amp;w_qd=IlPT2AEptyoA_yitJU7mHiU5vhXPLqCyZhaDQ_&amp;sec=22108&amp;di=8c5570f1d6ae3a47&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAXinhMXmYGlGwdoSOxBt8w83c_79j7QwTaP1s&amp;clk_info=%7B%22srcid%22%3A%221599%22%2C%22tplname%22%3A%22www_normal%22%2C%22t%22%3A1498709801466%2C%22sig%22%3A%221646%22%2C%22xpath%22%3A%22div-a-h3%22%7D</a></p>
<p>基于LinkedHashMap实现LRU缓存调度算法原理及应用</p>
<p><a href="http://woming66.iteye.com/blog/1284326" target="_blank" rel="external">http://woming66.iteye.com/blog/1284326</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]11、深度优先搜索、广度优先搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]11、深度优先搜索、广度优先搜索/" itemprop="url">11、深度优先搜索、广度优先搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:30:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迷宫问题（深度优先搜索解法）"><a href="#迷宫问题（深度优先搜索解法）" class="headerlink" title="迷宫问题（深度优先搜索解法）"></a>迷宫问题（深度优先搜索解法）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从（0，0）开始，目的地是（5，7），0表示可以走，1表示不可走，求所有路径</p>
<p><img src="http://i.imgur.com/ztTNOdD.jpg" alt=""></p>
<p>几个关键点：</p>
<p>1、深度优先模版</p>
<p>如果下一个路径没有越界，而且可以访问（数组中的值是0），那么继续在下一个节点上继续进行深度优先搜索</p>
<pre><code>public void DFS(int[][] map, Point current, Point start, Point end) {
    //遍历方向
    int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
    int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

    for (int i = 0; i &lt; x.length; i++) {
        Point next = new Point(current.x + x[i], current.y + y[i]);
        //剪枝
        if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                &amp;&amp; map[next.x][next.y] == 0) {
            DFS(map, next, start, end);
        }
    }
}
</code></pre><p>运行程序的时候发现一个问题，会出现<strong>相邻路径来回走</strong>，导致栈溢出，所以需要设置<strong>在当前遍历的路径中做上标记，在往前搜索的过程中不走回头路</strong></p>
<p>2、标记访问路径</p>
<p><img src="http://i.imgur.com/5LTdjLJ.jpg" alt=""></p>
<p>上图所示的就是来回走的一个案例，这个的解决方法就是在访问到节点后，设置标志位为1。</p>
<p>但是这会出现一个问题：如果这条路不通，换条路径访问的时候这个节点应该还是需要可以访问的，所以在这条路径回溯的时候，需要重新标注节点为未访问</p>
<p><strong>貌似标记的地方每次都是的DFS（）这个函数之前、之后</strong></p>
<pre><code>map[next.x][next.y] = 1;
DFS(map, next, start, end);
map[next.x][next.y] = 0;
</code></pre><p>3、记录路径</p>
<p>貌似每次也都是在DFS之前添加路径，在DFS之后删除路径</p>
<pre><code>path.add(next);
DFS(map, next, start, end);
path.remove(path.size() - 1);
</code></pre><p>4、</p>
<p>5、小技巧，防止起始点和终点被遍历到，初始化时将开头和结尾置为1</p>
<pre><code>int[][] map = {
        {0, 1, 0, 1, 0, 0, 0, 1},
        {1, 0, 0, 1, 1, 0, 1, 0},
        {0, 1, 1, 0, 0, 1, 1, 1},
        {1, 0, 0, 1, 1, 0, 0, 1},
        {1, 0, 0, 0, 1, 1, 0, 1},
        {0, 1, 1, 1, 0, 0, 0, 0}
};
map[0][0] = 1;
map[5][7] = 1;    
</code></pre><p>完整代码</p>
<pre><code>//current参数是重点，别的只是信息传递
public void DFS(int[][] map, Point current, Point start, Point end) {
    //遍历方向
    int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
    int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

    for (int i = 0; i &lt; x.length; i++) {
        Point next = new Point(current.x + x[i], current.y + y[i]);

        //找到了
        if (next.x == end.x &amp;&amp; next.y == end.y) {
            System.out.println(&quot;找到了：&quot; + ++count);
            System.out.println(path);
            continue;
        }

        //剪枝
        if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                &amp;&amp; map[next.x][next.y] == 0) {
            System.out.println(next);
            path.add(next);
            map[next.x][next.y] = 1;
            DFS(map, next, start, end);
            map[next.x][next.y] = 0;
            path.remove(path.size() - 1);
        }
    }
}

public static void main(String[] args) {
    int[][] map = {
            {0, 1, 0, 1, 0, 0, 0, 1},
            {1, 0, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 0, 0, 1, 1, 1},
            {1, 0, 0, 1, 1, 0, 0, 1},
            {1, 0, 0, 0, 1, 1, 0, 1},
            {0, 1, 1, 1, 0, 0, 0, 0}
    };
    Solution s = new Solution();
    //s.BFS(map, new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
    map[0][0] = 1;
    map[5][7] = 1;
    s.DFS(map, new Point(0, 0), new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
}
</code></pre><h2 id="迷宫问题（广度优先搜索解法）"><a href="#迷宫问题（广度优先搜索解法）" class="headerlink" title="迷宫问题（广度优先搜索解法）"></a>迷宫问题（广度优先搜索解法）</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]11、迷宫问题-最短路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]11、迷宫问题-最短路径/" itemprop="url">11、迷宫问题-最短路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:30:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从（0，0）开始，目的地是（5，7），0表示可以走，1表示不可走，要求最短路径</p>
<p><img src="http://i.imgur.com/ztTNOdD.jpg" alt=""></p>
<h2 id="几个重点"><a href="#几个重点" class="headerlink" title="几个重点"></a>几个重点</h2><p>0、广度优先搜索找到的是最短路径</p>
<p>上次提交的层次遍历就是广度优先搜索</p>
<pre><code>//层次遍历模版
Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
//将根元素放入队列
queue.offer(root);
while(!queue.isEmpty()){
    //从队头取出元素，并访问
    TreeNode node = queue.poll();
    result.add(node.val);
    //将左右节点放入队列
    if(node.left != null){
        queue.offer(node.left);
    }
    if(node.right != null){
        queue.offer(node.right);
    }
}
</code></pre><p>1、运行8个方向：上、右上、右、右下、下、左下、左、左上</p>
<pre><code>int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
int[] y = {1, 1, 0, -1, -1, -1, 0, 1};
</code></pre><p>2、记录已经访问过</p>
<p>0表示可以访问，访问之后变成1，这样每个点只被访问一下</p>
<p>3、如何记录路径</p>
<pre><code>Point[][] pre = new Point[map.length][map[0].length];
</code></pre><p>一个二维数组，（i，j）记录上一个路径</p>
<p>4、注意点：</p>
<p>开始节点访问之后，记得标注为1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

public class Solution {

    public void BFS(int[][] map, Point start, Point end) {
        //基于当前节点上一个路径
        Point[][] pre = new Point[map.length][map[0].length];
        pre[start.x][start.y] = start;
        //队列
        Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;();
        queue.offer(start);
        map[start.x][start.y] = 1;
        //遍历方向
        int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
        int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

        while (!queue.isEmpty()) {
            Point current = queue.poll();
            //8个方向遍历
            for (int i = 0; i &lt; x.length; i++) {
                //判断是否越界，是否已经访问
                Point next = new Point(current.x + x[i], current.y + y[i]);
                //达到目录
                if (next.x == end.x &amp;&amp; next.y == end.y) {
                    System.out.println(next);
                    for (Point t = current; current != pre[current.x][current.y]; current = pre[current.x][current.y]) {
                        System.out.println(current);
                    }
                    System.out.println(start);
                    return;
                }

                if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                        &amp;&amp; map[next.x][next.y] == 0) {//0表示可以访问
                    queue.offer(next);
                    map[next.x][next.y] = 1;//标记已经访问过了
                    pre[next.x][next.y] = current;//记录路径
                }
            }
        }
    }

    public static void main(String[] args) {
        int[][] map = {
                {0, 1, 0, 1, 0, 0, 0, 1},
                {1, 0, 0, 1, 1, 0, 1, 0},
                {0, 1, 1, 0, 0, 1, 1, 1},
                {1, 0, 0, 1, 1, 0, 0, 1},
                {1, 0, 0, 0, 1, 1, 0, 1},
                {0, 1, 1, 1, 0, 0, 0, 0}
        };
        Solution s = new Solution();
        s.BFS(map, new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return &quot;Point{&quot; +
                &quot;x=&quot; + x +
                &quot;, y=&quot; + y +
                &apos;}&apos;;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]10、全排列（DFS+剪枝）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]10、全排列（DFS+剪枝）/" itemprop="url">10、全排列（DFS+剪枝）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T09:17:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：全排列"><a href="#题目：全排列" class="headerlink" title="题目：全排列"></a>题目：全排列</h2><p>例如ABC，全排列的结果是ABC、ACB、BAC、BCA、CAB、CBA</p>
<h2 id="递归穷举"><a href="#递归穷举" class="headerlink" title="递归穷举"></a>递归穷举</h2><p>1、穷举，遍历出所有结果。因为对于长度为n的字符串，<strong>需要n层for循环，代码没法写</strong>，所以需要利用递归实现</p>
<pre><code>for(int i = 0; i &lt; str.length(); i++){
    for(int i = 0; i &lt; str.length(); i++){
        for(int i = 0; i &lt; str.length(); i++){
            .....长度为n的字符串需要写n个for，代码没法写了
        }
    }
}
</code></pre><p>写成递归的形式：</p>
<pre><code>public void DFS(int step) {

    //递归结束
    if(step &gt;= str.length()){
        return;
    }

    for (int i = 0; i &lt; str.length(); i++) {
        System.out.println(str.charAt(i));
        DFS(step + 1);//进去都是for循环，和多个嵌套for一样，要注意结束点
    }
}
</code></pre><p>遍历结果：</p>
<p>a、a、a、b、c、b、a、b、c、c、a、b、c<br>b、a、a、b、c、b、a、b、c、c、a、b、c<br>c、a、a、b、c、b、a、b、c、c、a、b、c</p>
<p>参照画的图，结果一致：</p>
<p><img src="http://i.imgur.com/9IPlcrP.jpg" alt=""></p>
<h2 id="记录路径"><a href="#记录路径" class="headerlink" title="记录路径"></a>记录路径</h2><p>还是以循环的形式考虑，这个很容易理解</p>
<pre><code>List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();
for (int i = 0; i &lt; str.length(); i++) {
    path.add(i);
    for (int j = 0; j &lt; str.length(); j++) {
        path.add(j);
        for (int k = 0; k &lt; str.length(); k++) {
            path.add(k);
            //输出
            System.out.println(path);
            path.remove(path.size() - 1);
        }
        path.remove(path.size() - 1);
    }
    path.remove(path.size() - 1);
}
</code></pre><p>输出结果：</p>
<pre><code>[0, 0, 0]
[0, 0, 1]
[0, 0, 2]
[0, 1, 0]
[0, 1, 1]
[0, 1, 2]
[0, 2, 0]
[0, 2, 1]
[0, 2, 2]
[1, 0, 0]
[1, 0, 1]
[1, 0, 2]
[1, 1, 0]
[1, 1, 1]
[1, 1, 2]
[1, 2, 0]
[1, 2, 1]
[1, 2, 2]
[2, 0, 0]
[2, 0, 1]
[2, 0, 2]
[2, 1, 0]
[2, 1, 1]
[2, 1, 2]
[2, 2, 0]
[2, 2, 1]
[2, 2, 2]
</code></pre><p>现在改成递归的方式应该很容易了吧，<strong>你知道哪里应该add，哪里应该remove了</strong></p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            path.add(i);
            if(path.size() == str.length()){
                System.out.println(path);
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;abc&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);
    }

}
</code></pre><p>有个问题：输出是放在DFS（step + 1）前还是后面？</p>
<pre><code>if(path.size() == str.length()){
    System.out.println(path);
}
</code></pre><p>如果到达<strong>最后一层</strong>循环，这个DFS（step+1）相当于<strong>空函数！！</strong>，所以<strong>输出放在DFS(step + 1)前或者后都一样</strong></p>
<pre><code>for (int i = 0; i &lt; str.length(); i++) {
    //System.out.println(str.charAt(i));
    path.add(i);
    if(path.size() == str.length()){
        System.out.println(path);
    }
    DFS(step + 1);
    path.remove(path.size() - 1);
}
</code></pre><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p><img src="http://i.imgur.com/C15NY78.jpg" alt=""></p>
<p>红色描绘的路径是符合条件的全排列，观察后发现：</p>
<ul>
<li><strong>访问的路径节点之前已经存在</strong>，那么就需要剪枝</li>
<li>路径刚才我们已经保存了，所以可以做到</li>
</ul>
<p>加入节点前需要判断这个节点是否已经存在</p>
<pre><code>if(path.contains(i)){
    continue;
}
</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>递归完整版</p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            if(path.contains(i)){
                continue;
            }
            path.add(i);
            //输出
            if(path.size() == str.length()){
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;abc&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);
    }

}
</code></pre><p>循环完整版</p>
<pre><code>List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();
    for (int i = 0; i &lt; str.length(); i++) {
        if(path.contains(i)){
            continue;
        }
        path.add(i);
        for (int j = 0; j &lt; str.length(); j++) {
            if(path.contains(j)){
                continue;
            }
            path.add(j);
            for (int k = 0; k &lt; str.length(); k++) {
                if(path.contains(k)){
                    continue;
                }

                path.add(k);
                //输出
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();

                path.remove(path.size() - 1);
            }
            path.remove(path.size() - 1);
        }
        path.remove(path.size() - 1);
    }
}
</code></pre><h2 id="如果有重复"><a href="#如果有重复" class="headerlink" title="如果有重复"></a>如果有重复</h2><p>如果输入aac，将会输出</p>
<pre><code>a a c 
a c a 
a a c 
a c a 
c a a 
c a a 
</code></pre><p>有重复，为什么？为了区分用a1，a2表示</p>
<p>下图为按照未重复的时候的结果进行遍历、剪枝，打钩的即为需要保留的元素，与程序运行的一致</p>
<p><img src="http://i.imgur.com/vfH34t6.jpg" alt=""></p>
<p>下图中圈出来的路径需要被剪去，思考一下有什么特征？</p>
<p><img src="http://i.imgur.com/jv61CWg.jpg" alt=""></p>
<pre><code>a2、a1、c
a2、c、a1
c、a2、a1
</code></pre><p><strong>如果之前路径有相同的元素（这里是判断值相等，刚才是判断下标是否相等），而且当前下标比之前的小，则剪去</strong></p>
<p>代码如下：</p>
<pre><code>//重复元素
boolean flag = false;
for(Integer t : path){
    if(str.charAt(t) == str.charAt(i) &amp;&amp; i &lt; t){
        flag = true;
        break;
    }
}
if(flag){
    continue;
}
</code></pre><p>完整代码：</p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            if(path.contains(i)){
                continue;
            }

            //重复元素
            boolean flag = false;
            for(Integer t : path){
                if(str.charAt(t) == str.charAt(i) &amp;&amp; i &lt; t){
                    flag = true;
                    break;
                }
            }
            if(flag){
                continue;
            }

            path.add(i);
            //输出
            if(path.size() == str.length()){
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;aaaa&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);

    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/27/[Java并发编程]ConcurrentHashMap★★★（Happen Before、Volatile）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/[Java并发编程]ConcurrentHashMap★★★（Happen Before、Volatile）/" itemprop="url">ConcurrentHashMap★★★（Happen Before、Volatile）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T10:00:00+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://i.imgur.com/8TDvzvH.jpg" alt=""></p>
<p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>
<h2 id="并发读写考虑"><a href="#并发读写考虑" class="headerlink" title="并发读写考虑"></a>并发读写考虑</h2><p>1、<strong>非结构性修改操作</strong>只是更改某个 HashEntry 的 value 域的值。由于对 <strong>Volatile</strong> 变量的写入操作将与随后对这个变量的读操作进行同步。当一个写线程修改了某个 HashEntry 的 value 域后，另一个读线程读这个值域，Java 内存模型能够保证读线程读取的一定是更新后的值。所以，写线程对链表的非结构性修改能够被后续不加锁的读线程”看到”。</p>
<p>2、put-读</p>
<p>情况一：key已经存在，put操作为非结构性修改，查看1</p>
<p>情况二：新插入节点</p>
<p>put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。</p>
<p>采用头插法插入节点不影响读，<strong>每次遍历都是从头结点table[x]开始</strong>，即不影响读的遍历</p>
<p><img src="http://i.imgur.com/4BLoPBR.png" alt=""></p>
<p>3、remove-读</p>
<p><img src="http://i.imgur.com/jzXlXZm.jpg" alt=""></p>
<p><img src="http://i.imgur.com/wan6AGT.jpg" alt=""></p>
<p>和 get 操作一样，首先根据散列码找到具体的链表；然后遍历这个链表找到要删除的节点；<strong>最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中，直到复制完之后将table引用过去</strong></p>
<p>下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表</p>
<p>在执行 remove 操作时，<strong>原始链表并没有被修改</strong>，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p>
<p>4、clear-读</p>
<pre><code>void clear() {
    if (count != 0) {
        lock();
        try {
            HashEntry&lt;K,V&gt;[] tab = table;
            for (int i = 0; i &lt; tab.length ; i++)
                tab[i] = null;
            ++modCount;
            count = 0; // write-volatile
        } finally {
            unlock();
        }
    }
}
</code></pre><p>clear 操作只是把 ConcurrentHashMap 中所有的桶”置空”，<strong>每个桶之前引用的链表依然存在</strong>，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</p>
<h2 id="ConcurrentHashMap的get操作-volatile-★★★★★"><a href="#ConcurrentHashMap的get操作-volatile-★★★★★" class="headerlink" title="ConcurrentHashMap的get操作(volatile)★★★★★"></a>ConcurrentHashMap的get操作(volatile)★★★★★</h2><p><strong>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读？</strong>，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？</p>
<p>原因是它的<strong>get方法里将要使用的共享变量都定义成volatile</strong>，如用于统计当前Segement大小的 <strong>count</strong> 字段和用于存储值的 <strong>HashEntry 的 value</strong>。<br><br></p>
<font color="red">定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被<strong>单线程写</strong>（有一种情况可以被<strong>多线程写，就是写入的值不依赖于原值</strong>），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。</font>

<p><strong>之所以不会读到过期的值，是根据 java 内存模型的 happen before 原则，对 volatile 字段的写入操作先于读操作</strong>，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<p><strong>源码分析：</strong></p>
<pre><code>V get(Object key, int hash) {
    if (count != 0) { // read-volatile // ①
        HashEntry&lt;K,V&gt; e = getFirst(hash); 
        while (e != null) {
            if (e.hash == hash &amp;&amp; key.equals(e.key)) {
                V v = e.value;
                if (v != null)  // ② 注意这里
                    return v;
                return readValueUnderLock(e); // recheck
            }
            e = e.next;
        }
    }
    return null;
}
</code></pre><p>第一步，先判断一下 count != 0；count变量表示segment中存在entry的个数。如果为0就不用找了。</p>
<p>假设这个时候恰好另一个线程put或者remove了这个segment中的一个entry，会不会导致两个线程看到的count值不一致呢？</p>
<p>看一下count变量的定义： </p>
<pre><code>transient volatile int count;
</code></pre><p>它使用了volatile来修改。我们前文说过，Java5之后，JMM实现了对volatile的保证：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong>所以，每次判断count变量的时候，即使恰好其他线程改变了segment也会体现出来。</p>
<p>第二步，获取到要该key所在segment中的索引地址，如果该地址有相同的hash对象，顺着链表一直比较下去找到该entry。当找到entry的时候，先做了一次比较： if(v != null) ，这是为何呢？即<strong>如果get得到的结果是null，需要加锁读，否则直接返回</strong></p>
<p>考虑一下，如果这个时候，另一个线程恰好新增/删除了entry，或者改变了entry的value，会如何？</p>
<p>1) 在get代码的①和②之间，另一个线程新增了一个entry</p>
<p><img src="http://i.imgur.com/jO3Ir3q.jpg" alt=""></p>
<p>因为每个HashEntry中的next也是final的，没法对链表最后一个元素增加一个后续entry所以新增一个entry的实现方式只能通过头结点来插入了。</p>
<p>newEntry对象是通过 new HashEntry(K k , V v, HashEntry next) 来创建的。如果另一个线程刚好 <font color="red"><strong>new</strong></font> 这个对象时，当前线程来  <font color="red"><strong>get</strong></font> 它。<strong>因为没有同步，就可能会出现当前线程得到的newEntry对象是一个没有完全构造好的对象引用。</strong></p>
<p>回想一下我们之前讨论的DCL的问题，这里也一样，没有锁同步的话，new 一个对象对于多线程看到这个对象的状态是没有保障的，这里同样有可能一个线程new这个对象的时候还没有执行完构造函数就被另一个线程得到这个对象引用。</p>
<p>所以才需要判断一下：if (v != null) 如果确实是一个不完整的对象，则使用锁的方式再次get一次。</p>
<p><strong>有没有可能会put进一个value为null的entry？ 不会的，已经做了检查，这种情况会抛出异常</strong>，所以 ②处的判断完全是出于对多线程下访问一个new出来的对象的状态检测。</p>
<font color="red">注意：是否会出现 v！=null，但是返回的对象没有初始化，存在隐患？</font>

<p>如果对象HashEntry没有被volatile修饰，会出现这种情况。但是查看定义，<strong>HashEntry[]被volatile修饰。</strong></p>
<p>那么为什么不被volatile修饰，new HashEntry会出现引用不为null，但是对象未被初始化？</p>
<p>因为new的操作不是原子操作，分为1、分配内存 2、实例化 3、引用指向内存（此时不为null）</p>
<p><strong>但是指令重排序后，可能会出现1，3，2，此时在3是时候读取对象时不为null，但是对象未被初始化，出现隐患</strong></p>
<p>使用volatile修饰后，根据happen before原则，读操作必须在写之后，而且读线程是可见的</p>
<p><strong>所以，如果得到对象！=null，说明找到对象了，如果=null，可能是不存在，也可能是刚刚添加进去，等到put线程更新table指针，注意此时返回的元素是头指针，如果查找的就是刚刚添加的元素，释放锁后就能返回插入的结果</strong></p>
<p>2) 在get代码的①和②之间，另一个线程修改了一个entry的value</p>
<p><strong>value是用volitale修饰的，可以保证读取时获取到的是修改后的值。</strong></p>
<p>3) 在get代码的①之后，另一个线程删除了一个entry</p>
<p>假设我们的链表元素是：e1-&gt; e2 -&gt; e3 -&gt; e4 我们要删除 e3这个entry，因为HashEntry中next的不可变，所以我们无法直接把e2的next指向e4，而是将要删除的节点之前的节点复制一份，形成新的链表。</p>
<p>它的实现大致如下图所示：</p>
<p><img src="http://i.imgur.com/aNjCXWM.jpg" alt=""></p>
<p>如果我们get的也恰巧是e3，可能我们顺着链表刚找到e1，这时另一个线程就执行了删除e3的操作，<strong>而我们线程还会继续沿着旧的链表找到e3返回。这里没有办法实时保证了。</strong></p>
<p>我们第①处就判断了count变量，它保障了在 ① 处能看到其他线程修改后的。①之后到②之间，如果再次发生了其他线程再删除了entry节点，就没法保证看到最新的了。</p>
<p>不过这也没什么关系，即使我们返回e3的时候，它被其他线程删除了，暴漏出去的e3也不会对我们新的链表造成影响。</p>
<p>这其实是一种乐观设计，设计者假设 ① 之后到 ② 之间发生被其它线程增、删、改的操作可能性很小，所以不采用同步设计，而是采用了事后（其它线程这期间也来操作，并且可能发生非安全事件）弥补的方式。</p>
<p>而<font color="red"><strong>因为其他线程的”改”和”删”对我们的数据都不会造成影响，所以只有对”新增”操作进行了安全检查，就是②处的非null检查</strong></font>，如果确认不安全事件发生，则采用加锁的方式再次get。</p>
<h2 id="总结★★★★★"><a href="#总结★★★★★" class="headerlink" title="总结★★★★★"></a>总结★★★★★</h2><p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ul>
<li>用<strong>分离锁</strong>实现多个线程间的更深层次的共享访问。</li>
<li><strong>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</strong>（就是说当需要对链表结构进行改变时，对链表进行复制，先不更改原来的链表，然后操作完成之后再把table切换过去，在put/remove中体现）</li>
<li>通过对同一个 <strong>Volatile</strong> 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ul>
<h2 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h2><p>① <strong>程序次序法则</strong>：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。<br>② <strong>监视器锁法则</strong>：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。<br>③ volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong><br>④ 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。<br>⑤ 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。<br>⑥ 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。<br>⑦ 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。<br>⑧ <strong>传递性</strong>：如果A happens-before于B，且B happens-before于C，则A happens-before于C</p>
<p><strong>我们重点关注的是②，③，这两条也是我们通常编程中常用的。</strong></p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>使用锁方式实现”Happens-before”是最简单，容易理解的。</p>
<p><img src="http://i.imgur.com/Y2duLzx.jpg" alt=""></p>
<p>早期Java中的锁只有最基本的synchronized，它是一种互斥的实现方式。在Java5之后，增加了一些其它锁，比如ReentrantLock，它基本作用和synchronized相似，但提供了更多的操作方式，比如在获取锁时不必像synchronized那样只是<strong>傻等，可以设置定时，轮询，或者中断</strong>，这些方法使得它在获取多个锁的情况可以避免死锁操作。</p>
<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>JMM对Volatile的定义是：保证读写volatile都直接发生在main memory中，线程的working memory不进行缓存。它只承诺了读和写过程的可见性</p>
<p>Volatile可以看做一种轻量级的锁，但又和锁有些不同。</p>
<p>a) 它对于多线程，不是一种互斥（mutex）关系。<br>b) 用volatile修饰的变量，不能保证该变量状态的改变对于其他线程来说是一种”原子化操作”。</p>
<p>那对于”原子化操作”怎么理解呢？看下面例子：</p>
<pre><code>private static volatile int nextSerialNum = 0;

public static int generateSerialNumber(){
    return nextSerialNum++;
}
</code></pre><p>上面代码中对nextSerialNum使用了volatile来修饰，根据前面”Happens-Before”法则的第三条Volatile变量法则，看似不同线程都会得到一个新的serialNumber</p>
<p><strong>问题出在了 nextSerialNum++ 这条语句上，它不是一个原子化的</strong>，实际上是read-modify-write三项操作，<strong>这就有可能使得在线程1在write之前，线程2也访问到了nextSerialNum</strong>，造成了线程1和线程2得到一样的serialNumber。所以，在使用Volatile时，需要注意</p>
<p>使用场景：</p>
<ul>
<li>单线程写</li>
<li>被多线程写，就是写入的值不依赖于原值</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不变模式（immutable）是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。</p>
<p>不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让<strong>不可变形对象不需要同步就能自由地被访问和共享。</strong></p>
<h3 id="用Happens-Before规则理解一个经典问题：双重检测锁-DCL-为什么在java中不适用？"><a href="#用Happens-Before规则理解一个经典问题：双重检测锁-DCL-为什么在java中不适用？" class="headerlink" title="用Happens-Before规则理解一个经典问题：双重检测锁(DCL)为什么在java中不适用？"></a>用Happens-Before规则理解一个经典问题：双重检测锁(DCL)为什么在java中不适用？</h3><pre><code>public class LazySingleton {

    private static LazySingleton instance;

    private LazySingleton(){}

    public static LazySingleton getInstance() {
        if (instance == null) {// (2)
            synchronized (LazySingleton.class) { // (3)
              if (instance == null) { // (4)
                instance = new LazySingleton(); // (5)
              }
            }
        }
        return instance; // (6)
    }

}
</code></pre><p>假设线程1执行完(5)时，线程2正好执行到了(2)；</p>
<p>看看 new LazySingleton(); 这个语句的执行过程： 它不是一个原子操作，实际是由多个步骤，我们从我们关注的角度简化一下，简单的认为它主要有2步操作好了：</p>
<p>a） 在内存中分配空间，并将引用指向该内存空间。<br>b） 执行对象的<strong>初始化</strong>的逻辑(和操作)，完成对象的构建。</p>
<p>此时因为线程1和线程2没有用同步，他们之间不存在”Happens-Before”规则的约束，所以在线程1创建LazySingleton对象的 a),b)这两个步骤对于线程2来说会有可能出现a)可见，b)不可见<br>造成了<strong>线程2获取到了一个未创建完整的lazySingleton对象引用</strong>，为后边埋下隐患。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>多线程程序设计时需要考虑读-读、读-写、写-写</p>
<p>可以并发读：读不加锁<br>不能并发写：写加锁<br>写的时候不能影响正在读，或从头开始遍历的读</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/jianghuxiaojin/article/details/52006110" target="_blank" rel="external">http://blog.csdn.net/jianghuxiaojin/article/details/52006110</a></p>
<p><a href="http://blog.csdn.net/seapeak007/article/details/53409618" target="_blank" rel="external">http://blog.csdn.net/seapeak007/article/details/53409618</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/26/[分布式架构]构建高可用的系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/[分布式架构]构建高可用的系统/" itemprop="url">构建高可用的系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T21:46:00+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式架构/" itemprop="url" rel="index">
                    <span itemprop="name">分布式架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i.imgur.com/NO7vRM7.jpg" alt=""></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡分为硬件负载均衡和软件负载均衡</p>
<h3 id="防止单点"><a href="#防止单点" class="headerlink" title="防止单点"></a>防止单点</h3><p>负载均衡为避免自己成为单点，通常由两台机器构成，但只有一台处于服务状态，另一台则处于standby状态。一旦处于服务的那台机器出现问题，standby这台会自动接管</p>
<p><img src="http://i.imgur.com/Q2IQmQe.jpg" alt=""></p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>用户发送请求到负载均衡机器，负载均衡机器再将请求转发给实际的业务处理机器，通常负载均衡机器知道实际业务处理机器的IP地址，选择的方式如下：</p>
<p>1、随机选择<br>2、<strong>Hash选择</strong>。对应用层的请求信息做hash，这样可以保证每次请求的都是同一台机器，命中缓存。如查询图片<br>3、<strong>Round-Robin选择</strong>。按照处理机器的IP地址列表顺序选择，为了保持顺序选择时需要同步操作，但由于操作时间段性能损失很小，这种方式硬件负载和软件负载都支持，<strong>实际中使用最多</strong><br>4、按权重选择。根据每个地址的权重进行选择<br>5、按负载选择。根据实际业务处理机器的负载来选择，选择负载相对较低的机器来处理<br>6、按连接选择，让连接数相对较少的机器来处理业务，如果重启一台机器，可能会瞬间接收到大量请求，造成机器宕掉，这种方式实际应用很少</p>
<h3 id="跳过问题机器"><a href="#跳过问题机器" class="headerlink" title="跳过问题机器"></a>跳过问题机器</h3><p>为保证访问时跳过出问题的机器，通常采用的方法是负载均衡机器定时和实际的业务处理机器进行<strong>心跳</strong>（ping、端口检测、url侦测），发现心跳失败的机器并将它<strong>从可用地址列表中拿掉，在心跳成功后再重新加入可用列表中</strong></p>
<h3 id="响应返回方式"><a href="#响应返回方式" class="headerlink" title="响应返回方式"></a>响应返回方式</h3><p>业务处理机器处理完毕后，要将响应返回给用户，通常有两种返回方式：</p>
<p>1、响应通过负载均衡机器返回</p>
<p><strong>基于NAT实现</strong>，当请求从客户端发送至负载均衡机器时，负载均衡机器选择一台实际的业务处理机器，然后将<strong>请求报文的目标地址和端口改为实际业务处理机器的IP地址和端口</strong>，并将报文发送出去。当响应回到负载均衡机器上时，将报文的源地址和端口修改为负载均衡机器的VIP地址和端口</p>
<p><img src="http://i.imgur.com/TJ5MAmZ.jpg" alt=""></p>
<p>2、响应直接返回至请求发起方</p>
<p>响应直接返回至请求发起方可将请求包和响应包分开处理，以分散负载均衡机器的压力，使负载均衡机器可以支撑更大的请求量。要达到响应直接返回的效果，须要采用IP Tunneling或DR（Direct Routing，硬件负载设备中又简写为DSR：Direct Service Routing），这两种方式对负载均衡机器和实际业务处理机器的系统环境都有要求</p>
<p>①IP Tunneling</p>
<p>当采用IP Tunneling方式时，请求从客户端发送至负载均衡机器，负载均衡机器首先选择一台实际的业务处理机器，然后将请求的IP报文基于IP封装技术封装成另外一个IP报文，在做完以上处理后将报文发送出去，实际的业务处理机器收到报文后，先将报文解开获得目标地址为VIP的报文，处理完毕请求后，处理机器发现此VIP地址配置在本地的IP隧道设备上，则根据路由表将响应报文直接返回至请求方。IP Tunneling方式要求负载均衡机器和实际的业务处理机器的os都支持IP Tunneling，并将VIP地址同时配置在实际业务处理机器的IP隧道设备上</p>
<p><img src="http://i.imgur.com/CLTQdf4.jpg" alt=""></p>
<p>②Direct Routing</p>
<p>当采用Direct Routing方式时，请求从客户端发送至负载均衡机器，负载均衡机器首先选择一台实际的业务处理机器，然后将请求数据帧的MAC地址修改为此业务处理机器的MAC地址，并发送出去，实际的业务处理机器收到请求后，获取IP报文，当发现IP报文中的目标地址VIP配置在本地的网络设备上时，根据路由表将响应报文直接返回给用户。Direct Routing方式要求负载均衡机器和实际的业务处理机器在同一个物理网段中，并且不响应ARP</p>
<p><img src="http://i.imgur.com/97MaQPD.jpg" alt=""></p>
<p>根据上面的描述可以看出，IP Tunneling方式对系统环境的要求并不高，目前大部分的OS都支持IP Tunneling，Direct Routing方式对系统环境的要求则比较高，因此IP Tunneling方式更适合实现将响应直接返回给请求发起方，从而大幅度提升负载均衡机器所能支撑的请求量。</p>
<h3 id="软件负载"><a href="#软件负载" class="headerlink" title="软件负载"></a>软件负载</h3><p>1、LVS+KeepAlived</p>
<p>软件负载方案中最常用的为LVS（Linux Virtual Server），多数情况下采取<strong>LVS+Keepalived来避免负载均衡机器的单点，实现负载均衡机器的自动接管</strong>。</p>
<p>Keepalived基于<strong>VRRP</strong>（Virtual Router Redundancy Protocol）协议实现，在VRRP协议中，由一个Master的VRRP路由器和多个Backup的VRRP路由器构成<strong>VRRP虚拟路由器</strong>，但Master并不是永远不变的，Master的VRRP路由器会每隔一段时间发送广播包。当Backup VRRP路由器在连续三个周期内都收不到广播包时，即认为Master VRRP路由器出现问题，或收到优先级为0的广播包后，所有Backup VRRP路由器都发送VRRP广播信息，声称自己是Master，<strong>并将虚拟IP增加到当前机器上，从而保持对外提供的IP地址及MAC地址不变。</strong>Backup VRRP路由器收到VRRP广播信息后，首先比较优先级，如优先级比收到的VRRP广播信息中的优先级低，则重新将状态置为BACKUP。如优先级相等，则比较IP地址，IP值小的则重新将状态恢复为BACKUP，整个切换过程对于请求端而言是透明的。但由于VRRP方式依靠广播信息来确认是否健康，如网络上出现异常，有可能会出现多个Master的现象，这个时候会出现一些问题，因此当使用VRRP方式时要特别监测是否出现此类现象，一旦出现就要迅速人工介入处理。</p>
<p>2、硬件负载设备</p>
<p>除了采用Keepalived方式实现自动接管外，也可采用类似硬件负载设备的方式来实现，即<strong>采用心跳线+高可用软件来实现</strong>。在linux目前使用范畴最广的高可用软件为heartbeat，默认情况下heartbeat通过UDP方式来监测。</p>
<p>除LVS外，软件负载方案中还有像HAProxy这样的佼佼者，在考察采用哪种软件负载方案时，则要从应用场景、系统环境等多方面考虑。</p>
<h3 id="故障传播"><a href="#故障传播" class="headerlink" title="故障传播"></a>故障传播</h3><p>在系统从单机演变为集群后，可用性确实会得到一定提升，但随着系统功能的不断丰富，会出现<strong>多个系统访问同一系统提供的功能</strong>的情况，在这种情况下有可能会出现其中某个系统的访问导致其他系统故障。</p>
<p>对于以上这种故障传播的现象，通常会根据应用性质的不同做隔离的方案，通常采取配置多个不同的VIP的方法，<strong>各个系统通过域名访问，通过dns等方法使域名根据不同的系统解析为不同的VIP</strong>，从而实现根据应用性质不同来隔离，避免故障传播。</p>
<h2 id="热备"><a href="#热备" class="headerlink" title="热备"></a>热备</h2><p>热备通常对程序的要求不高，<strong>热备的情况下真正对外服务的机器只有一台，其他机器处于standby状态。</strong>standby机器通过心跳机制检查对外服务机器的健康状况，当出现问题时，其中一台standby机器即进行接管，机器间的状态同步至其他standby机器或写入一个集中存储设备，例如上述章节中LVS+Keepalived实现自动接管的方式</p>
<p>对于大型应用而言，除了单机故障外，<strong>还须考虑整个机房出现不可用的情况。如所有的应用都部署在单个机房，也可以认为是单点现象，</strong>一旦发生机房断电或机房出现不可抗力的灾难性事故时，整个系统的可用性就完全无法保障了，对于此类现象，通常采用多个机房的方法来避免，一方面可以做到其中一个机房出现问题时对整个系统不会产生太大的影响，另一方面也可以分流，提升性能。</p>
<h2 id="使用多机房——保持一致性"><a href="#使用多机房——保持一致性" class="headerlink" title="使用多机房——保持一致性"></a>使用多机房——保持一致性</h2><p>❶、主从同步</p>
<p>数据库数据的同步通常采用 <strong>单master、多slave</strong> 或 <strong>多master方案</strong>。单master方案只有一个写入点，其主要解决的是master同步到slave的问题，通常采取的是<strong>数据库自带的同步方案</strong>，例如oracle standby方案或mysql replication方案。</p>
<p>❷、分布式同步</p>
<p>多master方案有多个写入点，相对单master方案就复杂多了，通常采取的两阶段提交、三阶段提交或基于Paxos的方式来保持多master数据的一致性。</p>
<p>1、两阶段提交（2PC）保持一致性</p>
<p>在采用两阶段提交保证多master数据的一致性时，步骤为：</p>
<pre><code>1）开启事务；
2）通知每个master执行某操作；
3）所有master在接到请求后，锁定执行此操作需要的资源，例如假设是个扣款动作，那么先冻结相应的款项，冻结完毕后返回；
4）在收到所有master的反馈后，如均为可执行此操作，则继续之后的步骤，如有一个master反馈不能执行或一段时间内无反馈，则通知所有master回滚操作；
5）通知所有master完成操作。
两阶段提交方式相对而言比较易于实现，但问题在于所有的master都要冻结资源，而且一旦有一个master出现问题就要全部回滚。
</code></pre><p>2、三阶段提交（3PC）保持一致性</p>
<p>为了避免在通知所有master提交时，其中一个master crash不一致时，就出现了三阶段提交的方式。三阶段提交在两阶段提交的基础上增加了preCommit的过程，<strong>当所有master收到preCommit后，并不执行动作，直到收到commit或超过一定时间后才完成操作。</strong></p>
<p>在实现两阶段或三阶段提交时，为了避免通知所有master时出现问题，通常会借助消息中间件或让任意的一个master能够接管成为通知者。</p>
<p>3、基于Paxos保持一致性</p>
<p>Paxos最大的改变在于不要求所有master都反馈成功，<strong>只须有大多数反馈成功就执行了</strong>，更多具体的细节请参考相关文献。</p>
<p>总结：</p>
<p>文件的同步和内存数据的同步采取的方案和数据库数据同步的方案基本相同。<br>总的来说，由于采用多机房后带来的网络延时问题，技术上会出现不少的挑战，不过对于要求高可用的应用，采用多机房还是很有必要的。</p>
<h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><p>分布式文件系统采用的方法由众多普通PC Server机器构成巨大的存储池，<strong>每台机器只存储一部分数据</strong>，其本身通常可非常好地支持水平伸缩。例如一台机器能存储500GB数据，那么当要存储2000GB数据时，只要增加到四台机器即可</p>
<p><img src="http://i.imgur.com/Gj27UUY.jpg" alt=""></p>
<p>当Node A要上传文件时，Node A上的GFS Client会将文件按固定大小划分，并向主服务器提交<strong>文件名和块索引信息，从而得到要存储的目标机器及位置</strong>，主服务器根据目前各存储机器的存活状态、硬件使用率等来决定块需要存储到的目标机器，之后Node A将数据存储到目标机器的相应位置上。主服务器负责记录文件和块的命名空间、文件到块的映射及每个块副本的位置。</p>
<p>为了保证安全可靠，同时<strong>将数据复制到多个存储机器上</strong>，复制的份数可在主服务器上进行设置，当Node B要读取此文件时，则只要从主服务器上获取此文件划分的存储位置列表，然后随机挑选机器进行读取，最后<strong>根据块的索引进行合并即可</strong>。</p>
<h2 id="应用水平伸缩"><a href="#应用水平伸缩" class="headerlink" title="应用水平伸缩"></a>应用水平伸缩</h2><p>在系统建设初期，会采用将各种业务都放在同一个系统的方式，这会导致这个系统日渐庞大，所需的资源（CPU、内存、数据库连接）越来越多，在进行水平伸缩时要考虑系统里各种业务会造成的资源增加的现象，这种状况会导致水平伸缩很难进行。例如增加机器后就造成了多个数据库连接的增加，对于这样的状况，通常采取拆分应用的方式来解决。</p>
<p><strong>拆分应用通常按照业务领域来划分</strong>，即将原在同一系统中处理的功能拆分到各个不同的业务系统中，例如eBay将其业务系统拆分为商品、用户、评价、交易等</p>
<p><img src="http://i.imgur.com/XY3YCaY.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/25/[数据结构与算法]索引、高级树结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/[数据结构与算法]索引、高级树结构/" itemprop="url">索引、高级树结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T17:13:00+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是把一个关键码与它对应的数据记录的位置相关联的过程</p>
<p>索引文件记录了&lt;关键码，指针&gt;对，指针指向了文件的真实地址</p>
<h3 id="线性索引"><a href="#线性索引" class="headerlink" title="线性索引"></a>线性索引</h3><p>数据库中的记录是不等长的，而且无需存储的。但建立的索引文件是<strong>等长（Key，Point对）、按照关键字有序存储的</strong>，这样可以方便进行二分查找；索引文件的指针指向磁盘文件的地址</p>
<p><img src="http://i.imgur.com/1DXYCvu.png" alt=""></p>
<p>如果线性索引太大，可以存储在磁盘中。但是一次检索过程中会有多次访问磁盘，从而影响检索的效率，可以使用<strong>二级线性索引</strong></p>
<h3 id="二级线性索引"><a href="#二级线性索引" class="headerlink" title="二级线性索引"></a>二级线性索引</h3><p>如果一级索引太大无法直接读入内存，可以存入磁盘中，存在<strong>连续的磁盘块中</strong>。二级线性对磁盘块进行索引</p>
<p><img src="http://i.imgur.com/5DF8sRQ.png" alt=""></p>
<p>二级线性索引能快速索引到<strong>磁盘块</strong>：</p>
<ul>
<li>二级线性索引的关键码与磁盘块第一条记录的值相等</li>
<li>指针指向响应磁盘块的其实位置</li>
</ul>
<p><img src="http://i.imgur.com/OmgLiY6.png" alt="">、、</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>对某属性按属性值建立索引；因为不是由记录关键码来确定属性值，而是由属性值来确定记录的位置，因此成为倒排索引</p>
<p>这些属性往往是<strong>离散型</strong>的，对于连续型的用B树</p>
<p>举个例子，假设EMP是主键，其余的是属性。如果不建立属性倒排索引，如果需要查找属性为某个值的记录，那么需要从头开始读取记录，判断每条记录的属性是否是查询的值，非常耗时</p>
<p><img src="http://i.imgur.com/cCjGMrk.png" alt=""></p>
<p>倒排文件的索引项是（key，point[]）：</p>
<ul>
<li>一个具体的索引值</li>
<li>一组指针（因为属性值不是唯一的，一个属性会对应多条记录）</li>
</ul>
<p>对上述记录建立的倒排文件如下，可以根据属性获得主键ID，然后再通过主键查询记录</p>
<p><img src="http://i.imgur.com/7Ty52wU.png" alt=""></p>
<h3 id="正文索引"><a href="#正文索引" class="headerlink" title="正文索引"></a>正文索引</h3><p>对文本内容进行快速检索</p>
<ul>
<li>词索引：从正文中抽出关键词，对关键词进行快速索引</li>
<li>全文索引：把正文看做一个长的字符串，对每一个字符建立索引，使查找不再限于关键词，需要更大的空间</li>
</ul>
<p>建立正文倒排索引步骤：</p>
<p>1、把正文分成多条记录<br>2、每条记录赋予一个关键词<br>3、建立正文倒排文件</p>
<p>倒排文件的索引结构：</p>
<p><img src="http://i.imgur.com/Ib1kiRz.png" alt=""></p>
<h2 id="高级树结构"><a href="#高级树结构" class="headerlink" title="高级树结构"></a>高级树结构</h2><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie来源于retrieval，即检索</p>
<p>基于关键码分解的数据结构，常应用于信息检索、存储英文字符串</p>
<p>下面展示的Trie结构的树，<strong>人为指定左右节点的范围</strong>，使树的分布相对均匀；如在根节点，将小于32的树放在左子树，大于32的树放入右子树</p>
<p><img src="http://i.imgur.com/BGjZxHO.png" alt=""></p>
<h3 id="英文字符树"><a href="#英文字符树" class="headerlink" title="英文字符树"></a>英文字符树</h3><p>按照英文字幕的索引建立索引，即前缀树</p>
<p><img src="http://i.imgur.com/VPBvjz0.png" alt=""></p>
<p>对于不等长的字符串，比如规定字符串的长度是3，那么对于字符串an，可以转换成an*；检索时检索到*表示检索结束</p>
<p><img src="http://i.imgur.com/4kUY7zI.png" alt=""></p>
<h3 id="平衡的二叉搜索树（AVL）"><a href="#平衡的二叉搜索树（AVL）" class="headerlink" title="平衡的二叉搜索树（AVL）"></a>平衡的二叉搜索树（AVL）</h3><p>平衡的二叉搜索树定义：左右节点的高度小于等于1</p>
<p><strong>插入节点后，根节点的变化大致有三类：</strong></p>
<ul>
<li>原来节点时平衡的，现在成为左重或右重的</li>
<li>节点原来是某一边重，而现在成为平衡的了</li>
<li>节点原来是左重或右重的，又加到重的一边，<strong>现在不平衡了</strong>，需要进行调整！！！</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>如下图，插入17前是平衡树，节点2的平衡因子是+1，即右子树比左子树高度大1；节点15是平衡的；<br>插入17后，节点2的平衡因子变成2，节点1的平衡因子变成1，失衡了，<strong>需要调整节点2，节点15，节点7之间的关系</strong></p>
<p>很简单，用中间值15作为根节点，12小于15作为左节点，17大于15作为右节点，调整后如下：</p>
<p><img src="http://i.imgur.com/zBKQlJG.png" alt=""></p>
<font color="red">可以发现，调整之前，节点2的高度是2，调整之后，节点2的高度还是2，没有变化，所以不影响其他节点</font>

<p><strong>插入节点时平衡因子变化</strong></p>
<ul>
<li>不平衡的情况发生在插入新节点后</li>
<li><strong>BST把新节点插入到叶结点</strong>★★★（根节点与叶节点交换，然后插入）</li>
<li>假设a是离插入节点最近，且平衡因子绝对值不等于0的节点（如果节点的平衡因子等于0不需要调整结构）<ul>
<li>插入的关键码要么在它的左子树中，要么在其右子树中</li>
<li><strong>假设插入在右边</strong>，此时a的平衡因子有三种情况：-1，0，1，如下图</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/4alZl20.png" alt=""></p>
<p>1、原来a的平衡因子是-1，即左子树的高度比右子树的高度大1。右边插入节点后，平衡因子变成0，左右子树高度相等，变平衡了<br>2、原来a的平衡因子是0，左右子树高度相等。右边插入节点后，右子树的高度比左子树高度大1，平衡因子变为1<br>3、左图a的平衡因子变成2，b的平衡因子为1，<font color="red">需要调整</font>；右图a的平衡因子变成，b的平衡因子编程-1，<font color="red">需要调整</font>；</p>
<p><strong>不平衡的情况总结★★★★</strong></p>
<p><img src="http://i.imgur.com/tfK5H9S.png" alt=""></p>
<p>分为四种：LL，LR，RL，RR，其中LL和RR比较相似，LR和RL相似</p>
<p><strong>LL</strong></p>
<p>如下图有一颗平衡树，其中T1、T2、T3都表示子树，他们的高度都是h。那么节点B的平衡因子是0，节点A的平衡因子是-1，中序遍历的结果是：T1、B、T2、A、T3</p>
<p>此时如果在A的左子树中插入一个节点，会造成节点A的平衡因子变成-2，造成树不平衡</p>
<p><img src="http://i.imgur.com/h9NsaHS.jpg" alt=""></p>
<p>LL主要节点是A、B、T1，三者的大小关系是T1&lt;B&lt;A， B为A和T1的分割节点，调整时保持B不变，将A右旋</p>
<p><strong>先确定T、B、A的位置，T1和A各自的子节点保持不变；在A右旋的时候，替换了B的右节点，所以将B的有节点T2挂载挂在A的左节点上</strong></p>
<p><img src="http://i.imgur.com/zVVdLOn.jpg" alt=""></p>
<p>调整后中序遍历结果没有变化，树保持平衡</p>
<p><img src="http://i.imgur.com/I6vDXgv.jpg" alt=""></p>
<p><strong>RL</strong></p>
<p><img src="http://i.imgur.com/vckMLrR.jpg" alt=""></p>
<p><img src="http://i.imgur.com/7WY6ERj.jpg" alt=""></p>
<p><img src="http://i.imgur.com/ivnDQpp.jpg" alt=""></p>
<p><img src="http://i.imgur.com/1TST6pV.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/24/[数据库]5、B数、B+数、红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/[数据库]5、B数、B+数、红黑树/" itemprop="url">5、B数、B+数、红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T22:08:00+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p><img src="http://i.imgur.com/AURzDMV.png" alt=""></p>
<p>关键字 1-2 个<br>子节点 2-3 个</p>
<p>平衡树：子节点的高度一致</p>
<h2 id="B树（Balacned-Tree）"><a href="#B树（Balacned-Tree）" class="headerlink" title="B树（Balacned Tree）"></a>B树（Balacned Tree）</h2><p><strong>一种平衡的多分树</strong></p>
<p>平衡：所有的叶结点在同一层，所以每个子节点的高度一致</p>
<h3 id="m阶B树的结构定义"><a href="#m阶B树的结构定义" class="headerlink" title="m阶B树的结构定义"></a>m阶B树的结构定义</h3><p>1、每个结点至多有m个子结点<br>2、除根节点和叶节点外，其他每个结点至少有m/2（向上取整）个结点<br>3、根结点至少有两个子结点</p>
<ul>
<li>唯一例外的是根节点就是叶结点时没有子结点</li>
<li>此时B树只包含一个结点</li>
</ul>
<p>4、所有的叶结点在同一层（平衡）<br>5、有k个子节点的非根节点恰好包含k-1个关键码</p>
<h3 id="B树的性质"><a href="#B树的性质" class="headerlink" title="B树的性质"></a>B树的性质</h3><p>1、树高平衡，所有叶结点都在同一层<br>2、关键码没有重复，<strong>父结点中的关键码是其子结点的分界</strong><br>3、<strong>B树把（值接近）相关记录放在同一个磁盘页中，从而利用局部性原理</strong><br>4、B树保证树中至少有一定比例的结点是满的（每个结点有至少有m/2个子节点，半满）</p>
<ul>
<li>这样能改进空间的利用率（如果每个节点只有1个子节点，BST，树高会很高，空间利用率低）</li>
<li>减少索引和更新操作的磁盘读取数目（如果每个节点有m个子节点，全满，那么每次插入的时候没处插了）</li>
</ul>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>除根节点和叶节点外，M阶B树每个节点有m/2~m个结点，根节点至少有两个子节点（插入时多次分裂）</li>
<li>有k个子节点的非根节点恰好包含k-1个关键码</li>
<li>父结点中的关键码是其子结点的分界</li>
</ul>
<h3 id="B树的节点结构"><a href="#B树的节点结构" class="headerlink" title="B树的节点结构"></a>B树的节点结构</h3><p>B树的一个包含j个关键码，j+1个指针的节点的一般形式为：</p>
<pre><code>P0，K1，P1，K2，P2....Kj，Pj  #j个关键码，j+1个指针指向子节点
</code></pre><p>其中ki是关键码值，K1&lt;K2&lt;….&lt;Kj<br>Pi是指向Ki到Ki+1之间的关键码的子树的指针</p>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>如果有j个关键字，那么有可以表示j+1个区间，即有j+1个子节点</li>
<li>关键词下标从1开始，P从0开始，Pi是指向Ki到Ki+1之间的关键码的子树的指针</li>
<li>举个例子：P0指向K0到K1之间，即小于K1的，P1指向K1到K2</li>
</ul>
<p><img src="http://i.imgur.com/0I002wG.png" alt=""></p>
<h3 id="B树结点抽象数据类型"><a href="#B树结点抽象数据类型" class="headerlink" title="B树结点抽象数据类型"></a>B树结点抽象数据类型</h3><pre><code>class BNode{
    int n;//子节点的个数
    BNode&lt;Key&gt; *parent;//指向父节点的指针（可有可不有）
    Key key[MAXREC];//存储关键码的数组，最多有MAXREC个关键码
    BNode&lt;Key&gt; *ptr[MAXREC+1];//指向子节点的指针，最多有MAXREC+1个指针
}
</code></pre><h3 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h3><p>1、把根节点读出来，在根节点所包含的关键码K1…Kj中查找给定的关键码值。当关键码不多时，就用顺序检索，当节点包含的关键码较多时，可以用二分检索。如果找到则检索成功</p>
<p>2、否则，确定要查的关键码指在某个Ki和Ki+1之间，那么去Pi所指向的节点继续查找</p>
<p>下图为查找24的过程</p>
<p><img src="http://i.imgur.com/55g1tMJ.png" alt=""></p>
<p>如果树高为h，则查找时访问外存的次数是h</p>
<p>注意：<br><strong>每个关键码表示索引，找到索引后，每个关键码还对应一个指向外存的指针，这样通过索引才可以访问到完整的记录</strong></p>
<h3 id="B树的插入（分裂向上生长）"><a href="#B树的插入（分裂向上生长）" class="headerlink" title="B树的插入（分裂向上生长）"></a>B树的插入（分裂向上生长）</h3><p>情况1：</p>
<p>首先判断关键码14是否存在，按照图中的轨迹查找，此时到15所在的节点，遍历后发现没有14，则在该节点中插入</p>
<p>此时外存读的次数是3，写的次数是1</p>
<p><img src="http://i.imgur.com/mbAsXfh.png" alt=""></p>
<p>情况2：</p>
<p>插入可能导致B树朝着根的方向生长，即当插入位置超过关键字的最大个数，<strong>节点需要进行分裂</strong></p>
<p>如插入55，但2-3树要求关键字数只由1~2个，此时插入节点50，52已经达到个数，55无法直接插入，需要进行分裂</p>
<p><img src="http://i.imgur.com/H7UFbSW.png" alt=""></p>
<p>50 52 55如何拆分？</p>
<p>父节点需要增加一个节点进行区分子节点拆分后的节点，采用二分的方法，将<strong>中间</strong>的52送到父节点，得到结果：</p>
<p>此时读的次数3，写的次数3（申请两个节点，并分别写入，这里包含两次写，还有在父节点中写入1次）</p>
<p><img src="http://i.imgur.com/G6v7NrJ.png" alt=""></p>
<p>情况3：</p>
<p>多次分裂，树向上生长</p>
<p><img src="http://i.imgur.com/pSZFrHr.png" alt=""></p>
<p>最终的结果是：</p>
<p><img src="http://i.imgur.com/JxhAKc6.png" alt=""></p>
<h3 id="B数的删除（向左或向右合并）"><a href="#B数的删除（向左或向右合并）" class="headerlink" title="B数的删除（向左或向右合并）"></a>B数的删除（向左或向右合并）</h3><p>6阶B树删除45</p>
<p>对于6阶B树，子节点树要求m/2~m，即 3~6，<strong>关键码的个数为2~5</strong>，在删除的过程中需要<strong>防止下溢出</strong>，即关键码的数量小于规定的个数</p>
<p><img src="http://i.imgur.com/yK13FBp.png" alt=""></p>
<p>在删除掉45后，当前节点只有110一个关键字，下溢出了。其中一种方案是<strong>向左右节点借关键码，同时要将父节点拉下来</strong>，这里演示向右节点借关键码。此时合并的关键码有110，112，135，143，212，需要进行分裂，根据二分分裂的方式，将135移到父节点，即用135替换123，然后子节点分裂，反别是110，112和142，212，结果是：</p>
<p><img src="http://i.imgur.com/CoU6eYL.png" alt=""></p>
<p>给出一个极限情况下删除的例子：</p>
<p>删除的时候如果发生下溢出，即当前关键码个数小于定义的个数，则需要进行合并，向左节点或有节点合并</p>
<p>如果删除后，节点为0仍保持0的状态，按照向左向右合并的方式进行操作</p>
<p><img src="http://i.imgur.com/pFdZra1.jpg" alt=""></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的一种变形，<strong>是在叶结点上存储信息的树</strong>：</p>
<ul>
<li>所有的管家那么均出现在叶结点上</li>
<li>各层节点中的关键码均是下一层相应节点中最大关键码（或最小关键码）的复写</li>
</ul>
<h3 id="B-树的结构定义"><a href="#B-树的结构定义" class="headerlink" title="B+树的结构定义"></a>B+树的结构定义</h3><ul>
<li>每个节点至多有m个子节点</li>
<li>每个结点（除根外）至少有m/2（向上取整）个子结点</li>
<li>根节点至少有两个子结点</li>
<li><strong>有k个子结点的必有k个关键码</strong>（这个是与B树的差别）</li>
</ul>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>根节点有2~m个子节点</li>
<li>除根节点外有m/2（向上取整）~m个子结点</li>
<li>有k个子结点的节点有k个关键字（这是与B树的结构差别，B树有k-1个关键字）</li>
</ul>
<p><img src="http://i.imgur.com/SWjSq7P.png" alt=""></p>
<ul>
<li>m阶B+树有m个子节点，也有m个关键字</li>
<li>m个关键字是子结点的复写，当前层的关键码是其每个子结点关键码的最大关键码（也可以是最小）</li>
<li>根节点是线性索引，可以顺序查找；再加上多分树形查找</li>
<li>树形索引中不包含指向真实数据位置的指针，必须索引到树的叶子节点才算找到；<strong>好处是可以提高树的阶数，降低树的高度，加速索引速度</strong></li>
</ul>
<h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>如下3阶B+树，节点最多有3个关键码，当插入15后，查询到10 23这个节点，插入15。父节点不需要重写</p>
<p><img src="http://i.imgur.com/DFBPxEe.png" alt=""></p>
<p>3阶B+树插入16后，叶子节点的关键为16超过最大阶3，所以需要分类成10、15和16、23，并增加分类节点之间的线性链接，修改父节点的关键码，每个关键码是子结点关键码最大值的复写</p>
<p><img src="http://i.imgur.com/IQy3m4D.png" alt=""></p>
<p>多次分裂</p>
<p><img src="http://i.imgur.com/Bsdyx8M.jpg" alt=""></p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>如下B+树删除23，首先需要查找23；第一个节点判断，23&lt;=35，到第二个子结点查找；23&lt;=23，在第一个子结点中查找；删除关键码23；</p>
<p>此时父节点中的23能够正确标识父节点的区间，所以不进行更新（类似线段树中的延迟更新）</p>
<p><img src="http://i.imgur.com/x8PASHT.png" alt=""></p>
<h2 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h2><p>节点结构：</p>
<ul>
<li>当前节点有k个子结点，B树有k-1个关键码，B+树有k个关键码</li>
<li>B树当前节点的关键码类似BST是子结点关键码的分割，B+树当前节点的关键码是子结点的复写（子结点关键码的最大值或最小值）</li>
</ul>
<p>查找：</p>
<p>B树每个节点保存了指向真实位置的指针，找到关键码就能找到真实位置；B+树必须索引到叶子节点；B+树提供了索性查找和顺序查找两种方式</p>
<p>实际中使用B+树特别多</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>第10章 索引——2（B树,B树） 标清<br><a href="https://www.youtube.com/watch?v=vBD6Ve8VryY" target="_blank" rel="external">https://www.youtube.com/watch?v=vBD6Ve8VryY</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
