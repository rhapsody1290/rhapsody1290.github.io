<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Qian's Home">
<meta property="og:url" content="http://qianmingxs.com/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Qian's Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/"/>





  <title>Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/07/17/[Redis]Redis底层数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/17/[Redis]Redis底层数据结构/" itemprop="url">Redis底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T21:45:00+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis单进程单线程执行速度快的原因"><a href="#Redis单进程单线程执行速度快的原因" class="headerlink" title="Redis单进程单线程执行速度快的原因"></a>Redis单进程单线程执行速度快的原因</h2><p>总体来说快速的原因如下：</p>
<p>1）绝大部分请求是纯粹的内存操作（非常快速）<br>2）采用单线程,避免了不必要的上下文切换和竞争条件<br>3）非阻塞IO</p>
<p>内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间    </p>
<p>这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。</p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p>首先，Redis没有MySQL那样的索引机制，因为其内建一个基于hash的字典，如下图：</p>
<p><img src="http://i.imgur.com/u4CAMEI.jpg" alt=""></p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<p># 使用字典设置的哈希函数，计算键 key 的哈希值<br>hash = dict-&gt;type-&gt;hashFunction(key);</p>
<p># 使用哈希表的 sizemask 属性和哈希值，计算出索引值<br># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]<br>index = hash &amp; dict-&gt;ht[x].sizemask;<br>插入数据时，根据以上算出index，然后根据index值放入table表中相应位置即可。</p>
<p><strong>QM注释：</strong><br>1、每个dictht为一个map结构，字典dict中有两个map<br>2、map为key、value的结构，value可以为各种数据类型，包括字符串、链表…</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>例如：Set hello world </p>
<p><img src="http://i.imgur.com/cb0jdYP.png" alt=""></p>
<p>字符串类似Java中的String对象，存储类似HashMap，key为字符串的名字，value为String对象</p>
<h3 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h3><p>例如：Lpush list aaaa bbb ccc</p>
<p><img src="http://i.imgur.com/kGPk6LE.png" alt=""></p>
<pre><code>// 双向链表
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

//数据结构 + 操作
typedef struct list {
    listNode *head;
    listNode *tail;
    ...
} list;
</code></pre><p>链表类似Java中的LinkedList，定义每个链表时取一个名称；存储类似HashMap，key为链表的名称，value为list对象</p>
<h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>例如：Hset test hello world</p>
<p><img src="http://i.imgur.com/udIIoGc.png" alt=""></p>
<p>存储类似HashMap，key为hash表的名称，value为hash表</p>
<p>注：新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现（一个key对应一个hash表）。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合，常用来存储不重复数据的数据结构，底层基于hashtable；在redis中为了优化存储，set的编码类型可以为：intset，hashtable。</p>
<h3 id="Sorted-Set-ZSet"><a href="#Sorted-Set-ZSet" class="headerlink" title="Sorted Set(ZSet)"></a>Sorted Set(ZSet)</h3><p>链表+跳跃表</p>
<p><a href="https://mp.weixin.qq.com/s/RDHebf6IfLWfw38dPvfiZQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/RDHebf6IfLWfw38dPvfiZQ</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cnblogs.com/renzherushe/p/4779390.html" target="_blank" rel="external">http://www.cnblogs.com/renzherushe/p/4779390.html</a></p>
<h2 id="Redis过期检测"><a href="#Redis过期检测" class="headerlink" title="Redis过期检测"></a>Redis过期检测</h2><p>Redis对于过期检测，有2种方式，一个主动检测，一个是被动检测；在redis和client交互过程中，对于任何数据的操作，都会首先检测key是否已经过期，这是被动检测；主动检测是Redis启动的后台线程中，不间断的随机扫描一定量的key（randomKey），并对key进行过期检测</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/29/[JDK源码阅读]LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/[JDK源码阅读]LinkedHashMap/" itemprop="url">LinkedHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T14:00:00+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JDK源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">JDK源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>1、Entry节点增加了after、before两个指针，组成双向链表，记录节点插入顺序</p>
<pre><code>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
}
</code></pre><p>2、LinkedHashMap保存头节点指针，插入的方式都采用头插法，因为是双向链表，可以轻易插在头部和尾部</p>
<pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
{
    private transient Entry&lt;K,V&gt; header;
}
</code></pre><p>3、LinkHashMap有一个成员变量accessOrder，表示链表的保存顺序，默认是false，按照插入顺序保存。</p>
<pre><code>private final boolean accessOrder;
</code></pre><p><strong>注意：</strong>因为插入时采用的是头插法，所以链表的存储顺序是逆序的，<strong>即先插入的在尾部</strong>，但是迭代器在遍历的时候从尾到头的顺序，所以不影响</p>
<p>如果想实现LRU的方式，按照访问顺序的方式存储节点，构造LinkedHashMap的时候accessOrder设为true</p>
<pre><code>public LinkedHashMap(int initialCapacity,
         float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
</code></pre><h2 id="源码关键"><a href="#源码关键" class="headerlink" title="源码关键"></a>源码关键</h2><pre><code>//LinkedHashMap方法
public V get(Object key) {
    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);
    if (e == null)
        return null;
    e.recordAccess(this);
    return e.value;
}

//HashMap方法
public V put(K key, V value) {
    if (key == null)
    return putForNullKey(value);
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
</code></pre><p>1、<font color="red"><strong>当调用get或者put方法的时候，如果K-V已经存在，会回调Entry.recordAccess()方法</strong></font></p>
<p>当 accessOrder 为 true，即按LRU的策略存储，会先调用 remove 清除的当前首尾元素的指向关系，之后调用addBefore方法，<strong>将当前元素加入header之前。</strong></p>
<pre><code>/**
 * This method is invoked by the superclass whenever the value
 * of a pre-existing entry is read by Map.get or modified by Map.set.
 * If the enclosing Map is access-ordered, it moves the entry
 * to the end of the list; otherwise, it does nothing. 
 */
void recordAccess(HashMap&lt;K,V&gt; m) {
    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;
    if (lm.accessOrder) {
        lm.modCount++;
        remove();
        addBefore(lm.header);
    }
}

/**
 * Remove this entry from the linked list.
 */
private void remove() {
    before.after = after;
    after.before = before;
}

/**                                             
 * Insert this entry before the specified existing entry in the list.
 */
private void addBefore(Entry&lt;K,V&gt; existingEntry) {
    after  = existingEntry;
    before = existingEntry.before;
    before.after = this;
    after.before = this;
}
</code></pre><p>2、put操作时，如果key不存在，当有新元素加入 Ma p的时候会调用 Entry 的 addEntry 方法，<strong>会调用 removeEldestEntry 方法，这里就是实现LRU元素过期机制的地方</strong>，默认的情况下removeEldestEntry方法只返回false表示元素永远不过期。 </p>
<pre>
/**
 * This override alters behavior of superclass put method. It causes newly
 * allocated entry to get inserted at the end of the linked list and
 * removes the eldest entry if appropriate.
 */
void addEntry(int hash, K key, V value, int bucketIndex) {
    createEntry(hash, key, value, bucketIndex);

    // Remove eldest entry if instructed, else grow capacity if appropriate
    Entry<k,v> eldest = header.after;
    if (<font color="red">removeEldestEntry(eldest)</font>) {
        removeEntryForKey(eldest.key);
    } else {
        if (size >= threshold) 
            resize(2 * table.length);
    }
}

/**
 * This override differs from addEntry in that it doesn't resize the
 * table or remove the eldest entry.
 */
void createEntry(int hash, K key, V value, int bucketIndex) {
    HashMap.Entry<k,v> old = table[bucketIndex];
    Entry<k,v> e = new Entry<k,v>(hash, key, value, old);
    table[bucketIndex] = e;
    e.addBefore(header);
    size++;
}

protected boolean removeEldestEntry(Map.Entry<k,v> eldest) {
    <font color="red">return false;</font>
}
</k,v></k,v></k,v></k,v></k,v></pre>

<h2 id="实现LRU"><a href="#实现LRU" class="headerlink" title="实现LRU"></a>实现LRU</h2><p>LRU缓存LinkedHashMap(inheritance)实现</p>
<p>采用inheritance方式实现比较简单，而且实现了Map接口，在多线程环境使用时可以使用 <strong>Collections.synchronizedMap()</strong>方法实现线程安全操作</p>
<p>1、构造函数中调用父类的构造函数，accessOrder设置为true<br>2、重写removeEldestEntry，当元素数量大于缓存最大数量时，删除</p>
<pre>
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache2<k, v=""> extends LinkedHashMap<k, v=""> {

    private final int MAX_CACHE_SIZE;

    public LRUCache2(int cacheSize) {
        super ((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, <font color="red">true</font>);
        MAX_CACHE_SIZE = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        <font color="red">return size() > MAX_CACHE_SIZE;</font>
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<k, v=""> entry : entrySet()) {
            sb.append(String.format("%s:%s ", entry.getKey(), entry.getValue()));
        }       
        return sb.toString();
    }
}
</k,></k,></k,></pre>

<h2 id="实现FIFO"><a href="#实现FIFO" class="headerlink" title="实现FIFO"></a>实现FIFO</h2><p>1、只需重写removeEldestEntry就行，默认accessOrder就是false<br>2、重写removeEldestEntry方法，当缓存个数大于最大个数时，删除最先放进去的元素</p>
<pre><code>final int cacheSize = 5;
LinkedHashMap&lt;Integer, String&gt; lru = new LinkedHashMap&lt;Integer, String&gt;() {
    @Override   
    protected boolean removeEldestEntry(Map.Entry&lt;Integer, String&gt; eldest) {
        return size() &gt; cacheSize;
    }
};
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>LRU缓存实现(Java)</p>
<p><a href="http://transcoder.tradaquan.com/from=1086k/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%40320_1002%2Cta%40iphone_2_5.1_2_6.0/baiduid=99806F566512D4B5CD2F1444260EE0C9/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=7454783636244085594&amp;order=1&amp;fm=alop&amp;h5ad=1&amp;srd=1&amp;dict=32&amp;tj=www_normal_1_0_10_title&amp;url_mf_score=4&amp;vit=osres&amp;m=8&amp;cltj=cloud_title&amp;asres=1&amp;title=LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%28Java%29-%E6%87%92%E6%83%B0%E7%9A%84%E8%82%A5%E5%85%94-%E5%8D%9A%E5%AE%A2%E5%9B%AD&amp;w_qd=IlPT2AEptyoA_yitJU7mHiU5vhXPLqCyZhaDQ_&amp;sec=22108&amp;di=8c5570f1d6ae3a47&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAXinhMXmYGlGwdoSOxBt8w83c_79j7QwTaP1s&amp;clk_info=%7B%22srcid%22%3A%221599%22%2C%22tplname%22%3A%22www_normal%22%2C%22t%22%3A1498709801466%2C%22sig%22%3A%221646%22%2C%22xpath%22%3A%22div-a-h3%22%7D" target="_blank" rel="external">http://transcoder.tradaquan.com/from=1086k/bd_page_type=1/ssid=0/uid=0/pu=usm%401%2Csz%40320_1002%2Cta%40iphone_2_5.1_2_6.0/baiduid=99806F566512D4B5CD2F1444260EE0C9/w=0_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=7454783636244085594&amp;order=1&amp;fm=alop&amp;h5ad=1&amp;srd=1&amp;dict=32&amp;tj=www_normal_1_0_10_title&amp;url_mf_score=4&amp;vit=osres&amp;m=8&amp;cltj=cloud_title&amp;asres=1&amp;title=LRU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%28Java%29-%E6%87%92%E6%83%B0%E7%9A%84%E8%82%A5%E5%85%94-%E5%8D%9A%E5%AE%A2%E5%9B%AD&amp;w_qd=IlPT2AEptyoA_yitJU7mHiU5vhXPLqCyZhaDQ_&amp;sec=22108&amp;di=8c5570f1d6ae3a47&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IEQGG_ytK1DK6mlrte4viZQRAXinhMXmYGlGwdoSOxBt8w83c_79j7QwTaP1s&amp;clk_info=%7B%22srcid%22%3A%221599%22%2C%22tplname%22%3A%22www_normal%22%2C%22t%22%3A1498709801466%2C%22sig%22%3A%221646%22%2C%22xpath%22%3A%22div-a-h3%22%7D</a></p>
<p>基于LinkedHashMap实现LRU缓存调度算法原理及应用</p>
<p><a href="http://woming66.iteye.com/blog/1284326" target="_blank" rel="external">http://woming66.iteye.com/blog/1284326</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]11、迷宫问题-最短路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]11、迷宫问题-最短路径/" itemprop="url">11、迷宫问题-最短路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:30:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从（0，0）开始，目的地是（5，7），0表示可以走，1表示不可走，要求最短路径</p>
<p><img src="http://i.imgur.com/ztTNOdD.jpg" alt=""></p>
<h2 id="几个重点"><a href="#几个重点" class="headerlink" title="几个重点"></a>几个重点</h2><p>0、广度优先搜索找到的是最短路径</p>
<p>上次提交的层次遍历就是广度优先搜索</p>
<pre><code>//层次遍历模版
Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
//将根元素放入队列
queue.offer(root);
while(!queue.isEmpty()){
    //从队头取出元素，并访问
    TreeNode node = queue.poll();
    result.add(node.val);
    //将左右节点放入队列
    if(node.left != null){
        queue.offer(node.left);
    }
    if(node.right != null){
        queue.offer(node.right);
    }
}
</code></pre><p>1、运行8个方向：上、右上、右、右下、下、左下、左、左上</p>
<pre><code>int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
int[] y = {1, 1, 0, -1, -1, -1, 0, 1};
</code></pre><p>2、记录已经访问过</p>
<p>0表示可以访问，访问之后变成1，这样每个点只被访问一下</p>
<p>3、如何记录路径</p>
<pre><code>Point[][] pre = new Point[map.length][map[0].length];
</code></pre><p>一个二维数组，（i，j）记录上一个路径</p>
<p>4、注意点：</p>
<p>开始节点访问之后，记得标注为1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

public class Solution {

    public void BFS(int[][] map, Point start, Point end) {
        //基于当前节点上一个路径
        Point[][] pre = new Point[map.length][map[0].length];
        pre[start.x][start.y] = start;
        //队列
        Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;();
        queue.offer(start);
        map[start.x][start.y] = 1;
        //遍历方向
        int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
        int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

        while (!queue.isEmpty()) {
            Point current = queue.poll();
            //8个方向遍历
            for (int i = 0; i &lt; x.length; i++) {
                //判断是否越界，是否已经访问
                Point next = new Point(current.x + x[i], current.y + y[i]);
                //达到目录
                if (next.x == end.x &amp;&amp; next.y == end.y) {
                    System.out.println(next);
                    for (Point t = current; current != pre[current.x][current.y]; current = pre[current.x][current.y]) {
                        System.out.println(current);
                    }
                    System.out.println(start);
                    return;
                }

                if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                        &amp;&amp; map[next.x][next.y] == 0) {//0表示可以访问
                    queue.offer(next);
                    map[next.x][next.y] = 1;//标记已经访问过了
                    pre[next.x][next.y] = current;//记录路径
                }
            }
        }
    }

    public static void main(String[] args) {
        int[][] map = {
                {0, 1, 0, 1, 0, 0, 0, 1},
                {1, 0, 0, 1, 1, 0, 1, 0},
                {0, 1, 1, 0, 0, 1, 1, 1},
                {1, 0, 0, 1, 1, 0, 0, 1},
                {1, 0, 0, 0, 1, 1, 0, 1},
                {0, 1, 1, 1, 0, 0, 0, 0}
        };
        Solution s = new Solution();
        s.BFS(map, new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
    }
}

class Point {
    int x;
    int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return &quot;Point{&quot; +
                &quot;x=&quot; + x +
                &quot;, y=&quot; + y +
                &apos;}&apos;;
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]11、深度优先搜索、广度优先搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]11、深度优先搜索、广度优先搜索/" itemprop="url">11、深度优先搜索、广度优先搜索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T20:30:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迷宫问题（深度优先搜索解法）"><a href="#迷宫问题（深度优先搜索解法）" class="headerlink" title="迷宫问题（深度优先搜索解法）"></a>迷宫问题（深度优先搜索解法）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从（0，0）开始，目的地是（5，7），0表示可以走，1表示不可走，求所有路径</p>
<p><img src="http://i.imgur.com/ztTNOdD.jpg" alt=""></p>
<p>几个关键点：</p>
<p>1、深度优先模版</p>
<p>如果下一个路径没有越界，而且可以访问（数组中的值是0），那么继续在下一个节点上继续进行深度优先搜索</p>
<pre><code>public void DFS(int[][] map, Point current, Point start, Point end) {
    //遍历方向
    int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
    int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

    for (int i = 0; i &lt; x.length; i++) {
        Point next = new Point(current.x + x[i], current.y + y[i]);
        //剪枝
        if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                &amp;&amp; map[next.x][next.y] == 0) {
            DFS(map, next, start, end);
        }
    }
}
</code></pre><p>运行程序的时候发现一个问题，会出现<strong>相邻路径来回走</strong>，导致栈溢出，所以需要设置<strong>在当前遍历的路径中做上标记，在往前搜索的过程中不走回头路</strong></p>
<p>2、标记访问路径</p>
<p><img src="http://i.imgur.com/5LTdjLJ.jpg" alt=""></p>
<p>上图所示的就是来回走的一个案例，这个的解决方法就是在访问到节点后，设置标志位为1。</p>
<p>但是这会出现一个问题：如果这条路不通，换条路径访问的时候这个节点应该还是需要可以访问的，所以在这条路径回溯的时候，需要重新标注节点为未访问</p>
<p><strong>貌似标记的地方每次都是的DFS（）这个函数之前、之后</strong></p>
<pre><code>map[next.x][next.y] = 1;
DFS(map, next, start, end);
map[next.x][next.y] = 0;
</code></pre><p>3、记录路径</p>
<p>貌似每次也都是在DFS之前添加路径，在DFS之后删除路径</p>
<pre><code>path.add(next);
DFS(map, next, start, end);
path.remove(path.size() - 1);
</code></pre><p>4、</p>
<p>5、小技巧，防止起始点和终点被遍历到，初始化时将开头和结尾置为1</p>
<pre><code>int[][] map = {
        {0, 1, 0, 1, 0, 0, 0, 1},
        {1, 0, 0, 1, 1, 0, 1, 0},
        {0, 1, 1, 0, 0, 1, 1, 1},
        {1, 0, 0, 1, 1, 0, 0, 1},
        {1, 0, 0, 0, 1, 1, 0, 1},
        {0, 1, 1, 1, 0, 0, 0, 0}
};
map[0][0] = 1;
map[5][7] = 1;    
</code></pre><p>完整代码</p>
<pre><code>//current参数是重点，别的只是信息传递
public void DFS(int[][] map, Point current, Point start, Point end) {
    //遍历方向
    int[] x = {0, 1, 1, 1, 0, -1, -1, -1};
    int[] y = {1, 1, 0, -1, -1, -1, 0, 1};

    for (int i = 0; i &lt; x.length; i++) {
        Point next = new Point(current.x + x[i], current.y + y[i]);

        //找到了
        if (next.x == end.x &amp;&amp; next.y == end.y) {
            System.out.println(&quot;找到了：&quot; + ++count);
            System.out.println(path);
            continue;
        }

        //剪枝
        if (next.x &gt;= 0 &amp;&amp; next.x &lt;= end.x &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt;= end.y
                &amp;&amp; map[next.x][next.y] == 0) {
            System.out.println(next);
            path.add(next);
            map[next.x][next.y] = 1;
            DFS(map, next, start, end);
            map[next.x][next.y] = 0;
            path.remove(path.size() - 1);
        }
    }
}

public static void main(String[] args) {
    int[][] map = {
            {0, 1, 0, 1, 0, 0, 0, 1},
            {1, 0, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 0, 0, 1, 1, 1},
            {1, 0, 0, 1, 1, 0, 0, 1},
            {1, 0, 0, 0, 1, 1, 0, 1},
            {0, 1, 1, 1, 0, 0, 0, 0}
    };
    Solution s = new Solution();
    //s.BFS(map, new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
    map[0][0] = 1;
    map[5][7] = 1;
    s.DFS(map, new Point(0, 0), new Point(0, 0), new Point(map.length - 1, map[0].length - 1));
}
</code></pre><h2 id="迷宫问题（广度优先搜索解法）"><a href="#迷宫问题（广度优先搜索解法）" class="headerlink" title="迷宫问题（广度优先搜索解法）"></a>迷宫问题（广度优先搜索解法）</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/28/[数据结构与算法]10、全排列（DFS+剪枝）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/[数据结构与算法]10、全排列（DFS+剪枝）/" itemprop="url">10、全排列（DFS+剪枝）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T09:17:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：全排列"><a href="#题目：全排列" class="headerlink" title="题目：全排列"></a>题目：全排列</h2><p>例如ABC，全排列的结果是ABC、ACB、BAC、BCA、CAB、CBA</p>
<h2 id="递归穷举"><a href="#递归穷举" class="headerlink" title="递归穷举"></a>递归穷举</h2><p>1、穷举，遍历出所有结果。因为对于长度为n的字符串，<strong>需要n层for循环，代码没法写</strong>，所以需要利用递归实现</p>
<pre><code>for(int i = 0; i &lt; str.length(); i++){
    for(int i = 0; i &lt; str.length(); i++){
        for(int i = 0; i &lt; str.length(); i++){
            .....长度为n的字符串需要写n个for，代码没法写了
        }
    }
}
</code></pre><p>写成递归的形式：</p>
<pre><code>public void DFS(int step) {

    //递归结束
    if(step &gt;= str.length()){
        return;
    }

    for (int i = 0; i &lt; str.length(); i++) {
        System.out.println(str.charAt(i));
        DFS(step + 1);//进去都是for循环，和多个嵌套for一样，要注意结束点
    }
}
</code></pre><p>遍历结果：</p>
<p>a、a、a、b、c、b、a、b、c、c、a、b、c<br>b、a、a、b、c、b、a、b、c、c、a、b、c<br>c、a、a、b、c、b、a、b、c、c、a、b、c</p>
<p>参照画的图，结果一致：</p>
<p><img src="http://i.imgur.com/9IPlcrP.jpg" alt=""></p>
<h2 id="记录路径"><a href="#记录路径" class="headerlink" title="记录路径"></a>记录路径</h2><p>还是以循环的形式考虑，这个很容易理解</p>
<pre><code>List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();
for (int i = 0; i &lt; str.length(); i++) {
    path.add(i);
    for (int j = 0; j &lt; str.length(); j++) {
        path.add(j);
        for (int k = 0; k &lt; str.length(); k++) {
            path.add(k);
            //输出
            System.out.println(path);
            path.remove(path.size() - 1);
        }
        path.remove(path.size() - 1);
    }
    path.remove(path.size() - 1);
}
</code></pre><p>输出结果：</p>
<pre><code>[0, 0, 0]
[0, 0, 1]
[0, 0, 2]
[0, 1, 0]
[0, 1, 1]
[0, 1, 2]
[0, 2, 0]
[0, 2, 1]
[0, 2, 2]
[1, 0, 0]
[1, 0, 1]
[1, 0, 2]
[1, 1, 0]
[1, 1, 1]
[1, 1, 2]
[1, 2, 0]
[1, 2, 1]
[1, 2, 2]
[2, 0, 0]
[2, 0, 1]
[2, 0, 2]
[2, 1, 0]
[2, 1, 1]
[2, 1, 2]
[2, 2, 0]
[2, 2, 1]
[2, 2, 2]
</code></pre><p>现在改成递归的方式应该很容易了吧，<strong>你知道哪里应该add，哪里应该remove了</strong></p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            path.add(i);
            if(path.size() == str.length()){
                System.out.println(path);
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;abc&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);
    }

}
</code></pre><p>有个问题：输出是放在DFS（step + 1）前还是后面？</p>
<pre><code>if(path.size() == str.length()){
    System.out.println(path);
}
</code></pre><p>如果到达<strong>最后一层</strong>循环，这个DFS（step+1）相当于<strong>空函数！！</strong>，所以<strong>输出放在DFS(step + 1)前或者后都一样</strong></p>
<pre><code>for (int i = 0; i &lt; str.length(); i++) {
    //System.out.println(str.charAt(i));
    path.add(i);
    if(path.size() == str.length()){
        System.out.println(path);
    }
    DFS(step + 1);
    path.remove(path.size() - 1);
}
</code></pre><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p><img src="http://i.imgur.com/C15NY78.jpg" alt=""></p>
<p>红色描绘的路径是符合条件的全排列，观察后发现：</p>
<ul>
<li><strong>访问的路径节点之前已经存在</strong>，那么就需要剪枝</li>
<li>路径刚才我们已经保存了，所以可以做到</li>
</ul>
<p>加入节点前需要判断这个节点是否已经存在</p>
<pre><code>if(path.contains(i)){
    continue;
}
</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>递归完整版</p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            if(path.contains(i)){
                continue;
            }
            path.add(i);
            //输出
            if(path.size() == str.length()){
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;abc&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);
    }

}
</code></pre><p>循环完整版</p>
<pre><code>List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();
    for (int i = 0; i &lt; str.length(); i++) {
        if(path.contains(i)){
            continue;
        }
        path.add(i);
        for (int j = 0; j &lt; str.length(); j++) {
            if(path.contains(j)){
                continue;
            }
            path.add(j);
            for (int k = 0; k &lt; str.length(); k++) {
                if(path.contains(k)){
                    continue;
                }

                path.add(k);
                //输出
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();

                path.remove(path.size() - 1);
            }
            path.remove(path.size() - 1);
        }
        path.remove(path.size() - 1);
    }
}
</code></pre><h2 id="如果有重复"><a href="#如果有重复" class="headerlink" title="如果有重复"></a>如果有重复</h2><p>如果输入aac，将会输出</p>
<pre><code>a a c 
a c a 
a a c 
a c a 
c a a 
c a a 
</code></pre><p>有重复，为什么？为了区分用a1，a2表示</p>
<p>下图为按照未重复的时候的结果进行遍历、剪枝，打钩的即为需要保留的元素，与程序运行的一致</p>
<p><img src="http://i.imgur.com/vfH34t6.jpg" alt=""></p>
<p>下图中圈出来的路径需要被剪去，思考一下有什么特征？</p>
<p><img src="http://i.imgur.com/jv61CWg.jpg" alt=""></p>
<pre><code>a2、a1、c
a2、c、a1
c、a2、a1
</code></pre><p><strong>如果之前路径有相同的元素（这里是判断值相等，刚才是判断下标是否相等），而且当前下标比之前的小，则剪去</strong></p>
<p>代码如下：</p>
<pre><code>//重复元素
boolean flag = false;
for(Integer t : path){
    if(str.charAt(t) == str.charAt(i) &amp;&amp; i &lt; t){
        flag = true;
        break;
    }
}
if(flag){
    continue;
}
</code></pre><p>完整代码：</p>
<pre><code>public class Permutation {

    String str;
    List&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();

    public void DFS(int step) {

        if (step &gt;= str.length()) {
            return;
        }

        for (int i = 0; i &lt; str.length(); i++) {
            if(path.contains(i)){
                continue;
            }

            //重复元素
            boolean flag = false;
            for(Integer t : path){
                if(str.charAt(t) == str.charAt(i) &amp;&amp; i &lt; t){
                    flag = true;
                    break;
                }
            }
            if(flag){
                continue;
            }

            path.add(i);
            //输出
            if(path.size() == str.length()){
                //System.out.println(path);
                for(Integer t : path){
                    System.out.print(str.charAt(t) + &quot; &quot;);
                }
                System.out.println();
            }
            DFS(step + 1);
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        String str = &quot;aaaa&quot;;
        Permutation s = new Permutation();
        s.str = str;
        s.DFS(0);

    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/27/[Java并发编程]ConcurrentHashMap★★★（Happen Before、Volatile）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/[Java并发编程]ConcurrentHashMap★★★（Happen Before、Volatile）/" itemprop="url">ConcurrentHashMap★★★（Happen Before、Volatile）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T10:00:00+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://i.imgur.com/8TDvzvH.jpg" alt=""></p>
<p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>
<h2 id="并发读写考虑"><a href="#并发读写考虑" class="headerlink" title="并发读写考虑"></a>并发读写考虑</h2><p>1、<strong>非结构性修改操作</strong>只是更改某个 HashEntry 的 value 域的值。由于对 <strong>Volatile</strong> 变量的写入操作将与随后对这个变量的读操作进行同步。当一个写线程修改了某个 HashEntry 的 value 域后，另一个读线程读这个值域，Java 内存模型能够保证读线程读取的一定是更新后的值。所以，写线程对链表的非结构性修改能够被后续不加锁的读线程”看到”。</p>
<p>2、put-读</p>
<p>情况一：key已经存在，put操作为非结构性修改，查看1</p>
<p>情况二：新插入节点</p>
<p>put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。</p>
<p>采用头插法插入节点不影响读，<strong>每次遍历都是从头结点table[x]开始</strong>，即不影响读的遍历</p>
<p><img src="http://i.imgur.com/4BLoPBR.png" alt=""></p>
<p>3、remove-读</p>
<p><img src="http://i.imgur.com/jzXlXZm.jpg" alt=""></p>
<p><img src="http://i.imgur.com/wan6AGT.jpg" alt=""></p>
<p>和 get 操作一样，首先根据散列码找到具体的链表；然后遍历这个链表找到要删除的节点；<strong>最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中，直到复制完之后将table引用过去</strong></p>
<p>下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表</p>
<p>在执行 remove 操作时，<strong>原始链表并没有被修改</strong>，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p>
<p>4、clear-读</p>
<pre><code>void clear() {
    if (count != 0) {
        lock();
        try {
            HashEntry&lt;K,V&gt;[] tab = table;
            for (int i = 0; i &lt; tab.length ; i++)
                tab[i] = null;
            ++modCount;
            count = 0; // write-volatile
        } finally {
            unlock();
        }
    }
}
</code></pre><p>clear 操作只是把 ConcurrentHashMap 中所有的桶”置空”，<strong>每个桶之前引用的链表依然存在</strong>，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</p>
<h2 id="ConcurrentHashMap的get操作-volatile-★★★★★"><a href="#ConcurrentHashMap的get操作-volatile-★★★★★" class="headerlink" title="ConcurrentHashMap的get操作(volatile)★★★★★"></a>ConcurrentHashMap的get操作(volatile)★★★★★</h2><p><strong>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读？</strong>，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？</p>
<p>原因是它的<strong>get方法里将要使用的共享变量都定义成volatile</strong>，如用于统计当前Segement大小的 <strong>count</strong> 字段和用于存储值的 <strong>HashEntry 的 value</strong>。<br><br></p>
<font color="red">定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被<strong>单线程写</strong>（有一种情况可以被<strong>多线程写，就是写入的值不依赖于原值</strong>），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。</font>

<p><strong>之所以不会读到过期的值，是根据 java 内存模型的 happen before 原则，对 volatile 字段的写入操作先于读操作</strong>，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<p><strong>源码分析：</strong></p>
<pre><code>V get(Object key, int hash) {
    if (count != 0) { // read-volatile // ①
        HashEntry&lt;K,V&gt; e = getFirst(hash); 
        while (e != null) {
            if (e.hash == hash &amp;&amp; key.equals(e.key)) {
                V v = e.value;
                if (v != null)  // ② 注意这里
                    return v;
                return readValueUnderLock(e); // recheck
            }
            e = e.next;
        }
    }
    return null;
}
</code></pre><p>第一步，先判断一下 count != 0；count变量表示segment中存在entry的个数。如果为0就不用找了。</p>
<p>假设这个时候恰好另一个线程put或者remove了这个segment中的一个entry，会不会导致两个线程看到的count值不一致呢？</p>
<p>看一下count变量的定义： </p>
<pre><code>transient volatile int count;
</code></pre><p>它使用了volatile来修改。我们前文说过，Java5之后，JMM实现了对volatile的保证：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong>所以，每次判断count变量的时候，即使恰好其他线程改变了segment也会体现出来。</p>
<p>第二步，获取到要该key所在segment中的索引地址，如果该地址有相同的hash对象，顺着链表一直比较下去找到该entry。当找到entry的时候，先做了一次比较： if(v != null) ，这是为何呢？即<strong>如果get得到的结果是null，需要加锁读，否则直接返回</strong></p>
<p>考虑一下，如果这个时候，另一个线程恰好新增/删除了entry，或者改变了entry的value，会如何？</p>
<p>1) 在get代码的①和②之间，另一个线程新增了一个entry</p>
<p><img src="http://i.imgur.com/jO3Ir3q.jpg" alt=""></p>
<p>因为每个HashEntry中的next也是final的，没法对链表最后一个元素增加一个后续entry所以新增一个entry的实现方式只能通过头结点来插入了。</p>
<p>newEntry对象是通过 new HashEntry(K k , V v, HashEntry next) 来创建的。如果另一个线程刚好 <font color="red"><strong>new</strong></font> 这个对象时，当前线程来  <font color="red"><strong>get</strong></font> 它。<strong>因为没有同步，就可能会出现当前线程得到的newEntry对象是一个没有完全构造好的对象引用。</strong></p>
<p>回想一下我们之前讨论的DCL的问题，这里也一样，没有锁同步的话，new 一个对象对于多线程看到这个对象的状态是没有保障的，这里同样有可能一个线程new这个对象的时候还没有执行完构造函数就被另一个线程得到这个对象引用。</p>
<p>所以才需要判断一下：if (v != null) 如果确实是一个不完整的对象，则使用锁的方式再次get一次。</p>
<p><strong>有没有可能会put进一个value为null的entry？ 不会的，已经做了检查，这种情况会抛出异常</strong>，所以 ②处的判断完全是出于对多线程下访问一个new出来的对象的状态检测。</p>
<font color="red">注意：是否会出现 v！=null，但是返回的对象没有初始化，存在隐患？</font>

<p>如果对象HashEntry没有被volatile修饰，会出现这种情况。但是查看定义，<strong>HashEntry[]被volatile修饰。</strong></p>
<p>那么为什么不被volatile修饰，new HashEntry会出现引用不为null，但是对象未被初始化？</p>
<p>因为new的操作不是原子操作，分为1、分配内存 2、实例化 3、引用指向内存（此时不为null）</p>
<p><strong>但是指令重排序后，可能会出现1，3，2，此时在3是时候读取对象时不为null，但是对象未被初始化，出现隐患</strong></p>
<p>使用volatile修饰后，根据happen before原则，读操作必须在写之后，而且读线程是可见的</p>
<p><strong>所以，如果得到对象！=null，说明找到对象了，如果=null，可能是不存在，也可能是刚刚添加进去，等到put线程更新table指针，注意此时返回的元素是头指针，如果查找的就是刚刚添加的元素，释放锁后就能返回插入的结果</strong></p>
<p>2) 在get代码的①和②之间，另一个线程修改了一个entry的value</p>
<p><strong>value是用volitale修饰的，可以保证读取时获取到的是修改后的值。</strong></p>
<p>3) 在get代码的①之后，另一个线程删除了一个entry</p>
<p>假设我们的链表元素是：e1-&gt; e2 -&gt; e3 -&gt; e4 我们要删除 e3这个entry，因为HashEntry中next的不可变，所以我们无法直接把e2的next指向e4，而是将要删除的节点之前的节点复制一份，形成新的链表。</p>
<p>它的实现大致如下图所示：</p>
<p><img src="http://i.imgur.com/aNjCXWM.jpg" alt=""></p>
<p>如果我们get的也恰巧是e3，可能我们顺着链表刚找到e1，这时另一个线程就执行了删除e3的操作，<strong>而我们线程还会继续沿着旧的链表找到e3返回。这里没有办法实时保证了。</strong></p>
<p>我们第①处就判断了count变量，它保障了在 ① 处能看到其他线程修改后的。①之后到②之间，如果再次发生了其他线程再删除了entry节点，就没法保证看到最新的了。</p>
<p>不过这也没什么关系，即使我们返回e3的时候，它被其他线程删除了，暴漏出去的e3也不会对我们新的链表造成影响。</p>
<p>这其实是一种乐观设计，设计者假设 ① 之后到 ② 之间发生被其它线程增、删、改的操作可能性很小，所以不采用同步设计，而是采用了事后（其它线程这期间也来操作，并且可能发生非安全事件）弥补的方式。</p>
<p>而<font color="red"><strong>因为其他线程的”改”和”删”对我们的数据都不会造成影响，所以只有对”新增”操作进行了安全检查，就是②处的非null检查</strong></font>，如果确认不安全事件发生，则采用加锁的方式再次get。</p>
<h2 id="总结★★★★★"><a href="#总结★★★★★" class="headerlink" title="总结★★★★★"></a>总结★★★★★</h2><p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ul>
<li>用<strong>分离锁</strong>实现多个线程间的更深层次的共享访问。</li>
<li><strong>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</strong>（就是说当需要对链表结构进行改变时，对链表进行复制，先不更改原来的链表，然后操作完成之后再把table切换过去，在put/remove中体现）</li>
<li>通过对同一个 <strong>Volatile</strong> 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ul>
<h2 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h2><p>① <strong>程序次序法则</strong>：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。<br>② <strong>监视器锁法则</strong>：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。<br>③ volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</strong><br>④ 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。<br>⑤ 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。<br>⑥ 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。<br>⑦ 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。<br>⑧ <strong>传递性</strong>：如果A happens-before于B，且B happens-before于C，则A happens-before于C</p>
<p><strong>我们重点关注的是②，③，这两条也是我们通常编程中常用的。</strong></p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>使用锁方式实现”Happens-before”是最简单，容易理解的。</p>
<p><img src="http://i.imgur.com/Y2duLzx.jpg" alt=""></p>
<p>早期Java中的锁只有最基本的synchronized，它是一种互斥的实现方式。在Java5之后，增加了一些其它锁，比如ReentrantLock，它基本作用和synchronized相似，但提供了更多的操作方式，比如在获取锁时不必像synchronized那样只是<strong>傻等，可以设置定时，轮询，或者中断</strong>，这些方法使得它在获取多个锁的情况可以避免死锁操作。</p>
<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>JMM对Volatile的定义是：保证读写volatile都直接发生在main memory中，线程的working memory不进行缓存。它只承诺了读和写过程的可见性</p>
<p>Volatile可以看做一种轻量级的锁，但又和锁有些不同。</p>
<p>a) 它对于多线程，不是一种互斥（mutex）关系。<br>b) 用volatile修饰的变量，不能保证该变量状态的改变对于其他线程来说是一种”原子化操作”。</p>
<p>那对于”原子化操作”怎么理解呢？看下面例子：</p>
<pre><code>private static volatile int nextSerialNum = 0;

public static int generateSerialNumber(){
    return nextSerialNum++;
}
</code></pre><p>上面代码中对nextSerialNum使用了volatile来修饰，根据前面”Happens-Before”法则的第三条Volatile变量法则，看似不同线程都会得到一个新的serialNumber</p>
<p><strong>问题出在了 nextSerialNum++ 这条语句上，它不是一个原子化的</strong>，实际上是read-modify-write三项操作，<strong>这就有可能使得在线程1在write之前，线程2也访问到了nextSerialNum</strong>，造成了线程1和线程2得到一样的serialNumber。所以，在使用Volatile时，需要注意</p>
<p>使用场景：</p>
<ul>
<li>单线程写</li>
<li>被多线程写，就是写入的值不依赖于原值</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不变模式（immutable）是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。</p>
<p>不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让<strong>不可变形对象不需要同步就能自由地被访问和共享。</strong></p>
<h3 id="用Happens-Before规则理解一个经典问题：双重检测锁-DCL-为什么在java中不适用？"><a href="#用Happens-Before规则理解一个经典问题：双重检测锁-DCL-为什么在java中不适用？" class="headerlink" title="用Happens-Before规则理解一个经典问题：双重检测锁(DCL)为什么在java中不适用？"></a>用Happens-Before规则理解一个经典问题：双重检测锁(DCL)为什么在java中不适用？</h3><pre><code>public class LazySingleton {

    private static LazySingleton instance;

    private LazySingleton(){}

    public static LazySingleton getInstance() {
        if (instance == null) {// (2)
            synchronized (LazySingleton.class) { // (3)
              if (instance == null) { // (4)
                instance = new LazySingleton(); // (5)
              }
            }
        }
        return instance; // (6)
    }

}
</code></pre><p>假设线程1执行完(5)时，线程2正好执行到了(2)；</p>
<p>看看 new LazySingleton(); 这个语句的执行过程： 它不是一个原子操作，实际是由多个步骤，我们从我们关注的角度简化一下，简单的认为它主要有2步操作好了：</p>
<p>a） 在内存中分配空间，并将引用指向该内存空间。<br>b） 执行对象的<strong>初始化</strong>的逻辑(和操作)，完成对象的构建。</p>
<p>此时因为线程1和线程2没有用同步，他们之间不存在”Happens-Before”规则的约束，所以在线程1创建LazySingleton对象的 a),b)这两个步骤对于线程2来说会有可能出现a)可见，b)不可见<br>造成了<strong>线程2获取到了一个未创建完整的lazySingleton对象引用</strong>，为后边埋下隐患。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>多线程程序设计时需要考虑读-读、读-写、写-写</p>
<p>可以并发读：读不加锁<br>不能并发写：写加锁<br>写的时候不能影响正在读，或从头开始遍历的读</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/jianghuxiaojin/article/details/52006110" target="_blank" rel="external">http://blog.csdn.net/jianghuxiaojin/article/details/52006110</a></p>
<p><a href="http://blog.csdn.net/seapeak007/article/details/53409618" target="_blank" rel="external">http://blog.csdn.net/seapeak007/article/details/53409618</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/26/[分布式架构]构建高可用的系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/[分布式架构]构建高可用的系统/" itemprop="url">构建高可用的系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T21:46:00+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式架构/" itemprop="url" rel="index">
                    <span itemprop="name">分布式架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i.imgur.com/NO7vRM7.jpg" alt=""></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡分为硬件负载均衡和软件负载均衡</p>
<h3 id="防止单点"><a href="#防止单点" class="headerlink" title="防止单点"></a>防止单点</h3><p>负载均衡为避免自己成为单点，通常由两台机器构成，但只有一台处于服务状态，另一台则处于standby状态。一旦处于服务的那台机器出现问题，standby这台会自动接管</p>
<p><img src="http://i.imgur.com/Q2IQmQe.jpg" alt=""></p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>用户发送请求到负载均衡机器，负载均衡机器再将请求转发给实际的业务处理机器，通常负载均衡机器知道实际业务处理机器的IP地址，选择的方式如下：</p>
<p>1、随机选择<br>2、<strong>Hash选择</strong>。对应用层的请求信息做hash，这样可以保证每次请求的都是同一台机器，命中缓存。如查询图片<br>3、<strong>Round-Robin选择</strong>。按照处理机器的IP地址列表顺序选择，为了保持顺序选择时需要同步操作，但由于操作时间段性能损失很小，这种方式硬件负载和软件负载都支持，<strong>实际中使用最多</strong><br>4、按权重选择。根据每个地址的权重进行选择<br>5、按负载选择。根据实际业务处理机器的负载来选择，选择负载相对较低的机器来处理<br>6、按连接选择，让连接数相对较少的机器来处理业务，如果重启一台机器，可能会瞬间接收到大量请求，造成机器宕掉，这种方式实际应用很少</p>
<h3 id="跳过问题机器"><a href="#跳过问题机器" class="headerlink" title="跳过问题机器"></a>跳过问题机器</h3><p>为保证访问时跳过出问题的机器，通常采用的方法是负载均衡机器定时和实际的业务处理机器进行<strong>心跳</strong>（ping、端口检测、url侦测），发现心跳失败的机器并将它<strong>从可用地址列表中拿掉，在心跳成功后再重新加入可用列表中</strong></p>
<h3 id="响应返回方式"><a href="#响应返回方式" class="headerlink" title="响应返回方式"></a>响应返回方式</h3><p>业务处理机器处理完毕后，要将响应返回给用户，通常有两种返回方式：</p>
<p>1、响应通过负载均衡机器返回</p>
<p><strong>基于NAT实现</strong>，当请求从客户端发送至负载均衡机器时，负载均衡机器选择一台实际的业务处理机器，然后将<strong>请求报文的目标地址和端口改为实际业务处理机器的IP地址和端口</strong>，并将报文发送出去。当响应回到负载均衡机器上时，将报文的源地址和端口修改为负载均衡机器的VIP地址和端口</p>
<p><img src="http://i.imgur.com/TJ5MAmZ.jpg" alt=""></p>
<p>2、响应直接返回至请求发起方</p>
<p>响应直接返回至请求发起方可将请求包和响应包分开处理，以分散负载均衡机器的压力，使负载均衡机器可以支撑更大的请求量。要达到响应直接返回的效果，须要采用IP Tunneling或DR（Direct Routing，硬件负载设备中又简写为DSR：Direct Service Routing），这两种方式对负载均衡机器和实际业务处理机器的系统环境都有要求</p>
<p>①IP Tunneling</p>
<p>当采用IP Tunneling方式时，请求从客户端发送至负载均衡机器，负载均衡机器首先选择一台实际的业务处理机器，然后将请求的IP报文基于IP封装技术封装成另外一个IP报文，在做完以上处理后将报文发送出去，实际的业务处理机器收到报文后，先将报文解开获得目标地址为VIP的报文，处理完毕请求后，处理机器发现此VIP地址配置在本地的IP隧道设备上，则根据路由表将响应报文直接返回至请求方。IP Tunneling方式要求负载均衡机器和实际的业务处理机器的os都支持IP Tunneling，并将VIP地址同时配置在实际业务处理机器的IP隧道设备上</p>
<p><img src="http://i.imgur.com/CLTQdf4.jpg" alt=""></p>
<p>②Direct Routing</p>
<p>当采用Direct Routing方式时，请求从客户端发送至负载均衡机器，负载均衡机器首先选择一台实际的业务处理机器，然后将请求数据帧的MAC地址修改为此业务处理机器的MAC地址，并发送出去，实际的业务处理机器收到请求后，获取IP报文，当发现IP报文中的目标地址VIP配置在本地的网络设备上时，根据路由表将响应报文直接返回给用户。Direct Routing方式要求负载均衡机器和实际的业务处理机器在同一个物理网段中，并且不响应ARP</p>
<p><img src="http://i.imgur.com/97MaQPD.jpg" alt=""></p>
<p>根据上面的描述可以看出，IP Tunneling方式对系统环境的要求并不高，目前大部分的OS都支持IP Tunneling，Direct Routing方式对系统环境的要求则比较高，因此IP Tunneling方式更适合实现将响应直接返回给请求发起方，从而大幅度提升负载均衡机器所能支撑的请求量。</p>
<h3 id="软件负载"><a href="#软件负载" class="headerlink" title="软件负载"></a>软件负载</h3><p>1、LVS+KeepAlived</p>
<p>软件负载方案中最常用的为LVS（Linux Virtual Server），多数情况下采取<strong>LVS+Keepalived来避免负载均衡机器的单点，实现负载均衡机器的自动接管</strong>。</p>
<p>Keepalived基于<strong>VRRP</strong>（Virtual Router Redundancy Protocol）协议实现，在VRRP协议中，由一个Master的VRRP路由器和多个Backup的VRRP路由器构成<strong>VRRP虚拟路由器</strong>，但Master并不是永远不变的，Master的VRRP路由器会每隔一段时间发送广播包。当Backup VRRP路由器在连续三个周期内都收不到广播包时，即认为Master VRRP路由器出现问题，或收到优先级为0的广播包后，所有Backup VRRP路由器都发送VRRP广播信息，声称自己是Master，<strong>并将虚拟IP增加到当前机器上，从而保持对外提供的IP地址及MAC地址不变。</strong>Backup VRRP路由器收到VRRP广播信息后，首先比较优先级，如优先级比收到的VRRP广播信息中的优先级低，则重新将状态置为BACKUP。如优先级相等，则比较IP地址，IP值小的则重新将状态恢复为BACKUP，整个切换过程对于请求端而言是透明的。但由于VRRP方式依靠广播信息来确认是否健康，如网络上出现异常，有可能会出现多个Master的现象，这个时候会出现一些问题，因此当使用VRRP方式时要特别监测是否出现此类现象，一旦出现就要迅速人工介入处理。</p>
<p>2、硬件负载设备</p>
<p>除了采用Keepalived方式实现自动接管外，也可采用类似硬件负载设备的方式来实现，即<strong>采用心跳线+高可用软件来实现</strong>。在linux目前使用范畴最广的高可用软件为heartbeat，默认情况下heartbeat通过UDP方式来监测。</p>
<p>除LVS外，软件负载方案中还有像HAProxy这样的佼佼者，在考察采用哪种软件负载方案时，则要从应用场景、系统环境等多方面考虑。</p>
<h3 id="故障传播"><a href="#故障传播" class="headerlink" title="故障传播"></a>故障传播</h3><p>在系统从单机演变为集群后，可用性确实会得到一定提升，但随着系统功能的不断丰富，会出现<strong>多个系统访问同一系统提供的功能</strong>的情况，在这种情况下有可能会出现其中某个系统的访问导致其他系统故障。</p>
<p>对于以上这种故障传播的现象，通常会根据应用性质的不同做隔离的方案，通常采取配置多个不同的VIP的方法，<strong>各个系统通过域名访问，通过dns等方法使域名根据不同的系统解析为不同的VIP</strong>，从而实现根据应用性质不同来隔离，避免故障传播。</p>
<h2 id="热备"><a href="#热备" class="headerlink" title="热备"></a>热备</h2><p>热备通常对程序的要求不高，<strong>热备的情况下真正对外服务的机器只有一台，其他机器处于standby状态。</strong>standby机器通过心跳机制检查对外服务机器的健康状况，当出现问题时，其中一台standby机器即进行接管，机器间的状态同步至其他standby机器或写入一个集中存储设备，例如上述章节中LVS+Keepalived实现自动接管的方式</p>
<p>对于大型应用而言，除了单机故障外，<strong>还须考虑整个机房出现不可用的情况。如所有的应用都部署在单个机房，也可以认为是单点现象，</strong>一旦发生机房断电或机房出现不可抗力的灾难性事故时，整个系统的可用性就完全无法保障了，对于此类现象，通常采用多个机房的方法来避免，一方面可以做到其中一个机房出现问题时对整个系统不会产生太大的影响，另一方面也可以分流，提升性能。</p>
<h2 id="使用多机房——保持一致性"><a href="#使用多机房——保持一致性" class="headerlink" title="使用多机房——保持一致性"></a>使用多机房——保持一致性</h2><p>❶、主从同步</p>
<p>数据库数据的同步通常采用 <strong>单master、多slave</strong> 或 <strong>多master方案</strong>。单master方案只有一个写入点，其主要解决的是master同步到slave的问题，通常采取的是<strong>数据库自带的同步方案</strong>，例如oracle standby方案或mysql replication方案。</p>
<p>❷、分布式同步</p>
<p>多master方案有多个写入点，相对单master方案就复杂多了，通常采取的两阶段提交、三阶段提交或基于Paxos的方式来保持多master数据的一致性。</p>
<p>1、两阶段提交（2PC）保持一致性</p>
<p>在采用两阶段提交保证多master数据的一致性时，步骤为：</p>
<pre><code>1）开启事务；
2）通知每个master执行某操作；
3）所有master在接到请求后，锁定执行此操作需要的资源，例如假设是个扣款动作，那么先冻结相应的款项，冻结完毕后返回；
4）在收到所有master的反馈后，如均为可执行此操作，则继续之后的步骤，如有一个master反馈不能执行或一段时间内无反馈，则通知所有master回滚操作；
5）通知所有master完成操作。
两阶段提交方式相对而言比较易于实现，但问题在于所有的master都要冻结资源，而且一旦有一个master出现问题就要全部回滚。
</code></pre><p>2、三阶段提交（3PC）保持一致性</p>
<p>为了避免在通知所有master提交时，其中一个master crash不一致时，就出现了三阶段提交的方式。三阶段提交在两阶段提交的基础上增加了preCommit的过程，<strong>当所有master收到preCommit后，并不执行动作，直到收到commit或超过一定时间后才完成操作。</strong></p>
<p>在实现两阶段或三阶段提交时，为了避免通知所有master时出现问题，通常会借助消息中间件或让任意的一个master能够接管成为通知者。</p>
<p>3、基于Paxos保持一致性</p>
<p>Paxos最大的改变在于不要求所有master都反馈成功，<strong>只须有大多数反馈成功就执行了</strong>，更多具体的细节请参考相关文献。</p>
<p>总结：</p>
<p>文件的同步和内存数据的同步采取的方案和数据库数据同步的方案基本相同。<br>总的来说，由于采用多机房后带来的网络延时问题，技术上会出现不少的挑战，不过对于要求高可用的应用，采用多机房还是很有必要的。</p>
<h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><p>分布式文件系统采用的方法由众多普通PC Server机器构成巨大的存储池，<strong>每台机器只存储一部分数据</strong>，其本身通常可非常好地支持水平伸缩。例如一台机器能存储500GB数据，那么当要存储2000GB数据时，只要增加到四台机器即可</p>
<p><img src="http://i.imgur.com/Gj27UUY.jpg" alt=""></p>
<p>当Node A要上传文件时，Node A上的GFS Client会将文件按固定大小划分，并向主服务器提交<strong>文件名和块索引信息，从而得到要存储的目标机器及位置</strong>，主服务器根据目前各存储机器的存活状态、硬件使用率等来决定块需要存储到的目标机器，之后Node A将数据存储到目标机器的相应位置上。主服务器负责记录文件和块的命名空间、文件到块的映射及每个块副本的位置。</p>
<p>为了保证安全可靠，同时<strong>将数据复制到多个存储机器上</strong>，复制的份数可在主服务器上进行设置，当Node B要读取此文件时，则只要从主服务器上获取此文件划分的存储位置列表，然后随机挑选机器进行读取，最后<strong>根据块的索引进行合并即可</strong>。</p>
<h2 id="应用水平伸缩"><a href="#应用水平伸缩" class="headerlink" title="应用水平伸缩"></a>应用水平伸缩</h2><p>在系统建设初期，会采用将各种业务都放在同一个系统的方式，这会导致这个系统日渐庞大，所需的资源（CPU、内存、数据库连接）越来越多，在进行水平伸缩时要考虑系统里各种业务会造成的资源增加的现象，这种状况会导致水平伸缩很难进行。例如增加机器后就造成了多个数据库连接的增加，对于这样的状况，通常采取拆分应用的方式来解决。</p>
<p><strong>拆分应用通常按照业务领域来划分</strong>，即将原在同一系统中处理的功能拆分到各个不同的业务系统中，例如eBay将其业务系统拆分为商品、用户、评价、交易等</p>
<p><img src="http://i.imgur.com/XY3YCaY.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/25/[数据结构与算法]索引、高级树结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/[数据结构与算法]索引、高级树结构/" itemprop="url">索引、高级树结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T17:13:00+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是把一个关键码与它对应的数据记录的位置相关联的过程</p>
<p>索引文件记录了&lt;关键码，指针&gt;对，指针指向了文件的真实地址</p>
<h3 id="线性索引"><a href="#线性索引" class="headerlink" title="线性索引"></a>线性索引</h3><p>数据库中的记录是不等长的，而且无需存储的。但建立的索引文件是<strong>等长（Key，Point对）、按照关键字有序存储的</strong>，这样可以方便进行二分查找；索引文件的指针指向磁盘文件的地址</p>
<p><img src="http://i.imgur.com/1DXYCvu.png" alt=""></p>
<p>如果线性索引太大，可以存储在磁盘中。但是一次检索过程中会有多次访问磁盘，从而影响检索的效率，可以使用<strong>二级线性索引</strong></p>
<h3 id="二级线性索引"><a href="#二级线性索引" class="headerlink" title="二级线性索引"></a>二级线性索引</h3><p>如果一级索引太大无法直接读入内存，可以存入磁盘中，存在<strong>连续的磁盘块中</strong>。二级线性对磁盘块进行索引</p>
<p><img src="http://i.imgur.com/5DF8sRQ.png" alt=""></p>
<p>二级线性索引能快速索引到<strong>磁盘块</strong>：</p>
<ul>
<li>二级线性索引的关键码与磁盘块第一条记录的值相等</li>
<li>指针指向响应磁盘块的其实位置</li>
</ul>
<p><img src="http://i.imgur.com/OmgLiY6.png" alt="">、、</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>对某属性按属性值建立索引；因为不是由记录关键码来确定属性值，而是由属性值来确定记录的位置，因此成为倒排索引</p>
<p>这些属性往往是<strong>离散型</strong>的，对于连续型的用B树</p>
<p>举个例子，假设EMP是主键，其余的是属性。如果不建立属性倒排索引，如果需要查找属性为某个值的记录，那么需要从头开始读取记录，判断每条记录的属性是否是查询的值，非常耗时</p>
<p><img src="http://i.imgur.com/cCjGMrk.png" alt=""></p>
<p>倒排文件的索引项是（key，point[]）：</p>
<ul>
<li>一个具体的索引值</li>
<li>一组指针（因为属性值不是唯一的，一个属性会对应多条记录）</li>
</ul>
<p>对上述记录建立的倒排文件如下，可以根据属性获得主键ID，然后再通过主键查询记录</p>
<p><img src="http://i.imgur.com/7Ty52wU.png" alt=""></p>
<h3 id="正文索引"><a href="#正文索引" class="headerlink" title="正文索引"></a>正文索引</h3><p>对文本内容进行快速检索</p>
<ul>
<li>词索引：从正文中抽出关键词，对关键词进行快速索引</li>
<li>全文索引：把正文看做一个长的字符串，对每一个字符建立索引，使查找不再限于关键词，需要更大的空间</li>
</ul>
<p>建立正文倒排索引步骤：</p>
<p>1、把正文分成多条记录<br>2、每条记录赋予一个关键词<br>3、建立正文倒排文件</p>
<p>倒排文件的索引结构：</p>
<p><img src="http://i.imgur.com/Ib1kiRz.png" alt=""></p>
<h2 id="高级树结构"><a href="#高级树结构" class="headerlink" title="高级树结构"></a>高级树结构</h2><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie来源于retrieval，即检索</p>
<p>基于关键码分解的数据结构，常应用于信息检索、存储英文字符串</p>
<p>下面展示的Trie结构的树，<strong>人为指定左右节点的范围</strong>，使树的分布相对均匀；如在根节点，将小于32的树放在左子树，大于32的树放入右子树</p>
<p><img src="http://i.imgur.com/BGjZxHO.png" alt=""></p>
<h3 id="英文字符树"><a href="#英文字符树" class="headerlink" title="英文字符树"></a>英文字符树</h3><p>按照英文字幕的索引建立索引，即前缀树</p>
<p><img src="http://i.imgur.com/VPBvjz0.png" alt=""></p>
<p>对于不等长的字符串，比如规定字符串的长度是3，那么对于字符串an，可以转换成an*；检索时检索到*表示检索结束</p>
<p><img src="http://i.imgur.com/4kUY7zI.png" alt=""></p>
<h3 id="平衡的二叉搜索树（AVL）"><a href="#平衡的二叉搜索树（AVL）" class="headerlink" title="平衡的二叉搜索树（AVL）"></a>平衡的二叉搜索树（AVL）</h3><p>平衡的二叉搜索树定义：左右节点的高度小于等于1</p>
<p><strong>插入节点后，根节点的变化大致有三类：</strong></p>
<ul>
<li>原来节点时平衡的，现在成为左重或右重的</li>
<li>节点原来是某一边重，而现在成为平衡的了</li>
<li>节点原来是左重或右重的，又加到重的一边，<strong>现在不平衡了</strong>，需要进行调整！！！</li>
</ul>
<p><strong>举个例子：</strong></p>
<p>如下图，插入17前是平衡树，节点2的平衡因子是+1，即右子树比左子树高度大1；节点15是平衡的；<br>插入17后，节点2的平衡因子变成2，节点1的平衡因子变成1，失衡了，<strong>需要调整节点2，节点15，节点7之间的关系</strong></p>
<p>很简单，用中间值15作为根节点，12小于15作为左节点，17大于15作为右节点，调整后如下：</p>
<p><img src="http://i.imgur.com/zBKQlJG.png" alt=""></p>
<font color="red">可以发现，调整之前，节点2的高度是2，调整之后，节点2的高度还是2，没有变化，所以不影响其他节点</font>

<p><strong>插入节点时平衡因子变化</strong></p>
<ul>
<li>不平衡的情况发生在插入新节点后</li>
<li><strong>BST把新节点插入到叶结点</strong>★★★（根节点与叶节点交换，然后插入）</li>
<li>假设a是离插入节点最近，且平衡因子绝对值不等于0的节点（如果节点的平衡因子等于0不需要调整结构）<ul>
<li>插入的关键码要么在它的左子树中，要么在其右子树中</li>
<li><strong>假设插入在右边</strong>，此时a的平衡因子有三种情况：-1，0，1，如下图</li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/4alZl20.png" alt=""></p>
<p>1、原来a的平衡因子是-1，即左子树的高度比右子树的高度大1。右边插入节点后，平衡因子变成0，左右子树高度相等，变平衡了<br>2、原来a的平衡因子是0，左右子树高度相等。右边插入节点后，右子树的高度比左子树高度大1，平衡因子变为1<br>3、左图a的平衡因子变成2，b的平衡因子为1，<font color="red">需要调整</font>；右图a的平衡因子变成，b的平衡因子编程-1，<font color="red">需要调整</font>；</p>
<p><strong>不平衡的情况总结★★★★</strong></p>
<p><img src="http://i.imgur.com/tfK5H9S.png" alt=""></p>
<p>分为四种：LL，LR，RL，RR，其中LL和RR比较相似，LR和RL相似</p>
<p><strong>LL</strong></p>
<p>如下图有一颗平衡树，其中T1、T2、T3都表示子树，他们的高度都是h。那么节点B的平衡因子是0，节点A的平衡因子是-1，中序遍历的结果是：T1、B、T2、A、T3</p>
<p>此时如果在A的左子树中插入一个节点，会造成节点A的平衡因子变成-2，造成树不平衡</p>
<p><img src="http://i.imgur.com/h9NsaHS.jpg" alt=""></p>
<p>LL主要节点是A、B、T1，三者的大小关系是T1&lt;B&lt;A， B为A和T1的分割节点，调整时保持B不变，将A右旋</p>
<p><strong>先确定T、B、A的位置，T1和A各自的子节点保持不变；在A右旋的时候，替换了B的右节点，所以将B的有节点T2挂载挂在A的左节点上</strong></p>
<p><img src="http://i.imgur.com/zVVdLOn.jpg" alt=""></p>
<p>调整后中序遍历结果没有变化，树保持平衡</p>
<p><img src="http://i.imgur.com/I6vDXgv.jpg" alt=""></p>
<p><strong>RL</strong></p>
<p><img src="http://i.imgur.com/vckMLrR.jpg" alt=""></p>
<p><img src="http://i.imgur.com/7WY6ERj.jpg" alt=""></p>
<p><img src="http://i.imgur.com/ivnDQpp.jpg" alt=""></p>
<p><img src="http://i.imgur.com/1TST6pV.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/24/[数据库]5、B数、B+数、红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/[数据库]5、B数、B+数、红黑树/" itemprop="url">5、B数、B+数、红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T22:08:00+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p><img src="http://i.imgur.com/AURzDMV.png" alt=""></p>
<p>关键字 1-2 个<br>子节点 2-3 个</p>
<p>平衡树：子节点的高度一致</p>
<h2 id="B树（Balacned-Tree）"><a href="#B树（Balacned-Tree）" class="headerlink" title="B树（Balacned Tree）"></a>B树（Balacned Tree）</h2><p><strong>一种平衡的多分树</strong></p>
<p>平衡：所有的叶结点在同一层，所以每个子节点的高度一致</p>
<h3 id="m阶B树的结构定义"><a href="#m阶B树的结构定义" class="headerlink" title="m阶B树的结构定义"></a>m阶B树的结构定义</h3><p>1、每个结点至多有m个子结点<br>2、除根节点和叶节点外，其他每个结点至少有m/2（向上取整）个结点<br>3、根结点至少有两个子结点</p>
<ul>
<li>唯一例外的是根节点就是叶结点时没有子结点</li>
<li>此时B树只包含一个结点</li>
</ul>
<p>4、所有的叶结点在同一层（平衡）<br>5、有k个子节点的非根节点恰好包含k-1个关键码</p>
<h3 id="B树的性质"><a href="#B树的性质" class="headerlink" title="B树的性质"></a>B树的性质</h3><p>1、树高平衡，所有叶结点都在同一层<br>2、关键码没有重复，<strong>父结点中的关键码是其子结点的分界</strong><br>3、<strong>B树把（值接近）相关记录放在同一个磁盘页中，从而利用局部性原理</strong><br>4、B树保证树中至少有一定比例的结点是满的（每个结点有至少有m/2个子节点，半满）</p>
<ul>
<li>这样能改进空间的利用率（如果每个节点只有1个子节点，BST，树高会很高，空间利用率低）</li>
<li>减少索引和更新操作的磁盘读取数目（如果每个节点有m个子节点，全满，那么每次插入的时候没处插了）</li>
</ul>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>除根节点和叶节点外，M阶B树每个节点有m/2~m个结点，根节点至少有两个子节点（插入时多次分裂）</li>
<li>有k个子节点的非根节点恰好包含k-1个关键码</li>
<li>父结点中的关键码是其子结点的分界</li>
</ul>
<h3 id="B树的节点结构"><a href="#B树的节点结构" class="headerlink" title="B树的节点结构"></a>B树的节点结构</h3><p>B树的一个包含j个关键码，j+1个指针的节点的一般形式为：</p>
<pre><code>P0，K1，P1，K2，P2....Kj，Pj  #j个关键码，j+1个指针指向子节点
</code></pre><p>其中ki是关键码值，K1&lt;K2&lt;….&lt;Kj<br>Pi是指向Ki到Ki+1之间的关键码的子树的指针</p>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>如果有j个关键字，那么有可以表示j+1个区间，即有j+1个子节点</li>
<li>关键词下标从1开始，P从0开始，Pi是指向Ki到Ki+1之间的关键码的子树的指针</li>
<li>举个例子：P0指向K0到K1之间，即小于K1的，P1指向K1到K2</li>
</ul>
<p><img src="http://i.imgur.com/0I002wG.png" alt=""></p>
<h3 id="B树结点抽象数据类型"><a href="#B树结点抽象数据类型" class="headerlink" title="B树结点抽象数据类型"></a>B树结点抽象数据类型</h3><pre><code>class BNode{
    int n;//子节点的个数
    BNode&lt;Key&gt; *parent;//指向父节点的指针（可有可不有）
    Key key[MAXREC];//存储关键码的数组，最多有MAXREC个关键码
    BNode&lt;Key&gt; *ptr[MAXREC+1];//指向子节点的指针，最多有MAXREC+1个指针
}
</code></pre><h3 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h3><p>1、把根节点读出来，在根节点所包含的关键码K1…Kj中查找给定的关键码值。当关键码不多时，就用顺序检索，当节点包含的关键码较多时，可以用二分检索。如果找到则检索成功</p>
<p>2、否则，确定要查的关键码指在某个Ki和Ki+1之间，那么去Pi所指向的节点继续查找</p>
<p>下图为查找24的过程</p>
<p><img src="http://i.imgur.com/55g1tMJ.png" alt=""></p>
<p>如果树高为h，则查找时访问外存的次数是h</p>
<p>注意：<br><strong>每个关键码表示索引，找到索引后，每个关键码还对应一个指向外存的指针，这样通过索引才可以访问到完整的记录</strong></p>
<h3 id="B树的插入（分裂向上生长）"><a href="#B树的插入（分裂向上生长）" class="headerlink" title="B树的插入（分裂向上生长）"></a>B树的插入（分裂向上生长）</h3><p>情况1：</p>
<p>首先判断关键码14是否存在，按照图中的轨迹查找，此时到15所在的节点，遍历后发现没有14，则在该节点中插入</p>
<p>此时外存读的次数是3，写的次数是1</p>
<p><img src="http://i.imgur.com/mbAsXfh.png" alt=""></p>
<p>情况2：</p>
<p>插入可能导致B树朝着根的方向生长，即当插入位置超过关键字的最大个数，<strong>节点需要进行分裂</strong></p>
<p>如插入55，但2-3树要求关键字数只由1~2个，此时插入节点50，52已经达到个数，55无法直接插入，需要进行分裂</p>
<p><img src="http://i.imgur.com/H7UFbSW.png" alt=""></p>
<p>50 52 55如何拆分？</p>
<p>父节点需要增加一个节点进行区分子节点拆分后的节点，采用二分的方法，将<strong>中间</strong>的52送到父节点，得到结果：</p>
<p>此时读的次数3，写的次数3（申请两个节点，并分别写入，这里包含两次写，还有在父节点中写入1次）</p>
<p><img src="http://i.imgur.com/G6v7NrJ.png" alt=""></p>
<p>情况3：</p>
<p>多次分裂，树向上生长</p>
<p><img src="http://i.imgur.com/pSZFrHr.png" alt=""></p>
<p>最终的结果是：</p>
<p><img src="http://i.imgur.com/JxhAKc6.png" alt=""></p>
<h3 id="B数的删除（向左或向右合并）"><a href="#B数的删除（向左或向右合并）" class="headerlink" title="B数的删除（向左或向右合并）"></a>B数的删除（向左或向右合并）</h3><p>6阶B树删除45</p>
<p>对于6阶B树，子节点树要求m/2~m，即 3~6，<strong>关键码的个数为2~5</strong>，在删除的过程中需要<strong>防止下溢出</strong>，即关键码的数量小于规定的个数</p>
<p><img src="http://i.imgur.com/yK13FBp.png" alt=""></p>
<p>在删除掉45后，当前节点只有110一个关键字，下溢出了。其中一种方案是<strong>向左右节点借关键码，同时要将父节点拉下来</strong>，这里演示向右节点借关键码。此时合并的关键码有110，112，135，143，212，需要进行分裂，根据二分分裂的方式，将135移到父节点，即用135替换123，然后子节点分裂，反别是110，112和142，212，结果是：</p>
<p><img src="http://i.imgur.com/CoU6eYL.png" alt=""></p>
<p>给出一个极限情况下删除的例子：</p>
<p>删除的时候如果发生下溢出，即当前关键码个数小于定义的个数，则需要进行合并，向左节点或有节点合并</p>
<p>如果删除后，节点为0仍保持0的状态，按照向左向右合并的方式进行操作</p>
<p><img src="http://i.imgur.com/pFdZra1.jpg" alt=""></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的一种变形，<strong>是在叶结点上存储信息的树</strong>：</p>
<ul>
<li>所有的管家那么均出现在叶结点上</li>
<li>各层节点中的关键码均是下一层相应节点中最大关键码（或最小关键码）的复写</li>
</ul>
<h3 id="B-树的结构定义"><a href="#B-树的结构定义" class="headerlink" title="B+树的结构定义"></a>B+树的结构定义</h3><ul>
<li>每个节点至多有m个子节点</li>
<li>每个结点（除根外）至少有m/2（向上取整）个子结点</li>
<li>根节点至少有两个子结点</li>
<li><strong>有k个子结点的必有k个关键码</strong>（这个是与B树的差别）</li>
</ul>
<font color="red"><strong>QM总结：</strong></font>

<ul>
<li>根节点有2~m个子节点</li>
<li>除根节点外有m/2（向上取整）~m个子结点</li>
<li>有k个子结点的节点有k个关键字（这是与B树的结构差别，B树有k-1个关键字）</li>
</ul>
<p><img src="http://i.imgur.com/SWjSq7P.png" alt=""></p>
<ul>
<li>m阶B+树有m个子节点，也有m个关键字</li>
<li>m个关键字是子结点的复写，当前层的关键码是其每个子结点关键码的最大关键码（也可以是最小）</li>
<li>根节点是线性索引，可以顺序查找；再加上多分树形查找</li>
<li>树形索引中不包含指向真实数据位置的指针，必须索引到树的叶子节点才算找到；<strong>好处是可以提高树的阶数，降低树的高度，加速索引速度</strong></li>
</ul>
<h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>如下3阶B+树，节点最多有3个关键码，当插入15后，查询到10 23这个节点，插入15。父节点不需要重写</p>
<p><img src="http://i.imgur.com/DFBPxEe.png" alt=""></p>
<p>3阶B+树插入16后，叶子节点的关键为16超过最大阶3，所以需要分类成10、15和16、23，并增加分类节点之间的线性链接，修改父节点的关键码，每个关键码是子结点关键码最大值的复写</p>
<p><img src="http://i.imgur.com/IQy3m4D.png" alt=""></p>
<p>多次分裂</p>
<p><img src="http://i.imgur.com/Bsdyx8M.jpg" alt=""></p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>如下B+树删除23，首先需要查找23；第一个节点判断，23&lt;=35，到第二个子结点查找；23&lt;=23，在第一个子结点中查找；删除关键码23；</p>
<p>此时父节点中的23能够正确标识父节点的区间，所以不进行更新（类似线段树中的延迟更新）</p>
<p><img src="http://i.imgur.com/x8PASHT.png" alt=""></p>
<h2 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h2><p>节点结构：</p>
<ul>
<li>当前节点有k个子结点，B树有k-1个关键码，B+树有k个关键码</li>
<li>B树当前节点的关键码类似BST是子结点关键码的分割，B+树当前节点的关键码是子结点的复写（子结点关键码的最大值或最小值）</li>
</ul>
<p>查找：</p>
<p>B树每个节点保存了指向真实位置的指针，找到关键码就能找到真实位置；B+树必须索引到叶子节点；B+树提供了索性查找和顺序查找两种方式</p>
<p>实际中使用B+树特别多</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>第10章 索引——2（B树,B树） 标清<br><a href="https://www.youtube.com/watch?v=vBD6Ve8VryY" target="_blank" rel="external">https://www.youtube.com/watch?v=vBD6Ve8VryY</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2017/06/23/[NIO]NIO快速入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/23/[NIO]NIO快速入门/" itemprop="url">NIO快速入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T16:36:00+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NIO/" itemprop="url" rel="index">
                    <span itemprop="name">NIO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要NIO"><a href="#为什么需要NIO" class="headerlink" title="为什么需要NIO"></a>为什么需要NIO</h2><p>1、Java I/O是阻塞的，当线程调用read（）或write（）时，线程是阻塞的，直到数据读取、写入完毕，在此期间线程不能再干其他任何事情了。</p>
<p>2、这种方式对于小规模的程序非常方便，但是对于存在大量并发连接的时候，需要为每一个连接建立一个线程来操作，这种做法存在以下缺陷：</p>
<ul>
<li>并发数与线程数成正比，线程是宝贵的系统资源，当线程数过大会导致系统的性能急剧下降，并发量有限</li>
<li></li>
</ul>
<h2 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h2><p>1、面向流与面向缓冲xxxxxxxxxxxx</p>
<p>IO是面向流的，NIO是面向缓冲区的。<strong>Java IO</strong>面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；<strong>NIO</strong>的将数据存放到一个缓冲区，当缓冲区中包含需要处理的数据</p>
<p>2、阻塞与非阻塞IOxxxxxxxxxxxxxxxxxx</p>
<p><strong>Java IO</strong>的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。<strong>Java NIO</strong>的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h2 id="NIO原理"><a href="#NIO原理" class="headerlink" title="NIO原理"></a>NIO原理</h2><p>除了普通的Socket与ServerSocket实现的阻塞式通信外，Java提供了非阻塞式通信的NIO API。先看一下NIO的实现原理，<strong>NIO中三个重要的类：Selector、Channel、Buffer</strong></p>
<p><img src="http://i.imgur.com/BYMk6vz.png" alt=""></p>
<p>从图中可以看出，服务器上所有Channel（包括ServerSocketChannel和SocketChannel）都需要向Selector注册，而该Selector则负责监视这些Socket的IO状态，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数，该整数值就表示该Selector上有多少个Channel具有可用的IO操作，并提供了selectedKeys（）方法来返回这些Channel对应的SelectionKey集合。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()方法即可知道当前所有Channel是否有需要处理的IO操作。</p>
<p>总结：</p>
<p>1、所有 Channel 需要向 Selector 注册<br>2、Selector 监听 Socket 的 IO 状态，当其中任意一个 Channel 具有可用的 IO 操作时，Selector 的 select（）方法返回大于0的整数，表示有多少个 Channel 具有可用的 IO 操作，并提供 selectedKeys 返回这些 Channel 对应的 SelectionKey 集合</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Java网络编程——使用NIO实现非阻塞Socket通信<br><a href="http://blog.csdn.net/yanmei_yao/article/details/8586199" target="_blank" rel="external">http://blog.csdn.net/yanmei_yao/article/details/8586199</a></p>
<p>Java NIO 网络编程<br><a href="https://my.oschina.net/gaoguofan/blog/753213" target="_blank" rel="external">https://my.oschina.net/gaoguofan/blog/753213</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">138</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">85</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
