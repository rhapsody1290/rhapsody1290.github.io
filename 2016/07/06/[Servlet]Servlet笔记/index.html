<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaEE,Servlet," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="常用#网页输出
PrintWriter out = response.getWriter();
out.println(&amp;quot;Hello World&amp;quot;);
#请求头
request.getHeader(&amp;quot;host&amp;quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&amp;lt;String&amp;gt; names = request.getHead">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet笔记">
<meta property="og:url" content="http://qianmingxs.com/2016/07/06/[Servlet]Servlet笔记/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta property="og:description" content="常用#网页输出
PrintWriter out = response.getWriter();
out.println(&amp;quot;Hello World&amp;quot;);
#请求头
request.getHeader(&amp;quot;host&amp;quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&amp;lt;String&amp;gt; names = request.getHead">
<meta property="og:image" content="http://i.imgur.com/jvuMyhS.png">
<meta property="og:image" content="http://i.imgur.com/0HhKiSj.png">
<meta property="og:image" content="http://i.imgur.com/6yEbnhC.png">
<meta property="og:image" content="http://i.imgur.com/6IcaPJQ.gif">
<meta property="og:image" content="http://i.imgur.com/VYwK3wL.png">
<meta property="og:image" content="http://i.imgur.com/ogGRxkN.png">
<meta property="og:image" content="http://i.imgur.com/ZyoAE8n.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160607204306776">
<meta property="og:image" content="http://i.imgur.com/zplY6DJ.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160608153021012">
<meta property="og:image" content="http://img.blog.csdn.net/20160608154011510">
<meta property="og:image" content="http://i.imgur.com/ihpk6OJ.png">
<meta property="og:image" content="http://i.imgur.com/jnEcC7g.png">
<meta property="og:image" content="http://i.imgur.com/FlOMxdb.png">
<meta property="og:image" content="http://i.imgur.com/LarH0Wk.png">
<meta property="og:image" content="http://i.imgur.com/Klh1fzm.png">
<meta property="og:image" content="http://i.imgur.com/mqreaNv.png">
<meta property="og:image" content="http://i.imgur.com/5S0gzS0.png">
<meta property="og:image" content="http://i.imgur.com/OirpKFm.png">
<meta property="og:image" content="http://i.imgur.com/V7Ec9aU.png">
<meta property="og:image" content="http://i.imgur.com/S75GBO8.png">
<meta property="og:image" content="http://i.imgur.com/SSL3f5N.png">
<meta property="og:image" content="http://i.imgur.com/4vvjT4z.png">
<meta property="og:updated_time" content="2016-11-29T03:37:24.603Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Servlet笔记">
<meta name="twitter:description" content="常用#网页输出
PrintWriter out = response.getWriter();
out.println(&amp;quot;Hello World&amp;quot;);
#请求头
request.getHeader(&amp;quot;host&amp;quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&amp;lt;String&amp;gt; names = request.getHead">
<meta name="twitter:image" content="http://i.imgur.com/jvuMyhS.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://qianmingxs.com/2016/07/06/[Servlet]Servlet笔记/"/>


  <title> Servlet笔记 | Mr.Qian's Home </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Qian's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Servlet笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T11:17:00+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Servlet/" itemprop="url" rel="index">
                    <span itemprop="name">Servlet</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/06/[Servlet]Servlet笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/06/[Servlet]Servlet笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><pre><code>#网页输出
PrintWriter out = response.getWriter();
out.println(&quot;Hello World&quot;);
#请求头
request.getHeader(&quot;host&quot;)//参数见http请求头那节
//获取所有请求体
Enumeration&lt;String&gt; names = request.getHeaderNames();
while(names.hasMoreElements()){
    String name = names.nextElement();
    System.out.println(name + &quot;：&quot; + request.getHeader(name));
}
#浏览器返回
response.setContentType(&quot;text/html;charset=utf-8&quot;);
response.setCharacterEncoding(&quot;utf-8&quot;);
#获得请求参数
String username = request.getParameter(&quot;username&quot;);
Enumeration&lt;String&gt; e = request.getParameterNames()
#跳转
1、request.getRequestDispatcher(&quot;/资源URI&quot;).forward(request,response)
2、response.sendRedirect(&quot;/web应用/资源URI&quot;);
#获得web应用根路径
String path = this.getServletContext().getRealPath(&quot;/&quot;);
#获得资源路径
String path = this.getServletContext().getRealPath(&quot;/image/无标题.png&quot;);
#session，可以存字符串和对象
request.getSession().setAttribute(&quot;username&quot;,username);
request.getSession().getAttribute(&quot;username&quot;)
</code></pre><h2 id="为什么需要Servlet技术？"><a href="#为什么需要Servlet技术？" class="headerlink" title="为什么需要Servlet技术？"></a>为什么需要Servlet技术？</h2><p>　　普通的java技术很难完成网站开发，sun 就开发了servlet技术供程序员使用</p>
<h2 id="servlet的介绍"><a href="#servlet的介绍" class="headerlink" title="servlet的介绍"></a>servlet的介绍</h2><ul>
<li>servlet 其实就是java程序(java类)</li>
<li>该 java程序(java 类)要遵循servlet开发规范，继承servlet类</li>
<li>serlvet是运行在服务端</li>
<li>serlvet功能强大,几乎可以完成网站的所有功能</li>
<li>是学习jsp基础</li>
</ul>
<h2 id="Tomcat-和-servlet-在网络中的位置"><a href="#Tomcat-和-servlet-在网络中的位置" class="headerlink" title="Tomcat 和 servlet 在网络中的位置"></a>Tomcat 和 servlet 在网络中的位置</h2><p><img src="http://i.imgur.com/jvuMyhS.png" alt=""></p>
<h3 id="Tomcat三大功能"><a href="#Tomcat三大功能" class="headerlink" title="Tomcat三大功能"></a>Tomcat三大功能</h3><ul>
<li>Web服务器，与浏览器通信，解析和处理HTTP请求，处理静态页面</li>
<li>Servlet容器（Catalina），处理Servlet</li>
<li>JSP容器，把JSP页面翻译成一般的Servlet</li>
</ul>
<h3 id="Servlet容器与Servlet关系★★★★★"><a href="#Servlet容器与Servlet关系★★★★★" class="headerlink" title="Servlet容器与Servlet关系★★★★★"></a>Servlet容器与Servlet关系★★★★★</h3><ul>
<li>Servlet技术的核心是Servlet，所有的Servlet类必须直接或间接实现Servlet接口</li>
<li><strong><em>Servlet接口定义了Servlet与Servlet容器之间的契约</em></strong>，即Servlet容器将Servlet类载入内存，并在Servlet实例是调用具体的方法，如用户请求时Servlet调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例</li>
</ul>
<h2 id="Web程序目录结构"><a href="#Web程序目录结构" class="headerlink" title="Web程序目录结构"></a>Web程序目录结构</h2><p><img src="http://i.imgur.com/0HhKiSj.png" alt=""></p>
<ul>
<li>静态页面、jsp直接放在web目录下</li>
<li>Servlet是Java程序，必须放在WEB-INF/classes目录下</li>
</ul>
<h2 id="Servlet工作流程★★★"><a href="#Servlet工作流程★★★" class="headerlink" title="Servlet工作流程★★★"></a>Servlet工作流程★★★</h2><p><img src="http://i.imgur.com/6yEbnhC.png" alt=""></p>
<pre><code>用户输入的URL为http://localhost:8088/hspWeb1/MyFirstServlet
浏览器解析主机名（host文件，dns）
浏览器尝试连接web服务器（三次握手）
浏览器发送http请求
web服务器开始工作，首先解析主机名，选择使用哪个主机（引擎下有多个主机，有默认主机）
web服务器解析web应用，确定使用主机下的context
web服务器解析资源名，一个web应用下有多个资源，这里是MyFirstServlet
查询web.xml文件，确定MyFirstServlet在哪个包下
Web服务器利用反射机制，创建实例，并调用init方法（该方法只调用一次）
web服务器把接收到的http请求封装成Request对象，作为service的参数传入。service会被调用多次，没访问一次Servlet，它的service就会被调用一次
Servlet获得response对象，返回结果
web服务器把request的信息拆除，形成http响应格式
当在某些情况下（tomcat重启、reload该webapp、重启电脑）web服务器会调用Servlet的destroy方法，将该servlet销毁
</code></pre><h2 id="面试题-请简述servlet的生命周期-工作流程"><a href="#面试题-请简述servlet的生命周期-工作流程" class="headerlink" title="面试题: 请简述servlet的生命周期(工作流程)"></a>面试题: 请简述servlet的生命周期(工作流程)</h2><p>答:<br>　　当第一次访问某个servlet，web服务器将会创建一个该servlet的实例，并且调用 servlet的init()方法，init函数只会被调用一次；如果当服务器已经存在了一个servlet实例，那么，将直接使用此实例；每次请求都会调用service()方法，service()方法将根据客户端的请求方式来决定调用对应的doXXX()方法；当 web应用 reload 或者 关闭 tomcat 或者 关机，web服务器将调用destroy()方法，将该servlet从服务器内存中删除。</p>
<h2 id="开发Servlet程序"><a href="#开发Servlet程序" class="headerlink" title="开发Servlet程序"></a>开发Servlet程序</h2><p><strong><em>开发servlet有三种方法★★★</em></strong></p>
<ul>
<li>(1)    实现 Servlet接口(对Servlet的工作过程有清晰的认识)</li>
<li>(2)    通过继承 GenericServlet</li>
<li>(3)    通过继承 HttpServlet</li>
</ul>
<h3 id="①实现servlet接口的方式"><a href="#①实现servlet接口的方式" class="headerlink" title="①实现servlet接口的方式"></a>①实现servlet接口的方式</h3><p>需求如下: 请使用实现接口的方式，来开发一个Servlet，要求该Servlet可以显示Hello，world，同时显示当前时间</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、在webapps下建立一个web应用my<br>2、在my下建立 WEB-INF-&gt;web.xml [web.xml可以从 ROOT/WEB-INF/web.xml拷贝]<br>3、在WEB-INF下建立 classes 目录(我们的Servlet 就要在该目录开发)，建立lib文件夹<br>4、开发MyServlet.java  </p>
<pre>
package com.apeius;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class MyServlet implements Servlet
{
    //该函数用于初始化servlet,就是把该servlet装载到内存中,该函数只会被调用一次
    <font color="red">/*调用这个方法，Servlet容器会传入一个ServletConfig，
    * 一般会将ServletConfig赋给一个类级对象，这样可以在Servlet类中其他点来使用，
    * 但Servlet实例会被一个应用程序的所有用户共享，使用类级变量须是只读的，或者是
    * java.util.concurrent.atomic包的成员
    * /</font>
    public void init(ServletConfig config)
          throws ServletException{
    }

    //得到ServletConfig对象
    public ServletConfig getServletConfig(){
        return null;
    }

    //该函数是服务函数,我们的业务逻辑代码就是写在这里
    //该函数每次都会被调用
    public void service(ServletRequest req,
                    ServletResponse res)
             throws ServletException,
                    java.io.IOException{
        //在控制台输出时间
        System.out.println(new java.util.Date());
    }
    //该函数时得到servlet配置信息
    public java.lang.String getServletInfo(){
        return null;
    }
    //销毁该servlet,从内存中清除,该函数被调用一次
    public void destroy(){

    }
}
</pre>

<p>5、编译</p>
<p>如果使用javac去编译一个带package的java文件，则需要带命令参数<code>javac –d . java文件</code></p>
<p>6、根据Servlet规范，我们还需要部署Servlet</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
   version=&quot;2.5&quot;&gt;

    &lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/ABC&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

服务器调用流程：http://localhost:8088/my/ABC---&gt;①---&gt;②---&gt;③---&gt;④
</code></pre><p>7、在浏览器中测试</p>
<p>　　在浏览器中输入<a href="http://localhost:8080/my/ABC" target="_blank" rel="external">http://localhost:8080/my/ABC</a></p>
<h3 id="②使用GenericServlet开发servlet（了解即可）"><a href="#②使用GenericServlet开发servlet（了解即可）" class="headerlink" title="②使用GenericServlet开发servlet（了解即可）"></a>②使用GenericServlet开发servlet（了解即可）</h3><h4 id="为什么使用GenericServlet"><a href="#为什么使用GenericServlet" class="headerlink" title="为什么使用GenericServlet"></a>为什么使用GenericServlet</h4><p>1、实现Servlet接口<strong><em>必须实现接口中的所有方法</em></strong>，即使有一些方法根本没有包含任何代码<br>2、此外还<strong><em>需要将ServletConfig对象保存到类级变量中</em></strong></p>
<h4 id="GenericServlet完成的任务"><a href="#GenericServlet完成的任务" class="headerlink" title="GenericServlet完成的任务"></a>GenericServlet完成的任务</h4><ul>
<li>将init方法中个ServletConfig赋给一个类级变量，以便可以通过getServletConfig获取</li>
<li>为Servlet接口中的所有方法提供默认的实现</li>
<li>提供方法，包围ServletConfig中的方法</li>
</ul>
<h4 id="GenericServlet原理"><a href="#GenericServlet原理" class="headerlink" title="GenericServlet原理"></a>GenericServlet原理</h4><p>GenericServlet通过将ServletConfig赋给init方法中的类级变量private transient ServletConfig config；来保存ServletConfig</p>
<pre><code>public void init(ServletConfig config) throws ServletException {
    this.config = config;
    this.init();
}
</code></pre><p>但是，如果在子类中覆盖了这个方法，就会调用Servlet中的init方法，并且还必须调用super.init(servletConfig)来保存ServletConfig，为了避免上述麻烦，<strong><em>GenericServlet提供了第二个init方法，它不带参数。</em></strong>这个方法是在ServletConfig被赋给servletConfig后，由第一个init方法调用，子类改写后调用的是子类的无参数init方法</p>
<p><strong>总结：</strong><br>Tomcat调用Servlet接口的init(ServletConfig config)方法，其实现类是用户继承的子类，该子类重写了无参数的init方法进行初始化工作。首先调用父类中的init(ServletConfig config)方法，将config对象保存为类级变量，然后调用this.init()方法，this指针指向子类实例，init方法被重写，所以调用子类的init方法，若需要访问GenericServlet中的无参数init方法，则需要在子类中使用super.init()；</p>
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>继承GenericServlet</em></strong></p>
<pre><code>package com.hsp;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
public class MyGenericServlet extends GenericServlet
{
    public  void service(ServletRequest req,
                             ServletResponse res)
                      throws ServletException,
                             java.io.IOException{
        res.getWriter().println(&quot;hello,world,i am geneirc servlet&quot;);
    }
}
</code></pre><p><strong><em>将该Servlet部署到web.xml文件中:</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
 &lt;servlet&gt;
    &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
  &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
  &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
  &lt;servlet-class&gt;com.hsp.MyGenericServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    &lt;!--Servlet的映射--&gt;
 &lt;servlet-mapping&gt;
    &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
    &lt;servlet-name&gt;MyGenericServlet&lt;/servlet-name&gt;
    &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分,默认命名规范:
    就是该Servlet的名字--&gt;
    &lt;url-pattern&gt;/MyGenericServlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><h3 id="③使用继承-HttpServlet-的方法来开发Serlvet"><a href="#③使用继承-HttpServlet-的方法来开发Serlvet" class="headerlink" title="③使用继承 HttpServlet 的方法来开发Serlvet"></a>③使用继承 HttpServlet 的方法来开发Serlvet</h3><ul>
<li>在软件公司 90%都是通过该方法开发.</li>
<li>举例说明，还是显示 hello,world 当前日期</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>HttpServlet类继承了GenericServlet类，并重写了service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，Tomcat调用Servlet接口的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，实际调用的是HttpServlet类中的的service(<font color="red">ServletRequest</font> req,<font color="red">ServletResponse</font> res)方法，方法体内将ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse，并调用新添加的service方法</li>
</ul>
<pre><code>public void service(ServletRequest req, ServletResponse res)
    throws ServletException, IOException
    {
        HttpServletRequest    request;
        HttpServletResponse    response;

    try {
        request = (HttpServletRequest) req;
        response = (HttpServletResponse) res;
    } catch (ClassCastException e) {
        throw new ServletException(&quot;non-HTTP request or response&quot;);
    }

    service(request, response);
}
</code></pre><ul>
<li>HttpServlet中扩展了一个protected void service(HttpServletRequest req, HttpServletResponse resp)方法，根据不同的请求方法，调用不同的doXXX方法</li>
</ul>
<pre><code>protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
    {
    String method = req.getMethod();

    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
        // servlet doesn&apos;t support if-modified-since, no reason
        // to go through further expensive logic
        doGet(req, resp);
        } else {
        long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
        if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) {
            // If the servlet mod time is later, call doGet()
                    // Round down to the nearest second for a proper compare
                    // A ifModifiedSince of -1 will always be less
            maybeSetLastModified(resp, lastModified);
            doGet(req, resp);
        } else {
            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        }
        }

    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);

    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);    

    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);

    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);

    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);

    } else {
        //
        // Note that this means NO servlet supports whatever
        // method was requested, anywhere on this server.
        //

        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);

        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}
</code></pre><ul>
<li>子类继承后，通过改写doGet和doPost方法，实现方法的调用</li>
</ul>
<h4 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h4><p><strong><em>代码</em></strong></p>
<pre><code>package com.apeius;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class MyHttpServlet extends HttpServlet
{
    //在HttpServlet 中，设计者对post 提交和 get提交分别处理
    //回忆 &lt;form action=&quot;提交给?&quot; method=&quot;post|get&quot;/&gt;,默认是get

    protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
              throws ServletException,
                     java.io.IOException{
        resp.getWriter().println(&quot;i am httpServet doGet()&quot;);

    }
    protected void doPost(HttpServletRequest req,
                      HttpServletResponse resp)
               throws ServletException,
                      java.io.IOException{ 
        resp.getWriter().println(&quot;i am httpServet doPost() post name=&quot;+req.getParameter(&quot;username&quot;));
    }
}
</code></pre><p><strong><em>还有一个login.html</em></strong></p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;/my/MyHttpServlet&quot; method=&quot;post&quot;&gt;
    u:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;login&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong><em>部署</em></strong></p>
<pre><code>&lt;!--根据serlvet规范，需要将Servlet部署到web.xml文件,该部署配置可以从examples下拷贝--&gt;
    &lt;servlet&gt;
      &lt;!--servlet-name 给该Servlet取名, 该名字可以自己定义:默认就使用该Servlet的名字--&gt;
      &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--③--&gt;
      &lt;!--servlet-class要指明该Servlet 放在哪个包下 的,形式是 包/包/../类--&gt;
      &lt;servlet-class&gt;com.apeius.MyHttpServlet&lt;/servlet-class&gt; &lt;!--注意:后面不要带.java④--&gt;
    &lt;/servlet&gt;
        &lt;!--Servlet的映射--&gt;
    &lt;servlet-mapping&gt;
        &lt;!--这个Servlet-name要和上面的servlet-name名字一样--&gt;
        &lt;servlet-name&gt;MyHttpServlet&lt;/servlet-name&gt;&lt;!--②--&gt;
        &lt;!--url-pattern 这里就是将来访问该Servlet的资源名部分，默认命名规范就是Servlet的名字--&gt;
        &lt;url-pattern&gt;/MyHttpServlet&lt;/url-pattern&gt;&lt;!--①则访问的url为localhost:8080/my/ABC--&gt;
    &lt;/servlet-mapping&gt;
</code></pre><h2 id="使用myeclipse来开发servlet，IDEA类似"><a href="#使用myeclipse来开发servlet，IDEA类似" class="headerlink" title="使用myeclipse来开发servlet，IDEA类似"></a>使用myeclipse来开发servlet，IDEA类似</h2><p><strong><em>(1)    建立web工程</em></strong></p>
<p><img src="http://i.imgur.com/6IcaPJQ.gif" alt=""></p>
<p><strong><em>(2)    在Src 目录下创建了一个包 com.hsp.servlet</em></strong></p>
<p><img src="http://i.imgur.com/VYwK3wL.png" alt=""></p>
<p><strong><em>添加Package，方法一般只需创建doGet()和doPost()方法，修改Servlet/JSP Mapping URL</em></strong></p>
<p><img src="http://i.imgur.com/ogGRxkN.png" alt=""></p>
<p><strong><em>(3)    开发一个Servlet</em></strong></p>
<pre><code>MySerlvet 的代码:
public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        response.setContentType(&quot;text/html&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;hello &quot;+new java.util.Date().toString() );
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        this.doGet(request, response);
    }
}
</code></pre><h2 id="使用IDEA来开发Servlet程序"><a href="#使用IDEA来开发Servlet程序" class="headerlink" title="使用IDEA来开发Servlet程序"></a>使用IDEA来开发Servlet程序</h2><p>　　见另一篇博文:<a href="https://rhapsody1290.github.io/2016/07/07/[Servlet]Intellij%20IDEA%E5%88%9B%E5%BB%BAMaven%E7%AE%A1%E7%90%86%E7%9A%84Java%20Web%E9%A1%B9%E7%9B%AE/" target="_blank" rel="external">Intellij IDEA15创建Maven管理的Java Web项目</a></p>
<h2 id="Servlet的细节问题-映射、单例、通配符、自启动"><a href="#Servlet的细节问题-映射、单例、通配符、自启动" class="headerlink" title="Servlet的细节问题[映射、单例、通配符、自启动]"></a>Servlet的细节问题[映射、单例、通配符、自启动]</h2><h3 id="①-一个已经注册的Servlet可以被多次映射即"><a href="#①-一个已经注册的Servlet可以被多次映射即" class="headerlink" title="① 一个已经注册的Servlet可以被多次映射即:"></a>① 一个已经注册的Servlet可以被多次映射即:</h3><pre><code>&lt;servlet&gt;
&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;
&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;
&lt;!-- servlet的注册名 --&gt;
&lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
&lt;!-- servlet类的全路径(包名+类名) --&gt;
&lt;servlet-class&gt;com.hsp.servlet.MyServlet1&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!-- 对一个已经注册的servlet的映射 --&gt;
&lt;!-- 映射1 --&gt;
&lt;servlet-mapping&gt;
    &lt;!-- servelt的注册名 --&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;!-- servlet的访问路径 --&gt;
    &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- 映射2 --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hsp&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><hr>
<h3 id="②-映射一个servlet时候，可以多层，比如"><a href="#②-映射一个servlet时候，可以多层，比如" class="headerlink" title="② 映射一个servlet时候，可以多层，比如"></a>② 映射一个servlet时候，可以多层，比如</h3><pre><code>&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt;
</code></pre><p>　　从这里还可以看出，后缀名是 html 不一定就是 html,可能是假象.</p>
<h3 id="③-用通配符在servlet映射到URL中"><a href="#③-用通配符在servlet映射到URL中" class="headerlink" title="③ 用通配符在servlet映射到URL中"></a>③ 用通配符在servlet映射到URL中</h3><p><strong><em>有两种格式:</em></strong></p>
<ul>
<li>第一种格式  <code>*.扩展名</code>，比如 <code>*.do</code>，<code>*.ss</code></li>
<li>第二种格式  以 <code>/</code> 开头，同时以 <code>/*</code> 结尾。比如  <code>/*</code>,<code>/news/*</code> </li>
</ul>
<p><strong><em>在匹配的时候，要参考的标准:</em></strong></p>
<ul>
<li>看谁的匹配度高，谁就被选择</li>
<li><code>*.do</code>的优先级最低</li>
</ul>
<p><strong><em>通配符练习题：</em></strong></p>
<pre><code>● Servlet1 映射到 /abc/* 
● Servlet2 映射到 /* 
● Servlet3 映射到 /abc 
● Servlet4 映射到 *.do 
问题(面试题)：
当请求URL为&apos;/abc/a.html&apos;，&apos;/abc/*&apos;和&apos;/*&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为&apos;/abc&apos;时，&apos;/abc/*&apos;和&apos;/abc&apos;都匹配，哪个servlet响应
    Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
当请求URL为“/xxx/yyy/a.do”时，“/*”和“*.do”都匹配，哪个servlet响应
    Servlet引擎将调用Servlet2。
</code></pre><h3 id="④Servlet单例问题"><a href="#④Servlet单例问题" class="headerlink" title="④Servlet单例问题"></a>④Servlet单例问题</h3><ul>
<li>当Servlet被第一次访问后，就被加载到内存，以后该实例对各个请求服务，即在使用中是单例</li>
<li><strong><em>Servlet实例会在一个应用程序中被所有用户共享，因此不建议使用类级变量</em></strong> ，除非它们是只读的，或者是java.util.concurrent.atomic包的成员</li>
</ul>
<p><strong><em>证明：</em></strong></p>
<p>　　在Servlet中定义一个变量i，当浏览器访问时i++，并输出i；如果Servlet是单例，则每次输出i都会增加</p>
<p><strong><em>问题：</em></strong></p>
<p>　　因为 Servlet是单例，因此会出现线程安全问题: 比如:售票系统. 如果不加同步机制，则会出现问题:</p>
<p><strong><em>原则:</em></strong></p>
<ul>
<li>（1）如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制  </li>
</ul>
<pre>
synchronized (对象){
  //同步代码
}
</pre>

<ul>
<li>（2）如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题  </li>
</ul>
<h3 id="⑤servlet中的-lt-load-on-startup-gt-配置"><a href="#⑤servlet中的-lt-load-on-startup-gt-配置" class="headerlink" title="⑤servlet中的&lt;load-on-startup&gt;配置"></a>⑤servlet中的&lt;load-on-startup&gt;配置</h3><p><strong><em>需求</em></strong></p>
<p>　　当我们的网站启动的时候，可能会要求初始化一些数据，(比如创建临时表), 在比如：我们的网站有一些要求定时完成的任务[ 定时写日志，定时备份数据.. 定时发送邮件..]</p>
<p><strong><em>解决方法</em></strong></p>
<p>　　可以通过 &lt; load-on-startup &gt; 配合线程知识搞定.<br>　　一般在有用户访问该Servlet时才会被加载进内存，现在需要在网站启动的时候自动启动Servlet。首先在web.xml下，该Servlet下进行配置<br><code>&lt;load-on-startup &gt;1（数字Servlet启动优先级）&lt;/load-on-startup&gt;</code><br>　　这样该Servlet在网站启动时将会被自动创建.</p>
<h2 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h2><ul>
<li>调用Servlet的init方法时，Servlet容器会传入一个ServletConfig实例，该对象主要用于读取 servlet的配置信息</li>
</ul>
<p><strong><em>案例</em></strong></p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.hsp.servlet.ServletConfigTest&lt;/servlet-class&gt;
    &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

获得配置参数
String encoding=this.getServletConfig().getInitParameter(&quot;encoding&quot;);
</code></pre><p><strong><em>补充说明</em></strong></p>
<p>　　这种配置参数的方式，只能被某个Servlet独立使用.如希望让所有的Servlet都去读取某个参数,这样配置:</p>
<pre><code>&lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;utf-8&lt;/param-value&gt;
&lt;/context-param&gt;

获得配置参数
String encoding = this.getServletContext().getInitParameter(&quot;encoding&quot;)
</code></pre><p><strong><em>如果要把所有的参数都读取，则使用 如下方法 ：</em></strong></p>
<pre><code>Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames();
while(names.hasMoreElements()){
    String name=names.nextElement();
    System.out.println(name);
    System.out.println(this.getServletConfig().getInitParameter(name));
}
</code></pre><h2 id="ServletContext★★★★★（包含读取文件路径）"><a href="#ServletContext★★★★★（包含读取文件路径）" class="headerlink" title="ServletContext★★★★★（包含读取文件路径）"></a>ServletContext★★★★★（包含读取文件路径）</h2><p>在访问某个网站时，首页会显示您是第几个浏览者，这个怎么实现的？除了数据库，文件等方式，最方便的是使用ServletContext。  </p>
<font color="red">ServletContext是一个公共的空间，可以被所有客户访问</font>

<p><img src="http://i.imgur.com/ZyoAE8n.png" alt=""></p>
<ul>
<li>Web容器在启动时，它会为每个Web应用程序创建一个对应的ServletContext对象，它代表当前Web应用。当web应用关闭/tomcat关闭/对web应用reload会造成servletContext销毁.</li>
<li>ServletContext对象通过ServletConfig.getServletContext方法获得对ServletContext对象的引用，也可以通过this.getServletContext()来获得其对象的引用</li>
<li><strong><em>每个Web应用程序只有一个上下文，一个Web应用中所有的Servlet共享同一个ServletContext对象</em></strong>，因此Servlet对象之间可以通过ServletContext对象实现通讯。ServletContext对象通常也被称为context域对象，公共聊天室就会用到它</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>获取:
this.getServletContext();  #在HttpServlet中直接获取
this.getServletConfig().getServletContext(); # 在ServletConfig中获取
request.getSession().getServletContext(); #通过HttpRequest获得 
添加属性:
servletcontext.setAttribute(string,object);
取出属性
servletcontext.getAttribute(“属性名”)
删除
setvletContext.removeAttribute(“属性名”);
</code></pre><h3 id="ServletContext的应用"><a href="#ServletContext的应用" class="headerlink" title="ServletContext的应用"></a>ServletContext的应用</h3><h4 id="获取WEB应用的初始化参数"><a href="#获取WEB应用的初始化参数" class="headerlink" title="获取WEB应用的初始化参数"></a>获取WEB应用的初始化参数</h4><pre><code>&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;name&lt;/param-name&gt;
    &lt;param-value&gt;scott&lt;/param-value&gt;
&lt;/context-param&gt;
如何获取
String val= this.getServletContext().getInitParameter(&quot;name&quot;);
</code></pre><h4 id="使用ServletContext实现跳转"><a href="#使用ServletContext实现跳转" class="headerlink" title="使用ServletContext实现跳转"></a>使用ServletContext实现跳转</h4><pre><code>//目前我们跳转到下一个页面的方法
//1 response.sendRedirect(&quot;/web应用名/资源名&quot;);
//2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);
/*
 * 区别1. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器
 *     2. 如果request.setAttribute(&quot;name&quot;,&quot;顺平&quot;) 希望下一个页面可以使用 属性值，则使用 getRequestDispatcher
 *       3. 如果session.setAttribute(&quot;name2&quot;,&quot;顺平3&quot;), 希望下一个页面可以使用 属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher
 *     4. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect
 */
//3.这种方法和2一样
this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response);
</code></pre><h4 id="读取文件，和获取文件全路径"><a href="#读取文件，和获取文件全路径" class="headerlink" title="读取文件，和获取文件全路径"></a>读取文件，和获取文件全路径</h4><p>　　读Web目录下和WEB-INF目录下的文件</p>
<pre><code>//首先读取到文件dbinfo.properties放在web根目录下
InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;);

//创建Properties
Properties pp=new Properties();
pp.load(inputStream);

out.println(&quot;name=&quot;+pp.getProperty(&quot;username&quot;));
</code></pre><p>　　如果文件放在src目录下(如果是maven项目，则resources目录下为根目录)，则使用类加载器</p>
<pre><code>//如果文件放在上述目录下，我们应该使用类加载器来读取
InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;)
//如果放在包下，则带上包名，例如cn/apeius/xx.properties
</code></pre><p>　　获取文件全路径（以WEB目录为根目录）</p>
<pre><code>//如果读取到一个文件的全路径（dbinfo.properties在web目录下）
String path=this.getServletContext().getRealPath(&quot;dbinfo.properties&quot;);
out.println(&quot;paht = &quot;+path);
</code></pre><h4 id="网站计数器"><a href="#网站计数器" class="headerlink" title="网站计数器"></a>网站计数器</h4><ul>
<li>我们建立一个文件recoder.txt文件，用于保存访问量,可以可以保证稳定增长.</li>
<li>建立InitServlet,Web项目启动时自动加载该Servlet，读取record.txt，初始化Servletcontext中的访问量，和在关闭tomcat时保存访问量如record.txt</li>
<li>如果我们的tomcat异常退出，使用线程定时把ServletContext的值，刷新到recorder.txt</li>
</ul>
<h2 id="http请求消息头"><a href="#http请求消息头" class="headerlink" title="http请求消息头"></a>http请求消息头</h2><pre><code>1.    Accept: text/html,image/*   [告诉服务器，我可以接受 文本，网页，图片]
2.    Accept-Charset: ISO-8859-1 [接受字符编码 iso-8859-1]
3.    Accept-Encoding: gzip,compress [可以接受 gzip,compress压缩后数据.]
4.    Accept-Language: en-us,zh-cn [浏览器支持中，英文]
5.    Host: www.sohu.com:80 [我要找主机是 www.sohu.com:80]
6.    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT [ 告诉服务器，我的缓冲中有这个资源文件，该文件的时间是 。。。，文件有更新才发送]
7.    Referer: http://www.sohu.com/index.jsp  [告诉服务器，我来自哪里,该消息头，常用于防止盗链]
8.    User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)[告诉服务器，浏览器内核]
9.    Cookie [cookie后面介绍]
10.    Connection: close/Keep-Alive   [保持连接，发完数据后，我不关闭连接]
11.    Date: Tue, 11 Jul 2000 18:23:51 GMT [浏览器发送该http请求的时间]
</code></pre><h2 id="http响应消息头"><a href="#http响应消息头" class="headerlink" title="http响应消息头"></a>http响应消息头</h2><pre><code>Location: http://www.baidu.org/index.jsp  【让浏览器重新定位到url】
Server:apache tomcat 【告诉浏览器我是tomcat】
Content-Encoding: gzip 【告诉浏览器我使用 gzip】
Content-Length: 80  【告诉浏览器会送的数据大小80节】
Content-Language: zh-cn 【支持中文】
Content-Type: text/html; charset=GB2312 [内容格式text/html; 编码gab2312]
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 【告诉浏览器，该资源上次更新时间】
Refresh: 1;url=http://www.baidu.com 【过多久去，刷新到 http://www.baidu.com】
Content-Disposition: attachment; filename=aaa.zip 【告诉浏览器，有文件下载】
Transfer-Encoding: chunked  [传输的编码]
Set-Cookie:SS=Q0=5Lb_nQ; path=/search[后面详讲]
Expires: -1[告诉浏览器如何缓存页面IE]
Cache-Control: no-cache  [告诉浏览器如何缓存页面火狐]
Pragma: no-cache   [告诉浏览器如何缓存页面]
Connection: close/Keep-Alive   [保持连接 1.1是Keep-Alive]
Date: Tue, 11 Jul 2000 18:23:51 GMT
</code></pre><h2 id="http响应的状态行"><a href="#http响应的状态行" class="headerlink" title="http响应的状态行"></a>http响应的状态行</h2><pre><code>200 就是整个请求和响应过程没有发生错误，这个最常见.
302: 表示当你请求一个资源的时候，服务器返回302 表示，让浏览器转向到另外一个资源，比如: response.sendRedirect(“/web应用/资源名”)

案例:
    response.setStatus(302);
    response.setHeader(&quot;Location&quot;, &quot;/servletPro/Servlet2&quot;);
    // 上面两句话等价 response.sendRedirect(&quot;/servletPro/Servlet2&quot;);

404： 找不到资源
500: 服务器端错误
</code></pre><h2 id="http响应头应用★★★-防盗链、定时、文件下载、缓存"><a href="#http响应头应用★★★-防盗链、定时、文件下载、缓存" class="headerlink" title="http响应头应用★★★[防盗链、定时、文件下载、缓存]"></a>http响应头应用★★★[防盗链、定时、文件下载、缓存]</h2><h3 id="防盗链-Referer"><a href="#防盗链-Referer" class="headerlink" title="防盗链 - Referer"></a>防盗链 - Referer</h3><pre><code>//获取用户浏览器Referer
String referer=request.getHeader(&quot;Referer&quot;);
if(referer==null||!referer.startsWith(&quot;http://localhost:8088/servletPro&quot;)){
    response.sendRedirect(&quot;/servletPro/Error&quot;);
    return;
}
</code></pre><h3 id="定时刷新Refresh使用"><a href="#定时刷新Refresh使用" class="headerlink" title="定时刷新Refresh使用"></a>定时刷新Refresh使用</h3><pre><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=/servletPro/Servlet2&quot;);
</code></pre><h3 id="文件下载-Content-Disposition"><a href="#文件下载-Content-Disposition" class="headerlink" title="文件下载 Content-Disposition"></a>文件下载 Content-Disposition</h3><pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

    response.setContentType(&quot;text/html&quot;);
    //★★★需要注释
    //PrintWriter out = response.getWriter();

    //演示下载文件
    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=winter.jpg&quot;);

    //打开文件.说明一下web 站点下载文件的原理
    //1.获取到要下载文件的全路径
    String path=this.getServletContext().getRealPath(&quot;/images/Winter.jpg&quot;);
    //System.out.println(&quot;path=&quot;+path);
    //2创建文件输入流
    FileInputStream fis=new FileInputStream(path);
    //做一个缓冲字节数组
    byte buff[]=new byte[1024];
    int len=0;//表示实际每次读取了多个个字节
    OutputStream os=response.getOutputStream();
    while((len=fis.read(buff))&gt;0){
        os.write(buff, 0, len);
    }
    //关闭
    os.close();
    fis.close();
}
</code></pre><h3 id="缓存讲解"><a href="#缓存讲解" class="headerlink" title="缓存讲解"></a>缓存讲解</h3><p>　　提出问题：浏览器默认情况下，会缓存我们的页面，这样出现一个问题：如果我们的用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用cache中取数据（刷新还是会重新向服务器请求数据）。</p>
<p><strong><em>（1）有些网站要求及时性很高，因此要求我们不缓存页面</em></strong></p>
<pre><code>//指定该页面不缓存 Ie
response.setDateHeader(&quot;Expires&quot;, -1);//【针对IE浏览器设置不缓存】
//为了保证兼容性.
response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//【针对火狐浏览器等】
response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//【其他浏览器】
</code></pre><p><strong><em>（2）有些网站要求网页缓存一定时间,比如缓存一个小时</em></strong></p>
<pre><code>response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+3600*1000*24);后面一个参数表示设置的缓存保持时间，-1表示永远缓存
</code></pre><h2 id="HttpServletResponse的再说明"><a href="#HttpServletResponse的再说明" class="headerlink" title="HttpServletResponse的再说明"></a>HttpServletResponse的再说明</h2><p>HttpServletResponse中输出流两个方法：</p>
<ul>
<li>getWriter()</li>
<li>getOutputStream()</li>
</ul>
<p><strong><em>区别</em></strong></p>
<p>1、    getWriter() 用于向客户机回送字符数据</p>
<pre><code>PrintWriter out = response.getWriter();
out.println(&quot;hello,world&quot;);
</code></pre><p>2、    getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据(二进制数据)，但也可以输出文本内容</p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
</code></pre><p><strong><em>如何选择:</em></strong></p>
<ul>
<li>如果我们是回送字符数据，则使用PrintWriter对象,效率高</li>
<li>如果我们是回送字节数据(binary date),则只能使用OutputStream</li>
<li>这两个流不能同时使用.</li>
</ul>
<p><strong><em>比如：</em></strong></p>
<pre><code>OutputStream os=response.getOutputStream();
os.write(&quot;hello,world&quot;.getBytes());
PrintWriter out=response.getWriter();
out.println(&quot;abc&quot;);
就会报错:
java.lang.IllegalStateException: getOutputStream() has already been called for this response
</code></pre><p><strong><em>注意：</em></strong><br>　　Web服务器会自动检查并关闭流，为什么我们没有主动关闭流，程序也没有问题的原因.当然：你主动关闭流，更好.
　　</p>
<h2 id="参数的传递方式sendRedirect-和session"><a href="#参数的传递方式sendRedirect-和session" class="headerlink" title="参数的传递方式sendRedirect()和session()"></a>参数的传递方式sendRedirect()和session()</h2><p><img src="http://img.blog.csdn.net/20160607204306776" alt="这里写代码片"></p>
<p><strong><em>需求:</em></strong><br>　　当用户登录成功后，把该用户名字显示在登录成功页面;  </p>
<p><strong><em>解决方法</em></strong></p>
<ul>
<li><p>使用 java 基础 static，专门用一个类来存储静态数据</p>
</li>
<li><p>使用 sendRedirect()，在url上加上需要传递的参数</p>
</li>
</ul>
<pre>
response.sendRedirect("/UsersManager/MainFrame?uname="+username+"&pwd="+password);

说明:
基本格式:
response.sendRedirect("/Context/servlet的?参数名=参数值&参数名=参数值...");
</pre>

<ul>
<li>使用session传递</li>
</ul>
<p>　　session既可以传递字符串，也可以传递对象</p>
<pre><code>A.传递字符串
放入session   
    request.getSession.setAttribute(&quot;loginUser&quot;,username); 
取出session     
    在JSP中通过session取出 request.getSession.getAttribute(&quot;loginUser&quot;);

B．传递对象
User user= new User();
user.setName(&quot;xiaoli&quot;);
user.setPassWord(“123”);

放入session   
    request.getSession.setAttribute(&quot;userObj&quot;,userObj); 
取出session     
    User user=(User)request.getSession.getAttribute(&quot;userObj&quot;);
</code></pre><h2 id="中文乱码处理"><a href="#中文乱码处理" class="headerlink" title="中文乱码处理"></a>中文乱码处理</h2><p>　　发生中文乱码有三种情况，我们应当尽量使用post方式提交</p>
<h3 id="①表单form"><a href="#①表单form" class="headerlink" title="①表单form"></a>①表单form</h3><p><img src="http://i.imgur.com/zplY6DJ.png" alt=""></p>
<ul>
<li>(1)表单以post方式提交<br><br>　　浏览器把请求发送给web服务器[utf-8]，web服务器以ISO-8859-1编码方式进行接收，产生乱码，之后进行传递也都是乱码。<br>　　在接收参数时，采用正确的编码，即可解决问题，在服务器端设置成浏览器端的编码方式。</li>
</ul>
<pre>request.setCharacterEncoding("utf-8"); //gbk gb2312 big5</pre>

<ul>
<li>(2)表单以get方式提交<br><br>　　请求内容是以请求行URL进行提交，而不是用请求体，所以使用setCharacterEncoding无效</li>
</ul>
<p>写一个工具类:</p>
<pre><code>package com.hsp.utils;
public class MyTools {
    public static String getNewString(String str) {
        String newString=&quot;&quot;;
        try {
            newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;);
        } catch (Exception e) {
            e.printStackTrace();
            // 把iso-8859-1 转换成 utf-8
        } 
        return newString;
    }
}
</code></pre><h3 id="②超链接"><a href="#②超链接" class="headerlink" title="②超链接"></a>②超链接</h3><p>　　数据以get方式进行传递，该方法和get处理方法一样.</p>
<pre><code>&lt;a href=”http://www.sohu.com?name=函数后”&gt;测试&lt;/a&gt;
</code></pre><h3 id="③sendRedirect-发生乱码"><a href="#③sendRedirect-发生乱码" class="headerlink" title="③sendRedirect() 发生乱码"></a>③sendRedirect() 发生乱码</h3><p>　　客户端会重新发送一个http请求，该方法和get处理方法一样</p>
<pre><code>response.sendRedirect(&quot;servlet地址?username=顺平&quot;); 
</code></pre><h3 id="版本低导致的乱码"><a href="#版本低导致的乱码" class="headerlink" title="版本低导致的乱码"></a>版本低导致的乱码</h3><p>　　特别说明，如果你的浏览器是 ie6 或以下版本，则我们的 ② 和 ③中情况会出现乱码(当中文是奇数的时候)<br>解决方法是 ：</p>
<pre><code>String info=java.net.URLEncoder.encode(&quot;你好吗.jpg&quot;, &quot;utf-8&quot;);
&lt;a href=&quot;http://www.sohu.com?name=&quot;+ info &gt;测试&lt;/a&gt;
response.sendRedirect(&quot;servlet地址?username=&quot; + info);
</code></pre><h3 id="★★★★返回浏览器显示乱码"><a href="#★★★★返回浏览器显示乱码" class="headerlink" title="★★★★返回浏览器显示乱码"></a>★★★★返回浏览器显示乱码</h3><p>　　在服务端是中文，在response的时候，也要考虑浏览器显示是否正确,一般我们通过</p>
<pre><code>　response.setContentType(&quot;text/html;charset=utf-8&quot;);
</code></pre><h3 id="下载提示框中文乱码"><a href="#下载提示框中文乱码" class="headerlink" title="下载提示框中文乱码"></a>下载提示框中文乱码</h3><p>　　补充一个知识点: 当我们下载文件的时候，可能提示框是中文乱码 </p>
<pre><code>String temp=java.net.URLEncoder.encode(&quot;传奇.mp3&quot;,&quot;utf-8&quot;);
response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment; filename=&quot;+temp);
</code></pre><h2 id="HttpServletRequest对象的详解"><a href="#HttpServletRequest对象的详解" class="headerlink" title="HttpServletRequest对象的详解"></a>HttpServletRequest对象的详解</h2><p>　　该对象表示浏览器的请求(http请求), 当web服务器得到该请求后，会把请求信息封装成一个HttpServletRequest 对象</p>
<ul>
<li>getRequestURL方法返回客户端发出请求时的完整URL。</li>
<li>getRequestURI方法返回请求行中的资源名部分。</li>
<li>getQueryString方法返回请求行中的参数部分(参数名+值)。该函数可以获取请求部分的数据，比如<br><code>http://localhost/web名?username=abc&amp;pwd=123request.getQueryString();</code><br>就会得到  username=abc&amp;pwd=123</li>
<li>getRemoteAddr方法返回发出请求的客户机的IP地址</li>
<li>getRemoteHost方法返回发出请求的客户机的完整主机名，如果该客户机没有在dns注册，则返回ip地址</li>
<li>getRemotePort方法返回客户机所使用的网络端口号，客户机的端口号是随机选择的，web服务器的端口号是一定的</li>
<li>getLocalPort方法返回web服务器所使用的网络端口号</li>
<li>getLocalAddr方法返回WEB服务器的IP地址。</li>
<li>getLocalName方法返回WEB服务器的主机名</li>
</ul>
<h2 id="url-和-uri-的区别"><a href="#url-和-uri-的区别" class="headerlink" title="url 和 uri 的区别"></a>url 和 uri 的区别</h2><pre><code>比如：
    Url=http://localhost:8088/servletPort3/GetinfoServlet 完整的请求
    Uri=/servletPort3/GetinfoServlet web应用的名称+资源的名称
</code></pre><h2 id="请求转发getRequestDispatcher"><a href="#请求转发getRequestDispatcher" class="headerlink" title="请求转发getRequestDispatcher"></a>请求转发getRequestDispatcher</h2><pre><code>#请求转发
requeset.getRequestDispatcher(资源地址).forward(request,response);
#可以在request的域对象中存储数据，request中的attribute在一次请求中有效
request.setAttribute(&quot;username&quot;,username);
</code></pre><p>　　资源地址：不需要项目名。因为它只是在WEB服务器内部转发。<br>　　<br><img src="http://img.blog.csdn.net/20160608153021012" alt="这里写图片描述"></p>
<p>　　Servlet接收到数据后，可以把数据放入到request域对象，Request中的Attribute在一次请求有效。<br>　　一次请求：浏览器发送一次http请求到接收到响应成为一次http请求，只要没有停止，也没有回到浏览器重定向，就算一次  </p>
<p><strong><em>请求转发的的(uml)图</em></strong></p>
<p><img src="http://img.blog.csdn.net/20160608154011510" alt="这里写图片描述"></p>
<ol>
<li>使用forward不能转发到该web应用外的url</li>
<li>因为 forward 是发生在web服务器，所以 Servlet1 和 Servlet 2使用的是用一个request 和response.</li>
<li>使用sendRedirect() 方法不能通过request.setAttribute() 把 属性传递给下一个Servlet</li>
</ol>
<p><strong><em>面试题：请问sendRedirect和 forward的区别是什么？</em></strong><br>答:  </p>
<pre><code>1. 叫法sendRedirect()请求重定向，转发forward()叫请求转发  
2. 实际发生的位置不一样    
　　sendRedirect发生在浏览器，由浏览器重新发出http请求  
　　forward发生web服务器，请求在web服务器转发  
3. 用法不一样    
　　request.getRequestDispatcher(“/资源URI”).forward(request,response)
　　response.sendRedirect(“/web应用/资源URI”);  
4. 能够去URL范围不一样  
　　sendRedirect可以去外边URL  
　　forward只能去当前的WEB应用的资源
</code></pre><h2 id="会话技术cookie"><a href="#会话技术cookie" class="headerlink" title="会话技术cookie"></a>会话技术cookie</h2><h3 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话"></a>什么是会话</h3><p>　　基本概念: 指用户开一个浏览器，访问一个网站,只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话。比如打电话</p>
<p><strong><em>为什么需要cookie技术(会话技术)</em></strong>  </p>
<ul>
<li>如何保存用户上次登录时间</li>
<li>如何显示用户浏览历史</li>
<li>如何把登录的用户名和密码电脑，下次登录，不需要重新输入</li>
</ul>
<h3 id="cookie的原理图"><a href="#cookie的原理图" class="headerlink" title="cookie的原理图"></a>cookie的原理图</h3><p><img src="http://i.imgur.com/ihpk6OJ.png" alt=""></p>
<h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><pre><code>//创建cookie
Cookie cookie = new Cookie(&quot;name&quot;,&quot;qm&quot;);
//设置cookie的生命周期
cookie.setMaxAge(3600);
//把cookie会写给浏览器
response.addCookie(cookie);
</code></pre><h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><pre><code>Cookie[] cookies = request.getCookies();
System.out.println(cookies.length);
for(Cookie c : cookies){
    out.println(c.getName() + &quot; &quot; + c.getValue() + &quot;&lt;br/&gt;&quot;);
}
</code></pre><h3 id="cookie的小结★★★"><a href="#cookie的小结★★★" class="headerlink" title="cookie的小结★★★"></a>cookie的小结★★★</h3><ul>
<li>cookie 是在服务端创建</li>
<li>cookie 是保存在浏览器这端</li>
<li>cookie 的生命周期可以通过cookie.setMaxAge(2000);如果不设置setMaxAge则该cookie的生命周期当浏览器关闭时，就消亡</li>
<li><font color="red">同一个浏览器<strong><em>多个实例</em></strong>共享cookie，若cookie没到期，关闭浏览器后还能共享该cookie。当然不同浏览器之间是不能共享cookie的，因为每个浏览器存放cookie的路径不一样(与session的区别，session在关闭浏览器后，不采取任何方式，无法访问到session)</font></li>
<li>我们可以把cookie想成一张表<br><img src="http://i.imgur.com/jnEcC7g.png" alt=""></li>
<li>如果cookie重名就会替换存在的cookie值</li>
<li>一个web应用可以保存多个cookie,但保存在客户端浏览器下同一个cookie文本中</li>
<li>浏览器访问web应用时，会携带该web应用相关的cookie</li>
<li>cookie存放的时候是以明文方式存放，因此安全较低，我们可以通过加密后保存[MD5算法见Java基础常用-MD5]</li>
</ul>
<h3 id="举例-保存上次登录时间★★★"><a href="#举例-保存上次登录时间★★★" class="headerlink" title="举例 - 保存上次登录时间★★★"></a>举例 - 保存上次登录时间★★★</h3><pre><code>//先获取cookie
// 假设我们 保存上次登录时间的cookie &quot;lasttime&quot; &quot;2011-11-11 12:12:12&quot;;
// 这里我们要考虑一个情况: 用户第一次登录 &apos;您是第一次登录..&apos;
Cookie[] cookies = request.getCookies();
boolean b = false;//假设没有lasttime cookie
if (cookies != null) { //保证有cookie,取遍历
    for (Cookie cookie : cookies) {
        //取出名
        String name = cookie.getName();
        if (&quot;lasttime&quot;.equals(name)) {
            //显示
            out.println(&quot;您上次登录时间是 &quot; + cookie.getValue());
            //更新时间
            //把当前日期保存cookie
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String nowTime = simpleDateFormat.format(new java.util.Date());
            cookie.setValue(nowTime);
            cookie.setMaxAge(7 * 3600 * 24);//保存一周
            response.addCookie(cookie);
            b = true;
            break;
        }
    }
}

if (!b) {
    //没有找到
    out.println(&quot;您是第一次登录..&quot;);
    //把当前日期保存cookie
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    String nowTime = simpleDateFormat.format(new java.util.Date());
    Cookie cookie = new Cookie(&quot;lasttime&quot;, nowTime);
    cookie.setMaxAge(7 * 3600 * 24);//保存一周
    response.addCookie(cookie);
}
</code></pre><h3 id="cookie的细节★★★"><a href="#cookie的细节★★★" class="headerlink" title="cookie的细节★★★"></a>cookie的细节★★★</h3><p>① 一个浏览器最多放入300cookie，一个web站点，最多20cookie，而且一个cookie大小限制子4k<br>② cookie生命周期的再说明:</p>
<ul>
<li><font color="red">cookie默认生命周期是会话级别，即浏览器关闭，cookie生命周期结束</font></li>
<li>通过setMaxAge() 可以设置生命周期<ul>
<li>setMaxAge(正数)，即多少秒后该cookie失效</li>
<li>setMaxAge(0)，删除该cookie</li>
<li>setMaxAge(负数)，相当于该cookie生命周期是会话级别</li>
</ul>
</li>
<li>cookie的生命周期，指的是累计时间，例如设置生命周期为30s，那么在30s之后cookie消亡（与session区别，session是发呆时间，即在一段时间内没有访问session就会消亡）</li>
</ul>
<p><strong><em>案例 ：</em></strong></p>
<pre><code>//先得到该cookie
Cookie cookies[]=request.getCookies();
for(Cookie cookie: cookies){
    if(cookie.getName().equals(&quot;id&quot;)){
        System.out.println(&quot;id&quot;);
        //删除
        cookie.setMaxAge(0);
        response.addCookie(cookie);//一定带上这句话，否则不能删除
    }
}
</code></pre><p>特别说明: 如果该web应用只有一个cookie ，则删除该cookie后，在浏览器的临时文件夹下没有该cookie文件，如果该web应用有多个cookie,则删除一个cookie后，文件还在，只是该cookie没有</p>
<p>③    cookie存放中文，怎么处理</p>
<p>进行URLEncoder</p>
<pre><code>存放:
String val=java.net.URLEncoder.encode(&quot;顺平&quot;,&quot;utf-8&quot;);
Cookie cookie=new Cookie(&quot;name&quot;,val);
取出:
String val=java.net.URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;);
out.println(&quot;name =&quot;+val);
</code></pre><h2 id="会话技术session（生成验证码）"><a href="#会话技术session（生成验证码）" class="headerlink" title="会话技术session（生成验证码）"></a>会话技术session（生成验证码）</h2><h3 id="session有什么用"><a href="#session有什么用" class="headerlink" title="session有什么用?"></a>session有什么用?</h3><p>　　问题1: 如何实现在不同的页面，可以去查看信息(比如说购物车)，同时还要实现不同的用户看到的信息是自己.<br>　　Session是服务端技术，可以为每一个用户的浏览器创建一个独享的session对象</p>
<h3 id="session工作原理图"><a href="#session工作原理图" class="headerlink" title="session工作原理图"></a>session工作原理图</h3><p> <img src="http://i.imgur.com/FlOMxdb.png" alt=""></p>
<ul>
<li>session对象一行就代表一个属性，键值对  </li>
<li>request.getSession()获得session，若第一次访问session会自动被创建，该浏览器第二次访问时将字节返回之前创建的session，不会创建新的。</li>
<li><font color="red">一个浏览器关联一个session。</font>如果此时有新的浏览器2访问Servlet1，那么就会创建一个新的sesssion与浏览器2对应</li>
<li>session默认的生命周期是30分钟</li>
<li>session中使用setAttribute时使用相同的属性名，属性值会被替换</li>
</ul>
<h3 id="session基本使用"><a href="#session基本使用" class="headerlink" title="session基本使用"></a>session基本使用</h3><pre><code>//访问session[当发现没有session时候，就会自动创建session]
HttpSession session = request.getSession();
//向session中添加属性
session.setAttribute(&quot;name&quot;,&quot;姓名&quot;);
//从session中得到某个属性
String name = (String) session.getAttribute(&quot;name&quot;);
out.println(name + &quot;&lt;br/&gt;&quot;);
//从session中删除某个属性
session.removeAttribute(&quot;name&quot;);
out.println((String) session.getAttribute(&quot;name&quot;) + &quot;&lt;br/&gt;&quot;);
</code></pre><h3 id="session小结"><a href="#session小结" class="headerlink" title="session小结"></a>session小结</h3><p>① session是存在服务器的内存中<br>② 一个用户浏览器，独享一个session域对象（不能浏览器会创建新的session）<br>③ session中的属性的默认生命周期是30min，你可以通过web.xml来修改<br>④ 3种session生命周期的设置</p>
<pre><code>（1）一个地方是 tomcat/conf/web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;//表示30分钟的意思
    &lt;/session-config&gt;
    对所有的web应用生效
（2）另外一个地方，就是在单个web应用的下去修改 web.xml
    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;session精确到分钟,cookie精确到秒
    &lt;/session-config&gt;
    如果发生冲突，则以自己的web应用优先级高
（3）session.setMaxInactiveinterval(60) 六十秒为发呆时间，即在这六十秒内没有访问过session，则session中所有属性失效
</code></pre><p><img src="http://i.imgur.com/LarH0Wk.png" alt=""></p>
<ul>
<li>session周期是发呆时间，如果我们设置session是10s，是指在10s内，没有访问过session，session属性失效，如果在9s时候，你访问session，session就会重新计时</li>
<li>如果重启tomcat，或者reload web应用，或者关机了，session失效</li>
<li>我们也可以通过函数，让session失效。invalidate()方法让所有属性失效，通常用于用户安全退出</li>
<li>如果你希望某个session属性失效，可以使用方法removeAttribute</li>
</ul>
<p>⑤ session中可以存放多个属性<br>⑥ session可以存放对象<br>⑦ 如果session.setAttribute(“name”,val)，如果名字重复，则会替换该属性.</p>
<h3 id="session的更深入理解"><a href="#session的更深入理解" class="headerlink" title="session的更深入理解"></a>session的更深入理解</h3><p><strong><em>为什么服务器能够为不同的浏览器提供不同session？</em></strong>  </p>
<p>　　图中浏览器A第一次访问Servlet1的时候，没有携带JSESSIONID，调用getSession()就会自动给你创建一个session，id为110，并创建cookie：JSESSIONID=110.<br>　　第二次浏览器访问Servlet2时，携带cookie：JSESSIONID=110，说明session已经创建，getSession（）方法返回id=110的session，能够获得session中的数据<br>　　同理，浏览器B访问servlet1时会新建一个新的session，id=119<br>　　每个浏览器独享一个session对象<br>　　<font color="red">session自动返回的cookie不会被写入文件，所以不同浏览器访问servlet会获取不同的session</font></p>
<p><img src="http://i.imgur.com/Klh1fzm.png" alt=""></p>
<h3 id="生成验证码案例"><a href="#生成验证码案例" class="headerlink" title="生成验证码案例"></a>生成验证码案例</h3><pre><code>public class check_code extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 7.禁止浏览器缓存随机图片
        response.setDateHeader(&quot;Expires&quot;, -1);
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        // 6.通知客户机以图片方式打开发送过去的数据
        response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);
        // 1.在内存中创建一副图片
        BufferedImage image = new BufferedImage(60,30,BufferedImage.TYPE_INT_RGB);
        // 2.向图片上写数据
        Graphics g = image.getGraphics();
        // 设背景色
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, 60, 30);
        // 3.设置写入数据的颜色和字体
        g.setColor(Color.RED);
        g.setFont(new Font(null, Font.BOLD, 20));
        // 4.向图片上写数据
        String num = makeNum();
        //这句话就是把随机生成的数值，保存到session
        request.getSession().setAttribute(&quot;check_code&quot;, num); //通过session就可以直接去到随即生成的验证码了
        g.drawString(num, 5, 22);
        // 5.把写好数据的图片输出给浏览器
        ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());
    }
    //该函数时随机生成4位数字
    public String makeNum() {
        Random r = new Random();
        //9999999 可以生成7位
        String num = r.nextInt(9999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        //如果不够4位，前面补零
        for (int i = 0; i &lt; 4 - num.length(); i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
</code></pre><h3 id="IE上购买商品后关闭，再打开IE，要求上次的商品还在"><a href="#IE上购买商品后关闭，再打开IE，要求上次的商品还在" class="headerlink" title="IE上购买商品后关闭，再打开IE，要求上次的商品还在"></a>IE上购买商品后关闭，再打开IE，要求上次的商品还在</h3><p><strong><em>分析</em></strong></p>
<ul>
<li>设session生命周期为30min,该session不会随浏览器的关闭而自动销毁。而会到30min后，才会被服务器销毁</li>
<li>关闭浏览器后，再打开。由于服务器端传回来的cookie：JSESSIONID没有设置生命周期，那么在浏览器关闭后cookie的生命周期结束。下次打开浏览器时，没有携带cookie：JSESSIONID，访问Servlet又会创建一个新的session</li>
<li>我们使用代码来实现该功能(session + cookie结合使用)</li>
</ul>
<p><strong><em>分析实现的思路:</em></strong></p>
<pre><code>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType(&quot;text/html;charset=utf-8&quot;);
    PrintWriter out = response.getWriter();
    //创建一个session，并放入一个属性
    HttpSession session = request.getSession();
    session.setAttribute(&quot;name&quot;, &quot;xxx&quot;);
    out.println(&quot;创一个session并放入姓名属性&quot;);
    //把session_id保存在cookie，cookie名字必须按照规范命名，必须大写JSESSIONID
    Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());
    ////如果不设置时间生命周期，cookie在浏览器关闭后就消亡
    cookie.setMaxAge(60*30);
    response.addCookie(cookie);
}
</code></pre><h3 id="ie禁用cookie后使用session的方法"><a href="#ie禁用cookie后使用session的方法" class="headerlink" title="ie禁用cookie后使用session的方法"></a>ie禁用cookie后使用session的方法</h3><p><strong><em>简易购物车的实例</em></strong></p>
<p><img src="http://i.imgur.com/mqreaNv.png" alt=""></p>
<p><strong><em>思路</em></strong></p>
<pre><code>当用户点击购买商品时，我们把该商品保存到session中，该session的结构是:
name             val
mybookds    hashMap对象
而hashmap的结构是    
key     val
书号   书对象.
</code></pre><p>若禁用cookie后，每次访问Servlet不携带cookie数据，创建一个新的session，购物车商品不能保存</p>
<p><strong><em>解决方法</em></strong></p>
<p>URL重写</p>
<ul>
<li>response.encodeURL(java.lang.String url)用于对表单action和超链接的url地址进行重写</li>
<li>response.encodeRedirectURL(java.lang.String url)用于对sendRedirect方法后的url地址进行重写</li>
</ul>
<p>Servlet.java</p>
<pre><code>request.getSession();//必须访问一下sesion
String url = response.encodeURL(&quot;/ServletStudy/cl&quot;);
out.println(&quot;&lt;form method = &apos;post&apos; action = &apos;&quot;+url+&quot;&apos;&gt;&quot;);
out.println(&quot;&lt;input type = &apos;submit&apos;/&gt;&quot;);
out.println(&quot;&lt;/form&gt;&quot;);
</code></pre><p>cl.java</p>
<pre><code>HttpSession session = request.getSession();
ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;) session.getAttribute(&quot;array&quot;);
if(null == array){
    array = new ArrayList&lt;String&gt;();
    session.setAttribute(&quot;array&quot;,array);
}
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String time = simpleDateFormat.format(new java.util.Date());
array.add(time);

for(String s : array){
    out.println(s + &quot;&lt;br/&gt;&quot;);
}
String url = response.encodeURL(&quot;/ServletStudy/Servlet&quot;);
out.println(&quot;&lt;a href = &apos;&quot;+url+&quot;&apos;&gt;返回&lt;/a&gt;&quot;);
</code></pre><h2 id="cookie-vs-session"><a href="#cookie-vs-session" class="headerlink" title="cookie vs session"></a>cookie vs session</h2><h3 id="存在的位置"><a href="#存在的位置" class="headerlink" title="存在的位置"></a>存在的位置</h3><ul>
<li>cookie存在客户端的临时文件夹</li>
<li>session存在服务器的内存中，一个sessio与对象为一个用户浏览器服务</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>cookie是以明文方式存放在客户端，安全性弱，可以通过加密md5再存放</li>
<li>session是存放在服务端的内存中，安全性好</li>
</ul>
<h3 id="网络传输量"><a href="#网络传输量" class="headerlink" title="网络传输量"></a>网络传输量</h3><ul>
<li>cookie会传递信息，给服务端</li>
<li>session的属性值不会给客户端</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>cookie的生命周期是累计时间，即如果我们给cookie设置setMaxAge（30），则cookie在30s后失效</li>
<li>session额生命周期是间隔时间，如果我们设置session 20min，指在20min内，如果没有访问session，则session失效（指的是session属性失效），在关闭tomcat,reload web应用，时间到，invalidate也会让session失效</li>
</ul>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><p>　　因为session会占用服务器的内存，因此不要向session存放过多的对象，会影响性能</p>
<h2 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器 Filter"></a>过滤器 Filter</h2><ul>
<li>客户端请求request在<strong>抵达Servlet之前</strong>、服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>会经过过滤器，过滤器用于在Servlet之外<strong>对request或者response进行修改</strong></li>
<li>Filter体现的是设计模式中的Filter模式</li>
</ul>
<h3 id="过滤器链-FilterChain"><a href="#过滤器链-FilterChain" class="headerlink" title="过滤器链 FilterChain"></a>过滤器链 FilterChain</h3><p>一个过滤器链包括多个Filter，客户端请求request在<strong>抵达Servlet之前</strong>会经过FilterChain里的所有Filter，服务器响应response在<strong>从Servlet抵达客户端浏览器</strong>之前也会经过FilterChain里的所有Filter</p>
<p><img src="http://i.imgur.com/5S0gzS0.png" alt=""></p>
<h3 id="防盗链Filter"><a href="#防盗链Filter" class="headerlink" title="防盗链Filter"></a>防盗链Filter</h3><pre><code>public class ImageRedirectFilter implements Filter {

    public void init(FilterConfig config) throws ServletException {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 禁止缓存
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);
        response.setHeader(&quot;Pragrma&quot;, &quot;no-cache&quot;);
        response.setDateHeader(&quot;Expires&quot;, 0);

        // 链接来源地址
        String referer = request.getHeader(&quot;referer&quot;);

        if (referer == null || !referer.contains(request.getServerName())) {

            /**
             * 如果 链接地址来自其他网站，则返回错误图片
             */
            request.getRequestDispatcher(&quot;/error.gif&quot;).forward(request,
                    response);

        } else {

            /**
             * 图片正常显示
             */
            chain.doFilter(request, response);
        }

    }

    public void destroy() {
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;
</code></pre><h3 id="字符编码-Filter"><a href="#字符编码-Filter" class="headerlink" title="字符编码 Filter"></a>字符编码 Filter</h3><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><pre><code>public class CharacterEncodingFilter implements Filter {

    private String characterEncoding;
    private boolean enabled;

    @Override
    public void init(FilterConfig config) throws ServletException {

        characterEncoding = config.getInitParameter(&quot;characterEncoding&quot;);

        enabled = &quot;true&quot;.equalsIgnoreCase(characterEncoding.trim())
                || &quot;1&quot;.equalsIgnoreCase(characterEncoding.trim());
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {

        if (enabled || characterEncoding != null) {
            request.setCharacterEncoding(characterEncoding);
            response.setCharacterEncoding(characterEncoding);
        }

        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        characterEncoding = null;
    }
}
</code></pre><p>配置：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.CharacterEncodingFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;characterEncoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;enable&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h4 id="Spring-mvc自带"><a href="#Spring-mvc自带" class="headerlink" title="Spring mvc自带"></a>Spring mvc自带</h4><pre><code>&lt;!-- 编码过滤器，UTF8编码，对POST有效 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="异常捕捉-Filter"><a href="#异常捕捉-Filter" class="headerlink" title="异常捕捉 Filter"></a>异常捕捉 Filter</h3><pre><code>public class ExceptionHandlerFilter implements Filter {

    public void destroy() {}

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        try {
            chain.doFilter(request, response);
        } catch (Exception e) {
            Throwable rootCause = e;
            while (rootCause.getCause() != null) {
                rootCause = rootCause.getCause();
            }
            String message = rootCause.getMessage();
            message = message == null ? &quot;异常：&quot; + rootCause.getClass().getName()
                    : message;
            request.setAttribute(&quot;message&quot;, message);
            request.setAttribute(&quot;e&quot;, e);

            if (rootCause instanceof AccountException) {
                request.getRequestDispatcher(&quot;/accountException.jsp&quot;).forward(
                        request, response);
            } else if (rootCause instanceof BusinessException) {
                request.getRequestDispatcher(&quot;/businessException.jsp&quot;).forward(
                        request, response);
            } else {
                request.getRequestDispatcher(&quot;/exception.jsp&quot;).forward(request,
                        response);
            }
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</code></pre><h3 id="内容替换-Filter"><a href="#内容替换-Filter" class="headerlink" title="内容替换 Filter"></a>内容替换 Filter</h3><p>需求：有时候需要对网站的内容进行控制，防止输出非法内容或者敏感内容<br>解决方案：</p>
<ul>
<li>方案一：在Servlet里输出到客户端时进行内容替换，这种方案需要对每个Servlet<br>都进行替换，工作量大，业务耦合比较严重</li>
<li>方案二：在Servlet将内容输出到response时，response将内容缓存起来，<br>在Filter中进行替换，然后再输出到客户端浏览器。但是默认的response并不能严格的<br>缓存输出内容，因此需要<font color="red"><strong><em>自定义一个具有缓存功能的response</em></strong></font></li>
</ul>
<p>要点：自定义的一个response只是一个伪装的response。Servlet会通过它输出内容到客户端，但是它内部只是将内容缓存起来了（<font color="red"><strong><em>使用自己创建的PrintWriter</em></strong></font>），并没有真正输出到客户端。最终输出到客户端还是通过原来的resonse完成的</p>
<p>框图：</p>
<p><img src="http://i.imgur.com/OirpKFm.png" alt=""></p>
<p>具体操作：</p>
<p>1、通过扩展HttpServletResponseWrapper类来<font color="red"><strong><em>实现自定义的response</em></strong></font>，该类覆盖了getWriter()方法，当Servlet使用该response对象调用getWriter()莱输出内容时，内容将被输出到CharArrayWriter对象中，达到缓存的效果</p>
<pre>
public class HttpCharacterResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">private CharArrayWriter charArrayWriter = new CharArrayWriter();</font>

    public HttpCharacterResponseWrapper(HttpServletResponse response) {
        super(response);
    }

    <font color="red">@Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(charArrayWriter);
    }</font>

    public CharArrayWriter getCharArrayWriter() {
        return charArrayWriter;
    }
}
</pre>

<p>2、Filter将自定义的response传进Servlet中</p>
<pre>
public class OutputReplaceFilter implements Filter {

    private Properties pp = new Properties();

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("file");
        String realPath = config.getServletContext().getRealPath(file);
        try {
            pp.load(new FileInputStream(realPath));
        } catch (IOException e) {
        }
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        <font color="red">// 自定义的 response
        HttpCharacterResponseWrapper response = new HttpCharacterResponseWrapper(
                (HttpServletResponse) res);

        // 提交给 Servlet 或者下一个 Filter
        chain.doFilter(req, response);</font>

        // 得到缓存在自定义 response 中的输出内容
        String output = response.getCharArrayWriter().toString();

        // 修改，替换
        for (Object obj : pp.keySet()) {
            String key = (String) obj;
            output = output.replace(key, pp.getProperty(key));
        }

        <font color="red">// 输出
        PrintWriter out = res.getWriter();
        out.write(output);</font>
        out.println("<!-- Generated at " + new java.util.Date() + " -->");
    }

    public void destroy() {
    }
}
</pre>

<h3 id="GZIP-压缩-Filter"><a href="#GZIP-压缩-Filter" class="headerlink" title="GZIP 压缩 Filter"></a>GZIP 压缩 Filter</h3><p>Servlet中操作输入输出流：</p>
<pre>
String path = request.getSession().getServletContext().getRealPath("/error.jpg");
InputStream inputStream = new FileInputStream(path);
int len = -1;
byte[] buffer = new byte[1024];
<font color="red">OutputStream outputStream = response.getOutputStream();</font>
while((len = inputStream.read(buffer)) != -1){
    <font color="red">outputStream.write(buffer,0,len);</font>
}
<font color="red">outputStream.close();</font>
inputStream.close();
</pre>

<p>要点：<br>1、替换response，并且替换的response中重写response中的getOutputStream()方法[也需要重写getWrite()，因为除了压缩二进制文件，还要压缩文本文件]<br>2、重写ServletOutputStream，当调用write方法时，使用JDK自带的GZIPOutputStream类进行数据压缩★★★★★★★★（核心）</p>
<p>总体操作框图：</p>
<p><img src="http://i.imgur.com/V7Ec9aU.png" alt=""></p>
<pre>
①自定义的GZipResponseWrapper替换tomcat传入的respone
    <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);</font>
    chain.doFilter(request, gzipResponse);
②Servlet中调用response中的getOutputStream()获得输出流，数据写入缓存，调用close方法进行压缩
    OutputStream outputStream = response.<font color="red">getOutputStream();</font>
    while((len = inputStream.read(buffer)) != -1){
        outputStream.write(buffer,0,len);
    }
    <font color="red">outputStream.close();</font>
    inputStream.close();
③输出压缩数据
    gzipResponse.finishResponse();
</pre>

<p>GZIPOutputStream类API：</p>
<pre><code>void finish() 
      完成将压缩数据写入输出流的操作，无需关闭底层流。 
void write(byte[] buf, int off, int len) 
      将字节数组写入压缩输出流。 
</code></pre><p>1、GZipFilter，如果客户端支持GZip自动解压，则进行GZIP压缩，否则不压缩</p>
<pre>
public class GZipFilter implements Filter {

    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        String acceptEncoding = request.getHeader("Accept-Encoding");
        System.out.println("Accept-Encoding: " + acceptEncoding);

        if (acceptEncoding != null
                && acceptEncoding.toLowerCase().indexOf("gzip") != -1) {

            // 如果客户浏览器支持 GZIP 格式, 则使用 GZIP 压缩数据
            <font color="red">GZipResponseWrapper gzipResponse = new GZipResponseWrapper(response);
            chain.doFilter(request, gzipResponse);</font>

            <font color="red">/*
            * 输出压缩数据，一般由用户在调用outputStream.close()自己关闭输出流，
            * 此处调用是为了防止用户忘记
            */
            gzipResponse.finishResponse();</font>

        } else {
            // 否则, 不压缩
            chain.doFilter(request, response);
        }
    }

    public void init(FilterConfig arg0) throws ServletException {
    }
}
</pre>

<p>2、GZipResponseWrapper伪装response，GZipOutputStream为它的成员变量，Servlet中的输出就是对GZipOutputStream的操作</p>
<ul>
<li>GZipResponseWrapper为自定义的response类，内部将对输出的内容进行GZIP压缩。它继承HttpServletResponseWrapper，也是一个伪装的response，不真正输出内容到客户端</li>
<li>由于该response要处理二进制内容，又要处理字符内容，因此需要覆盖getOutputStream和getWriter</li>
<li><strong>GZipResponseWrapper中的方法是实现对GZipOutputStream的操作</strong></li>
</ul>
<pre>
public class GZipResponseWrapper extends HttpServletResponseWrapper {

    <font color="red">/*
    * 传入默认的response，保存起来作为成员变量
    */</font>
    private HttpServletResponse response;

    <font color="red">/*
    * 可以不保存，如果用户自己关闭输入流，则无需调用finishResponse方法来关闭文本或二进制输出流。
    * 但是为了增加可靠性，在response抵达客户端浏览器前进行关闭流操作
    */</font>
    // 自定义的 outputStream, 执行close()的时候对数据压缩，并输出
    private GZipOutputStream gzipOutputStream;
    // 自定义 printWriter，将内容输出到 GZipOutputStream 中
    private PrintWriter writer;

    public GZipResponseWrapper(HttpServletResponse response) throws IOException {
        super(response);
        this.response = response;
    }

    public ServletOutputStream getOutputStream() throws IOException {
        if (gzipOutputStream == null)
            <font color="red">gzipOutputStream = new GZipOutputStream(response);</font>
        return gzipOutputStream;
    }

    public PrintWriter getWriter() throws IOException {
        if (writer == null)
            <font color="red">writer = new PrintWriter(new OutputStreamWriter(
                    new GZipOutputStream(response), "UTF-8"));</font>
        return writer;
    }

    // 压缩后数据长度会发生变化 因此将该方法内容置空
    public void setContentLength(int contentLength) {
    }

    public void flushBuffer() throws IOException {
        gzipOutputStream.flush();
    }

    <font color="red">public void finishResponse() throws IOException {
        if (gzipOutputStream != null)
            gzipOutputStream.close();
        if (writer != null)
            writer.close();
    }</font>
}
</pre>

<p>3、自定义GZipOutputStream类，继承ServletOutputStream，使用JDK自带的GZIP压缩类将数据缓存起来，之后调用finish函数进行数据压缩，并输出到客户端浏览器</p>
<pre>
public class GZipOutputStream extends ServletOutputStream {

    private HttpServletResponse response;

    // JDK 自带的压缩数据的类
    private GZIPOutputStream gzipOutputStream;

    // 将压缩后的数据存放到 ByteArrayOutputStream 对象中
    private ByteArrayOutputStream byteArrayOutputStream;

    <font color="red">/*
    * GZipResponseWrapper中调用构造函数，创建实例，数据缓存在ByteArrayOutputStream
    */</font>
    public GZipOutputStream(HttpServletResponse response) throws IOException {
        this.response = response;
        byteArrayOutputStream = new ByteArrayOutputStream();
        gzipOutputStream = new GZIPOutputStream(byteArrayOutputStream);
    }

    <font color="red">/*
    * Servlet中调用write方法，将数据写入缓存
    */</font>
    public void write(int b) throws IOException {
        gzipOutputStream.write(b);
    }

    <font color="red">/*
    * Servlet中调用close方法，并不是直接关闭输入流，而是先执行压缩操作，然后调用浏览器本身的输出流，在写入到客户端浏览器
    */</font>
    public void close() throws IOException {

        // 压缩完毕 一定要调用该方法
        gzipOutputStream.finish();

        // 将压缩后的数据输出到客户端
        byte[] content = byteArrayOutputStream.toByteArray();

        // 设定压缩方式为 GZIP, 客户端浏览器会自动将数据解压
        response.addHeader("Content-Encoding", "gzip");
        response.addHeader("Content-Length", Integer.toString(content.length));

        // 输出
        ServletOutputStream out = response.getOutputStream();
        out.write(content);
        out.close();
    }

    public void flush() throws IOException {
        gzipOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        gzipOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        gzipOutputStream.write(b);
    }
}
</pre>

<h3 id="图像水印-Filter"><a href="#图像水印-Filter" class="headerlink" title="图像水印 Filter"></a>图像水印 Filter</h3><p>使用Filter在图像上动态打上一个水印LOGO，工作原理与GZIP压缩类似，先把图像数据缓存起来，然后对图像进行水印处理后输出到客户端浏览器</p>
<p>图像水印Filter需要自定义response与servletOutputStream</p>
<p>1、WaterMarkFilter，在Filter初始化参数里设置水印图片文件路径</p>
<pre>
public class WaterMarkFilter implements Filter {

    // 水印图片，配置在初始化参数中
    private String waterMarkFile;

    public void init(FilterConfig config) throws ServletException {
        String file = config.getInitParameter("waterMarkFile");
        waterMarkFile = config.getServletContext().getRealPath(file);
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 自定义的response
        WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

        chain.doFilter(request, waterMarkRes);

        // 打水印，输出到客户端浏览器
        waterMarkRes.finishResponse();
    }

    public void destroy() {
    }

}
</pre>

<p>2、WaterMarkResponseWrapper继承HttpServletResponseWrapper，改写了getOutputStream方法，finishResponse方法将缓存的数据进行水印处理，并输出到客户端浏览器。水印处理的代码被封装到ImageUtil类的静态方法waterMark()中</p>
<pre>
public class WaterMarkResponseWrapper extends HttpServletResponseWrapper {

    // 水印图片位置
    private String waterMarkFile;

    // 原response
    private HttpServletResponse response;

    // 自定义servletOutputStream，用于缓冲图像数据
    private WaterMarkOutputStream waterMarkOutputStream;

    public WaterMarkResponseWrapper(HttpServletResponse response,
            String waterMarkFile) throws IOException {
        super(response);
        this.response = response;
        this.waterMarkFile = waterMarkFile;
        this.waterMarkOutputStream = new WaterMarkOutputStream();
    }

    // 覆盖getOutputStream()，返回自定义的waterMarkOutputStream
    public ServletOutputStream getOutputStream() throws IOException {
        return waterMarkOutputStream;
    }

    public void flushBuffer() throws IOException {
        waterMarkOutputStream.flush();
    }

    // 将图像数据打水印，并输出到客户端浏览器
    public void finishResponse() throws IOException {

        // 原图片数据
        byte[] imageData = waterMarkOutputStream.getByteArrayOutputStream()
                .toByteArray();

        // 打水印后的图片数据
        byte[] image = ImageUtil.waterMark(imageData, waterMarkFile);

        // 将图像输出到浏览器
        response.setContentLength(image.length);
        response.getOutputStream().write(image);

        waterMarkOutputStream.close();
    }
}
</pre>

<p>3、WaterMarkOutputStream类将图像数据缓存起来</p>
<pre>
public class WaterMarkOutputStream extends ServletOutputStream {

    // 缓冲图片数据
    private ByteArrayOutputStream byteArrayOutputStream;

    public WaterMarkOutputStream() throws IOException {
        byteArrayOutputStream = new ByteArrayOutputStream();
    }

    public void write(int b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public void close() throws IOException {
        byteArrayOutputStream.close();
    }

    public void flush() throws IOException {
        byteArrayOutputStream.flush();
    }

    public void write(byte[] b, int off, int len) throws IOException {
        byteArrayOutputStream.write(b, off, len);
    }

    public void write(byte[] b) throws IOException {
        byteArrayOutputStream.write(b);
    }

    public ByteArrayOutputStream getByteArrayOutputStream() {
        return byteArrayOutputStream;
    }

}
</pre>

<p>4、ImageUtil类使用JDK的图像处理类完成添加水印的操作</p>
<pre>
public class ImageUtil {

    /**
     * 
     * @param imageData
     *            JPG 图像文件
     * @param waterMarkFile
     *            水印图片
     * @return 加水印后的图像数据
     * @throws IOException
     */
    public static byte[] waterMark(byte[] imageData, String waterMarkFile)
            throws IOException {

        // 水印图片的右边距 下边距
        int paddingRight = 10;
        int paddingBottom = 10;

        // 原始图像
        Image image = new ImageIcon(imageData).getImage();
        int imageWidth = image.getWidth(null);
        int imageHeight = image.getHeight(null);

        // 水印图片
        Image waterMark = ImageIO.read(new File(waterMarkFile));
        int waterMarkWidth = waterMark.getWidth(null);
        int waterMarkHeight = waterMark.getHeight(null);

        // 如果图片尺寸过小，则不打水印，直接返回
        if (imageWidth < waterMarkWidth + 2 * paddingRight
                || imageHeight < waterMarkHeight + 2 * paddingBottom) {
            return imageData;
        }
        BufferedImage bufferedImage = new BufferedImage(imageWidth,
                imageHeight, BufferedImage.TYPE_INT_RGB);

        Graphics g = bufferedImage.createGraphics();

        // 绘制原始图像
        g.drawImage(image, 0, 0, imageWidth, imageHeight, null);
        // 绘制水印图片
        g.drawImage(waterMark, imageWidth - waterMarkWidth - paddingRight,
                imageHeight - waterMarkHeight - paddingBottom, waterMarkWidth,
                waterMarkHeight, null);
        g.dispose();

        // 转成JPEG格式
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
        encoder.encode(bufferedImage);
        byte[] data = out.toByteArray();
        out.close();
        return data;
    }
}
</pre>

<p>5、配置文件</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.filter.ImageRedirectFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter&gt;
    &lt;filter-name&gt;waterMarkFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.watermark.WaterMarkFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;waterMarkFile&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/logo.png&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h3 id="内容替换、GZIP、图像水印-Filter-总结★★★★★★"><a href="#内容替换、GZIP、图像水印-Filter-总结★★★★★★" class="headerlink" title="内容替换、GZIP、图像水印 Filter 总结★★★★★★"></a>内容替换、GZIP、图像水印 Filter 总结★★★★★★</h3><p>以图像水印 Filter 为例</p>
<p>1、过滤器中自定义response包裹类，将原生response作为参数传入。自定义的response替换原生response传入Servlet；response返回客户端之前，调用新定义的finishResponse方法，输出到客户端浏览器</p>
<pre><code>// 自定义的response
WaterMarkResponseWrapper waterMarkRes = new WaterMarkResponseWrapper(response, waterMarkFile);

chain.doFilter(request, waterMarkRes);

// 打水印，输出到客户端浏览器
waterMarkRes.finishResponse();
</code></pre><p>2、自定义response包裹类有一个存放原生response的成员变量，一个自定义的输出流，起到缓存数据的功能。重写getOutputStream()方法或getWriter()方法，返回自定义输出流，添加finishResponse方法，将缓存中的数据进行处理，输出到客户端浏览器</p>
<p>3、重写ServletOutputStream类对数据进行，对数据缓存</p>
<h3 id="缓存-Filter"><a href="#缓存-Filter" class="headerlink" title="缓存 Filter"></a>缓存 Filter</h3><p><strong><em>对于访问量比较大的网站（淘宝），反复地查询数据库要消耗很多时间</em></strong>。如果第一次访问某页面查询了数据库，那么就可以把页面的内容缓存起来，下一次访问的时候直接返回缓存结果就行。使用缓存能将数据库读写次数较少都最少，从而提高服务器的响应速度</p>
<p>缓存Filter的工作流程：<br>1、截获浏览器提交的request<br>2、如果request为POST方式，则不进行缓存<br>3、<strong>如果request为GET方式，且请求的页面有缓存并且缓存没有过期</strong>，则直接返回缓存结果，这样就避免读取数据库<br>4、如果没有缓存或者缓存已过期，则重新请求Servlet，将Servlet返回的内容缓存并输出到客户端浏览器</p>
<p>使用缓存注意点：</p>
<p>1、缓存Filter不易用于数据会实时变化的数据，如报表、股票等，它适用于数据变化不大，但是访问次数多的内容，如论坛、博客、新闻等<br>2、缓存Filter不能用于POST方式提交数据，如登录、发表文章等<br>3、<strong>当缓存更新后，要更新缓存，或者直接将缓存删掉</strong><br>4、被缓存的内容不能依赖于Session，而要依赖于Cookie。即要使用Cookie来记录客户身份而不要使用Session，并且<strong>无论客户身份是管理员还是普通浏览者，Servlet输出内容都是一样的，只能在浏览器使用js根据cookie来决定显示什么内容</strong>。但是注意：由于菜单的显示与否并没有在服务器端进行权限检查，<font color="red"><strong><em>因此当客户单击链接操作的时候，一定要做权限检查，否则会引发安全问题</em></strong></font></p>
<p>框图：</p>
<p><img src="http://i.imgur.com/S75GBO8.png" alt=""></p>
<p>①如果存在缓存文件，直接缓存文件中读取数据并输出到客户端浏览器，不进入Servlet<br>②没有缓存或缓存过期，在Servlet将输出的内容缓存起来<br>③缓存Filter将缓存内容写入到缓存文件，并读取缓存文件将数据输出</p>
<p>程序流程图：</p>
<p><img src="http://i.imgur.com/SSL3f5N.png" alt=""></p>
<p>1、缓存Filter</p>
<pre>
public class CacheFilter implements Filter {

    private ServletContext servletContext;

    // 缓存文件夹，使用Tomcat工作目录
    private File temporalDir;

    // 缓存时间，配置在Filter初始化参数中
    private long cacheTime = Long.MAX_VALUE;

    public void init(FilterConfig config) throws ServletException {
        temporalDir = (File) config.getServletContext().getAttribute(
                "javax.servlet.context.tempdir");
        servletContext = config.getServletContext();
        cacheTime = new Long(config.getInitParameter("cacheTime"));
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        <font color="red">// 如果为 POST, 则不经过缓存</font>
        if ("POST".equals(request.getMethod())) {
            chain.doFilter(request, response);
            return;
        }

        <font color="red">// 请求的 URI，忽略应用程序名称</font>
        String uri = request.getRequestURI();
        if (uri == null)
            uri = "";
        uri = uri.replace(request.getContextPath() + "/", "");
        uri = uri.trim().length() == 0 ? "index.jsp" : uri;
        uri = request.getQueryString() == null ? uri : (uri + "?" + request
                .getQueryString());

        // 对应的缓存文件
        File cacheFile = new File(temporalDir, URLEncoder.encode(uri, "UTF-8"));
        System.out.println(cacheFile);

        // 如果缓存文件不存在 或者已经超出缓存时间 则请求 Servlet
        if (!cacheFile.exists()
                || cacheFile.length() == 0
                || cacheFile.lastModified() < System.currentTimeMillis()
                        - cacheTime) {

            CacheResponseWrapper cacheResponse = new CacheResponseWrapper(
                    response);

            chain.doFilter(request, cacheResponse);

            // 将内容写入缓存文件
            char[] content = cacheResponse.getCacheWriter().toCharArray();

            temporalDir.mkdirs();<font color="red">//递归创建文件夹</font>
            cacheFile.createNewFile();<font color="red">//创建文件</font>

            Writer writer = new OutputStreamWriter(new FileOutputStream(
                    cacheFile), "UTF-8");
            writer.write(content);
            writer.close();
        }

        // 请求的ContentType
        String mimeType = servletContext.getMimeType(request.getRequestURI());
        response.setContentType(mimeType);

        // 读取缓存文件的内容，写入客户端浏览器
        Reader ins = new InputStreamReader(new FileInputStream(cacheFile),
                "UTF-8");
        StringBuffer buffer = new StringBuffer();
        char[] cbuf = new char[1024];
        int len;
        while ((len = ins.read(cbuf)) > -1) {
            buffer.append(cbuf, 0, len);
        }
        ins.close();
        // 输出到客户端
        response.getWriter().write(buffer.toString());
    }

    public void destroy() {
    }
}
</pre>

<p>2、CacheResponseWrapper强Servlet中输出的内容缓存起来，然后被缓存Filter写入到缓存文件中。本缓存Filter只缓存字符类网页，因此只覆盖了getWriter()方法</p>
<pre><code>public class CacheResponseWrapper extends HttpServletResponseWrapper {

    // 缓存字符类输出
    private CharArrayWriter cacheWriter = new CharArrayWriter();

    public CacheResponseWrapper(HttpServletResponse response)
            throws IOException {
        super(response);
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        return new PrintWriter(cacheWriter);
    }

    @Override
    public void flushBuffer() throws IOException {
        cacheWriter.flush();
    }

    public void finishResponse() throws IOException {
        cacheWriter.close();
    }

    public CharArrayWriter getCacheWriter() {
        return cacheWriter;
    }

    public void setCacheWriter(CharArrayWriter cacheWriter) {
        this.cacheWriter = cacheWriter;
    }
}
</code></pre><p>3、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;
        com.helloweenvsfei.cache.CacheFilter
    &lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cache&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;cacheTime&lt;/param-name&gt;
        &lt;param-value&gt;1000000&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;cacheFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="XSLT-转换-Filter"><a href="#XSLT-转换-Filter" class="headerlink" title="XSLT 转换 Filter"></a>XSLT 转换 Filter</h3><p>XSLT转换时XML文件的功能之一，是利用XSLT样式文件将XML文件转换成其他格式，使用XSLT 转换 Filter，浏览器访问请求XML格式，返回浏览器时已经是转换后的HTML文件了</p>
<p>1、该Filter使用JDK自带的标准XML工具包进行XML格式转换。MSN的聊天记录是用XML形式保存的，浏览器访问XML格式，返回转换后的HTML文件</p>
<pre><code>public class XSLTFilter implements Filter {

    private ServletContext servletContext;

    public void init(FilterConfig config) throws ServletException {
        servletContext = config.getServletContext();
    }

    public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // 格式样本文件：/book.xsl
        Source styleSource = new StreamSource(servletContext
                .getRealPath(&quot;/MessageLog.xsl&quot;));

        // 请求的 xml 文件
        Source xmlSource = new StreamSource(servletContext.getRealPath(request
                .getRequestURI().replace(request.getContextPath() + &quot;&quot;, &quot;&quot;)));
        try {

            // 转换器工厂
            TransformerFactory transformerFactory = TransformerFactory
                    .newInstance();

            // 转换器
            Transformer transformer = transformerFactory
                    .newTransformer(styleSource);

            // 将转换的结果保存到该对象中
            CharArrayWriter charArrayWriter = new CharArrayWriter();
            StreamResult result = new StreamResult(charArrayWriter);

            // 转换
            transformer.transform(xmlSource, result);

            // 输出转换后的结果
            response.setContentType(&quot;text/html&quot;);
            response.setContentLength(charArrayWriter.toString().length());
            PrintWriter out = response.getWriter();
            out.write(charArrayWriter.toString());

        } catch (Exception ex) {
        }
    }

    public void destroy() {
    }
}
</code></pre><p>2、配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.helloweenvsfei.xml.XSLTFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;xsltFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/msn/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h2 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器 Listener"></a>监听器 Listener</h2><p>Listener用于监听Java Web程序中的事件，例如创建、修改、删除Session、request、context等</p>
<h3 id="Listener使用"><a href="#Listener使用" class="headerlink" title="Listener使用"></a>Listener使用</h3><p>使用Listener需要实现相应的Listener接口，<strong><em>触发Listener事件时，Tomcat会自动调用Listener的方法</em></strong></p>
<h4 id="实现Listener接口"><a href="#实现Listener接口" class="headerlink" title="实现Listener接口"></a>实现Listener接口</h4><p>创建Session服务器会调用sessionCreated()方法，销毁Session（包括sesson超时自动销毁）服务器会调用sessionDestroyed()方法</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener {

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        //Session创建时被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;创建了一个session：&quot; + session);
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        //销毁Session前被调用
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;销毁了一个Session：&quot; + session);
    }
}
</code></pre><h4 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h4><p>&lt;listener&gt;标签一般配置在&lt;servlet&gt;前面</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h3 id="Listener的分类★★★★★★"><a href="#Listener的分类★★★★★★" class="headerlink" title="Listener的分类★★★★★★"></a>Listener的分类★★★★★★</h3><h4 id="监听对象的创建与销毁"><a href="#监听对象的创建与销毁" class="headerlink" title="监听对象的创建与销毁"></a>监听对象的创建与销毁</h4><ul>
<li>HttpSessionListener：监听Session的创建与销毁。创建Session时执行sessionCreated方法，超时或执行session.invalidate()时执行sessionDestroyed方法。<font color="red"><strong><em>该Listener可以收集在线者信息</em></strong></font></li>
<li>ServletContextListener：监听context的创建与销毁。<strong>context代表当前的Web应用程序</strong>，服务器启动或者热部署war包时执行contextInitialized，服务器关闭或关闭该Web时会执行contextDestroyed方法。<font color="red"><strong><em>该Listener可用于启动时读取web.xml里配置的初始化参数</em></strong></font></li>
<li>ServletRequestListener：监听request的创建与销毁，用户每次请求都会执行requestInitialized方法，request处理完毕自动销毁前执行requestDestroyed。注意如果一个HTML页面包含多个图片，则一次请求可能会多次触发request事件</li>
</ul>
<h4 id="实例：监听Session、request、servletContext"><a href="#实例：监听Session、request、servletContext" class="headerlink" title="实例：监听Session、request、servletContext"></a>实例：监听Session、request、servletContext</h4><p>自定义监听器类同时实现HttpSessionListener、ServletContextListener、ServletRequestListener接口，使得多种监听器一块工作</p>
<pre><code>public class SessionListenerTest implements HttpSessionListener,
        ServletContextListener, ServletRequestListener {


    //Log log = LogFactory.getLog(getClass());
    Logger log = Logger.getLogger(SessionListenerTest.class);

    // 创建 session
    public void sessionCreated(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;新创建一个session, ID为: &quot; + session.getId());
    }

    // 销毁 session
    public void sessionDestroyed(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(&quot;销毁一个session, ID为: &quot; + session.getId());
    }

    // 加载 context
    public void contextInitialized(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将启动&quot; + servletContext.getContextPath());
    }

    // 卸载 context
    public void contextDestroyed(ServletContextEvent sce) {
        ServletContext servletContext = sce.getServletContext();
        log.info(&quot;即将关闭&quot; + servletContext.getContextPath());
    }

    // 创建 request
    public void requestInitialized(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        String uri = request.getRequestURI();
        uri = request.getQueryString() == null ? uri : (uri + &quot;?&quot; + request
                .getQueryString());

        request.setAttribute(&quot;dateCreated&quot;, System.currentTimeMillis());

        log.info(&quot;IP &quot; + request.getRemoteAddr() + &quot; 请求 &quot; + uri);
    }

    // 销毁 request
    public void requestDestroyed(ServletRequestEvent sre) {

        HttpServletRequest request = (HttpServletRequest) sre
                .getServletRequest();

        long time = System.currentTimeMillis()
                - (Long) request.getAttribute(&quot;dateCreated&quot;);

        log.info(request.getRemoteAddr() + &quot;请求处理结束, 用时&quot; + time + &quot;毫秒. &quot;);
    }
}
</code></pre><p>配置到web.xml</p>
<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;cn.apeius.listener.SessionListenerTest&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre><h4 id="监听对象的属性变化"><a href="#监听对象的属性变化" class="headerlink" title="监听对象的属性变化"></a>监听对象的属性变化</h4><ul>
<li>另一类Listener用于监听Session、context、request的属性变化，接口名称格式为xxxAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener</li>
<li>当想被监听对象中添加、更新、移除属性时，会分别执行xxxAdded()、xxxReplace()、xxxRemoved()方法，xxx分别代表Session、Context、request</li>
</ul>
<pre><code>public class SessionAttributeListenerTest implements
        HttpSessionAttributeListener {

    Log log = LogFactory.getLog(getClass());

    // 添加属性
    public void attributeAdded(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;新建session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 删除属性
    public void attributeRemoved(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        log.info(&quot;删除session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue());
    }

    // 修改属性
    public void attributeReplaced(HttpSessionBindingEvent se) {
        HttpSession session = se.getSession();
        String name = se.getName();
        Object oldValue = se.getValue();
        log.info(&quot;修改session属性：&quot; + name + &quot;, 原值：&quot; + oldValue + &quot;, 新值：&quot;
                + session.getAttribute(name));
    }
}
</code></pre><h4 id="监听Session内的对象"><a href="#监听Session内的对象" class="headerlink" title="监听Session内的对象"></a>监听Session内的对象</h4><p>除了上面的6中Listener，有两种Listener用于监听Session内的对象，分别是HttpSessionBindingListener、HttpSessionActivationListener，他们的触发时机是：</p>
<ul>
<li>HttpSessionBindingListener：当对象被放到Session里是执行valueBound方法，当对象从Session里移除时执行valueUnbound，<strong><em>对象必须实现该Listener接口</em></strong></li>
<li>HttpSessionActivationListener：服务器关闭时，会将Session里的内容保存到硬盘上，这个过程叫做钝化。服务器重启时，会将Session里的内容从硬盘上重新加载，钝化时会执行sessionWillPassivate方法，对象被重新加载时执行sessionDidActivate方法，<strong><em>对象必须实现该Listener接口</em></strong></li>
</ul>
<p>这两个Listener监听的是Session中的对象而非Session等，因此不需要再web.xml中声明</p>
<p>PersonInfo对象被放进、移出Session或者启动、关闭服务器都会触发PersonInfo内的Listener时间：</p>
<pre><code>public class PersonInfo implements HttpSessionActivationListener,
        HttpSessionBindingListener, Serializable {

    private static final long serialVersionUID = -4780592776386225973L;

    Log log = LogFactory.getLog(getClass());

    private String name;

    private Date dateCreated;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    // 从硬盘加载后
    public void sessionDidActivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;已经成功从硬盘中加载。sessionId: &quot; + session.getId());
    }

    // 即将被钝化到硬盘时
    public void sessionWillPassivate(HttpSessionEvent se) {
        HttpSession session = se.getSession();
        log.info(this + &quot;即将保存到硬盘。sessionId: &quot; + session.getId());
    }

    // 被放进session前
    public void valueBound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被绑定到session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上&quot;);

        // 记录放到session中的时间
        this.setDateCreated(new Date());
    }

    // 从session中移除后
    public void valueUnbound(HttpSessionBindingEvent event) {
        HttpSession session = event.getSession();
        String name = event.getName();
        log.info(this + &quot;被从session \&quot;&quot; + session.getId() + &quot;\&quot;的&quot; + name
                + &quot;属性上移除&quot;);
    }

    @Override
    public String toString() {
        return &quot;PersonInfo(&quot; + name + &quot;)&quot;;
    }

}
</code></pre><h3 id="Listener使用案例"><a href="#Listener使用案例" class="headerlink" title="Listener使用案例"></a>Listener使用案例</h3><h4 id="单态登录"><a href="#单态登录" class="headerlink" title="单态登录"></a>单态登录</h4><ul>
<li><font color="red"><strong>单态登录就是一个账号只能在一台机器上登录，如果在其他机器上登录了，则原来的登录无效</strong></font></li>
<li>单态登录的目的是为了防止多台机器同时使用一个账号</li>
</ul>
<h5 id="Listener方式实现"><a href="#Listener方式实现" class="headerlink" title="Listener方式实现"></a>Listener方式实现</h5><ul>
<li>见JavaWeb王者归来205页</li>
<li>思路：当成功验证用户信息，准备往session中存放用户的信息时，被监听器监听到，调用attributeAdded或attributeReplaced方法，方法中需要判断用户是否在别的机器上登录过，如果登录了则使以前的登录失效</li>
<li>使用这种方式Listener与登录模块没有代码耦合，部署Listener后将实现单态登录，拆掉该Listener后登录模块照常工作，只是不再保证是单态登录</li>
</ul>
<pre>
public class LoginSessionListener implements HttpSessionAttributeListener {

    Log log = LogFactory.getLog(this.getClass());

    Map<string, httpsession=""> map = new HashMap<string, httpsession="">();

    public void attributeAdded(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 登录
        if (name.equals("personInfo")) {

            PersonInfo personInfo = (PersonInfo) event.getValue();

            if (map.get(personInfo.getAccount()) != null) {

                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                PersonInfo oldPersonInfo = (PersonInfo) session
                        .getAttribute("personInfo");

                log.info("帐号" + oldPersonInfo.getAccount() + "在"
                        + oldPersonInfo.getIp() + "已经登录，该登录将被迫下线。");

                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }

            // 将session以用户名为索引，放入map中
            map.put(personInfo.getAccount(), event.getSession());
            log.info("帐号" + personInfo.getAccount() + "在" + personInfo.getIp()
                    + "登录。");
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 注销
        if (name.equals("personInfo")) {
            // 将该session从map中移除
            PersonInfo personInfo = (PersonInfo) event.getValue();
            map.remove(personInfo.getAccount());
            log.info("帐号" + personInfo.getAccount() + "注销。");
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        String name = event.getName();

        // 没有注销的情况下，用另一个帐号登录
        if (name.equals("personInfo")) {

            // 移除旧的的登录信息
            PersonInfo oldPersonInfo = (PersonInfo) event.getValue();
            map.remove(oldPersonInfo.getAccount());

            // 新的登录信息
            PersonInfo personInfo = (PersonInfo) event.getSession()
                    .getAttribute("personInfo");

            // 也要检查新登录的帐号是否在别的机器上登录过
            if (map.get(personInfo.getAccount()) != null) {
                // map 中有记录，表明该帐号在其他机器上登录过，将以前的登录失效
                HttpSession session = map.get(personInfo.getAccount());
                session.removeAttribute("personInfo");
                session.setAttribute("msg", "您的帐号已经在其他机器上登录，您被迫下线。");
            }
            map.put("personInfo", event.getSession());
        }

    }

}
</string,></string,></pre>

<h5 id="自己的实现"><a href="#自己的实现" class="headerlink" title="自己的实现"></a>自己的实现</h5><ul>
<li>如果没有要求单态登录，成功验证用户信息后，返回客户端token，在服务器端创建session，并将用户信息存入到session，之后客户端再次访问，根据token恢复session，如果session中存放了用户信息，则用户合法，否则退回登录页面</li>
<li>实现单态登录，需要在验证用户信息后，<font color="red"><strong><em>判断账号是否在别的机器上登录</em></strong></font>。</li>
<li>具体实现：用一个HashMap存储在线用户信息，主键为用户名，键值为session。成功验证用户信息后，根据用户名获取session，如果session不为空，说明用户已经在别的机器上登录，则使sesson无效，在HashMap上移除该值，这样之前登录的用户操作前，会检查session中没有用户信息，则必须重新登录，做到强制退出的目的</li>
<li>图示：红框是单态登录加入的模块</li>
</ul>
<p><img src="http://i.imgur.com/4vvjT4z.png" alt=""></p>
<pre>
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.setCharacterEncoding("utf-8");
    response.setCharacterEncoding("utf-8");
    response.setContentType("text/html;charset=utf-8");
    PrintWriter out = response.getWriter();

    String action = request.getParameter("action");
    if("login".equalsIgnoreCase(action)){
        String name = request.getParameter("name");
        String password = request.getParameter("password");
        User user = new User();
        user.setName(name);
        user.setPassword(password);
        if("qm".equals(name) && "123".equals(password)){
            <font color="red">//判断帐号是否在别的机器登录
            HttpSession oldSession = map.get(name);
            if(oldSession != null){//1、别的机器登录 2、重复登录
                oldSession.removeAttribute("user");
                <font color="blue">//oldSession.invalidate();不要删除session除了用户信息的其他属性，下次用户在本机登录还能获得先前的数据</font>
                map.remove(name);
            }</font>

            HttpSession session = request.getSession();
            session.setAttribute("user",user);
            map.put(name,session);
            out.println("登录成功");
        }else{
            out.println("登录失败");
        }
    }else if("logout".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //session.invalidate();
        session.removeAttribute("user");
        map.remove(user.getName());
        out.println("注销成功");
    }else if("main".equalsIgnoreCase(action)){
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute("user");
        if(user == null){
            out.println("请先登录");
            return;
        }
        //往session添加其他属性
        Integer count = (Integer) session.getAttribute("count");
        if(count == null){
            count = 0;
            session.setAttribute("count", count);
        }
        count ++;
        session.setAttribute("count",count);

        //在线用户
        out.println(session.getAttribute("count"));
    }
}
</pre>

<h4 id="显示在线用户"><a href="#显示在线用户" class="headerlink" title="显示在线用户"></a>显示在线用户</h4><p>存放服务器信息、用户信息的类：</p>
<pre><code>public class ApplicationConstants {

    // 所有的 Session，session_id与session组成键值对
    public static Map&lt;String, HttpSession&gt; SESSION_MAP = new HashMap&lt;String, HttpSession&gt;();

    // 当前登录的用户总数
    public static int CURRENT_LOGIN_COUNT = 0;

    // 历史访客总数
    public static int TOTAL_HISTORY_COUNT = 0;

    // 服务器启动时间
    public static Date START_DATE = new Date();

    // 最高在线时间
    public static Date MAX_ONLINE_COUNT_DATE = new Date();

    // 最高在线人数
    public static int MAX_ONLINE_COUNT = 0;
}
</code></pre><p>使用ServletContextListener来监听服务器的启动与关闭，记录服务器启动时间等</p>
<pre><code>public class MyContextListener implements ServletContextListener {

    public void contextInitialized(ServletContextEvent event) {
        // 启动时，记录服务器启动时间
        ApplicationConstants.START_DATE = new Date();
    }

    public void contextDestroyed(ServletContextEvent event) {
        // 关闭时，将结果清除。也可以将结果保存到硬盘上，下次启动时再加载到ApplicationConstants中
        ApplicationConstants.START_DATE = null;
        ApplicationConstants.MAX_ONLINE_COUNT_DATE = null;
    }
}
</code></pre><p>对Session的监听，维护在线用户列表、总访问人数：</p>
<ul>
<li>使用Map来索引所有的Session，Session创建的时候放到Map中，Session销毁时从Map中剔除</li>
<li>什么时候用户数改变？成功验证用户信息后往session中存入用户信息、用户注销、用户被强退，attributeAdded和attributeReplaced的区别就是用户人数是否需要增加</li>
</ul>
<pre>
public class MySessionListener implements HttpSessionListener,
        HttpSessionAttributeListener {

    public void sessionCreated(HttpSessionEvent sessionEvent) {

        HttpSession session = sessionEvent.getSession();

        <font color="red">// 将 session 放入 map
        ApplicationConstants.SESSION_MAP.put(session.getId(), session);</font>
        // 总访问人数++
        ApplicationConstants.TOTAL_HISTORY_COUNT++;

        // 如果当前在线人数超过历史记录，则更新最大在线人数，并记录时间
        if (ApplicationConstants.SESSION_MAP.size() > ApplicationConstants.MAX_ONLINE_COUNT) {
            ApplicationConstants.MAX_ONLINE_COUNT = ApplicationConstants.SESSION_MAP
                    .size();
            ApplicationConstants.MAX_ONLINE_COUNT_DATE = new Date();
        }
    }

    public void sessionDestroyed(HttpSessionEvent sessionEvent) {
        HttpSession session = sessionEvent.getSession();
        // 将session从map中移除
        ApplicationConstants.SESSION_MAP.remove(session.getId());
    }

    public void attributeAdded(HttpSessionBindingEvent event) {

        if (event.getName().equals("personInfo")) {

            // 当前登录用户数++
            ApplicationConstants.CURRENT_LOGIN_COUNT++;
            HttpSession session = event.getSession();

            // 查找该帐号有没有在其他机器上登录
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {

                // 如果该帐号已经在其他机器上登录，则以前的登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

    public void attributeRemoved(HttpSessionBindingEvent event) {

        // 注销 当前登录用户数--
        if (event.getName().equals("personInfo")) {
            ApplicationConstants.CURRENT_LOGIN_COUNT--;
        }
    }

    public void attributeReplaced(HttpSessionBindingEvent event) {

        // 重新登录，但人数不用增加
        if (event.getName().equals("personInfo")) {
            HttpSession session = event.getSession();
            for (HttpSession sess : ApplicationConstants.SESSION_MAP.values()) {
                // 如果新帐号在其他机器上登录过，则以前登录失效
                if (event.getValue().equals(sess.getAttribute("personInfo"))
                        && session.getId() != sess.getId()) {
                    sess.invalidate();
                }
            }
        }
    }

}
</pre>

<p>监听request主要是记录客户的IP地址、访问次数等，也可以记录用户访问的URI：</p>
<pre>
public class MyRequestListener implements ServletRequestListener {

    public void requestDestroyed(ServletRequestEvent event) {
    }

    public void requestInitialized(ServletRequestEvent event) {

        HttpServletRequest request = (HttpServletRequest) event
                .getServletRequest();

        <font color="red">/*
        * 如果session为空，则重新创建一个session，主要是之前session.invalidate()会销毁session        
        */</font>
        HttpSession session = request.getSession(true);

        // 记录IP地址
        session.setAttribute("ip", request.getRemoteAddr());

        // 记录访问次数，只记录访问 .html, .do, .jsp, .action 的累计次数
        String uri = request.getRequestURI();
        String[] suffix = { ".html", ".do", ".jsp", ".action" };
        for (int i=0; i&lt;suffix.length; i++) {
            if (uri.endsWith(suffix[i])) {
                break;
            }
            if(i == suffix.length-1)
                return;
        }

        Integer activeTimes = (Integer) session.getAttribute("activeTimes");

        if (activeTimes == null) {
            activeTimes = 0;
        }

        session.setAttribute("activeTimes", activeTimes + 1);
    }
}
</pre>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaEE/" rel="tag">#JavaEE</a>
          
            <a href="/tags/Servlet/" rel="tag">#Servlet</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/06/[Tomcat]Tomcat笔记/" rel="next" title="Tomcat笔记">
                <i class="fa fa-chevron-left"></i> Tomcat笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/07/[Servlet]Intellij IDEA创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂）/" rel="prev" title="Intellij IDEA15创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂）">
                Intellij IDEA15创建Maven管理的Java Web项目（使用IDEA启动方式，较复杂） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/06/[Servlet]Servlet笔记/"
           data-title="Servlet笔记" data-url="http://qianmingxs.com/2016/07/06/[Servlet]Servlet笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">126</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">88</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用"><span class="nav-number">1.</span> <span class="nav-text">常用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要Servlet技术？"><span class="nav-number">2.</span> <span class="nav-text">为什么需要Servlet技术？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#servlet的介绍"><span class="nav-number">3.</span> <span class="nav-text">servlet的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat-和-servlet-在网络中的位置"><span class="nav-number">4.</span> <span class="nav-text">Tomcat 和 servlet 在网络中的位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat三大功能"><span class="nav-number">4.1.</span> <span class="nav-text">Tomcat三大功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet容器与Servlet关系★★★★★"><span class="nav-number">4.2.</span> <span class="nav-text">Servlet容器与Servlet关系★★★★★</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web程序目录结构"><span class="nav-number">5.</span> <span class="nav-text">Web程序目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet工作流程★★★"><span class="nav-number">6.</span> <span class="nav-text">Servlet工作流程★★★</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-请简述servlet的生命周期-工作流程"><span class="nav-number">7.</span> <span class="nav-text">面试题: 请简述servlet的生命周期(工作流程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发Servlet程序"><span class="nav-number">8.</span> <span class="nav-text">开发Servlet程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#①实现servlet接口的方式"><span class="nav-number">8.1.</span> <span class="nav-text">①实现servlet接口的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤"><span class="nav-number">8.1.1.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#②使用GenericServlet开发servlet（了解即可）"><span class="nav-number">8.2.</span> <span class="nav-text">②使用GenericServlet开发servlet（了解即可）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用GenericServlet"><span class="nav-number">8.2.1.</span> <span class="nav-text">为什么使用GenericServlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenericServlet完成的任务"><span class="nav-number">8.2.2.</span> <span class="nav-text">GenericServlet完成的任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenericServlet原理"><span class="nav-number">8.2.3.</span> <span class="nav-text">GenericServlet原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开发步骤"><span class="nav-number">8.2.4.</span> <span class="nav-text">开发步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#③使用继承-HttpServlet-的方法来开发Serlvet"><span class="nav-number">8.3.</span> <span class="nav-text">③使用继承 HttpServlet 的方法来开发Serlvet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">8.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开发步骤-1"><span class="nav-number">8.3.2.</span> <span class="nav-text">开发步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用myeclipse来开发servlet，IDEA类似"><span class="nav-number">9.</span> <span class="nav-text">使用myeclipse来开发servlet，IDEA类似</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用IDEA来开发Servlet程序"><span class="nav-number">10.</span> <span class="nav-text">使用IDEA来开发Servlet程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet的细节问题-映射、单例、通配符、自启动"><span class="nav-number">11.</span> <span class="nav-text">Servlet的细节问题[映射、单例、通配符、自启动]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#①-一个已经注册的Servlet可以被多次映射即"><span class="nav-number">11.1.</span> <span class="nav-text">① 一个已经注册的Servlet可以被多次映射即:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#②-映射一个servlet时候，可以多层，比如"><span class="nav-number">11.2.</span> <span class="nav-text">② 映射一个servlet时候，可以多层，比如</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#③-用通配符在servlet映射到URL中"><span class="nav-number">11.3.</span> <span class="nav-text">③ 用通配符在servlet映射到URL中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#④Servlet单例问题"><span class="nav-number">11.4.</span> <span class="nav-text">④Servlet单例问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#⑤servlet中的-lt-load-on-startup-gt-配置"><span class="nav-number">11.5.</span> <span class="nav-text">⑤servlet中的<load-on-startup>配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServletConfig对象"><span class="nav-number">12.</span> <span class="nav-text">ServletConfig对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServletContext★★★★★（包含读取文件路径）"><span class="nav-number">13.</span> <span class="nav-text">ServletContext★★★★★（包含读取文件路径）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本使用"><span class="nav-number">13.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletContext的应用"><span class="nav-number">13.2.</span> <span class="nav-text">ServletContext的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取WEB应用的初始化参数"><span class="nav-number">13.2.1.</span> <span class="nav-text">获取WEB应用的初始化参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用ServletContext实现跳转"><span class="nav-number">13.2.2.</span> <span class="nav-text">使用ServletContext实现跳转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取文件，和获取文件全路径"><span class="nav-number">13.2.3.</span> <span class="nav-text">读取文件，和获取文件全路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网站计数器"><span class="nav-number">13.2.4.</span> <span class="nav-text">网站计数器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http请求消息头"><span class="nav-number">14.</span> <span class="nav-text">http请求消息头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http响应消息头"><span class="nav-number">15.</span> <span class="nav-text">http响应消息头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http响应的状态行"><span class="nav-number">16.</span> <span class="nav-text">http响应的状态行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http响应头应用★★★-防盗链、定时、文件下载、缓存"><span class="nav-number">17.</span> <span class="nav-text">http响应头应用★★★[防盗链、定时、文件下载、缓存]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防盗链-Referer"><span class="nav-number">17.1.</span> <span class="nav-text">防盗链 - Referer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定时刷新Refresh使用"><span class="nav-number">17.2.</span> <span class="nav-text">定时刷新Refresh使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件下载-Content-Disposition"><span class="nav-number">17.3.</span> <span class="nav-text">文件下载 Content-Disposition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存讲解"><span class="nav-number">17.4.</span> <span class="nav-text">缓存讲解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpServletResponse的再说明"><span class="nav-number">18.</span> <span class="nav-text">HttpServletResponse的再说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数的传递方式sendRedirect-和session"><span class="nav-number">19.</span> <span class="nav-text">参数的传递方式sendRedirect()和session()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中文乱码处理"><span class="nav-number">20.</span> <span class="nav-text">中文乱码处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#①表单form"><span class="nav-number">20.1.</span> <span class="nav-text">①表单form</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#②超链接"><span class="nav-number">20.2.</span> <span class="nav-text">②超链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#③sendRedirect-发生乱码"><span class="nav-number">20.3.</span> <span class="nav-text">③sendRedirect() 发生乱码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本低导致的乱码"><span class="nav-number">20.4.</span> <span class="nav-text">版本低导致的乱码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#★★★★返回浏览器显示乱码"><span class="nav-number">20.5.</span> <span class="nav-text">★★★★返回浏览器显示乱码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载提示框中文乱码"><span class="nav-number">20.6.</span> <span class="nav-text">下载提示框中文乱码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpServletRequest对象的详解"><span class="nav-number">21.</span> <span class="nav-text">HttpServletRequest对象的详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url-和-uri-的区别"><span class="nav-number">22.</span> <span class="nav-text">url 和 uri 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求转发getRequestDispatcher"><span class="nav-number">23.</span> <span class="nav-text">请求转发getRequestDispatcher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会话技术cookie"><span class="nav-number">24.</span> <span class="nav-text">会话技术cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是会话"><span class="nav-number">24.1.</span> <span class="nav-text">什么是会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie的原理图"><span class="nav-number">24.2.</span> <span class="nav-text">cookie的原理图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建cookie"><span class="nav-number">24.3.</span> <span class="nav-text">创建cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取cookie"><span class="nav-number">24.4.</span> <span class="nav-text">读取cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie的小结★★★"><span class="nav-number">24.5.</span> <span class="nav-text">cookie的小结★★★</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例-保存上次登录时间★★★"><span class="nav-number">24.6.</span> <span class="nav-text">举例 - 保存上次登录时间★★★</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie的细节★★★"><span class="nav-number">24.7.</span> <span class="nav-text">cookie的细节★★★</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会话技术session（生成验证码）"><span class="nav-number">25.</span> <span class="nav-text">会话技术session（生成验证码）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#session有什么用"><span class="nav-number">25.1.</span> <span class="nav-text">session有什么用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session工作原理图"><span class="nav-number">25.2.</span> <span class="nav-text">session工作原理图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session基本使用"><span class="nav-number">25.3.</span> <span class="nav-text">session基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session小结"><span class="nav-number">25.4.</span> <span class="nav-text">session小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session的更深入理解"><span class="nav-number">25.5.</span> <span class="nav-text">session的更深入理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成验证码案例"><span class="nav-number">25.6.</span> <span class="nav-text">生成验证码案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IE上购买商品后关闭，再打开IE，要求上次的商品还在"><span class="nav-number">25.7.</span> <span class="nav-text">IE上购买商品后关闭，再打开IE，要求上次的商品还在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ie禁用cookie后使用session的方法"><span class="nav-number">25.8.</span> <span class="nav-text">ie禁用cookie后使用session的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie-vs-session"><span class="nav-number">26.</span> <span class="nav-text">cookie vs session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存在的位置"><span class="nav-number">26.1.</span> <span class="nav-text">存在的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性"><span class="nav-number">26.2.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络传输量"><span class="nav-number">26.3.</span> <span class="nav-text">网络传输量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期"><span class="nav-number">26.4.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用原则"><span class="nav-number">26.5.</span> <span class="nav-text">使用原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器-Filter"><span class="nav-number">27.</span> <span class="nav-text">过滤器 Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器链-FilterChain"><span class="nav-number">27.1.</span> <span class="nav-text">过滤器链 FilterChain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防盗链Filter"><span class="nav-number">27.2.</span> <span class="nav-text">防盗链Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符编码-Filter"><span class="nav-number">27.3.</span> <span class="nav-text">字符编码 Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义"><span class="nav-number">27.3.1.</span> <span class="nav-text">自定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-mvc自带"><span class="nav-number">27.3.2.</span> <span class="nav-text">Spring mvc自带</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常捕捉-Filter"><span class="nav-number">27.4.</span> <span class="nav-text">异常捕捉 Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容替换-Filter"><span class="nav-number">27.5.</span> <span class="nav-text">内容替换 Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GZIP-压缩-Filter"><span class="nav-number">27.6.</span> <span class="nav-text">GZIP 压缩 Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像水印-Filter"><span class="nav-number">27.7.</span> <span class="nav-text">图像水印 Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容替换、GZIP、图像水印-Filter-总结★★★★★★"><span class="nav-number">27.8.</span> <span class="nav-text">内容替换、GZIP、图像水印 Filter 总结★★★★★★</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存-Filter"><span class="nav-number">27.9.</span> <span class="nav-text">缓存 Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSLT-转换-Filter"><span class="nav-number">27.10.</span> <span class="nav-text">XSLT 转换 Filter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监听器-Listener"><span class="nav-number">28.</span> <span class="nav-text">监听器 Listener</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener使用"><span class="nav-number">28.1.</span> <span class="nav-text">Listener使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现Listener接口"><span class="nav-number">28.1.1.</span> <span class="nav-text">实现Listener接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener配置"><span class="nav-number">28.1.2.</span> <span class="nav-text">Listener配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener的分类★★★★★★"><span class="nav-number">28.2.</span> <span class="nav-text">Listener的分类★★★★★★</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#监听对象的创建与销毁"><span class="nav-number">28.2.1.</span> <span class="nav-text">监听对象的创建与销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例：监听Session、request、servletContext"><span class="nav-number">28.2.2.</span> <span class="nav-text">实例：监听Session、request、servletContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听对象的属性变化"><span class="nav-number">28.2.3.</span> <span class="nav-text">监听对象的属性变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听Session内的对象"><span class="nav-number">28.2.4.</span> <span class="nav-text">监听Session内的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener使用案例"><span class="nav-number">28.3.</span> <span class="nav-text">Listener使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单态登录"><span class="nav-number">28.3.1.</span> <span class="nav-text">单态登录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Listener方式实现"><span class="nav-number">28.3.1.1.</span> <span class="nav-text">Listener方式实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自己的实现"><span class="nav-number">28.3.1.2.</span> <span class="nav-text">自己的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显示在线用户"><span class="nav-number">28.3.2.</span> <span class="nav-text">显示在线用户</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rhapsody1290"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  

  
<script type="text/javascript" src="/js/src/[qianmingxs]baidu_auto_post.js"></script>
</body>
</html>
