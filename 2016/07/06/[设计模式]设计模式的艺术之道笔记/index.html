<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="设计模式," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Java反射Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。 在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式的艺术之道笔记">
<meta property="og:url" content="http://qianmingxs.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/index.html">
<meta property="og:site_name" content="Mr.Qian&#39;s Home">
<meta property="og:description" content="Java反射Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。 在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i.imgur.com/EGuKZbM.png">
<meta property="og:image" content="http://i.imgur.com/Mw6iOgv.png">
<meta property="og:image" content="http://i.imgur.com/eJUCJtW.png">
<meta property="og:image" content="http://i.imgur.com/22oEW71.jpg">
<meta property="og:image" content="http://i.imgur.com/CbRwljs.jpg">
<meta property="og:image" content="http://i.imgur.com/03wHvRx.jpg">
<meta property="og:image" content="http://i.imgur.com/Z9Nc3VN.jpg">
<meta property="og:image" content="http://i.imgur.com/mNnbWcu.png">
<meta property="og:image" content="http://i.imgur.com/nGDvXzt.png">
<meta property="og:image" content="http://i.imgur.com/whQUxwW.png">
<meta property="og:image" content="http://i.imgur.com/aqAKcXE.png">
<meta property="og:image" content="http://i.imgur.com/lor8whj.png">
<meta property="og:image" content="http://i.imgur.com/c6WHHLA.png">
<meta property="og:image" content="http://i.imgur.com/Czffk8B.png">
<meta property="og:image" content="http://i.imgur.com/F5VGhOh.png">
<meta property="og:image" content="http://i.imgur.com/hfZUs1B.jpg">
<meta property="og:image" content="http://i.imgur.com/D8P7zwo.jpg">
<meta property="og:updated_time" content="2017-07-19T07:22:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式的艺术之道笔记">
<meta name="twitter:description" content="Java反射Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。 在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class">
<meta name="twitter:image" content="http://i.imgur.com/EGuKZbM.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'PERBMK758D',
      apiKey: 'bb735480ebfad21cf22f48a7a44c066a',
      indexName: 'Hexo',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianmingxs.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/"/>





  <title>设计模式的艺术之道笔记 | Mr.Qian's Home</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.Qian's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://qianmingxs.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Qian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.Qian's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式的艺术之道笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-06T00:00:00+08:00">
                2016-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射(Java Reflection)是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。</p>
<p>在反射中使用最多的类是Class，Class类的实例表示正在运行的Java应用程序中的类和接口，其forName(String className)方法可以返回与带有给定字符串名的类或接口相关联的 Class对象，再通过Class对象的newInstance()方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例</p>
<h2 id="XMLUtil"><a href="#XMLUtil" class="headerlink" title="XMLUtil"></a>XMLUtil</h2><pre><code>//工具类XMLUtil.java  
import javax.xml.parsers.*;  
import org.w3c.dom.*;  
import org.xml.sax.SAXException;  
import java.io.*;  

public class XMLUtil {  
//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象  
    public static Object getBean() {  
        try {  
            //创建DOM文档对象  
            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();  
            DocumentBuilder builder = dFactory.newDocumentBuilder();  
            Document doc;                             
            doc = builder.parse(new File(&quot;config.xml&quot;));   

            //获取包含类名的文本节点  
            NodeList nl = doc.getElementsByTagName(&quot;className&quot;);  
            Node classNode=nl.item(0).getFirstChild();  
            String cName=classNode.getNodeValue();  

            //通过类名生成实例对象并将其返回  
            Class c=Class.forName(cName);  
            Object obj=c.newInstance();  
            return obj;  
        }     
        catch(Exception e) {  
            e.printStackTrace();  
            return null;  
         }  
    }  
} 
</code></pre><p>文件</p>
<pre><code>&lt;!— config.xml --&gt;  
&lt;?xml version=&quot;1.0&quot;?&gt;  
&lt;config&gt;  
    &lt;className&gt;FileLoggerFactory&lt;/className&gt;  
&lt;/config&gt;  
</code></pre><h3 id="单例模式：确保一个类只有一个实例"><a href="#单例模式：确保一个类只有一个实例" class="headerlink" title="单例模式：确保一个类只有一个实例"></a>单例模式：确保一个类只有一个实例</h3><p>1、构造方法私有，外部不能通过new创建对象<br>2、静态变量保存唯一实例<br>3、静态的getInstance方法，是外部能够访问</p>
<p>饿汉模式:在类加载的时候已经创建了单例对象</p>
<pre><code>//staic final静态常量
private static final Singleton instance = new Singleton();
private Singleton(){}
public static Singleton getInstance(){return instance;}
</code></pre><p>懒汉模式：第一次调用的时候创建对象实例</p>
<pre><code>private static Singleton instatnce = null;
private Singleton(){}
//注意同步控制关键字 Synchronized
synchronized public Singleton getInstance(){
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}
</code></pre><p>方法二：synchronized同步控制代码块，双重检查锁定（单次判断实例不为空，如果一个线程正在创建对象但还未创建完成，另一个线程进入实例不为空的判断，最终产生两个实例，未被单一对象的原则）</p>
<pre><code>//使用volatile保证可见性
private volatile static Singleton instatnce = null;
private Singleton(){}
public static Singleton getInstance(){
    //第一重判断
    if(instance == null){
        synchronized(Singleton.class){
            //第二重判断
            if(instance == null){
                    instance = new Singleton();
            }
        }
    }
    return instance;
}
</code></pre><p>为什么需要使用volatile？不是同步快结束完之后，会将instance对象写入内存？</p>
<p>答：<strong>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</strong></p>
<ul>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ul>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<font color="red"><strong>解析</strong>：</font>

<pre><code>线程1创建调用getInstance（）方法执行到instance=new Singleton()，但是这条语句不是原子性的，他分为三个步骤：1、分配内存 2、初始化 3、instance对象指向内存空间，执行完这步后instance为非空了。

但是jvm存在指令重排序的优化，如果指令按照1，3，2的执行方式，但是线程1在执行3之后，但未执行2之前，此时instance已经不为null了，这时候线程2调用getInstance（）方法（注意这时线程2可以调拥这个方法，因为只有进入一重检查锁之后才是临界区。）执行第一重判断if(instance == null){，此时instance不为null，直接调用return instance语句返回对象，但对象并没有真正得实例化完毕，调用就会出现错误
</code></pre><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<p>有些人认为使用 volatile 的原因是<strong>可见性</strong>，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：<strong>禁止指令重排序优化</strong>。也就是说，在 volatile 变量的<strong>赋值操作后面会有一个内存屏障</strong>（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，<strong>读操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</strong>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>方法三（最优）：静态内部类中保持对象的实例，在第一次调用的时候创建单例对象</p>
<pre><code>private static class Hold{
    private static final Singleton instance = new Singleton();
}
private Singleton(){}

public static Singleton getInstance(){
    return Hold.inistance;
}
</code></pre><p>饿汉式和懒汉式对比：饿汉式在类加载的时候创建，不管用不用，都占据内存；懒汉式在第一次使用的时候创建，必须加锁，多线程时性能受影响</p>
<h2 id="第4章：集中式工厂的实现——简单工厂模式"><a href="#第4章：集中式工厂的实现——简单工厂模式" class="headerlink" title="第4章：集中式工厂的实现——简单工厂模式"></a>第4章：集中式工厂的实现——简单工厂模式</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>1、定义抽象产品类，将产品 <strong>公共的代码</strong> 移至抽象产品类，并在抽象产品类中声明一些 <strong>抽象方法</strong>，供不同的具体产品类来实现<br>2、具体产品类继承抽象产品类，实现抽象类中抽象方法<br>3、工厂类提供一个创建产品的工厂方法，根据传入参数不同创建不同具体产品的对象</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://i.imgur.com/EGuKZbM.png" alt=""></p>
<p>抽象产品类</p>
<pre><code>abstract class Product {  
    //所有产品类的公共业务方法  
    public void methodSame() {  
        //公共方法的实现  
    }  

    //声明抽象业务方法  
    public abstract void methodDiff();  
}  
</code></pre><p>具体产品类</p>
<pre><code>class ConcreteProduct extends Product {  
    //实现业务方法  
    public void methodDiff() {  
        //业务方法的实现  
    }  
} 
</code></pre><p>工厂类</p>
<pre><code>class Factory {  
    //静态工厂方法  
    public static Product getProduct(String arg) {  
        Product product = null;  
        if (arg.equalsIgnoreCase(&quot;A&quot;)) {  
            product = new ConcreteProductA();  
            //初始化设置product  
        }  
        else if (arg.equalsIgnoreCase(&quot;B&quot;)) {  
            product = new ConcreteProductB();  
            //初始化设置product  
        }  
        return product;  
    }  
}  
</code></pre><h3 id="简单工厂模式的简化"><a href="#简单工厂模式的简化" class="headerlink" title="简单工厂模式的简化"></a>简单工厂模式的简化</h3><p><img src="http://i.imgur.com/Mw6iOgv.png" alt=""></p>
<p>将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p>
<h3 id="创建对象与使用对象"><a href="#创建对象与使用对象" class="headerlink" title="创建对象与使用对象"></a>创建对象与使用对象</h3><p>与一个对象相关的职责通常有3类：对象本身所具有的职责、创建对象的职责、使用对象的职责</p>
<p>在Java语言中，通常有以下几种创建对象的方式：</p>
<p>1、使用new关键字直接创建对象<br>2、通过反射机制创建对象<br>3、通过clone方法创建对象<br>4、通过工厂类创建对象</p>
<h2 id="第5章：多态工厂的实现——工厂方法模式"><a href="#第5章：多态工厂的实现——工厂方法模式" class="headerlink" title="第5章：多态工厂的实现——工厂方法模式"></a>第5章：多态工厂的实现——工厂方法模式</h2><p>简单工厂虽然简单，但存在一个很严重的问题，当系统中需要引入新产品时，由于静态工厂方法 <strong>通过传入参数的不同来创建不同的产品</strong>，这必定要修改工厂类的源代码，<strong>违背开闭原则</strong></p>
<p>在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂</p>
<h3 id="工厂方法模式结构图"><a href="#工厂方法模式结构图" class="headerlink" title="工厂方法模式结构图"></a>工厂方法模式结构图</h3><p><img src="http://i.imgur.com/eJUCJtW.png" alt=""></p>
<ul>
<li>具体产品实现抽象产品接口，具体产品和具体工厂之间一一对应</li>
<li>与简单工厂模式相比，工厂方式模式组重要的区别是引入了抽象工厂角色，在抽象工厂中声明工厂方法，由具体工厂类实现</li>
<li>客户端针对抽象工厂编程，在运行时再指定具体工厂类，<strong>不同的具体工厂可以创建不同的具体产品</strong></li>
<li>具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以 <strong>负责产品对象的初始化工作以及一些资源和环境配置工作</strong>，例如连接数据库、创建文件等。</li>
</ul>
<h3 id="使用工厂方法模式设计的日志记录器"><a href="#使用工厂方法模式设计的日志记录器" class="headerlink" title="使用工厂方法模式设计的日志记录器"></a>使用工厂方法模式设计的日志记录器</h3><p><img src="http://i.imgur.com/22oEW71.jpg" alt=""></p>
<p>抽象产品：</p>
<pre><code>//日志记录器接口：抽象产品
interface Logger {
    public void writeLog();
}
</code></pre><p>具体产品：</p>
<pre><code>//数据库日志记录器：具体产品
class DatabaseLogger implements Logger {
    public void writeLog() {
        System.out.println(&quot;数据库日志记录。&quot;);
    }
}

//文件日志记录器：具体产品
class FileLogger implements Logger {
    public void writeLog() {
        System.out.println(&quot;文件日志记录。&quot;);
    }
}
</code></pre><p>抽象工厂：</p>
<pre><code>//日志记录器工厂接口：抽象工厂
interface LoggerFactory {
    public Logger createLogger();
}
</code></pre><p>具体工厂：</p>
<pre><code>//数据库日志记录器工厂类：具体工厂
class DatabaseLoggerFactory implements LoggerFactory {
    public Logger createLogger() {
            //连接数据库，代码省略
            //创建数据库日志记录器对象
            Logger logger = new DatabaseLogger(); 
            //初始化数据库日志记录器，代码省略
            return logger;
    }    
}

//文件日志记录器工厂类：具体工厂
class FileLoggerFactory implements LoggerFactory {
    public Logger createLogger() {
            //创建文件日志记录器对象
            Logger logger = new FileLogger(); 
            //创建文件，代码省略
            return logger;
    }    
}
</code></pre><p>客户端测试:</p>
<pre><code>class Client {  
    public static void main(String args[]) {  
        LoggerFactory factory;  
        Logger logger;  
        factory = new FileLoggerFactory(); //可引入配置文件实现  
        logger = factory.createLogger();  
        logger.writeLog();  
    }  
}  
</code></pre><h2 id="第6章：产品族的创建——抽象工厂模式"><a href="#第6章：产品族的创建——抽象工厂模式" class="headerlink" title="第6章：产品族的创建——抽象工厂模式"></a>第6章：产品族的创建——抽象工厂模式</h2><p>工厂方法模式中每个工厂只生产一类产品，<strong>可能会导致系统中存在大量的工厂类</strong>，势必会增加系统的开销，此时可以考虑将<strong>一些相关的产品组成一个”产品族”</strong>，由同一个工厂统一生产（抽象工厂中声明多个工厂方法，用于创建不同类型的产品，这些产品构成了一个产品族）</p>
<h3 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h3><p>(1) 产品等级结构：<strong>产品等级结构即产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则 <strong>抽象电视机与具体品牌的电视机之间构成了一个产品等级结构</strong>，抽象电视机是父类，而具体品牌的电视机是其子类。</p>
<p>(2) 产品族：在抽象工厂模式中，产品族是指由<strong>同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如 <strong>海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机</strong> 位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</p>
<p><img src="http://i.imgur.com/CbRwljs.jpg" alt=""></p>
<p>不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构</p>
<h3 id="抽象工厂模式结构图"><a href="#抽象工厂模式结构图" class="headerlink" title="抽象工厂模式结构图"></a>抽象工厂模式结构图</h3><p><img src="http://i.imgur.com/03wHvRx.jpg" alt=""></p>
<p>在抽象工厂模式中，每一个具体的工厂都提供了 <strong>多个工厂方法</strong> 用于产生多种不同类型的产品，<strong>这些产品构成了一个产品族</strong></p>
<p>抽象工厂的典型代码如下：</p>
<pre><code>abstract class AbstractFactory {  
    public abstract AbstractProductA createProductA(); //工厂方法一  
    public abstract AbstractProductB createProductB(); //工厂方法二  
    ……  
}
</code></pre><p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂创建的产品对象构成了一个产品族：</p>
<pre><code>class ConcreteFactory1 extends AbstractFactory {  
    //工厂方法一  
    public AbstractProductA createProductA() {  
        return new ConcreteProductA1();  
    }  

    //工厂方法二  
    public AbstractProductB createProductB() {  
        return new ConcreteProductB1();  
    }  

    ……  
}  
</code></pre><h3 id="完整解决方案"><a href="#完整解决方案" class="headerlink" title="完整解决方案"></a>完整解决方案</h3><p>使用抽象工厂模式来重构界面皮肤库的设计，<em>要求同一风格的具体界面组件要一起显示</em>，其基本结构如图所示：</p>
<p><img src="http://i.imgur.com/Z9Nc3VN.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p>
<ul>
<li>能够保证客户端始终使用只使用同一个产品族中的产品</li>
<li><strong>增加新的产品族很方便</strong>，无需修改已有系统</li>
</ul>
<p>缺点：</p>
<p><strong>增加新的等级结构麻烦</strong>，需要对原有系统进行较大的修改，甚至需要修改抽象层的代码</p>
<p>使用场景：</p>
<p><strong>属于同一产品族的产品要在一起使用，这一约束必须在系统的设计中体现出来</strong>，例如：</p>
<p>1、同一操作系统下的按钮和文本，按钮和文本没有直接关系，但他们都属于某一操作系统，此时具有一个 <strong>约束条件</strong> 就是：同一个操作系统</p>
<h2 id="第8章：复杂对象的组装与创建——建造者模式"><a href="#第8章：复杂对象的组装与创建——建造者模式" class="headerlink" title="第8章：复杂对象的组装与创建——建造者模式"></a>第8章：复杂对象的组装与创建——建造者模式</h2><p>建造者模式是为了解决这类问题：<strong>如何一步一步地创建一个包含多个组个组成部分的复杂对象</strong></p>
<ul>
<li>建造者模式将包含多个组成部分的复杂对象的创建过程分离</li>
<li><strong>不同具体的建造者定义了不同的创建过程</strong></li>
<li>建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性</li>
</ul>
<h3 id="有Director的建造者模式"><a href="#有Director的建造者模式" class="headerlink" title="有Director的建造者模式"></a>有Director的建造者模式</h3><p>Director类有两个作用：</p>
<ul>
<li>隔离了客户与创建过程，客户只要与Director类进行交互</li>
<li><strong>控制产品的创建过程</strong>，传入不同具体的建造者，输出产品</li>
</ul>
<p>Builder类的作用：创建对象的各个组件</p>
<p><img src="http://i.imgur.com/mNnbWcu.png" alt=""></p>
<p>Actor：定义输出的对象类型</p>
<pre><code>public class Actor {
    private String type;
    private String sex;

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return &quot;Actor{&quot; +
                &quot;sex=&apos;&quot; + sex + &apos;\&apos;&apos; +
                &quot;, type=&apos;&quot; + type + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>AbstractActorBuilder：抽象的对象创建方法，对象的组建过程分为两步：buildtType、buildSex，然后调用getResult方法输出，组建方法需要由子类改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }
}
</code></pre><p>HeroActorBuilder、AngelActorBuilder：定义了不同的组建过程</p>
<pre><code>public class HeroActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;英雄&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;男&quot;);
    }
}

public class AngelActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;Angle&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;女&quot;);
    }
}
</code></pre><p>Director：导演类封装了复杂对象的组建过程，客户端只需调用contruct方法，并传入对应的组建类，就可以得到所需要创建的类</p>
<pre><code>public class Director {
    public Actor contruct(AbstractActorBuilder builder){
        builder.buildtType();
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h3 id="省略Director"><a href="#省略Director" class="headerlink" title="省略Director"></a>省略Director</h3><p>AbstractActorBuilder需要承担创建复杂对象各个部分的职责，还要控制整个对象组建的顺序，但对系统的灵活性和可扩展性并没有任何影响</p>
<p>建议将construct方法单独封装在Director中，这样做更符合单一职责原则</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor construct() {
        buildtType();
        buildSex();
        return actor;
    }
}
</code></pre><h3 id="钩子方法的引入"><a href="#钩子方法的引入" class="headerlink" title="钩子方法的引入"></a>钩子方法的引入</h3><p>通过Director类可以更加精细地<strong>控制产品的创建过程</strong>，比如说增加一类钩子方法来控制是否调用某个build方法</p>
<p>钩子方法的返回类型一般是boolena类型，方法名一般是isXXX（）</p>
<p>钩子方法定义在抽象建造类中</p>
<p>下面案例，定义了一个钩子方法hasType()，默认都是返回true；可以在子类中改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }

    public boolean hasType(){
        return true;
    }
}
</code></pre><p>在Director中调用钩子方法hasType，如果返回结果是true，则调用buildType方法，否则不调用</p>
<pre><code>public class Director {
    public Actor construct(AbstractActorBuilder builder){
        if(builder.hasType()){
            builder.buildtType();
        }
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h2 id="第9章：适配器模式"><a href="#第9章：适配器模式" class="headerlink" title="第9章：适配器模式"></a>第9章：适配器模式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有的笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何才能让20V的笔记本电脑能够在220V的电压下工作，答案是引入一个电源适配器</p>
<h3 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h3><ul>
<li>应用程序定义了一个接口，且已经有开发人员面向该接口进行编程，所以目标接口不能修改</li>
<li>代码库中有已经实现类似该接口的功能，但接口不一致（请求参数、方法名不同），为了开发效率决定重用代码库中的类</li>
<li>引入一个适配器类，通过适配器类来调用代码库中的接口</li>
</ul>
<h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><ul>
<li>应用程序调用适配器的方法时，适配器内部将调用适配者类的方法</li>
<li><strong>适配器模式可以将一个类的接口和另一个类的接口匹配起来</strong>，而无须修改原来适配者接口和抽象目标类的接口</li>
</ul>
<p><img src="http://i.imgur.com/nGDvXzt.png" alt=""></p>
<p>具体实现代码请见清单 1-4。<br>清单 1. 客户端使用的接口</p>
<pre><code>/*
 * 定义客户端使用的接口，与业务相关
 */
public interface Target {
     /*
     * 客户端请求处理的方法
     */
    public void request();
}
</code></pre><p>清单 2. 被适配的对象</p>
<pre><code>/*
 * 已经存在的接口，这个接口需要配置
 */
public class Adaptee {
     /*
     * 原本存在的方法
     */
    public void specificRequest(){
        //业务代码
    }
}
</code></pre><p>清单 3. 适配器实现</p>
<pre><code>/*
 * 适配器类
 */
public class Adapter implements Target{
     /*
     * 持有需要被适配的接口对象
     */
    private Adaptee adaptee;
        /*
         * 构造方法，传入需要被适配的对象
         * @param adaptee 需要被适配的对象
         */
    public Adapter(Adaptee adaptee){
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // TODO Auto-generated method stub
        adaptee.specificRequest();
    }

}
</code></pre><p>清单 4. 客户端代码</p>
<pre><code>/*
 * 使用适配器的客户端
 */
public class Client {
     public static void main(String[] args){
         //创建需要被适配的对象
         Adaptee adaptee = new Adaptee();
         //创建客户端需要调用的接口对象
         Target target = new Adapter(adaptee);
         //请求处理
         target.request();
     }
}
</code></pre><h3 id="电脑适配器的例子"><a href="#电脑适配器的例子" class="headerlink" title="电脑适配器的例子"></a>电脑适配器的例子</h3><p>电</p>
<pre><code>public interface Electricity {
    public void support();
}

public class ElectricityImpl implements Electricity {

    private Integer value;

    public ElectricityImpl(Integer value){
        this.value = value;
    }

    public void support(){
        System.out.println(&quot;提供&quot;+ value +&quot;电&quot;);
    }
}
</code></pre><p>适配器</p>
<pre><code>public interface Adapter {
    public void transform();
}

public class Adapter220To12V implements Adapter{

    private Electricity electricity;

    public Adapter220To12V(Electricity electricity){
        this.electricity = electricity;
    }

    public void transform(){
        electricity.support();
        System.out.println(&quot;220V电压转成12V&quot;);
    }
}

public class Adapter330To12V implements Adapter{

    Electricity electricity;

    public Adapter330To12V(Electricity electricity){
        this.electricity = electricity;
    }

    @Override
    public void transform() {
        electricity.support();
        System.out.println(&quot;330V转成12V&quot;);
    }
}
</code></pre><p>电脑</p>
<pre><code>public interface Computer {
    public void work();
}

public class ComputerImpl implements Computer{

    private Adapter adapter;

    public ComputerImpl(Adapter adapter){
        this.adapter = adapter;
    }

    public void work(){
        adapter.transform();
        System.out.println(&quot;电脑运行需要12v&quot;);
    }
}
</code></pre><p>测试</p>
<pre><code>public class App {
    public static void main(String[] args){

        //电
        Electricity electricity = new ElectricityImpl(220);

        //适配器
        Adapter adapter = new Adapter220To12V(electricity);

        //电脑
        ComputerImpl computer = new ComputerImpl(adapter);
        computer.work();

        System.out.println(&quot;---------------------------&quot;);

        //电
        electricity = new ElectricityImpl(330);

        //适配器
        adapter = new Adapter330To12V(electricity);

        //电脑
        computer = new ComputerImpl(adapter);
        computer.work();

    }
}
</code></pre><p>结果</p>
<pre><code>提供220电
220V电压转成12V
电脑运行需要12v
---------------------------
提供330电
330V转成12V
电脑运行需要12v
</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>面向接口编程，程序有扩展性和灵活性</p>
<h3 id="缺省适配器模式"><a href="#缺省适配器模式" class="headerlink" title="缺省适配器模式"></a>缺省适配器模式</h3><p>当不需要实现一个接口所提供的所有方法时，<strong>可先设计一个抽象类实现该接口</strong>，并未接口中每个方法提供一个默认实现（空方法），<strong>那么该抽象类的子类可以选择性覆盖父类的某些方法来实现需求</strong>，它适用于不想使用一个接口中的所有方法的情况，又称单接口适配器模式</p>
<h2 id="第12章：扩展系统功能——装饰模式"><a href="#第12章：扩展系统功能——装饰模式" class="headerlink" title="第12章：扩展系统功能——装饰模式"></a>第12章：扩展系统功能——装饰模式</h2><p><a href="http://blog.csdn.net/lovelion/article/details/7425873" target="_blank" rel="external">http://blog.csdn.net/lovelion/article/details/7425873</a></p>
<p><strong>根据合成复用的原则，在实现功能复用的时候，要多用关联，少用继承</strong></p>
<ul>
<li>装饰模式可以在不改变一个对象本身功能的基础上给对象<strong>增加额外的新行为</strong></li>
<li>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系</li>
</ul>
<h3 id="装饰模式结构图"><a href="#装饰模式结构图" class="headerlink" title="装饰模式结构图"></a>装饰模式结构图</h3><p><img src="http://i.imgur.com/whQUxwW.png" alt=""></p>
<p>1、可以将一个具体构件注入装饰器类，再通过具体装饰类进行装饰<br>2、可以将一个已经装饰过Decorator子类的对象再注入其中进行多次装饰，从而对原有功能进行多次扩展</p>
<p>客户端调用：</p>
<pre><code>Component c = new ConcreteComponent();
Component component = new ConcreteDecoratorA(c);
component.operation();
</code></pre><h3 id="只有一个具体构建类的装饰模式"><a href="#只有一个具体构建类的装饰模式" class="headerlink" title="只有一个具体构建类的装饰模式"></a>只有一个具体构建类的装饰模式</h3><p><img src="http://i.imgur.com/aqAKcXE.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以对一个对象进行多次装饰，采用继承的方式在单继承语言中无法复用多个父类的功能</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>Sunny软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高 级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加 密。试使用装饰模式设计该多重加密系统。</p>
<p>类图：</p>
<p><img src="http://i.imgur.com/lor8whj.png" alt=""></p>
<p>抽象构件类</p>
<pre><code>/**
 * 抽象构件类&lt;br&gt;
 * 加密字符串抽象类
 *
 */
public abstract class StrEncrypt {

    /**
     * 加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public abstract String encryptStr(String str);

}
</code></pre><p>具体构件类</p>
<pre><code>/**
 * 具体构件类&lt;br&gt;
 * 加密字符串实现类
 *
 */
public class StrEncryptOperate extends StrEncrypt {

    @Override
    public String encryptStr(String str) {
        String encrypt = &quot;**&quot; + str + &quot;**&quot;;
        return encrypt;
    }

}
</code></pre><p>抽象装饰类</p>
<pre><code>/**
 * 抽象装饰类&lt;br&gt;
 * 加密字符串抽象装饰类
 *
 */
public class StrEncryptDecorator extends StrEncrypt {

    private StrEncrypt strEncrypt;

    public StrEncryptDecorator(StrEncrypt strEncrypt){
        this.strEncrypt = strEncrypt;
    }

    @Override
    public String encryptStr(String str) {
        return strEncrypt.encryptStr(str);
    }

}
</code></pre><p>具体装饰类 - 逆向加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 逆向加密字符串实现类
 *
 */
public class ReverseEncryptDecorator extends StrEncryptDecorator {

    public ReverseEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.reverseStr(super.encryptStr(str));
    }

    /**
     * 逆向加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String reverseStr(String str){
        String encrypt = &quot;$$&quot; + str + &quot;$$&quot;;
        return encrypt;
    }

}
</code></pre><p>具体装饰类 - 高级加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 高级加密字符串实现类
 *
 */
public class AdvanceEncryptDecorator extends StrEncryptDecorator {

    public AdvanceEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.advanceStr(super.encryptStr(str));
    }

    /**
     * 高级加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String advanceStr(String str){
        String encrypt = &quot;&amp;&amp;&quot; + str + &quot;&amp;&amp;&quot;;
        return encrypt;
    }

}
</code></pre><p>测试</p>
<pre><code>public class Test {

    public static void main(String[] args) {

        String str = &quot;aa&quot;;

        //加密字符串
        StrEncrypt strEncrypt = new StrEncryptOperate();

        //逆向加密
        StrEncrypt reverse = new ReverseEncryptDecorator(strEncrypt);
        //高级加密
        StrEncrypt advance = new AdvanceEncryptDecorator(reverse);

        System.out.println(advance.encryptStr(str));

    }

}
</code></pre><p>执行结果：&amp;&amp;$$<strong>aa</strong>$$&amp;&amp;</p>
<h2 id="第13章：提供统一入口——外观模式"><a href="#第13章：提供统一入口——外观模式" class="headerlink" title="第13章：提供统一入口——外观模式"></a>第13章：提供统一入口——外观模式</h2><p><strong>有时候客户端需要与多个子系统进行复杂的交互，而增加一个外观角色后，客户端只需要直接与外观角色交互</strong>，客户端与子系统之间原有的复杂关系由外观角色来实现，从而降低了系统的耦合度</p>
<p><img src="http://i.imgur.com/c6WHHLA.png" alt=""></p>
<p>总结：</p>
<ul>
<li>外观模式通过引入一个外观角色来简化客户端与子系统之间的交互，<strong>为复杂的子系统调用提供一个统一的入口</strong>，使子系统与客户端的耦合度降低，且客户端调用非常方便</li>
<li><strong>外观模式并不给系统增加任何新功能，它的作用就是简化调用接口</strong></li>
</ul>
<h2 id="第15章：代理模式"><a href="#第15章：代理模式" class="headerlink" title="第15章：代理模式"></a>第15章：代理模式</h2><p>客户端使用对象时，返回这个对象的代理对象，这个代理对象控制对原对象的引用，对于客户端的使用是透明的</p>
<p><img src="http://i.imgur.com/Czffk8B.png" alt=""></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><img src="http://i.imgur.com/F5VGhOh.png" alt=""></p>
<p>1、定义接口Subject</p>
<pre><code>public interface Subject {
    public void request();
}
</code></pre><p>2、实现接口</p>
<pre><code>public class Proxy implements Subject{

    public void request() {

    }

}

public class RealSubject implements Subject{
    public void request() {
        System.out.println(&quot;处理请求&quot;);
    }
}
</code></pre><p>3、代理类中存放目标类的实例，并且添加新的方法、调用目标类的方法</p>
<pre><code>public class Proxy implements Subject{
    private RealSubject realSubject;
    public Proxy(RealSubject realSubject){
        this.realSubject = realSubject;
    }

    public void request() {
        preRequest();
        realSubject.request();
        postRequest();
    }

    private void postRequest() {
        System.out.println(&quot;记录时间&quot;);
    }

    private void preRequest() {
        System.out.println(&quot;日志记录&quot;);
    }
}
</code></pre><p>4、测试</p>
<pre><code>public class Run {
    public static void main(String[] args){
        RealSubject realSubject = new RealSubject();
        Subject proxy = new Proxy(realSubject);
        proxy.request();
    }
}
</code></pre><p>结果：</p>
<pre><code>日志记录
处理请求
记录时间
</code></pre><p>在不增加目标类的情况下，扩展了方法</p>
<h3 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h3><ul>
<li>通常情况下，代理类所实现的接口和所代理的方法都被固定，这种代理称之为 <strong>静态代理</strong></li>
<li>静态代理若需要对不同目标对象进行代理，或者对同一目标类代理不同的方法，都需要增加新的代理类，这就造成类的个数急剧增加</li>
<li>动态代理可以让一个类 <strong>代理多个不同的目标类</strong>，而且可以 <strong>代理不同的方法</strong></li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、调用处理函数程序类，传入目标对象、调用目标函数的方法、扩展方法</p>
<pre><code>class SubjectHandler implements InvocationHandler{
    //目标类的引用，通过构造方法传入对象
    private Object target;

    public SubjectHandler(Object target){
        this.target = target;
    }

    /*
    * 调用代理对象的方法时，调用此方法
    * Object proxy是代理的对象, Method method是真实对象中调用方法的Method类, Object[] args是真实对象中调用方法的参数

    */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        preHandler();
        Object o = method.invoke(target, args);
        postHandler();
        return o;
    }

    private void postHandler() {
        System.out.println(&quot;后置方法&quot;);
    }

    private void preHandler() {
        System.out.println(&quot;前置方法&quot;);
    }
}
</code></pre><p>2、创建动态代理</p>
<pre><code>public class Client {
    public static void main(String[] args){

        //目标类
        RealSubject realSubject = new RealSubject();
        //调用处理处理程序
        InvocationHandler invocationHandler = new SubjectHandler(realSubject);
        /** 创建代理类的实例
         *  第一个参数表示代理类的类加载器
         *  第二个参数表示代理类所实现的接口列表
         *  第三个参数为调用处理程序类，可以是new Class[]{Subject.class}，
         *      也可以 RealSubject.class.getInterfaces()
         */
        Subject proxy = (Subject) Proxy.newProxyInstance(Client.class.getClassLoader(), new Class[]{Subject.class},invocationHandler);
        proxy.request();
    }
}
</code></pre><p>原理：</p>
<p><a href="http://www.cnblogs.com/flyoung2008/p/3251148.html" target="_blank" rel="external">http://www.cnblogs.com/flyoung2008/p/3251148.html</a></p>
<p>Proxy静态方法newProxyInstance-&gt;类Proxy的getProxyClass方法<strong>调用ProxyGenerator的 generateProxyClass方法产生ProxySubject.class的二进制数据，需要传入参数类名和实现接口</strong>，以下为测试ProxyGenerator的generateProxyClass方法：</p>
<pre><code>byte[] proxyClassFile =    ProxyGenerator.generateProxyClass(&quot;xxx&quot;, new Class[]{Subject.class});
OutputStream o = new FileOutputStream(&quot;xxx.class&quot;);
o.write(proxyClassFile,0,proxyClassFile.length);
o.close();
</code></pre><p>产生字节码，经反编译后得到的结果：<br>生成的类继承Proxy，而且实现传入的接口方法request，每次调用接口方法，将会调用InvocationHandler的invoke方法</p>
<pre>
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

import Proxy.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class xxx <font color="red">extends Proxy implements Subject</font> {
    private static Method m1;
    private static Method m3;
    private static Method m0;
    private static Method m2;

    public xxx(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    <font color="red">//接口实现的方法</font>
    public final void request() throws  {
        try {
            //调用h为InvocationHandler类型，为Proxy的成员变量，创建代理对象的时候作为参数传入
            <font color="red">super.h.invoke(this, m3, (Object[])null);</font>
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]{Class.forName("java.lang.Object")});
            m3 = Class.forName("Proxy.Subject").getMethod("request", new Class[0]);
            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</pre>

<p>总结：</p>
<ul>
<li>使用：1、创建目标对象 2、自定义类实现InvocationHandler接口，构造函数中传入目标对象，在实现的接口方法Invoke中对根据选择对方法进行代理 3、调用Proxy.newProxyInstance方法中传入是三个参数，分别是类加载器，代理的接口和自定义InvocationHandler实例，返回代理对象</li>
<li>原理：1、调用ProxyGenerator的generateProxyClass方法产生ProxySubject.class的二进制数据，需要传入参数类名和实现接口，生成的代理类在调用接口方法时，会调用传入的InvocationHandler的invoke方法 2、利用反射创建代理对象的实例，并且传入InvocationHandler参数，返回代理对象实例</li>
<li>设计：</li>
</ul>
<h4 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h4><p>1、动态代理需要 <strong>代理不同的目标对象</strong> 和 <strong>同一目标对象的不同方法</strong>，所以动态代理类中需要传入代理方法（<strong>接口</strong>）和<strong>代理对象</strong><br>2、在Object newProxyInstance(ClassLoader loader,     Class&lt;?&gt;[] interfaces,InvocationHandler h)方法中直接传入接口，和InvocationHandler的实例，其中实例中传入目标对象，和调用处理方法，根据要求对不同方法进行代理</p>
<h3 id="其他的代理类型"><a href="#其他的代理类型" class="headerlink" title="其他的代理类型"></a>其他的代理类型</h3><p>1、远程代理：位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机，也可以在另一台主机中。在Java语言中，可以通过RMI机制来实现远程代理</p>
<p>2、虚拟代理：如果需要创建一个资源消耗较大的资源，先创建一个消耗相对较小的对象来表示，真是对象只是在需要时才会被真正创建。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<h2 id="第22章：对象间的联动——观察者模式"><a href="#第22章：对象间的联动——观察者模式" class="headerlink" title="第22章：对象间的联动——观察者模式"></a>第22章：对象间的联动——观察者模式</h2><p>观察者模式定义对象之间的一种一对多依赖关系，使得 <strong>当一个对对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</strong></p>
<p>在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者</p>
<h3 id="观察者模式示意代码"><a href="#观察者模式示意代码" class="headerlink" title="观察者模式示意代码"></a>观察者模式示意代码</h3><p>定义一个抽象目标Subject</p>
<pre><code>import java.util.*;
abstract class Subject {
    //定义一个观察者集合用于存储所有观察者对象
    protected ArrayList observers&lt;Observer&gt; = new ArrayList();

    //注册方法，用于向观察者集合中增加一个观察者
    public void attach(Observer observer) {
        observers.add(observer);
    }

    //注销方法，用于在观察者集合中删除一个观察者
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    //声明抽象通知方法
    public abstract void notify();
}    
</code></pre><p>具体目标类ConcreteSubject（如果无须扩展目标类，则具体目标类可省略）</p>
<pre><code>class ConcreteSubject extends Subject {  
    //实现通知方法  
    public void notify() {  
        //遍历观察者集合，调用每一个观察者的响应方法  
        for(Object obs:observers) {  
            ((Observer)obs).update();  
        }  
    }     
}  
</code></pre><p>抽象观察者角色一般定义为一个接口，通常只声明一个update()方法</p>
<pre><code>interface Observer {  
    //声明响应方法  
    public void update();  
}  
</code></pre><p>具体观察者ConcreteObserver中实现了update()方法</p>
<pre><code>class ConcreteObserver implements Observer {  
    //实现响应方法  
    public void update() {  
        //具体响应代码  
    }  
} 
</code></pre><h3 id="多人联机对战游戏结构图"><a href="#多人联机对战游戏结构图" class="headerlink" title="多人联机对战游戏结构图"></a>多人联机对战游戏结构图</h3><p><img src="http://i.imgur.com/hfZUs1B.jpg" alt=""></p>
<p>抽象观察类  </p>
<pre><code>interface Observer {  
    public String getName();  
    public void setName(String name);  
    public void help(); //声明支援盟友方法  
    public void beAttacked(AllyControlCenter acc); //声明遭受攻击方法  
}  
</code></pre><p>战队成员类：具体观察者类  </p>
<pre><code>class Player implements Observer {  
    private String name;  

    public Player(String name) {  
        this.name = name;  
    }  

    public void setName(String name) {  
        this.name = name;  
    }  

    public String getName() {  
        return this.name;  
    }  

    //支援盟友方法的实现  
    public void help() {  
        System.out.println(&quot;坚持住，&quot; + this.name + &quot;来救你！&quot;);  
    }  

    //遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法notifyObserver()来通知盟友  
    public void beAttacked(AllyControlCenter acc) {  
        System.out.println(this.name + &quot;被攻击！&quot;);  
        acc.notifyObserver(name);         
    }  
}  
</code></pre><p>战队控制中心类：目标类  </p>
<pre><code>abstract class AllyControlCenter {  
    protected String allyName; //战队名称  
    protected ArrayList&lt;Observer&gt; players = new ArrayList&lt;Observer&gt;(); //定义一个集合用于存储战队成员  

    public void setAllyName(String allyName) {  
        this.allyName = allyName;  
    }  

    public String getAllyName() {  
        return this.allyName;  
    }  

    //注册方法  
    public void join(Observer obs) {  
        System.out.println(obs.getName() + &quot;加入&quot; + this.allyName + &quot;战队！&quot;);  
        players.add(obs);  
    }  

    //注销方法  
    public void quit(Observer obs) {  
        System.out.println(obs.getName() + &quot;退出&quot; + this.allyName + &quot;战队！&quot;);  
        players.remove(obs);  
    }  

    //声明抽象通知方法  
    public abstract void notifyObserver(String name);  
}  
</code></pre><p>具体战队控制中心类：具体目标类  </p>
<pre><code>class ConcreteAllyControlCenter extends AllyControlCenter {  
    public ConcreteAllyControlCenter(String allyName) {  
        System.out.println(allyName + &quot;战队组建成功！&quot;);  
        System.out.println(&quot;----------------------------&quot;);  
        this.allyName = allyName;  
    }  

    //实现通知方法  
    public void notifyObserver(String name) {  
        System.out.println(this.allyName + &quot;战队紧急通知，盟友&quot; + name + &quot;遭受敌人攻击！&quot;);  
        //遍历观察者集合，调用每一个盟友（自己除外）的支援方法  
        for(Object obs : players) {  
            if (!((Observer)obs).getName().equalsIgnoreCase(name)) {  
                ((Observer)obs).help();  
            }  
        }         
    }  
}  
</code></pre><p>编写如下客户端测试代码：</p>
<pre><code>class Client {  
    public static void main(String args[]) {  
        //定义观察目标对象  
        AllyControlCenter acc;  
        acc = new ConcreteAllyControlCenter(&quot;金庸群侠&quot;);  

        //定义四个观察者对象  
        Observer player1,player2,player3,player4;  

        player1 = new Player(&quot;杨过&quot;);  
        acc.join(player1);  

        player2 = new Player(&quot;令狐冲&quot;);  
        acc.join(player2);  

        player3 = new Player(&quot;张无忌&quot;);  
        acc.join(player3);  

        player4 = new Player(&quot;段誉&quot;);  
        acc.join(player4);  

        //某成员遭受攻击  
        Player1.beAttacked(acc);  
    }  
} 
</code></pre><h2 id="JDK对观察者模式的支持"><a href="#JDK对观察者模式的支持" class="headerlink" title="JDK对观察者模式的支持"></a>JDK对观察者模式的支持</h2><p><img src="http://i.imgur.com/D8P7zwo.jpg" alt=""></p>
<p>(1)Observer接口<br>在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：</p>
<pre><code>void  update(Observable o, Object arg);
</code></pre><p>当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。</p>
<p>(2)Observable类<br>java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象</p>
<p>实例：</p>
<p>观察者：</p>
<pre><code>public class Listener implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;update&quot;);
    }
}
</code></pre><p>观察目标：</p>
<pre><code>public class Source extends Observable {

    public void fire(){
        setChanged();
        notifyObservers();
    }
}
</code></pre><p>测试：</p>
<pre><code>public class APP {
    public static void main(String[] args){
        Observer listener = new Listener();
        Source source = new Source();
        source.addObserver(listener);

        source.fire();
    }
}
</code></pre><h2 id="ThreadLocal设计模式"><a href="#ThreadLocal设计模式" class="headerlink" title="ThreadLocal设计模式"></a>ThreadLocal设计模式</h2><p><a href="https://my.oschina.net/pingpangkuangmo/blog/376321" target="_blank" rel="external">https://my.oschina.net/pingpangkuangmo/blog/376321</a></p>
<p>ThreadLocal设计模式：<br>（1）ThreadLocal所操作的数据是<strong>线程间不共享的</strong>。它不是用来解决多个线程竞争同一资源的多线程问题<br>（2）ThreadLocal所操作的数据主要用于<strong>线程内共享数据</strong>，可以避免同一线程内函数间的传参数问题</p>
<p>ThreadLocal更像是一个操作线程数据的工具类，哪个线程调用它，它就操作哪个线程的数据。 </p>
<p>其中ThreadUtil就是用ThreadLocal来实现的，ThreadLocal完全可以这样理解，它就是操作线程数据的工具类，哪个线程调用它的get或set方法，它就会操作调用它的线程中的数据如下：</p>
<pre><code>public class ThreadUtil {

    private static ThreadLocal&lt;String&gt; nameLocal=new ThreadLocal&lt;String&gt;();

    public static String getName(){
        return nameLocal.get();
    }

    public static void setName(String name){
        nameLocal.set(name);
    }
}
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/06/[Tomcat]Tomcat笔记/" rel="prev" title="Tomcat笔记">
                Tomcat笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">86</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java反射"><span class="nav-number">1.</span> <span class="nav-text">Java反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XMLUtil"><span class="nav-number">2.</span> <span class="nav-text">XMLUtil</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式：确保一个类只有一个实例"><span class="nav-number">2.1.</span> <span class="nav-text">单例模式：确保一个类只有一个实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章：集中式工厂的实现——简单工厂模式"><span class="nav-number">3.</span> <span class="nav-text">第4章：集中式工厂的实现——简单工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计思想"><span class="nav-number">3.1.</span> <span class="nav-text">设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类图"><span class="nav-number">3.2.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂模式的简化"><span class="nav-number">3.3.</span> <span class="nav-text">简单工厂模式的简化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象与使用对象"><span class="nav-number">3.4.</span> <span class="nav-text">创建对象与使用对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章：多态工厂的实现——工厂方法模式"><span class="nav-number">4.</span> <span class="nav-text">第5章：多态工厂的实现——工厂方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式结构图"><span class="nav-number">4.1.</span> <span class="nav-text">工厂方法模式结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用工厂方法模式设计的日志记录器"><span class="nav-number">4.2.</span> <span class="nav-text">使用工厂方法模式设计的日志记录器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章：产品族的创建——抽象工厂模式"><span class="nav-number">5.</span> <span class="nav-text">第6章：产品族的创建——抽象工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#产品等级结构与产品族"><span class="nav-number">5.1.</span> <span class="nav-text">产品等级结构与产品族</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式结构图"><span class="nav-number">5.2.</span> <span class="nav-text">抽象工厂模式结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整解决方案"><span class="nav-number">5.3.</span> <span class="nav-text">完整解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章：复杂对象的组装与创建——建造者模式"><span class="nav-number">6.</span> <span class="nav-text">第8章：复杂对象的组装与创建——建造者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有Director的建造者模式"><span class="nav-number">6.1.</span> <span class="nav-text">有Director的建造者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#省略Director"><span class="nav-number">6.2.</span> <span class="nav-text">省略Director</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#钩子方法的引入"><span class="nav-number">6.3.</span> <span class="nav-text">钩子方法的引入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9章：适配器模式"><span class="nav-number">7.</span> <span class="nav-text">第9章：适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">7.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器模式的使用场景"><span class="nav-number">7.2.</span> <span class="nav-text">适配器模式的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类图-1"><span class="nav-number">7.3.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电脑适配器的例子"><span class="nav-number">7.4.</span> <span class="nav-text">电脑适配器的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本质"><span class="nav-number">7.5.</span> <span class="nav-text">本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺省适配器模式"><span class="nav-number">7.6.</span> <span class="nav-text">缺省适配器模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12章：扩展系统功能——装饰模式"><span class="nav-number">8.</span> <span class="nav-text">第12章：扩展系统功能——装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰模式结构图"><span class="nav-number">8.1.</span> <span class="nav-text">装饰模式结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只有一个具体构建类的装饰模式"><span class="nav-number">8.2.</span> <span class="nav-text">只有一个具体构建类的装饰模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">8.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课后题"><span class="nav-number">8.4.</span> <span class="nav-text">课后题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13章：提供统一入口——外观模式"><span class="nav-number">9.</span> <span class="nav-text">第13章：提供统一入口——外观模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第15章：代理模式"><span class="nav-number">10.</span> <span class="nav-text">第15章：代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现步骤"><span class="nav-number">10.1.</span> <span class="nav-text">实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-动态代理"><span class="nav-number">10.2.</span> <span class="nav-text">Java 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤"><span class="nav-number">10.2.1.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么这么设计"><span class="nav-number">10.2.2.</span> <span class="nav-text">为什么这么设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他的代理类型"><span class="nav-number">10.3.</span> <span class="nav-text">其他的代理类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第22章：对象间的联动——观察者模式"><span class="nav-number">11.</span> <span class="nav-text">第22章：对象间的联动——观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式示意代码"><span class="nav-number">11.1.</span> <span class="nav-text">观察者模式示意代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多人联机对战游戏结构图"><span class="nav-number">11.2.</span> <span class="nav-text">多人联机对战游戏结构图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK对观察者模式的支持"><span class="nav-number">12.</span> <span class="nav-text">JDK对观察者模式的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal设计模式"><span class="nav-number">13.</span> <span class="nav-text">ThreadLocal设计模式</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  

  

  

  

  

</body>
</html>
