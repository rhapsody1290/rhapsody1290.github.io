<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="设计模式," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="第8章：复杂对象的组装与创建——建造者模式建造者模式是为了解决这类问题：如何一步一步地创建一个包含多个组个组成部分的复杂对象

建造者模式将包含多个组成部分的复杂对象的创建过程分离
不同具体的建造者定义了不同的创建过程
建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性

有Director的建造者模式Director类有两个作用：

隔离了客户与创建过程，客户只要与Director类">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式的艺术之道笔记">
<meta property="og:url" content="http://yoursite.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/index.html">
<meta property="og:site_name" content="Mr.Qian's Home">
<meta property="og:description" content="第8章：复杂对象的组装与创建——建造者模式建造者模式是为了解决这类问题：如何一步一步地创建一个包含多个组个组成部分的复杂对象

建造者模式将包含多个组成部分的复杂对象的创建过程分离
不同具体的建造者定义了不同的创建过程
建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性

有Director的建造者模式Director类有两个作用：

隔离了客户与创建过程，客户只要与Director类">
<meta property="og:image" content="http://i.imgur.com/mNnbWcu.png">
<meta property="og:image" content="http://i.imgur.com/nGDvXzt.png">
<meta property="og:image" content="http://i.imgur.com/whQUxwW.png">
<meta property="og:image" content="http://i.imgur.com/aqAKcXE.png">
<meta property="og:image" content="http://i.imgur.com/lor8whj.png">
<meta property="og:image" content="http://i.imgur.com/c6WHHLA.png">
<meta property="og:image" content="http://i.imgur.com/Czffk8B.png">
<meta property="og:image" content="http://i.imgur.com/F5VGhOh.png">
<meta property="og:updated_time" content="2016-11-25T07:22:38.835Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式的艺术之道笔记">
<meta name="twitter:description" content="第8章：复杂对象的组装与创建——建造者模式建造者模式是为了解决这类问题：如何一步一步地创建一个包含多个组个组成部分的复杂对象

建造者模式将包含多个组成部分的复杂对象的创建过程分离
不同具体的建造者定义了不同的创建过程
建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性

有Director的建造者模式Director类有两个作用：

隔离了客户与创建过程，客户只要与Director类">
<meta name="twitter:image" content="http://i.imgur.com/mNnbWcu.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/"/>


  <title> 设计模式的艺术之道笔记 | Mr.Qian's Home </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mr.Qian's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                设计模式的艺术之道笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T00:00:00+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/06/[设计模式]设计模式的艺术之道笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/06/[设计模式]设计模式的艺术之道笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第8章：复杂对象的组装与创建——建造者模式"><a href="#第8章：复杂对象的组装与创建——建造者模式" class="headerlink" title="第8章：复杂对象的组装与创建——建造者模式"></a>第8章：复杂对象的组装与创建——建造者模式</h2><p>建造者模式是为了解决这类问题：<strong>如何一步一步地创建一个包含多个组个组成部分的复杂对象</strong></p>
<ul>
<li>建造者模式将包含多个组成部分的复杂对象的创建过程分离</li>
<li><strong>不同具体的建造者定义了不同的创建过程</strong></li>
<li>建造新的建造者非常方便，无需修改已有代码，系统具有较好的扩展性</li>
</ul>
<h3 id="有Director的建造者模式"><a href="#有Director的建造者模式" class="headerlink" title="有Director的建造者模式"></a>有Director的建造者模式</h3><p>Director类有两个作用：</p>
<ul>
<li>隔离了客户与创建过程，客户只要与Director类进行交互</li>
<li><strong>控制产品的创建过程</strong>，传入不同具体的建造者，输出产品</li>
</ul>
<p>Builder类的作用：创建对象的各个组件</p>
<p><img src="http://i.imgur.com/mNnbWcu.png" alt=""></p>
<p>Actor：定义输出的对象类型</p>
<pre><code>public class Actor {
    private String type;
    private String sex;

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return &quot;Actor{&quot; +
                &quot;sex=&apos;&quot; + sex + &apos;\&apos;&apos; +
                &quot;, type=&apos;&quot; + type + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>AbstractActorBuilder：抽象的对象创建方法，对象的组建过程分为两步：buildtType、buildSex，然后调用getResult方法输出，组建方法需要由子类改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }
}
</code></pre><p>HeroActorBuilder、AngelActorBuilder：定义了不同的组建过程</p>
<pre><code>public class HeroActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;英雄&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;男&quot;);
    }
}

public class AngelActorBuilder extends AbstractActorBuilder{
    @Override
    public void buildtType() {
        actor.setType(&quot;Angle&quot;);
    }

    @Override
    public void buildSex() {
        actor.setSex(&quot;女&quot;);
    }
}
</code></pre><p>Director：导演类封装了复杂对象的组建过程，客户端只需调用contruct方法，并传入对应的组建类，就可以得到所需要创建的类</p>
<pre><code>public class Director {
    public Actor contruct(AbstractActorBuilder builder){
        builder.buildtType();
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h3 id="省略Director"><a href="#省略Director" class="headerlink" title="省略Director"></a>省略Director</h3><p>AbstractActorBuilder需要承担创建复杂对象各个部分的职责，还要控制整个对象组建的顺序，但对系统的灵活性和可扩展性并没有任何影响</p>
<p>建议将construct方法单独封装在Director中，这样做更符合单一职责原则</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor construct() {
        buildtType();
        buildSex();
        return actor;
    }
}
</code></pre><h3 id="钩子方法的引入"><a href="#钩子方法的引入" class="headerlink" title="钩子方法的引入"></a>钩子方法的引入</h3><p>通过Director类可以更加精细地<strong>控制产品的创建过程</strong>，比如说增加一类钩子方法来控制是否调用某个build方法</p>
<p>钩子方法的返回类型一般是boolena类型，方法名一般是isXXX（）</p>
<p>钩子方法定义在抽象建造类中</p>
<p>下面案例，定义了一个钩子方法hasType()，默认都是返回true；可以在子类中改写</p>
<pre><code>public abstract class AbstractActorBuilder{
    protected Actor actor = new Actor();

    public abstract void buildtType();

    public abstract void buildSex();

    public Actor getResult() {
        return actor;
    }

    public boolean hasType(){
        return true;
    }
}
</code></pre><p>在Director中调用钩子方法hasType，如果返回结果是true，则调用buildType方法，否则不调用</p>
<pre><code>public class Director {
    public Actor construct(AbstractActorBuilder builder){
        if(builder.hasType()){
            builder.buildtType();
        }
        builder.buildSex();
        return builder.getResult();
    }
}
</code></pre><h2 id="第9章：适配器模式"><a href="#第9章：适配器模式" class="headerlink" title="第9章：适配器模式"></a>第9章：适配器模式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有的笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何才能让20V的笔记本电脑能够在220V的电压下工作，答案是引入一个电源适配器</p>
<h3 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h3><ul>
<li>应用程序定义了一个接口，且已经有开发人员面向该接口进行编程，所以目标接口不能修改</li>
<li>代码库中有已经实现类似该接口的功能，但接口不一致（请求参数、方法名不同），为了开发效率决定重用代码库中的类</li>
<li>引入一个适配器类，通过适配器类来调用代码库中的接口</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul>
<li>应用程序调用适配器的方法时，适配器内部将调用适配者类的方法</li>
<li><strong>适配器模式可以将一个类的接口和另一个类的接口匹配起来</strong>，而无须修改原来适配者接口和抽象目标类的接口</li>
</ul>
<p><img src="http://i.imgur.com/nGDvXzt.png" alt=""></p>
<p>具体实现代码请见清单 1-4。<br>清单 1. 客户端使用的接口</p>
<pre><code>/*
 * 定义客户端使用的接口，与业务相关
 */
public interface Target {
     /*
     * 客户端请求处理的方法
     */
    public void request();
}
</code></pre><p>清单 2. 被适配的对象</p>
<pre><code>/*
 * 已经存在的接口，这个接口需要配置
 */
public class Adaptee {
     /*
     * 原本存在的方法
     */
    public void specificRequest(){
        //业务代码
    }
}
</code></pre><p>清单 3. 适配器实现</p>
<pre><code>/*
 * 适配器类
 */
public class Adapter implements Target{
     /*
     * 持有需要被适配的接口对象
     */
    private Adaptee adaptee;
        /*
         * 构造方法，传入需要被适配的对象
         * @param adaptee 需要被适配的对象
         */
    public Adapter(Adaptee adaptee){
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // TODO Auto-generated method stub
        adaptee.specificRequest();
    }

}
</code></pre><p>清单 4. 客户端代码</p>
<pre><code>/*
 * 使用适配器的客户端
 */
public class Client {
     public static void main(String[] args){
         //创建需要被适配的对象
         Adaptee adaptee = new Adaptee();
         //创建客户端需要调用的接口对象
         Target target = new Adapter(adaptee);
         //请求处理
         target.request();
     }
}
</code></pre><h3 id="电脑适配器的例子"><a href="#电脑适配器的例子" class="headerlink" title="电脑适配器的例子"></a>电脑适配器的例子</h3><p>电</p>
<pre><code>public interface Electricity {
    public void support();
}

public class ElectricityImpl implements Electricity {

    private Integer value;

    public ElectricityImpl(Integer value){
        this.value = value;
    }

    public void support(){
        System.out.println(&quot;提供&quot;+ value +&quot;电&quot;);
    }
}
</code></pre><p>适配器</p>
<pre><code>public interface Adapter {
    public void transform();
}

public class Adapter220To12V implements Adapter{

    private Electricity electricity;

    public Adapter220To12V(Electricity electricity){
        this.electricity = electricity;
    }

    public void transform(){
        electricity.support();
        System.out.println(&quot;220V电压转成12V&quot;);
    }
}

public class Adapter330To12V implements Adapter{

    Electricity electricity;

    public Adapter330To12V(Electricity electricity){
        this.electricity = electricity;
    }

    @Override
    public void transform() {
        electricity.support();
        System.out.println(&quot;330V转成12V&quot;);
    }
}
</code></pre><p>电脑</p>
<pre><code>public interface Computer {
    public void work();
}

public class ComputerImpl implements Computer{

    private Adapter adapter;

    public ComputerImpl(Adapter adapter){
        this.adapter = adapter;
    }

    public void work(){
        adapter.transform();
        System.out.println(&quot;电脑运行需要12v&quot;);
    }
}
</code></pre><p>测试</p>
<pre><code>public class App {
    public static void main(String[] args){

        //电
        Electricity electricity = new ElectricityImpl(220);

        //适配器
        Adapter adapter = new Adapter220To12V(electricity);

        //电脑
        ComputerImpl computer = new ComputerImpl(adapter);
        computer.work();

        System.out.println(&quot;---------------------------&quot;);

        //电
        electricity = new ElectricityImpl(330);

        //适配器
        adapter = new Adapter330To12V(electricity);

        //电脑
        computer = new ComputerImpl(adapter);
        computer.work();

    }
}
</code></pre><p>结果</p>
<pre><code>提供220电
220V电压转成12V
电脑运行需要12v
---------------------------
提供330电
330V转成12V
电脑运行需要12v
</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>面向接口编程，程序有扩展性和灵活性</p>
<h3 id="缺省适配器模式"><a href="#缺省适配器模式" class="headerlink" title="缺省适配器模式"></a>缺省适配器模式</h3><p>当不需要实现一个接口所提供的所有方法时，<strong>可先设计一个抽象类实现该接口</strong>，并未接口中每个方法提供一个默认实现（空方法），<strong>那么该抽象类的子类可以选择性覆盖父类的某些方法来实现需求</strong>，它适用于不想使用一个接口中的所有方法的情况，又称单接口适配器模式</p>
<h2 id="第12章：扩展系统功能——装饰模式"><a href="#第12章：扩展系统功能——装饰模式" class="headerlink" title="第12章：扩展系统功能——装饰模式"></a>第12章：扩展系统功能——装饰模式</h2><p><a href="http://blog.csdn.net/lovelion/article/details/7425873" target="_blank" rel="external">http://blog.csdn.net/lovelion/article/details/7425873</a></p>
<p><strong>根据合成复用的原则，在实现功能复用的时候，要多用关联，少用继承</strong></p>
<ul>
<li>装饰模式可以在不改变一个对象本身功能的基础上给对象<strong>增加额外的新行为</strong></li>
<li>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系</li>
</ul>
<h3 id="装饰模式结构图"><a href="#装饰模式结构图" class="headerlink" title="装饰模式结构图"></a>装饰模式结构图</h3><p><img src="http://i.imgur.com/whQUxwW.png" alt=""></p>
<p>1、可以将一个具体构件注入装饰器类，再通过具体装饰类进行装饰<br>2、可以将一个已经装饰过Decorator子类的对象再注入其中进行多次装饰，从而对原有功能进行多次扩展</p>
<p>客户端调用：</p>
<pre><code>Component c = new ConcreteComponent();
Component component = new ConcreteDecoratorA(c);
component.operation();
</code></pre><h3 id="只有一个具体构建类的装饰模式"><a href="#只有一个具体构建类的装饰模式" class="headerlink" title="只有一个具体构建类的装饰模式"></a>只有一个具体构建类的装饰模式</h3><p><img src="http://i.imgur.com/aqAKcXE.png" alt=""></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以对一个对象进行多次装饰，采用继承的方式在单继承语言中无法复用多个父类的功能</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>Sunny软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高 级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加 密。试使用装饰模式设计该多重加密系统。</p>
<p>类图：</p>
<p><img src="http://i.imgur.com/lor8whj.png" alt=""></p>
<p>抽象构件类</p>
<pre><code>/**
 * 抽象构件类&lt;br&gt;
 * 加密字符串抽象类
 *
 */
public abstract class StrEncrypt {

    /**
     * 加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public abstract String encryptStr(String str);

}
</code></pre><p>具体构件类</p>
<pre><code>/**
 * 具体构件类&lt;br&gt;
 * 加密字符串实现类
 *
 */
public class StrEncryptOperate extends StrEncrypt {

    @Override
    public String encryptStr(String str) {
        String encrypt = &quot;**&quot; + str + &quot;**&quot;;
        return encrypt;
    }

}
</code></pre><p>抽象装饰类</p>
<pre><code>/**
 * 抽象装饰类&lt;br&gt;
 * 加密字符串抽象装饰类
 *
 */
public class StrEncryptDecorator extends StrEncrypt {

    private StrEncrypt strEncrypt;

    public StrEncryptDecorator(StrEncrypt strEncrypt){
        this.strEncrypt = strEncrypt;
    }

    @Override
    public String encryptStr(String str) {
        return strEncrypt.encryptStr(str);
    }

}
</code></pre><p>具体装饰类 - 逆向加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 逆向加密字符串实现类
 *
 */
public class ReverseEncryptDecorator extends StrEncryptDecorator {

    public ReverseEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.reverseStr(super.encryptStr(str));
    }

    /**
     * 逆向加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String reverseStr(String str){
        String encrypt = &quot;$$&quot; + str + &quot;$$&quot;;
        return encrypt;
    }

}
</code></pre><p>具体装饰类 - 高级加密字符串</p>
<pre><code>/**
 * 具体装饰类&lt;br&gt;
 * 高级加密字符串实现类
 *
 */
public class AdvanceEncryptDecorator extends StrEncryptDecorator {

    public AdvanceEncryptDecorator(StrEncrypt strEncrypt) {
        super(strEncrypt);
    }

    @Override
    public String encryptStr(String str) {    
        return this.advanceStr(super.encryptStr(str));
    }

    /**
     * 高级加密字符串
     * 
     * @param str 需要加密的字符串
     * @return String 加密后的字符串
     */
    public String advanceStr(String str){
        String encrypt = &quot;&amp;&amp;&quot; + str + &quot;&amp;&amp;&quot;;
        return encrypt;
    }

}
</code></pre><p>测试</p>
<pre><code>public class Test {

    public static void main(String[] args) {

        String str = &quot;aa&quot;;

        //加密字符串
        StrEncrypt strEncrypt = new StrEncryptOperate();

        //逆向加密
        StrEncrypt reverse = new ReverseEncryptDecorator(strEncrypt);
        //高级加密
        StrEncrypt advance = new AdvanceEncryptDecorator(reverse);

        System.out.println(advance.encryptStr(str));

    }

}
</code></pre><p>执行结果：&amp;&amp;$$<strong>aa</strong>$$&amp;&amp;</p>
<h2 id="第13章：提供统一入口——外观模式"><a href="#第13章：提供统一入口——外观模式" class="headerlink" title="第13章：提供统一入口——外观模式"></a>第13章：提供统一入口——外观模式</h2><p><strong>有时候客户端需要与多个子系统进行复杂的交互，而增加一个外观角色后，客户端只需要直接与外观角色交互</strong>，客户端与子系统之间原有的复杂关系由外观角色来实现，从而降低了系统的耦合度</p>
<p><img src="http://i.imgur.com/c6WHHLA.png" alt=""></p>
<p>总结：</p>
<ul>
<li>外观模式通过引入一个外观角色来简化客户端与子系统之间的交互，<strong>为复杂的子系统调用提供一个统一的入口</strong>，使子系统与客户端的耦合度降低，且客户端调用非常方便</li>
<li><strong>外观模式并不给系统增加任何新功能，它的作用就是简化调用接口</strong></li>
</ul>
<h2 id="第15章：代理模式"><a href="#第15章：代理模式" class="headerlink" title="第15章：代理模式"></a>第15章：代理模式</h2><p>客户端使用对象时，返回这个对象的代理对象，这个代理对象控制对原对象的引用，对于客户端的使用是透明的</p>
<p><img src="http://i.imgur.com/Czffk8B.png" alt=""></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><img src="http://i.imgur.com/F5VGhOh.png" alt=""></p>
<p>1、定义接口Subject</p>
<pre><code>public interface Subject {
    public void request();
}
</code></pre><p>2、实现接口</p>
<pre><code>public class Proxy implements Subject{

    public void request() {

    }

}

public class RealSubject implements Subject{
    public void request() {
        System.out.println(&quot;处理请求&quot;);
    }
}
</code></pre><p>3、代理类中存放目标类的实例，并且添加新的方法、调用目标类的方法</p>
<pre><code>public class Proxy implements Subject{
    private RealSubject realSubject;
    public Proxy(RealSubject realSubject){
        this.realSubject = realSubject;
    }

    public void request() {
        preRequest();
        realSubject.request();
        postRequest();
    }

    private void postRequest() {
        System.out.println(&quot;记录时间&quot;);
    }

    private void preRequest() {
        System.out.println(&quot;日志记录&quot;);
    }
}
</code></pre><p>4、测试</p>
<pre><code>public class Run {
    public static void main(String[] args){
        RealSubject realSubject = new RealSubject();
        Subject proxy = new Proxy(realSubject);
        proxy.request();
    }
}
</code></pre><p>结果：</p>
<pre><code>日志记录
处理请求
记录时间
</code></pre><p>在不增加目标类的情况下，扩展了方法</p>
<h3 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h3><ul>
<li>通常情况下，代理类所实现的接口和所代理的方法都被固定，这种代理称之为 <strong>静态代理</strong></li>
<li>静态代理若需要对不同目标对象进行代理，或者对同一目标类代理不同的方法，都需要增加新的代理类，这就造成类的个数急剧增加</li>
<li>动态代理可以让一个类 <strong>代理多个不同的目标类</strong>，而且可以 <strong>代理不同的方法</strong></li>
</ul>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、调用处理函数程序类，传入目标对象、调用目标函数的方法、扩展方法</p>
<pre><code>class SubjectHandler implements InvocationHandler{
    //目标类的引用
    private Object target;

    public SubjectHandler(Object target){
        this.target = target;
    }

    /*
    * 调用代理对象的方法时，调用此方法
    */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        preHandler();
        Object o = method.invoke(target, args);
        postHandler();
        return o;
    }

    private void postHandler() {
        System.out.println(&quot;后置方法&quot;);
    }

    private void preHandler() {
        System.out.println(&quot;前置方法&quot;);
    }
}
</code></pre><p>2、创建动态代理</p>
<pre><code>public class Client {
    public static void main(String[] args){

        //目标类
        RealSubject realSubject = new RealSubject();
        //调用处理处理程序
        InvocationHandler invocationHandler = new SubjectHandler(realSubject);
        /** 创建代理类的实例
         *  第一个参数表示代理类的类加载器
         *  第二个参数表示代理类所实现的接口列表
         *  第三个参数为调用处理程序类，可以是new Class[]{Subject.class}，
         *      也可以 RealSubject.class.getInterfaces()
         */
        Subject proxy = (Subject) Proxy.newProxyInstance(Client.class.getClassLoader(), new Class[]{Subject.class},invocationHandler);
        proxy.request();
    }
}
</code></pre><h4 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h4><p>1、动态代理需要 <strong>代理不同的目标对象</strong> 和 <strong>同一目标对象的不同方法</strong>，所以动态代理类中需要传入代理方法（<strong>接口</strong>）和<strong>代理对象</strong><br>2、在Object newProxyInstance(ClassLoader loader,     Class&lt;?&gt;[] interfaces,InvocationHandler h)方法中直接传入接口，和InvocationHandler的实例，其中实例中传入目标对象，和调用处理方法，根据要求对不同方法进行代理</p>
<h3 id="其他的代理类型"><a href="#其他的代理类型" class="headerlink" title="其他的代理类型"></a>其他的代理类型</h3><p>1、远程代理：位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机，也可以在另一台主机中。在Java语言中，可以通过RMI机制来实现远程代理</p>
<p>2、虚拟代理：如果需要创建一个资源消耗较大的资源，先创建一个消耗相对较小的对象来表示，真是对象只是在需要时才会被真正创建。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<h2 id="ThreadLocal设计模式"><a href="#ThreadLocal设计模式" class="headerlink" title="ThreadLocal设计模式"></a>ThreadLocal设计模式</h2><p><a href="https://my.oschina.net/pingpangkuangmo/blog/376321" target="_blank" rel="external">https://my.oschina.net/pingpangkuangmo/blog/376321</a></p>
<p>ThreadLocal设计模式：<br>（1）ThreadLocal所操作的数据是<strong>线程间不共享的</strong>。它不是用来解决多个线程竞争同一资源的多线程问题<br>（2）ThreadLocal所操作的数据主要用于<strong>线程内共享数据</strong>，可以避免同一线程内函数间的传参数问题</p>
<p>ThreadLocal更像是一个操作线程数据的工具类，哪个线程调用它，它就操作哪个线程的数据。 </p>
<p>其中ThreadUtil就是用ThreadLocal来实现的，ThreadLocal完全可以这样理解，它就是操作线程数据的工具类，哪个线程调用它的get或set方法，它就会操作调用它的线程中的数据如下：</p>
<pre><code>public class ThreadUtil {

    private static ThreadLocal&lt;String&gt; nameLocal=new ThreadLocal&lt;String&gt;();

    public static String getName(){
        return nameLocal.get();
    }

    public static void setName(String name){
        nameLocal.set(name);
    }
}
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag">#设计模式</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/06/[Tomcat]Tomcat笔记/" rel="prev" title="Tomcat笔记">
                Tomcat笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/06/[设计模式]设计模式的艺术之道笔记/"
           data-title="设计模式的艺术之道笔记" data-url="http://yoursite.com/2016/07/06/[设计模式]设计模式的艺术之道笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Mr.Qian" />
          <p class="site-author-name" itemprop="name">Mr.Qian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章：复杂对象的组装与创建——建造者模式"><span class="nav-number">1.</span> <span class="nav-text">第8章：复杂对象的组装与创建——建造者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有Director的建造者模式"><span class="nav-number">1.1.</span> <span class="nav-text">有Director的建造者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#省略Director"><span class="nav-number">1.2.</span> <span class="nav-text">省略Director</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#钩子方法的引入"><span class="nav-number">1.3.</span> <span class="nav-text">钩子方法的引入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9章：适配器模式"><span class="nav-number">2.</span> <span class="nav-text">第9章：适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">2.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器模式的使用场景"><span class="nav-number">2.2.</span> <span class="nav-text">适配器模式的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类图"><span class="nav-number">2.3.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电脑适配器的例子"><span class="nav-number">2.4.</span> <span class="nav-text">电脑适配器的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本质"><span class="nav-number">2.5.</span> <span class="nav-text">本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺省适配器模式"><span class="nav-number">2.6.</span> <span class="nav-text">缺省适配器模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12章：扩展系统功能——装饰模式"><span class="nav-number">3.</span> <span class="nav-text">第12章：扩展系统功能——装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰模式结构图"><span class="nav-number">3.1.</span> <span class="nav-text">装饰模式结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只有一个具体构建类的装饰模式"><span class="nav-number">3.2.</span> <span class="nav-text">只有一个具体构建类的装饰模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">3.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#课后题"><span class="nav-number">3.4.</span> <span class="nav-text">课后题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13章：提供统一入口——外观模式"><span class="nav-number">4.</span> <span class="nav-text">第13章：提供统一入口——外观模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第15章：代理模式"><span class="nav-number">5.</span> <span class="nav-text">第15章：代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现步骤"><span class="nav-number">5.1.</span> <span class="nav-text">实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-动态代理"><span class="nav-number">5.2.</span> <span class="nav-text">Java 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤"><span class="nav-number">5.2.1.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么这么设计"><span class="nav-number">5.2.2.</span> <span class="nav-text">为什么这么设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他的代理类型"><span class="nav-number">5.3.</span> <span class="nav-text">其他的代理类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal设计模式"><span class="nav-number">6.</span> <span class="nav-text">ThreadLocal设计模式</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Qian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rhapsody1290"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
